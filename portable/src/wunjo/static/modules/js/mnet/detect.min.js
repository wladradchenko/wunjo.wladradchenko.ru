let mnet;const generateAnchors=(t,h,i)=>{var a=h.length,s=i.length,r=[],n=.5*t,o=.5*t;for(let e=0;e<a;e++){var d=h[e],c=Math.round(t/Math.sqrt(d)),g=Math.round(c*d);for(let t=0;t<s;t++){var w=i[t],l=c*w*.5,w=g*w*.5;r[e*s+t]=[n-l,o-w,n+l,o+w]}}return r},generateProposals=async(e,a,t,h,i,s,r)=>{var n=h.dims,o=n[3],d=n[2],c=o*d,g=await t.getData(),w=await h.getData(),l=await i.getData(),m=[],p=e.length;for(let t=0;t<p;t++){var M=e[t],v=(t+p)*c,f=4*t*c,u=10*t*c;let i=M[1];var x=M[2]-M[0],_=M[3]-M[1];for(let h=0;h<d;h++){let e=M[0];for(let t=0;t<o;t++){var S,b,C,E,k,y,I=h*o+t,T=g[v+I];s<=T&&(E=w[f+I+0*c],y=w[f+I+c],k=w[f+I+2*c],C=w[f+I+3*c],S=e+.5*x,y=(b=i+.5*_)+_*y,y={rect:[(E=S+x*E)-.5*(k=x*Math.exp(k)),y-.5*(C=_*Math.exp(C)),E+.5*k,y+.5*C],landmarks:[[S+(E=x*r+1)*l[u+I+0*c],b+(k=_*r+1)*l[u+I+c]],[S+E*l[u+I+2*c],b+k*l[u+I+3*c]],[S+E*l[u+I+4*c],b+k*l[u+I+5*c]],[S+E*l[u+I+6*c],b+k*l[u+I+7*c]],[S+E*l[u+I+8*c],b+k*l[u+I+9*c]]],prob:T},m.push(y)),e+=a}i+=a}}return m},processStride=async(t,e,h,i,a,s)=>{var r=t["face_rpn_cls_prob_reshape_stride"+i],n=t["face_rpn_bbox_pred_stride"+i],t=t["face_rpn_landmark_pred_stride"+i],a=generateAnchors(16,[1],a);e.push(...await generateProposals(a,i,r,n,t,h,s))},nmsSortedBboxes=(h,i)=>{var a=[],t=h.length,s=h.map(t=>(t.rect[2]-t.rect[0])*(t.rect[3]-t.rect[1]));for(let e=0;e<t;e++){var r=h[e];let t=1;for(const o of a){var n=h[o],n=Math.max(0,Math.min(r.rect[2],n.rect[2])-Math.max(r.rect[0],n.rect[0]))*Math.max(0,Math.min(r.rect[3],n.rect[3])-Math.max(r.rect[1],n.rect[1]));i<n/(s[e]+s[o]-n)&&(t=0)}t&&a.push(e)}return a},createCanvas=(t,e)=>{var h;return"undefined"!=typeof OffscreenCanvas?new OffscreenCanvas(t,e):((h=document.createElement("canvas")).width=t,h.height=e,h)};class MNET{constructor(t,e,h=640,i=640,a=.18181818){this.session=t,this.tensorClass=e,this.width=h,this.height=i,this.landmarksScale=a}scaleCoordinates(t,e,h,i,a,s){return t>=this.width&&e>=this.height?[h*(t/this.width),a*(e/this.height),i*(t/this.width),s*(e/this.height)]:t>=this.width&&e<this.height?[h*(t/this.width),(a-(this.height-e)/2/t/this.width)*e/this.height,i*(t/this.width),(s-(this.height-e)/2/t/this.width)*e/this.height]:t<this.width&&e>=this.height?[(h-(this.width-t)/2/e/this.height)*t/this.width,a*(e/this.height),(i-(this.width-t)/2/e/this.height)*t/this.width,s*(e/this.height)]:[(h-(this.width-t)/2/e/this.height)*t/this.width,(a-(this.height-e/(t/this.width))/2)*(t/this.width),(i-(this.width-t)/2/e/this.height)*t/this.width,(s-(this.height-e/(t/this.width))/2)*(t/this.width)]}detect=async(e,s=640,r=640,n=1,t=.75,h=.5)=>{if(e.width!==this.width||e.height!==this.height)throw new Error(`image should be ${this.width}x`+this.height);var i=new Float32Array(e.data.length/4*3),a=this.width*this.height;for(let t=0;t<a;t++)i[t]=e.data[4*t],i[t+a]=e.data[4*t+1],i[t+2*a]=e.data[4*t+2];var o=await this.session.run({data:new this.tensorClass("float32",i,[1,3,this.height,this.width])});const d=[];return await processStride(o,d,t,32,[32,16],this.landmarksScale),await processStride(o,d,t,16,[8,4],this.landmarksScale),await processStride(o,d,t,8,[2,1],this.landmarksScale),d.sort((t,e)=>e.prob-t.prob),nmsSortedBboxes(d,h).map(t=>{var t=d[t],e=Math.max(Math.min(t.rect[0],this.width-1),0)/n,h=Math.max(Math.min(t.rect[1],this.height-1),0)/n,i=Math.max(Math.min(t.rect[2],this.width-1),0)/n,a=Math.max(Math.min(t.rect[3],this.height-1),0)/n;return{rect:this.scaleCoordinates(s,r,e,i,h,a),landmarks:t.landmarks.map(t=>[t[0]/n,t[1]/n]),prob:t.prob}})};processImage(t){return new Promise((s,e)=>{const r=new Image;r.crossOrigin="anonymous",r.src=t.src,r.onload=()=>{let t,e;r.width>r.height?(t=this.width,e=Math.round(r.height/r.width*this.width)):(e=this.height,t=Math.round(r.width/r.height*this.height));var h=document.createElement("canvas");h.width=t,h.height=e;h.getContext("2d").drawImage(r,0,0,t,e),h.toDataURL("image/png");var h=[0,0,r.width,r.height],i=createCanvas(this.width,this.height).getContext("2d"),a=Math.min(this.width/r.width,this.height/r.height);i.drawImage(r,h[0],h[1],h[2]-h[0],h[3]-h[1],0,0,this.width,this.height),s([i.getImageData(0,0,this.width,this.height),t,e,a])},r.onerror=t=>{console.error("Error loading image:",t),e(t)}})}}const createMnet=async(t,e)=>{t=await createSession(t);mnet=new MNET(t,e)},detectFaces=async t=>{var e;mnet||(console.log("Model not initialized. Call createMnet first."),e=modelMNET,fetch(e).then(t=>{t.ok||console.log("Model onnx MNET doesn't exists.")}).catch(t=>{console.error("Error:",t)}),mnet=new MNET(await ort.InferenceSession.create(e).then(console.log("Model loaded")),ort.Tensor));try{var[h,i,a,s]=await mnet.processImage(t);return await mnet.detect(h,i,a,s)}catch(t){throw console.error("Image loading or processing error:",t),t}};export{detectFaces};