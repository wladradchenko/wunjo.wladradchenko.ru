/**
 * @license
 * Copyright 2024 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
! function(e, t) {
    "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).tf = e.tf || {})
}(this, (function(e) {
    "use strict";

    function t(e, t) {
        return t.forEach((function(t) {
            t && "string" != typeof t && !Array.isArray(t) && Object.keys(t).forEach((function(n) {
                if ("default" !== n && !(n in e)) {
                    var r = Object.getOwnPropertyDescriptor(t, n);
                    Object.defineProperty(e, n, r.get ? r : {
                        enumerable: !0,
                        get: function() {
                            return t[n]
                        }
                    })
                }
            }))
        })), e
    }
    var n = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};

    function r(e) {
        return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
    }

    function a(e) {
        var t, n;

        function r(t, n) {
            try {
                var o = e[t](n),
                    s = o.value,
                    u = s instanceof i;
                Promise.resolve(u ? s.v : s).then((function(n) {
                    if (u) {
                        var i = "return" === t ? "return" : "next";
                        if (!s.k || n.done) return r(i, n);
                        n = e[i](n).value
                    }
                    a(o.done ? "return" : "normal", n)
                }), (function(e) {
                    r("throw", e)
                }))
            } catch (e) {
                a("throw", e)
            }
        }

        function a(e, a) {
            switch (e) {
                case "return":
                    t.resolve({
                        value: a,
                        done: !0
                    });
                    break;
                case "throw":
                    t.reject(a);
                    break;
                default:
                    t.resolve({
                        value: a,
                        done: !1
                    })
            }(t = t.next) ? r(t.key, t.arg): n = null
        }
        this._invoke = function(e, a) {
            return new Promise((function(i, o) {
                var s = {
                    key: e,
                    arg: a,
                    resolve: i,
                    reject: o,
                    next: null
                };
                n ? n = n.next = s : (t = n = s, r(e, a))
            }))
        }, "function" != typeof e.return && (this.return = void 0)
    }

    function i(e, t) {
        this.v = e, this.k = t
    }

    function o() {
        o = function() {
            return e
        };
        var e = {},
            t = Object.prototype,
            n = t.hasOwnProperty,
            r = Object.defineProperty || function(e, t, n) {
                e[t] = n.value
            },
            a = "function" == typeof Symbol ? Symbol : {},
            i = a.iterator || "@@iterator",
            s = a.asyncIterator || "@@asyncIterator",
            u = a.toStringTag || "@@toStringTag";

        function c(e, t, n) {
            return Object.defineProperty(e, t, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }), e[t]
        }
        try {
            c({}, "")
        } catch (e) {
            c = function(e, t, n) {
                return e[t] = n
            }
        }

        function l(e, t, n, a) {
            var i = t && t.prototype instanceof f ? t : f,
                o = Object.create(i.prototype),
                s = new T(a || []);
            return r(o, "_invoke", {
                value: w(e, n, s)
            }), o
        }

        function h(e, t, n) {
            try {
                return {
                    type: "normal",
                    arg: e.call(t, n)
                }
            } catch (e) {
                return {
                    type: "throw",
                    arg: e
                }
            }
        }
        e.wrap = l;
        var p = {};

        function f() {}

        function d() {}

        function v() {}
        var m = {};
        c(m, i, (function() {
            return this
        }));
        var g = Object.getPrototypeOf,
            y = g && g(g(E([])));
        y && y !== t && n.call(y, i) && (m = y);
        var b = v.prototype = f.prototype = Object.create(m);

        function x(e) {
            ["next", "throw", "return"].forEach((function(t) {
                c(e, t, (function(e) {
                    return this._invoke(t, e)
                }))
            }))
        }

        function k(e, t) {
            function a(r, i, o, s) {
                var u = h(e[r], e, i);
                if ("throw" !== u.type) {
                    var c = u.arg,
                        l = c.value;
                    return l && "object" == typeof l && n.call(l, "__await") ? t.resolve(l.__await).then((function(e) {
                        a("next", e, o, s)
                    }), (function(e) {
                        a("throw", e, o, s)
                    })) : t.resolve(l).then((function(e) {
                        c.value = e, o(c)
                    }), (function(e) {
                        return a("throw", e, o, s)
                    }))
                }
                s(u.arg)
            }
            var i;
            r(this, "_invoke", {
                value: function(e, n) {
                    function r() {
                        return new t((function(t, r) {
                            a(e, n, t, r)
                        }))
                    }
                    return i = i ? i.then(r, r) : r()
                }
            })
        }

        function w(e, t, n) {
            var r = "suspendedStart";
            return function(a, i) {
                if ("executing" === r) throw new Error("Generator is already running");
                if ("completed" === r) {
                    if ("throw" === a) throw i;
                    return C()
                }
                for (n.method = a, n.arg = i;;) {
                    var o = n.delegate;
                    if (o) {
                        var s = I(o, n);
                        if (s) {
                            if (s === p) continue;
                            return s
                        }
                    }
                    if ("next" === n.method) n.sent = n._sent = n.arg;
                    else if ("throw" === n.method) {
                        if ("suspendedStart" === r) throw r = "completed", n.arg;
                        n.dispatchException(n.arg)
                    } else "return" === n.method && n.abrupt("return", n.arg);
                    r = "executing";
                    var u = h(e, t, n);
                    if ("normal" === u.type) {
                        if (r = n.done ? "completed" : "suspendedYield", u.arg === p) continue;
                        return {
                            value: u.arg,
                            done: n.done
                        }
                    }
                    "throw" === u.type && (r = "completed", n.method = "throw", n.arg = u.arg)
                }
            }
        }

        function I(e, t) {
            var n = t.method,
                r = e.iterator[n];
            if (void 0 === r) return t.delegate = null, "throw" === n && e.iterator.return && (t.method = "return", t.arg = void 0, I(e, t), "throw" === t.method) || "return" !== n && (t.method = "throw", t.arg = new TypeError("The iterator does not provide a '" + n + "' method")), p;
            var a = h(r, e.iterator, t.arg);
            if ("throw" === a.type) return t.method = "throw", t.arg = a.arg, t.delegate = null, p;
            var i = a.arg;
            return i ? i.done ? (t[e.resultName] = i.value, t.next = e.nextLoc, "return" !== t.method && (t.method = "next", t.arg = void 0), t.delegate = null, p) : i : (t.method = "throw", t.arg = new TypeError("iterator result is not an object"), t.delegate = null, p)
        }

        function N(e) {
            var t = {
                tryLoc: e[0]
            };
            1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t)
        }

        function S(e) {
            var t = e.completion || {};
            t.type = "normal", delete t.arg, e.completion = t
        }

        function T(e) {
            this.tryEntries = [{
                tryLoc: "root"
            }], e.forEach(N, this), this.reset(!0)
        }

        function E(e) {
            if (e) {
                var t = e[i];
                if (t) return t.call(e);
                if ("function" == typeof e.next) return e;
                if (!isNaN(e.length)) {
                    var r = -1,
                        a = function t() {
                            for (; ++r < e.length;)
                                if (n.call(e, r)) return t.value = e[r], t.done = !1, t;
                            return t.value = void 0, t.done = !0, t
                        };
                    return a.next = a
                }
            }
            return {
                next: C
            }
        }

        function C() {
            return {
                value: void 0,
                done: !0
            }
        }
        return d.prototype = v, r(b, "constructor", {
            value: v,
            configurable: !0
        }), r(v, "constructor", {
            value: d,
            configurable: !0
        }), d.displayName = c(v, u, "GeneratorFunction"), e.isGeneratorFunction = function(e) {
            var t = "function" == typeof e && e.constructor;
            return !!t && (t === d || "GeneratorFunction" === (t.displayName || t.name))
        }, e.mark = function(e) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(e, v) : (e.__proto__ = v, c(e, u, "GeneratorFunction")), e.prototype = Object.create(b), e
        }, e.awrap = function(e) {
            return {
                __await: e
            }
        }, x(k.prototype), c(k.prototype, s, (function() {
            return this
        })), e.AsyncIterator = k, e.async = function(t, n, r, a, i) {
            void 0 === i && (i = Promise);
            var o = new k(l(t, n, r, a), i);
            return e.isGeneratorFunction(n) ? o : o.next().then((function(e) {
                return e.done ? e.value : o.next()
            }))
        }, x(b), c(b, u, "Generator"), c(b, i, (function() {
            return this
        })), c(b, "toString", (function() {
            return "[object Generator]"
        })), e.keys = function(e) {
            var t = Object(e),
                n = [];
            for (var r in t) n.push(r);
            return n.reverse(),
                function e() {
                    for (; n.length;) {
                        var r = n.pop();
                        if (r in t) return e.value = r, e.done = !1, e
                    }
                    return e.done = !0, e
                }
        }, e.values = E, T.prototype = {
            constructor: T,
            reset: function(e) {
                if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = !1, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(S), !e)
                    for (var t in this) "t" === t.charAt(0) && n.call(this, t) && !isNaN(+t.slice(1)) && (this[t] = void 0)
            },
            stop: function() {
                this.done = !0;
                var e = this.tryEntries[0].completion;
                if ("throw" === e.type) throw e.arg;
                return this.rval
            },
            dispatchException: function(e) {
                if (this.done) throw e;
                var t = this;

                function r(n, r) {
                    return o.type = "throw", o.arg = e, t.next = n, r && (t.method = "next", t.arg = void 0), !!r
                }
                for (var a = this.tryEntries.length - 1; a >= 0; --a) {
                    var i = this.tryEntries[a],
                        o = i.completion;
                    if ("root" === i.tryLoc) return r("end");
                    if (i.tryLoc <= this.prev) {
                        var s = n.call(i, "catchLoc"),
                            u = n.call(i, "finallyLoc");
                        if (s && u) {
                            if (this.prev < i.catchLoc) return r(i.catchLoc, !0);
                            if (this.prev < i.finallyLoc) return r(i.finallyLoc)
                        } else if (s) {
                            if (this.prev < i.catchLoc) return r(i.catchLoc, !0)
                        } else {
                            if (!u) throw new Error("try statement without catch or finally");
                            if (this.prev < i.finallyLoc) return r(i.finallyLoc)
                        }
                    }
                }
            },
            abrupt: function(e, t) {
                for (var r = this.tryEntries.length - 1; r >= 0; --r) {
                    var a = this.tryEntries[r];
                    if (a.tryLoc <= this.prev && n.call(a, "finallyLoc") && this.prev < a.finallyLoc) {
                        var i = a;
                        break
                    }
                }
                i && ("break" === e || "continue" === e) && i.tryLoc <= t && t <= i.finallyLoc && (i = null);
                var o = i ? i.completion : {};
                return o.type = e, o.arg = t, i ? (this.method = "next", this.next = i.finallyLoc, p) : this.complete(o)
            },
            complete: function(e, t) {
                if ("throw" === e.type) throw e.arg;
                return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg, this.method = "return", this.next = "end") : "normal" === e.type && t && (this.next = t), p
            },
            finish: function(e) {
                for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                    var n = this.tryEntries[t];
                    if (n.finallyLoc === e) return this.complete(n.completion, n.afterLoc), S(n), p
                }
            },
            catch: function(e) {
                for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                    var n = this.tryEntries[t];
                    if (n.tryLoc === e) {
                        var r = n.completion;
                        if ("throw" === r.type) {
                            var a = r.arg;
                            S(n)
                        }
                        return a
                    }
                }
                throw new Error("illegal catch attempt")
            },
            delegateYield: function(e, t, n) {
                return this.delegate = {
                    iterator: E(e),
                    resultName: t,
                    nextLoc: n
                }, "next" === this.method && (this.arg = void 0), p
            }
        }, e
    }

    function s(e) {
        return s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }, s(e)
    }

    function u(e, t, n, r, a, i, o) {
        try {
            var s = e[i](o),
                u = s.value
        } catch (e) {
            return void n(e)
        }
        s.done ? t(u) : Promise.resolve(u).then(r, a)
    }

    function c(e) {
        return function() {
            var t = this,
                n = arguments;
            return new Promise((function(r, a) {
                var i = e.apply(t, n);

                function o(e) {
                    u(i, r, a, o, s, "next", e)
                }

                function s(e) {
                    u(i, r, a, o, s, "throw", e)
                }
                o(void 0)
            }))
        }
    }

    function l(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    function h(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, F(r.key), r)
        }
    }

    function p(e, t, n) {
        return t && h(e.prototype, t), n && h(e, n), Object.defineProperty(e, "prototype", {
            writable: !1
        }), e
    }

    function f(e, t, n) {
        return (t = F(t)) in e ? Object.defineProperty(e, t, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = n, e
    }

    function d(e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
        e.prototype = Object.create(t && t.prototype, {
            constructor: {
                value: e,
                writable: !0,
                configurable: !0
            }
        }), Object.defineProperty(e, "prototype", {
            writable: !1
        }), t && m(e, t)
    }

    function v(e) {
        return v = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        }, v(e)
    }

    function m(e, t) {
        return m = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
            return e.__proto__ = t, e
        }, m(e, t)
    }

    function g() {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;
        try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
        } catch (e) {
            return !1
        }
    }

    function y(e, t, n) {
        return y = g() ? Reflect.construct.bind() : function(e, t, n) {
            var r = [null];
            r.push.apply(r, t);
            var a = new(Function.bind.apply(e, r));
            return n && m(a, n.prototype), a
        }, y.apply(null, arguments)
    }

    function b(e) {
        var t = "function" == typeof Map ? new Map : void 0;
        return b = function(e) {
            if (null === e || (n = e, -1 === Function.toString.call(n).indexOf("[native code]"))) return e;
            var n;
            if ("function" != typeof e) throw new TypeError("Super expression must either be null or a function");
            if (void 0 !== t) {
                if (t.has(e)) return t.get(e);
                t.set(e, r)
            }

            function r() {
                return y(e, arguments, v(this).constructor)
            }
            return r.prototype = Object.create(e.prototype, {
                constructor: {
                    value: r,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), m(r, e)
        }, b(e)
    }

    function x(e) {
        if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e
    }

    function k(e, t) {
        if (t && ("object" == typeof t || "function" == typeof t)) return t;
        if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
        return x(e)
    }

    function w(e) {
        var t = g();
        return function() {
            var n, r = v(e);
            if (t) {
                var a = v(this).constructor;
                n = Reflect.construct(r, arguments, a)
            } else n = r.apply(this, arguments);
            return k(this, n)
        }
    }

    function I(e, t) {
        for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = v(e)););
        return e
    }

    function N() {
        return N = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, n) {
            var r = I(e, t);
            if (r) {
                var a = Object.getOwnPropertyDescriptor(r, t);
                return a.get ? a.get.call(arguments.length < 3 ? e : n) : a.value
            }
        }, N.apply(this, arguments)
    }

    function S(e, t) {
        return E(e) || function(e, t) {
            var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
            if (null != n) {
                var r, a, i, o, s = [],
                    u = !0,
                    c = !1;
                try {
                    if (i = (n = n.call(e)).next, 0 === t) {
                        if (Object(n) !== n) return;
                        u = !1
                    } else
                        for (; !(u = (r = i.call(n)).done) && (s.push(r.value), s.length !== t); u = !0);
                } catch (e) {
                    c = !0, a = e
                } finally {
                    try {
                        if (!u && null != n.return && (o = n.return(), Object(o) !== o)) return
                    } finally {
                        if (c) throw a
                    }
                }
                return s
            }
        }(e, t) || A(e, t) || _()
    }

    function T(e) {
        return function(e) {
            if (Array.isArray(e)) return R(e)
        }(e) || C(e) || A(e) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }

    function E(e) {
        if (Array.isArray(e)) return e
    }

    function C(e) {
        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e)
    }

    function A(e, t) {
        if (e) {
            if ("string" == typeof e) return R(e, t);
            var n = Object.prototype.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? R(e, t) : void 0
        }
    }

    function R(e, t) {
        (null == t || t > e.length) && (t = e.length);
        for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
        return r
    }

    function _() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }

    function O(e, t) {
        var n = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
        if (!n) {
            if (Array.isArray(e) || (n = A(e)) || t && e && "number" == typeof e.length) {
                n && (e = n);
                var r = 0,
                    a = function() {};
                return {
                    s: a,
                    n: function() {
                        return r >= e.length ? {
                            done: !0
                        } : {
                            done: !1,
                            value: e[r++]
                        }
                    },
                    e: function(e) {
                        throw e
                    },
                    f: a
                }
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }
        var i, o = !0,
            s = !1;
        return {
            s: function() {
                n = n.call(e)
            },
            n: function() {
                var e = n.next();
                return o = e.done, e
            },
            e: function(e) {
                s = !0, i = e
            },
            f: function() {
                try {
                    o || null == n.return || n.return()
                } finally {
                    if (s) throw i
                }
            }
        }
    }

    function F(e) {
        var t = function(e, t) {
            if ("object" != typeof e || null === e) return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t || "default");
                if ("object" != typeof r) return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }(e, "string");
        return "symbol" == typeof t ? t : String(t)
    }
    a.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function() {
        return this
    }, a.prototype.next = function(e) {
        return this._invoke("next", e)
    }, a.prototype.throw = function(e) {
        return this._invoke("throw", e)
    }, a.prototype.return = function(e) {
        return this._invoke("return", e)
    };
    var D, M, L = function(e) {
            return e && e.Math == Math && e
        },
        z = L("object" == ("undefined" == typeof globalThis ? "undefined" : s(globalThis)) && globalThis) || L("object" == ("undefined" == typeof window ? "undefined" : s(window)) && window) || L("object" == ("undefined" == typeof self ? "undefined" : s(self)) && self) || L("object" == s(n) && n) || function() {
            return this
        }() || Function("return this")(),
        P = {},
        B = function(e) {
            try {
                return !!e()
            } catch (e) {
                return !0
            }
        },
        W = !B((function() {
            return 7 != Object.defineProperty({}, 1, {
                get: function() {
                    return 7
                }
            })[1]
        })),
        U = !B((function() {
            var e = function() {}.bind();
            return "function" != typeof e || e.hasOwnProperty("prototype")
        })),
        V = U,
        G = Function.prototype.call,
        j = V ? G.bind(G) : function() {
            return G.apply(G, arguments)
        },
        H = {},
        q = {}.propertyIsEnumerable,
        K = Object.getOwnPropertyDescriptor,
        X = K && !q.call({
            1: 2
        }, 1),
        Y = (H.f = X ? function(e) {
            var t = K(this, e);
            return !!t && t.enumerable
        } : q, function(e, t) {
            return {
                enumerable: !(1 & e),
                configurable: !(2 & e),
                writable: !(4 & e),
                value: t
            }
        }),
        J = U,
        Z = Function.prototype,
        Q = Z.call,
        $ = J && Z.bind.bind(Q, Q),
        ee = J ? $ : function(e) {
            return function() {
                return Q.apply(e, arguments)
            }
        },
        te = ee,
        ne = te({}.toString),
        re = te("".slice),
        ae = function(e) {
            return re(ne(e), 8, -1)
        },
        ie = B,
        oe = ae,
        se = Object,
        ue = ee("".split),
        ce = ie((function() {
            return !se("z").propertyIsEnumerable(0)
        })) ? function(e) {
            return "String" == oe(e) ? ue(e, "") : se(e)
        } : se,
        le = function(e) {
            return null == e
        },
        he = le,
        pe = TypeError,
        fe = function(e) {
            if (he(e)) throw pe("Can't call method on " + e);
            return e
        },
        de = ce,
        ve = fe,
        me = function(e) {
            return de(ve(e))
        },
        ge = "object" == ("undefined" == typeof document ? "undefined" : s(document)) && document.all,
        ye = {
            all: ge,
            IS_HTMLDDA: void 0 === ge && void 0 !== ge
        },
        be = ye.all,
        xe = ye.IS_HTMLDDA ? function(e) {
            return "function" == typeof e || e === be
        } : function(e) {
            return "function" == typeof e
        },
        ke = xe,
        we = ye.all,
        Ie = ye.IS_HTMLDDA ? function(e) {
            return "object" == s(e) ? null !== e : ke(e) || e === we
        } : function(e) {
            return "object" == s(e) ? null !== e : ke(e)
        },
        Ne = z,
        Se = xe,
        Te = function(e) {
            return Se(e) ? e : void 0
        },
        Ee = function(e, t) {
            return arguments.length < 2 ? Te(Ne[e]) : Ne[e] && Ne[e][t]
        },
        Ce = ee({}.isPrototypeOf),
        Ae = "undefined" != typeof navigator && String(navigator.userAgent) || "",
        Re = z,
        _e = Ae,
        Oe = Re.process,
        Fe = Re.Deno,
        De = Oe && Oe.versions || Fe && Fe.version,
        Me = De && De.v8;
    Me && (M = (D = Me.split("."))[0] > 0 && D[0] < 4 ? 1 : +(D[0] + D[1])), !M && _e && (!(D = _e.match(/Edge\/(\d+)/)) || D[1] >= 74) && (D = _e.match(/Chrome\/(\d+)/)) && (M = +D[1]);
    var Le = M,
        ze = Le,
        Pe = B,
        Be = !!Object.getOwnPropertySymbols && !Pe((function() {
            var e = Symbol();
            return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && ze && ze < 41
        })),
        We = Be && !Symbol.sham && "symbol" == s(Symbol.iterator),
        Ue = Ee,
        Ve = xe,
        Ge = Ce,
        je = Object,
        He = We ? function(e) {
            return "symbol" == s(e)
        } : function(e) {
            var t = Ue("Symbol");
            return Ve(t) && Ge(t.prototype, je(e))
        },
        qe = String,
        Ke = function(e) {
            try {
                return qe(e)
            } catch (e) {
                return "Object"
            }
        },
        Xe = xe,
        Ye = Ke,
        Je = TypeError,
        Ze = function(e) {
            if (Xe(e)) return e;
            throw Je(Ye(e) + " is not a function")
        },
        Qe = Ze,
        $e = le,
        et = function(e, t) {
            var n = e[t];
            return $e(n) ? void 0 : Qe(n)
        },
        tt = j,
        nt = xe,
        rt = Ie,
        at = TypeError,
        it = function(e, t) {
            var n, r;
            if ("string" === t && nt(n = e.toString) && !rt(r = tt(n, e))) return r;
            if (nt(n = e.valueOf) && !rt(r = tt(n, e))) return r;
            if ("string" !== t && nt(n = e.toString) && !rt(r = tt(n, e))) return r;
            throw at("Can't convert object to primitive value")
        },
        ot = {
            exports: {}
        },
        st = !1,
        ut = z,
        ct = Object.defineProperty,
        lt = function(e, t) {
            try {
                ct(ut, e, {
                    value: t,
                    configurable: !0,
                    writable: !0
                })
            } catch (n) {
                ut[e] = t
            }
            return t
        },
        ht = lt,
        pt = "__core-js_shared__",
        ft = z[pt] || ht(pt, {}),
        dt = (ot.exports, ft);
    (ot.exports = function(e, t) {
        return dt[e] || (dt[e] = void 0 !== t ? t : {})
    })("versions", []).push({
        version: "3.29.1",
        mode: "global",
        copyright: "Â© 2014-2023 Denis Pushkarev (zloirock.ru)",
        license: "https://github.com/zloirock/core-js/blob/v3.29.1/LICENSE",
        source: "https://github.com/zloirock/core-js"
    });
    var vt = ot.exports,
        mt = fe,
        gt = Object,
        yt = function(e) {
            return gt(mt(e))
        },
        bt = yt,
        xt = ee({}.hasOwnProperty),
        kt = Object.hasOwn || function(e, t) {
            return xt(bt(e), t)
        },
        wt = ee,
        It = 0,
        Nt = Math.random(),
        St = wt(1..toString),
        Tt = function(e) {
            return "Symbol(" + (void 0 === e ? "" : e) + ")_" + St(++It + Nt, 36)
        },
        Et = vt,
        Ct = kt,
        At = Tt,
        Rt = Be,
        _t = We,
        Ot = z.Symbol,
        Ft = Et("wks"),
        Dt = _t ? Ot.for || Ot : Ot && Ot.withoutSetter || At,
        Mt = function(e) {
            return Ct(Ft, e) || (Ft[e] = Rt && Ct(Ot, e) ? Ot[e] : Dt("Symbol." + e)), Ft[e]
        },
        Lt = j,
        zt = Ie,
        Pt = He,
        Bt = et,
        Wt = it,
        Ut = TypeError,
        Vt = Mt("toPrimitive"),
        Gt = function(e, t) {
            if (!zt(e) || Pt(e)) return e;
            var n, r = Bt(e, Vt);
            if (r) {
                if (void 0 === t && (t = "default"), n = Lt(r, e, t), !zt(n) || Pt(n)) return n;
                throw Ut("Can't convert object to primitive value")
            }
            return void 0 === t && (t = "number"), Wt(e, t)
        },
        jt = Gt,
        Ht = He,
        qt = function(e) {
            var t = jt(e, "string");
            return Ht(t) ? t : t + ""
        },
        Kt = Ie,
        Xt = z.document,
        Yt = Kt(Xt) && Kt(Xt.createElement),
        Jt = function(e) {
            return Yt ? Xt.createElement(e) : {}
        },
        Zt = Jt,
        Qt = !W && !B((function() {
            return 7 != Object.defineProperty(Zt("div"), "a", {
                get: function() {
                    return 7
                }
            }).a
        })),
        $t = W,
        en = j,
        tn = H,
        nn = Y,
        rn = me,
        an = qt,
        on = kt,
        sn = Qt,
        un = Object.getOwnPropertyDescriptor,
        cn = (P.f = $t ? un : function(e, t) {
            if (e = rn(e), t = an(t), sn) try {
                return un(e, t)
            } catch (e) {}
            if (on(e, t)) return nn(!en(tn.f, e, t), e[t])
        }, {}),
        ln = W && B((function() {
            return 42 != Object.defineProperty((function() {}), "prototype", {
                value: 42,
                writable: !1
            }).prototype
        })),
        hn = Ie,
        pn = String,
        fn = TypeError,
        dn = function(e) {
            if (hn(e)) return e;
            throw fn(pn(e) + " is not an object")
        },
        vn = W,
        mn = Qt,
        gn = ln,
        yn = dn,
        bn = qt,
        xn = TypeError,
        kn = Object.defineProperty,
        wn = Object.getOwnPropertyDescriptor,
        In = "enumerable",
        Nn = "configurable",
        Sn = "writable",
        Tn = (cn.f = vn ? gn ? function(e, t, n) {
            if (yn(e), t = bn(t), yn(n), "function" == typeof e && "prototype" === t && "value" in n && Sn in n && !n.writable) {
                var r = wn(e, t);
                r && r.writable && (e[t] = n.value, n = {
                    configurable: Nn in n ? n.configurable : r.configurable,
                    enumerable: In in n ? n.enumerable : r.enumerable,
                    writable: !1
                })
            }
            return kn(e, t, n)
        } : kn : function(e, t, n) {
            if (yn(e), t = bn(t), yn(n), mn) try {
                return kn(e, t, n)
            } catch (e) {}
            if ("get" in n || "set" in n) throw xn("Accessors not supported");
            return "value" in n && (e[t] = n.value), e
        }, cn),
        En = Y,
        Cn = W ? function(e, t, n) {
            return Tn.f(e, t, En(1, n))
        } : function(e, t, n) {
            return e[t] = n, e
        },
        An = {
            exports: {}
        },
        Rn = W,
        _n = kt,
        On = Function.prototype,
        Fn = Rn && Object.getOwnPropertyDescriptor,
        Dn = _n(On, "name"),
        Mn = {
            EXISTS: Dn,
            PROPER: Dn && "something" === function() {}.name,
            CONFIGURABLE: Dn && (!Rn || Rn && Fn(On, "name").configurable)
        },
        Ln = xe,
        zn = ft,
        Pn = ee(Function.toString);
    Ln(zn.inspectSource) || (zn.inspectSource = function(e) {
        return Pn(e)
    });
    var Bn, Wn, Un, Vn = zn.inspectSource,
        Gn = xe,
        jn = z.WeakMap,
        Hn = Gn(jn) && /native code/.test(String(jn)),
        qn = Tt,
        Kn = vt("keys"),
        Xn = function(e) {
            return Kn[e] || (Kn[e] = qn(e))
        },
        Yn = {},
        Jn = Hn,
        Zn = z,
        Qn = Ie,
        $n = Cn,
        er = kt,
        tr = ft,
        nr = Xn,
        rr = Yn,
        ar = "Object already initialized",
        ir = Zn.TypeError,
        or = Zn.WeakMap;
    if (Jn || tr.state) {
        var sr = tr.state || (tr.state = new or);
        sr.get = sr.get, sr.has = sr.has, sr.set = sr.set, Bn = function(e, t) {
            if (sr.has(e)) throw ir(ar);
            return t.facade = e, sr.set(e, t), t
        }, Wn = function(e) {
            return sr.get(e) || {}
        }, Un = function(e) {
            return sr.has(e)
        }
    } else {
        var ur = nr("state");
        rr[ur] = !0, Bn = function(e, t) {
            if (er(e, ur)) throw ir(ar);
            return t.facade = e, $n(e, ur, t), t
        }, Wn = function(e) {
            return er(e, ur) ? e[ur] : {}
        }, Un = function(e) {
            return er(e, ur)
        }
    }
    var cr = {
            set: Bn,
            get: Wn,
            has: Un,
            enforce: function(e) {
                return Un(e) ? Wn(e) : Bn(e, {})
            },
            getterFor: function(e) {
                return function(t) {
                    var n;
                    if (!Qn(t) || (n = Wn(t)).type !== e) throw ir("Incompatible receiver, " + e + " required");
                    return n
                }
            }
        },
        lr = (An.exports, ee),
        hr = B,
        pr = xe,
        fr = kt,
        dr = W,
        vr = Mn.CONFIGURABLE,
        mr = Vn,
        gr = cr.enforce,
        yr = cr.get,
        br = String,
        xr = Object.defineProperty,
        kr = lr("".slice),
        wr = lr("".replace),
        Ir = lr([].join),
        Nr = dr && !hr((function() {
            return 8 !== xr((function() {}), "length", {
                value: 8
            }).length
        })),
        Sr = String(String).split("String"),
        Tr = An.exports = function(e, t, n) {
            "Symbol(" === kr(br(t), 0, 7) && (t = "[" + wr(br(t), /^Symbol\(([^)]*)\)/, "$1") + "]"), n && n.getter && (t = "get " + t), n && n.setter && (t = "set " + t), (!fr(e, "name") || vr && e.name !== t) && (dr ? xr(e, "name", {
                value: t,
                configurable: !0
            }) : e.name = t), Nr && n && fr(n, "arity") && e.length !== n.arity && xr(e, "length", {
                value: n.arity
            });
            try {
                n && fr(n, "constructor") && n.constructor ? dr && xr(e, "prototype", {
                    writable: !1
                }) : e.prototype && (e.prototype = void 0)
            } catch (e) {}
            var r = gr(e);
            return fr(r, "source") || (r.source = Ir(Sr, "string" == typeof t ? t : "")), e
        };
    Function.prototype.toString = Tr((function() {
        return pr(this) && yr(this).source || mr(this)
    }), "toString");
    var Er = An.exports,
        Cr = xe,
        Ar = cn,
        Rr = Er,
        _r = lt,
        Or = function(e, t, n, r) {
            r || (r = {});
            var a = r.enumerable,
                i = void 0 !== r.name ? r.name : t;
            if (Cr(n) && Rr(n, i, r), r.global) a ? e[t] = n : _r(t, n);
            else {
                try {
                    r.unsafe ? e[t] && (a = !0) : delete e[t]
                } catch (e) {}
                a ? e[t] = n : Ar.f(e, t, {
                    value: n,
                    enumerable: !1,
                    configurable: !r.nonConfigurable,
                    writable: !r.nonWritable
                })
            }
            return e
        },
        Fr = {},
        Dr = Math.ceil,
        Mr = Math.floor,
        Lr = Math.trunc || function(e) {
            var t = +e;
            return (t > 0 ? Mr : Dr)(t)
        },
        zr = Lr,
        Pr = function(e) {
            var t = +e;
            return t != t || 0 === t ? 0 : zr(t)
        },
        Br = Pr,
        Wr = Math.max,
        Ur = Math.min,
        Vr = function(e, t) {
            var n = Br(e);
            return n < 0 ? Wr(n + t, 0) : Ur(n, t)
        },
        Gr = Pr,
        jr = Math.min,
        Hr = function(e) {
            return e > 0 ? jr(Gr(e), 9007199254740991) : 0
        },
        qr = Hr,
        Kr = function(e) {
            return qr(e.length)
        },
        Xr = me,
        Yr = Vr,
        Jr = Kr,
        Zr = function(e) {
            return function(t, n, r) {
                var a, i = Xr(t),
                    o = Jr(i),
                    s = Yr(r, o);
                if (e && n != n) {
                    for (; o > s;)
                        if ((a = i[s++]) != a) return !0
                } else
                    for (; o > s; s++)
                        if ((e || s in i) && i[s] === n) return e || s || 0; return !e && -1
            }
        },
        Qr = {
            includes: Zr(!0),
            indexOf: Zr(!1)
        },
        $r = kt,
        ea = me,
        ta = Qr.indexOf,
        na = Yn,
        ra = ee([].push),
        aa = function(e, t) {
            var n, r = ea(e),
                a = 0,
                i = [];
            for (n in r) !$r(na, n) && $r(r, n) && ra(i, n);
            for (; t.length > a;) $r(r, n = t[a++]) && (~ta(i, n) || ra(i, n));
            return i
        },
        ia = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"],
        oa = aa,
        sa = ia.concat("length", "prototype"),
        ua = (Fr.f = Object.getOwnPropertyNames || function(e) {
            return oa(e, sa)
        }, {}),
        ca = (ua.f = Object.getOwnPropertySymbols, Ee),
        la = Fr,
        ha = ua,
        pa = dn,
        fa = ee([].concat),
        da = ca("Reflect", "ownKeys") || function(e) {
            var t = la.f(pa(e)),
                n = ha.f;
            return n ? fa(t, n(e)) : t
        },
        va = kt,
        ma = da,
        ga = P,
        ya = cn,
        ba = function(e, t, n) {
            for (var r = ma(t), a = ya.f, i = ga.f, o = 0; o < r.length; o++) {
                var s = r[o];
                va(e, s) || n && va(n, s) || a(e, s, i(t, s))
            }
        },
        xa = B,
        ka = xe,
        wa = /#|\.prototype\./,
        Ia = function(e, t) {
            var n = Sa[Na(e)];
            return n == Ea || n != Ta && (ka(t) ? xa(t) : !!t)
        },
        Na = Ia.normalize = function(e) {
            return String(e).replace(wa, ".").toLowerCase()
        },
        Sa = Ia.data = {},
        Ta = Ia.NATIVE = "N",
        Ea = Ia.POLYFILL = "P",
        Ca = Ia,
        Aa = z,
        Ra = P.f,
        _a = Cn,
        Oa = Or,
        Fa = lt,
        Da = ba,
        Ma = Ca,
        La = function(e, t) {
            var n, r, a, i, o, u = e.target,
                c = e.global,
                l = e.stat;
            if (n = c ? Aa : l ? Aa[u] || Fa(u, {}) : (Aa[u] || {}).prototype)
                for (r in t) {
                    if (i = t[r], a = e.dontCallGetSet ? (o = Ra(n, r)) && o.value : n[r], !Ma(c ? r : u + (l ? "." : "#") + r, e.forced) && void 0 !== a) {
                        if (s(i) == s(a)) continue;
                        Da(i, a)
                    }(e.sham || a && a.sham) && _a(i, "sham", !0), Oa(n, r, i, e)
                }
        },
        za = {};
    za[Mt("toStringTag")] = "z";
    var Pa, Ba = "[object z]" === String(za),
        Wa = Ba,
        Ua = xe,
        Va = ae,
        Ga = Mt("toStringTag"),
        ja = Object,
        Ha = "Arguments" == Va(function() {
            return arguments
        }()),
        qa = Wa ? Va : function(e) {
            var t, n, r;
            return void 0 === e ? "Undefined" : null === e ? "Null" : "string" == typeof(n = function(e, t) {
                try {
                    return e[t]
                } catch (e) {}
            }(t = ja(e), Ga)) ? n : Ha ? Va(t) : "Object" == (r = Va(t)) && Ua(t.callee) ? "Arguments" : r
        },
        Ka = qa,
        Xa = String,
        Ya = function(e) {
            if ("Symbol" === Ka(e)) throw TypeError("Cannot convert a Symbol value to a string");
            return Xa(e)
        },
        Ja = {},
        Za = aa,
        Qa = ia,
        $a = Object.keys || function(e) {
            return Za(e, Qa)
        },
        ei = W,
        ti = ln,
        ni = cn,
        ri = dn,
        ai = me,
        ii = $a,
        oi = (Ja.f = ei && !ti ? Object.defineProperties : function(e, t) {
            ri(e);
            for (var n, r = ai(t), a = ii(t), i = a.length, o = 0; i > o;) ni.f(e, n = a[o++], r[n]);
            return e
        }, Ee("document", "documentElement")),
        si = dn,
        ui = Ja,
        ci = ia,
        li = Yn,
        hi = oi,
        pi = Jt,
        fi = Xn("IE_PROTO"),
        di = function() {},
        vi = function(e) {
            return "<script>" + e + "</" + "script>"
        },
        mi = function(e) {
            e.write(vi("")), e.close();
            var t = e.parentWindow.Object;
            return e = null, t
        },
        gi = function() {
            try {
                Pa = new ActiveXObject("htmlfile")
            } catch (e) {}
            var e, t;
            gi = "undefined" != typeof document ? document.domain && Pa ? mi(Pa) : ((t = pi("iframe")).style.display = "none", hi.appendChild(t), t.src = String("javascript:"), (e = t.contentWindow.document).open(), e.write(vi("document.F=Object")), e.close(), e.F) : mi(Pa);
            for (var n = ci.length; n--;) delete gi.prototype[ci[n]];
            return gi()
        };
    li[fi] = !0;
    var yi = Object.create || function(e, t) {
            var n;
            return null !== e ? (di.prototype = si(e), n = new di, di.prototype = null, n[fi] = e) : n = gi(), void 0 === t ? n : ui.f(n, t)
        },
        bi = {},
        xi = qt,
        ki = cn,
        wi = Y,
        Ii = function(e, t, n) {
            var r = xi(t);
            r in e ? ki.f(e, r, wi(0, n)) : e[r] = n
        },
        Ni = Vr,
        Si = Kr,
        Ti = Ii,
        Ei = Array,
        Ci = Math.max,
        Ai = function(e, t, n) {
            for (var r = Si(e), a = Ni(t, r), i = Ni(void 0 === n ? r : n, r), o = Ei(Ci(i - a, 0)), s = 0; a < i; a++, s++) Ti(o, s, e[a]);
            return o.length = s, o
        },
        Ri = ae,
        _i = me,
        Oi = Fr.f,
        Fi = Ai,
        Di = "object" == ("undefined" == typeof window ? "undefined" : s(window)) && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [],
        Mi = (bi.f = function(e) {
            return Di && "Window" == Ri(e) ? function(e) {
                try {
                    return Oi(e)
                } catch (e) {
                    return Fi(Di)
                }
            }(e) : Oi(_i(e))
        }, Er),
        Li = cn,
        zi = function(e, t, n) {
            return n.get && Mi(n.get, t, {
                getter: !0
            }), n.set && Mi(n.set, t, {
                setter: !0
            }), Li.f(e, t, n)
        },
        Pi = {},
        Bi = Mt,
        Wi = (Pi.f = Bi, z),
        Ui = Wi,
        Vi = kt,
        Gi = Pi,
        ji = cn.f,
        Hi = function(e) {
            var t = Ui.Symbol || (Ui.Symbol = {});
            Vi(t, e) || ji(t, e, {
                value: Gi.f(e)
            })
        },
        qi = j,
        Ki = Ee,
        Xi = Mt,
        Yi = Or,
        Ji = function() {
            var e = Ki("Symbol"),
                t = e && e.prototype,
                n = t && t.valueOf,
                r = Xi("toPrimitive");
            t && !t[r] && Yi(t, r, (function(e) {
                return qi(n, this)
            }), {
                arity: 1
            })
        },
        Zi = cn.f,
        Qi = kt,
        $i = Mt("toStringTag"),
        eo = function(e, t, n) {
            e && !n && (e = e.prototype), e && !Qi(e, $i) && Zi(e, $i, {
                configurable: !0,
                value: t
            })
        },
        to = ae,
        no = ee,
        ro = function(e) {
            if ("Function" === to(e)) return no(e)
        },
        ao = Ze,
        io = U,
        oo = ro(ro.bind),
        so = function(e, t) {
            return ao(e), void 0 === t ? e : io ? oo(e, t) : function() {
                return e.apply(t, arguments)
            }
        },
        uo = ae,
        co = Array.isArray || function(e) {
            return "Array" == uo(e)
        },
        lo = ee,
        ho = B,
        po = xe,
        fo = qa,
        vo = Vn,
        mo = function() {},
        go = [],
        yo = Ee("Reflect", "construct"),
        bo = /^\s*(?:class|function)\b/,
        xo = lo(bo.exec),
        ko = !bo.exec(mo),
        wo = function(e) {
            if (!po(e)) return !1;
            try {
                return yo(mo, go, e), !0
            } catch (e) {
                return !1
            }
        },
        Io = function(e) {
            if (!po(e)) return !1;
            switch (fo(e)) {
                case "AsyncFunction":
                case "GeneratorFunction":
                case "AsyncGeneratorFunction":
                    return !1
            }
            try {
                return ko || !!xo(bo, vo(e))
            } catch (e) {
                return !0
            }
        };
    Io.sham = !0;
    var No = !yo || ho((function() {
            var e;
            return wo(wo.call) || !wo(Object) || !wo((function() {
                e = !0
            })) || e
        })) ? Io : wo,
        So = co,
        To = No,
        Eo = Ie,
        Co = Mt("species"),
        Ao = Array,
        Ro = function(e) {
            var t;
            return So(e) && (t = e.constructor, (To(t) && (t === Ao || So(t.prototype)) || Eo(t) && null === (t = t[Co])) && (t = void 0)), void 0 === t ? Ao : t
        },
        _o = Ro,
        Oo = function(e, t) {
            return new(_o(e))(0 === t ? 0 : t)
        },
        Fo = so,
        Do = ce,
        Mo = yt,
        Lo = Kr,
        zo = Oo,
        Po = ee([].push),
        Bo = function(e) {
            var t = 1 == e,
                n = 2 == e,
                r = 3 == e,
                a = 4 == e,
                i = 6 == e,
                o = 7 == e,
                s = 5 == e || i;
            return function(u, c, l, h) {
                for (var p, f, d = Mo(u), v = Do(d), m = Fo(c, l), g = Lo(v), y = 0, b = h || zo, x = t ? b(u, g) : n || o ? b(u, 0) : void 0; g > y; y++)
                    if ((s || y in v) && (f = m(p = v[y], y, d), e))
                        if (t) x[y] = f;
                        else if (f) switch (e) {
                    case 3:
                        return !0;
                    case 5:
                        return p;
                    case 6:
                        return y;
                    case 2:
                        Po(x, p)
                } else switch (e) {
                    case 4:
                        return !1;
                    case 7:
                        Po(x, p)
                }
                return i ? -1 : r || a ? a : x
            }
        },
        Wo = {
            forEach: Bo(0),
            map: Bo(1),
            filter: Bo(2),
            some: Bo(3),
            every: Bo(4),
            find: Bo(5),
            findIndex: Bo(6),
            filterReject: Bo(7)
        },
        Uo = La,
        Vo = z,
        Go = j,
        jo = ee,
        Ho = W,
        qo = Be,
        Ko = B,
        Xo = kt,
        Yo = Ce,
        Jo = dn,
        Zo = me,
        Qo = qt,
        $o = Ya,
        es = Y,
        ts = yi,
        ns = $a,
        rs = Fr,
        as = bi,
        is = ua,
        os = P,
        ss = cn,
        us = Ja,
        cs = H,
        ls = Or,
        hs = zi,
        ps = vt,
        fs = Yn,
        ds = Tt,
        vs = Mt,
        ms = Pi,
        gs = Hi,
        ys = Ji,
        bs = eo,
        xs = cr,
        ks = Wo.forEach,
        ws = Xn("hidden"),
        Is = "Symbol",
        Ns = xs.set,
        Ss = xs.getterFor(Is),
        Ts = Object.prototype,
        Es = Vo.Symbol,
        Cs = Es && Es.prototype,
        As = Vo.TypeError,
        Rs = Vo.QObject,
        _s = os.f,
        Os = ss.f,
        Fs = as.f,
        Ds = cs.f,
        Ms = jo([].push),
        Ls = ps("symbols"),
        zs = ps("op-symbols"),
        Ps = ps("wks"),
        Bs = !Rs || !Rs.prototype || !Rs.prototype.findChild,
        Ws = Ho && Ko((function() {
            return 7 != ts(Os({}, "a", {
                get: function() {
                    return Os(this, "a", {
                        value: 7
                    }).a
                }
            })).a
        })) ? function(e, t, n) {
            var r = _s(Ts, t);
            r && delete Ts[t], Os(e, t, n), r && e !== Ts && Os(Ts, t, r)
        } : Os,
        Us = function(e, t) {
            var n = Ls[e] = ts(Cs);
            return Ns(n, {
                type: Is,
                tag: e,
                description: t
            }), Ho || (n.description = t), n
        },
        Vs = function(e, t, n) {
            e === Ts && Vs(zs, t, n), Jo(e);
            var r = Qo(t);
            return Jo(n), Xo(Ls, r) ? (n.enumerable ? (Xo(e, ws) && e[ws][r] && (e[ws][r] = !1), n = ts(n, {
                enumerable: es(0, !1)
            })) : (Xo(e, ws) || Os(e, ws, es(1, {})), e[ws][r] = !0), Ws(e, r, n)) : Os(e, r, n)
        },
        Gs = function(e, t) {
            Jo(e);
            var n = Zo(t),
                r = ns(n).concat(Ks(n));
            return ks(r, (function(t) {
                Ho && !Go(js, n, t) || Vs(e, t, n[t])
            })), e
        },
        js = function(e) {
            var t = Qo(e),
                n = Go(Ds, this, t);
            return !(this === Ts && Xo(Ls, t) && !Xo(zs, t)) && (!(n || !Xo(this, t) || !Xo(Ls, t) || Xo(this, ws) && this[ws][t]) || n)
        },
        Hs = function(e, t) {
            var n = Zo(e),
                r = Qo(t);
            if (n !== Ts || !Xo(Ls, r) || Xo(zs, r)) {
                var a = _s(n, r);
                return !a || !Xo(Ls, r) || Xo(n, ws) && n[ws][r] || (a.enumerable = !0), a
            }
        },
        qs = function(e) {
            var t = Fs(Zo(e)),
                n = [];
            return ks(t, (function(e) {
                Xo(Ls, e) || Xo(fs, e) || Ms(n, e)
            })), n
        },
        Ks = function(e) {
            var t = e === Ts,
                n = Fs(t ? zs : Zo(e)),
                r = [];
            return ks(n, (function(e) {
                !Xo(Ls, e) || t && !Xo(Ts, e) || Ms(r, Ls[e])
            })), r
        };
    qo || (Es = function() {
        if (Yo(Cs, this)) throw As("Symbol is not a constructor");
        var e = arguments.length && void 0 !== arguments[0] ? $o(arguments[0]) : void 0,
            t = ds(e),
            n = function e(n) {
                this === Ts && Go(e, zs, n), Xo(this, ws) && Xo(this[ws], t) && (this[ws][t] = !1), Ws(this, t, es(1, n))
            };
        return Ho && Bs && Ws(Ts, t, {
            configurable: !0,
            set: n
        }), Us(t, e)
    }, ls(Cs = Es.prototype, "toString", (function() {
        return Ss(this).tag
    })), ls(Es, "withoutSetter", (function(e) {
        return Us(ds(e), e)
    })), cs.f = js, ss.f = Vs, us.f = Gs, os.f = Hs, rs.f = as.f = qs, is.f = Ks, ms.f = function(e) {
        return Us(vs(e), e)
    }, Ho && (hs(Cs, "description", {
        configurable: !0,
        get: function() {
            return Ss(this).description
        }
    }), ls(Ts, "propertyIsEnumerable", js, {
        unsafe: !0
    }))), Uo({
        global: !0,
        constructor: !0,
        wrap: !0,
        forced: !qo,
        sham: !qo
    }, {
        Symbol: Es
    }), ks(ns(Ps), (function(e) {
        gs(e)
    })), Uo({
        target: Is,
        stat: !0,
        forced: !qo
    }, {
        useSetter: function() {
            Bs = !0
        },
        useSimple: function() {
            Bs = !1
        }
    }), Uo({
        target: "Object",
        stat: !0,
        forced: !qo,
        sham: !Ho
    }, {
        create: function(e, t) {
            return void 0 === t ? ts(e) : Gs(ts(e), t)
        },
        defineProperty: Vs,
        defineProperties: Gs,
        getOwnPropertyDescriptor: Hs
    }), Uo({
        target: "Object",
        stat: !0,
        forced: !qo
    }, {
        getOwnPropertyNames: qs
    }), ys(), bs(Es, Is), fs[ws] = !0;
    var Xs = Be && !!Symbol.for && !!Symbol.keyFor,
        Ys = La,
        Js = Ee,
        Zs = kt,
        Qs = Ya,
        $s = vt,
        eu = Xs,
        tu = $s("string-to-symbol-registry"),
        nu = $s("symbol-to-string-registry");
    Ys({
        target: "Symbol",
        stat: !0,
        forced: !eu
    }, {
        for: function(e) {
            var t = Qs(e);
            if (Zs(tu, t)) return tu[t];
            var n = Js("Symbol")(t);
            return tu[t] = n, nu[n] = t, n
        }
    });
    var ru = La,
        au = kt,
        iu = He,
        ou = Ke,
        su = Xs,
        uu = vt("symbol-to-string-registry");
    ru({
        target: "Symbol",
        stat: !0,
        forced: !su
    }, {
        keyFor: function(e) {
            if (!iu(e)) throw TypeError(ou(e) + " is not a symbol");
            if (au(uu, e)) return uu[e]
        }
    });
    var cu = U,
        lu = Function.prototype,
        hu = lu.apply,
        pu = lu.call,
        fu = "object" == ("undefined" == typeof Reflect ? "undefined" : s(Reflect)) && Reflect.apply || (cu ? pu.bind(hu) : function() {
            return pu.apply(hu, arguments)
        }),
        du = ee([].slice),
        vu = co,
        mu = xe,
        gu = ae,
        yu = Ya,
        bu = ee([].push),
        xu = function(e) {
            if (mu(e)) return e;
            if (vu(e)) {
                for (var t = e.length, n = [], r = 0; r < t; r++) {
                    var a = e[r];
                    "string" == typeof a ? bu(n, a) : "number" != typeof a && "Number" != gu(a) && "String" != gu(a) || bu(n, yu(a))
                }
                var i = n.length,
                    o = !0;
                return function(e, t) {
                    if (o) return o = !1, t;
                    if (vu(this)) return t;
                    for (var r = 0; r < i; r++)
                        if (n[r] === e) return t
                }
            }
        },
        ku = La,
        wu = Ee,
        Iu = fu,
        Nu = j,
        Su = ee,
        Tu = B,
        Eu = xe,
        Cu = He,
        Au = du,
        Ru = xu,
        _u = Be,
        Ou = String,
        Fu = wu("JSON", "stringify"),
        Du = Su(/./.exec),
        Mu = Su("".charAt),
        Lu = Su("".charCodeAt),
        zu = Su("".replace),
        Pu = Su(1..toString),
        Bu = /[\uD800-\uDFFF]/g,
        Wu = /^[\uD800-\uDBFF]$/,
        Uu = /^[\uDC00-\uDFFF]$/,
        Vu = !_u || Tu((function() {
            var e = wu("Symbol")();
            return "[null]" != Fu([e]) || "{}" != Fu({
                a: e
            }) || "{}" != Fu(Object(e))
        })),
        Gu = Tu((function() {
            return '"\\udf06\\ud834"' !== Fu("\udf06\ud834") || '"\\udead"' !== Fu("\udead")
        })),
        ju = function(e, t) {
            var n = Au(arguments),
                r = Ru(t);
            if (Eu(r) || void 0 !== e && !Cu(e)) return n[1] = function(e, t) {
                if (Eu(r) && (t = Nu(r, this, Ou(e), t)), !Cu(t)) return t
            }, Iu(Fu, null, n)
        },
        Hu = function(e, t, n) {
            var r = Mu(n, t - 1),
                a = Mu(n, t + 1);
            return Du(Wu, e) && !Du(Uu, a) || Du(Uu, e) && !Du(Wu, r) ? "\\u" + Pu(Lu(e, 0), 16) : e
        };
    Fu && ku({
        target: "JSON",
        stat: !0,
        arity: 3,
        forced: Vu || Gu
    }, {
        stringify: function(e, t, n) {
            var r = Au(arguments),
                a = Iu(Vu ? ju : Fu, null, r);
            return Gu && "string" == typeof a ? zu(a, Bu, Hu) : a
        }
    });
    var qu = ua,
        Ku = yt;
    La({
        target: "Object",
        stat: !0,
        forced: !Be || B((function() {
            qu.f(1)
        }))
    }, {
        getOwnPropertySymbols: function(e) {
            var t = qu.f;
            return t ? t(Ku(e)) : []
        }
    });
    var Xu = La,
        Yu = W,
        Ju = ee,
        Zu = kt,
        Qu = xe,
        $u = Ce,
        ec = Ya,
        tc = zi,
        nc = ba,
        rc = z.Symbol,
        ac = rc && rc.prototype;
    if (Yu && Qu(rc) && (!("description" in ac) || void 0 !== rc().description)) {
        var ic = {},
            oc = function() {
                var e = arguments.length < 1 || void 0 === arguments[0] ? void 0 : ec(arguments[0]),
                    t = $u(ac, this) ? new rc(e) : void 0 === e ? rc() : rc(e);
                return "" === e && (ic[t] = !0), t
            };
        nc(oc, rc), oc.prototype = ac, ac.constructor = oc;
        var sc = "Symbol(test)" == String(rc("test")),
            uc = Ju(ac.valueOf),
            cc = Ju(ac.toString),
            lc = /^Symbol\((.*)\)[^)]+$/,
            hc = Ju("".replace),
            pc = Ju("".slice);
        tc(ac, "description", {
            configurable: !0,
            get: function() {
                var e = uc(this);
                if (Zu(ic, e)) return "";
                var t = cc(e),
                    n = sc ? pc(t, 7, -1) : hc(t, lc, "$1");
                return "" === n ? void 0 : n
            }
        }), Xu({
            global: !0,
            constructor: !0,
            forced: !0
        }, {
            Symbol: oc
        })
    }
    Hi("asyncIterator"), Hi("hasInstance"), Hi("isConcatSpreadable"), Hi("iterator"), Hi("match"), Hi("matchAll"), Hi("replace"), Hi("search"), Hi("species"), Hi("split");
    var fc = Ji;
    Hi("toPrimitive"), fc();
    var dc = Ee,
        vc = eo;
    Hi("toStringTag"), vc(dc("Symbol"), "Symbol"), Hi("unscopables");
    var mc = ee,
        gc = Ze,
        yc = function(e, t, n) {
            try {
                return mc(gc(Object.getOwnPropertyDescriptor(e, t)[n]))
            } catch (e) {}
        },
        bc = xe,
        xc = String,
        kc = TypeError,
        wc = function(e) {
            if ("object" == s(e) || bc(e)) return e;
            throw kc("Can't set " + xc(e) + " as a prototype")
        },
        Ic = yc,
        Nc = dn,
        Sc = wc,
        Tc = Object.setPrototypeOf || ("__proto__" in {} ? function() {
            var e, t = !1,
                n = {};
            try {
                (e = Ic(Object.prototype, "__proto__", "set"))(n, []), t = n instanceof Array
            } catch (e) {}
            return function(n, r) {
                return Nc(n), Sc(r), t ? e(n, r) : n.__proto__ = r, n
            }
        }() : void 0),
        Ec = cn.f,
        Cc = function(e, t, n) {
            n in e || Ec(e, n, {
                configurable: !0,
                get: function() {
                    return t[n]
                },
                set: function(e) {
                    t[n] = e
                }
            })
        },
        Ac = xe,
        Rc = Ie,
        _c = Tc,
        Oc = function(e, t, n) {
            var r, a;
            return _c && Ac(r = t.constructor) && r !== n && Rc(a = r.prototype) && a !== n.prototype && _c(e, a), e
        },
        Fc = Ya,
        Dc = function(e, t) {
            return void 0 === e ? arguments.length < 2 ? "" : t : Fc(e)
        },
        Mc = Ie,
        Lc = Cn,
        zc = function(e, t) {
            Mc(t) && "cause" in t && Lc(e, "cause", t.cause)
        },
        Pc = Error,
        Bc = ee("".replace),
        Wc = String(Pc("zxcasd").stack),
        Uc = /\n\s*at [^:]*:[^\n]*/,
        Vc = Uc.test(Wc),
        Gc = function(e, t) {
            if (Vc && "string" == typeof e && !Pc.prepareStackTrace)
                for (; t--;) e = Bc(e, Uc, "");
            return e
        },
        jc = Y,
        Hc = !B((function() {
            var e = Error("a");
            return !("stack" in e) || (Object.defineProperty(e, "stack", jc(1, 7)), 7 !== e.stack)
        })),
        qc = Cn,
        Kc = Gc,
        Xc = Hc,
        Yc = Error.captureStackTrace,
        Jc = function(e, t, n, r) {
            Xc && (Yc ? Yc(e, t) : qc(e, "stack", Kc(n, r)))
        },
        Zc = Ee,
        Qc = kt,
        $c = Cn,
        el = Ce,
        tl = Tc,
        nl = ba,
        rl = Cc,
        al = Oc,
        il = Dc,
        ol = zc,
        sl = Jc,
        ul = W,
        cl = function(e, t, n, r) {
            var a = "stackTraceLimit",
                i = r ? 2 : 1,
                o = e.split("."),
                s = o[o.length - 1],
                u = Zc.apply(null, o);
            if (u) {
                var c = u.prototype;
                if (Qc(c, "cause") && delete c.cause, !n) return u;
                var l = Zc("Error"),
                    h = t((function(e, t) {
                        var n = il(r ? t : e, void 0),
                            a = r ? new u(e) : new u;
                        return void 0 !== n && $c(a, "message", n), sl(a, h, a.stack, 2), this && el(c, this) && al(a, this, h), arguments.length > i && ol(a, arguments[i]), a
                    }));
                h.prototype = c, "Error" !== s ? tl ? tl(h, l) : nl(h, l, {
                    name: !0
                }) : ul && a in u && (rl(h, u, a), rl(h, u, "prepareStackTrace")), nl(h, u);
                try {
                    c.name !== s && $c(c, "name", s), c.constructor = h
                } catch (e) {}
                return h
            }
        },
        ll = La,
        hl = fu,
        pl = cl,
        fl = "WebAssembly",
        dl = z.WebAssembly,
        vl = 7 !== Error("e", {
            cause: 7
        }).cause,
        ml = function(e, t) {
            var n = {};
            n[e] = pl(e, t, vl), ll({
                global: !0,
                constructor: !0,
                arity: 1,
                forced: vl
            }, n)
        },
        gl = function(e, t) {
            if (dl && dl[e]) {
                var n = {};
                n[e] = pl("WebAssembly." + e, t, vl), ll({
                    target: fl,
                    stat: !0,
                    constructor: !0,
                    arity: 1,
                    forced: vl
                }, n)
            }
        };
    ml("Error", (function(e) {
        return function(t) {
            return hl(e, this, arguments)
        }
    })), ml("EvalError", (function(e) {
        return function(t) {
            return hl(e, this, arguments)
        }
    })), ml("RangeError", (function(e) {
        return function(t) {
            return hl(e, this, arguments)
        }
    })), ml("ReferenceError", (function(e) {
        return function(t) {
            return hl(e, this, arguments)
        }
    })), ml("SyntaxError", (function(e) {
        return function(t) {
            return hl(e, this, arguments)
        }
    })), ml("TypeError", (function(e) {
        return function(t) {
            return hl(e, this, arguments)
        }
    })), ml("URIError", (function(e) {
        return function(t) {
            return hl(e, this, arguments)
        }
    })), gl("CompileError", (function(e) {
        return function(t) {
            return hl(e, this, arguments)
        }
    })), gl("LinkError", (function(e) {
        return function(t) {
            return hl(e, this, arguments)
        }
    })), gl("RuntimeError", (function(e) {
        return function(t) {
            return hl(e, this, arguments)
        }
    }));
    var yl = W,
        bl = B,
        xl = dn,
        kl = yi,
        wl = Dc,
        Il = Error.prototype.toString,
        Nl = bl((function() {
            if (yl) {
                var e = kl(Object.defineProperty({}, "name", {
                    get: function() {
                        return this === e
                    }
                }));
                if ("true" !== Il.call(e)) return !0
            }
            return "2: 1" !== Il.call({
                message: 1,
                name: 2
            }) || "Error" !== Il.call({})
        })) ? function() {
            var e = xl(this),
                t = wl(e.name, "Error"),
                n = wl(e.message);
            return t ? n ? t + ": " + n : t : n
        } : Il,
        Sl = Or,
        Tl = Nl,
        El = Error.prototype;
    El.toString !== Tl && Sl(El, "toString", Tl);
    var Cl = !B((function() {
            function e() {}
            return e.prototype.constructor = null, Object.getPrototypeOf(new e) !== e.prototype
        })),
        Al = kt,
        Rl = xe,
        _l = yt,
        Ol = Cl,
        Fl = Xn("IE_PROTO"),
        Dl = Object,
        Ml = Dl.prototype,
        Ll = Ol ? Dl.getPrototypeOf : function(e) {
            var t = _l(e);
            if (Al(t, Fl)) return t[Fl];
            var n = t.constructor;
            return Rl(n) && t instanceof n ? n.prototype : t instanceof Dl ? Ml : null
        },
        zl = {},
        Pl = zl,
        Bl = Mt("iterator"),
        Wl = Array.prototype,
        Ul = function(e) {
            return void 0 !== e && (Pl.Array === e || Wl[Bl] === e)
        },
        Vl = qa,
        Gl = et,
        jl = le,
        Hl = zl,
        ql = Mt("iterator"),
        Kl = function(e) {
            if (!jl(e)) return Gl(e, ql) || Gl(e, "@@iterator") || Hl[Vl(e)]
        },
        Xl = j,
        Yl = Ze,
        Jl = dn,
        Zl = Ke,
        Ql = Kl,
        $l = TypeError,
        eh = function(e, t) {
            var n = arguments.length < 2 ? Ql(e) : t;
            if (Yl(n)) return Jl(Xl(n, e));
            throw $l(Zl(e) + " is not iterable")
        },
        th = j,
        nh = dn,
        rh = et,
        ah = function(e, t, n) {
            var r, a;
            nh(e);
            try {
                if (!(r = rh(e, "return"))) {
                    if ("throw" === t) throw n;
                    return n
                }
                r = th(r, e)
            } catch (e) {
                a = !0, r = e
            }
            if ("throw" === t) throw n;
            if (a) throw r;
            return nh(r), n
        },
        ih = so,
        oh = j,
        sh = dn,
        uh = Ke,
        ch = Ul,
        lh = Kr,
        hh = Ce,
        ph = eh,
        fh = Kl,
        dh = ah,
        vh = TypeError,
        mh = function(e, t) {
            this.stopped = e, this.result = t
        },
        gh = mh.prototype,
        yh = function(e, t, n) {
            var r, a, i, o, u, c, l, h = n && n.that,
                p = !(!n || !n.AS_ENTRIES),
                f = !(!n || !n.IS_RECORD),
                d = !(!n || !n.IS_ITERATOR),
                v = !(!n || !n.INTERRUPTED),
                m = ih(t, h),
                g = function(e) {
                    return r && dh(r, "normal", e), new mh(!0, e)
                },
                y = function(e) {
                    return p ? (sh(e), v ? m(e[0], e[1], g) : m(e[0], e[1])) : v ? m(e, g) : m(e)
                };
            if (f) r = e.iterator;
            else if (d) r = e;
            else {
                if (!(a = fh(e))) throw vh(uh(e) + " is not iterable");
                if (ch(a)) {
                    for (i = 0, o = lh(e); o > i; i++)
                        if ((u = y(e[i])) && hh(gh, u)) return u;
                    return new mh(!1)
                }
                r = ph(e, a)
            }
            for (c = f ? e.next : r.next; !(l = oh(c, r)).done;) {
                try {
                    u = y(l.value)
                } catch (e) {
                    dh(r, "throw", e)
                }
                if ("object" == s(u) && u && hh(gh, u)) return u
            }
            return new mh(!1)
        },
        bh = La,
        xh = Ce,
        kh = Ll,
        wh = Tc,
        Ih = ba,
        Nh = yi,
        Sh = Cn,
        Th = Y,
        Eh = zc,
        Ch = Jc,
        Ah = yh,
        Rh = Dc,
        _h = Mt("toStringTag"),
        Oh = Error,
        Fh = [].push,
        Dh = function(e, t) {
            var n, r = xh(Mh, this);
            wh ? n = wh(Oh(), r ? kh(this) : Mh) : (n = r ? this : Nh(Mh), Sh(n, _h, "Error")), void 0 !== t && Sh(n, "message", Rh(t)), Ch(n, Dh, n.stack, 1), arguments.length > 2 && Eh(n, arguments[2]);
            var a = [];
            return Ah(e, Fh, {
                that: a
            }), Sh(n, "errors", a), n
        };
    wh ? wh(Dh, Oh) : Ih(Dh, Oh, {
        name: !0
    });
    var Mh = Dh.prototype = Nh(Oh.prototype, {
        constructor: Th(1, Dh),
        message: Th(1, ""),
        name: Th(1, "AggregateError")
    });
    bh({
        global: !0,
        constructor: !0,
        arity: 2
    }, {
        AggregateError: Dh
    });
    var Lh = La,
        zh = fu,
        Ph = B,
        Bh = cl,
        Wh = "AggregateError",
        Uh = Ee(Wh),
        Vh = !Ph((function() {
            return 1 !== Uh([1]).errors[0]
        })) && Ph((function() {
            return 7 !== Uh([1], Wh, {
                cause: 7
            }).cause
        }));
    Lh({
        global: !0,
        constructor: !0,
        arity: 2,
        forced: Vh
    }, {
        AggregateError: Bh(Wh, (function(e) {
            return function(t, n) {
                return zh(e, this, arguments)
            }
        }), Vh, !0)
    });
    var Gh = Mt,
        jh = yi,
        Hh = cn.f,
        qh = Gh("unscopables"),
        Kh = Array.prototype;
    null == Kh[qh] && Hh(Kh, qh, {
        configurable: !0,
        value: jh(null)
    });
    var Xh = function(e) {
            Kh[qh][e] = !0
        },
        Yh = yt,
        Jh = Kr,
        Zh = Pr,
        Qh = Xh;
    La({
        target: "Array",
        proto: !0
    }, {
        at: function(e) {
            var t = Yh(this),
                n = Jh(t),
                r = Zh(e),
                a = r >= 0 ? r : n + r;
            return a < 0 || a >= n ? void 0 : t[a]
        }
    }), Qh("at");
    var $h = TypeError,
        ep = function(e) {
            if (e > 9007199254740991) throw $h("Maximum allowed index exceeded");
            return e
        },
        tp = B,
        np = Le,
        rp = Mt("species"),
        ap = function(e) {
            return np >= 51 || !tp((function() {
                var t = [];
                return (t.constructor = {})[rp] = function() {
                    return {
                        foo: 1
                    }
                }, 1 !== t[e](Boolean).foo
            }))
        },
        ip = La,
        op = B,
        sp = co,
        up = Ie,
        cp = yt,
        lp = Kr,
        hp = ep,
        pp = Ii,
        fp = Oo,
        dp = ap,
        vp = Le,
        mp = Mt("isConcatSpreadable"),
        gp = vp >= 51 || !op((function() {
            var e = [];
            return e[mp] = !1, e.concat()[0] !== e
        })),
        yp = function(e) {
            if (!up(e)) return !1;
            var t = e[mp];
            return void 0 !== t ? !!t : sp(e)
        };
    ip({
        target: "Array",
        proto: !0,
        arity: 1,
        forced: !gp || !dp("concat")
    }, {
        concat: function(e) {
            var t, n, r, a, i, o = cp(this),
                s = fp(o, 0),
                u = 0;
            for (t = -1, r = arguments.length; t < r; t++)
                if (yp(i = -1 === t ? o : arguments[t]))
                    for (a = lp(i), hp(u + a), n = 0; n < a; n++, u++) n in i && pp(s, u, i[n]);
                else hp(u + 1), pp(s, u++, i);
            return s.length = u, s
        }
    });
    var bp = Ke,
        xp = TypeError,
        kp = function(e, t) {
            if (!delete e[t]) throw xp("Cannot delete property " + bp(t) + " of " + bp(e))
        },
        wp = yt,
        Ip = Vr,
        Np = Kr,
        Sp = kp,
        Tp = Math.min,
        Ep = [].copyWithin || function(e, t) {
            var n = wp(this),
                r = Np(n),
                a = Ip(e, r),
                i = Ip(t, r),
                o = arguments.length > 2 ? arguments[2] : void 0,
                s = Tp((void 0 === o ? r : Ip(o, r)) - i, r - a),
                u = 1;
            for (i < a && a < i + s && (u = -1, i += s - 1, a += s - 1); s-- > 0;) i in n ? n[a] = n[i] : Sp(n, a), a += u, i += u;
            return n
        },
        Cp = Xh;
    La({
        target: "Array",
        proto: !0
    }, {
        copyWithin: Ep
    }), Cp("copyWithin");
    var Ap = B,
        Rp = function(e, t) {
            var n = [][e];
            return !!n && Ap((function() {
                n.call(null, t || function() {
                    return 1
                }, 1)
            }))
        },
        _p = Wo.every;
    La({
        target: "Array",
        proto: !0,
        forced: !Rp("every")
    }, {
        every: function(e) {
            return _p(this, e, arguments.length > 1 ? arguments[1] : void 0)
        }
    });
    var Op = yt,
        Fp = Vr,
        Dp = Kr,
        Mp = function(e) {
            for (var t = Op(this), n = Dp(t), r = arguments.length, a = Fp(r > 1 ? arguments[1] : void 0, n), i = r > 2 ? arguments[2] : void 0, o = void 0 === i ? n : Fp(i, n); o > a;) t[a++] = e;
            return t
        },
        Lp = Xh;
    La({
        target: "Array",
        proto: !0
    }, {
        fill: Mp
    }), Lp("fill");
    var zp = Wo.filter;
    La({
        target: "Array",
        proto: !0,
        forced: !ap("filter")
    }, {
        filter: function(e) {
            return zp(this, e, arguments.length > 1 ? arguments[1] : void 0)
        }
    });
    var Pp = La,
        Bp = Wo.find,
        Wp = Xh,
        Up = "find",
        Vp = !0;
    Up in [] && Array(1).find((function() {
        Vp = !1
    })), Pp({
        target: "Array",
        proto: !0,
        forced: Vp
    }, {
        find: function(e) {
            return Bp(this, e, arguments.length > 1 ? arguments[1] : void 0)
        }
    }), Wp(Up);
    var Gp = La,
        jp = Wo.findIndex,
        Hp = Xh,
        qp = "findIndex",
        Kp = !0;
    qp in [] && Array(1).findIndex((function() {
        Kp = !1
    })), Gp({
        target: "Array",
        proto: !0,
        forced: Kp
    }, {
        findIndex: function(e) {
            return jp(this, e, arguments.length > 1 ? arguments[1] : void 0)
        }
    }), Hp(qp);
    var Xp = so,
        Yp = ce,
        Jp = yt,
        Zp = Kr,
        Qp = function(e) {
            var t = 1 == e;
            return function(n, r, a) {
                for (var i, o = Jp(n), s = Yp(o), u = Xp(r, a), c = Zp(s); c-- > 0;)
                    if (u(i = s[c], c, o)) switch (e) {
                        case 0:
                            return i;
                        case 1:
                            return c
                    }
                    return t ? -1 : void 0
            }
        },
        $p = {
            findLast: Qp(0),
            findLastIndex: Qp(1)
        },
        ef = $p.findLast,
        tf = Xh;
    La({
        target: "Array",
        proto: !0
    }, {
        findLast: function(e) {
            return ef(this, e, arguments.length > 1 ? arguments[1] : void 0)
        }
    }), tf("findLast");
    var nf = $p.findLastIndex,
        rf = Xh;
    La({
        target: "Array",
        proto: !0
    }, {
        findLastIndex: function(e) {
            return nf(this, e, arguments.length > 1 ? arguments[1] : void 0)
        }
    }), rf("findLastIndex");
    var af = co,
        of = Kr,
        sf = ep,
        uf = so,
        cf = function e(t, n, r, a, i, o, s, u) {
            for (var c, l = i, h = 0, p = !!s && uf(s, u); h < a;) h in r && (c = p ? p(r[h], h, n) : r[h], o > 0 && af(c) ? l = e(t, n, c, of(c), l, o - 1) - 1 : (sf(l + 1), t[l] = c), l++), h++;
            return l
        },
        lf = cf,
        hf = yt,
        pf = Kr,
        ff = Pr,
        df = Oo;
    La({
        target: "Array",
        proto: !0
    }, {
        flat: function() {
            var e = arguments.length ? arguments[0] : void 0,
                t = hf(this),
                n = pf(t),
                r = df(t, 0);
            return r.length = lf(r, t, t, n, 0, void 0 === e ? 1 : ff(e)), r
        }
    });
    var vf = cf,
        mf = Ze,
        gf = yt,
        yf = Kr,
        bf = Oo;
    La({
        target: "Array",
        proto: !0
    }, {
        flatMap: function(e) {
            var t, n = gf(this),
                r = yf(n);
            return mf(e), (t = bf(n, 0)).length = vf(t, n, n, r, 0, 1, e, arguments.length > 1 ? arguments[1] : void 0), t
        }
    });
    var xf = Wo.forEach,
        kf = Rp("forEach") ? [].forEach : function(e) {
            return xf(this, e, arguments.length > 1 ? arguments[1] : void 0)
        };
    La({
        target: "Array",
        proto: !0,
        forced: [].forEach != kf
    }, {
        forEach: kf
    });
    var wf = dn,
        If = ah,
        Nf = function(e, t, n, r) {
            try {
                return r ? t(wf(n)[0], n[1]) : t(n)
            } catch (t) {
                If(e, "throw", t)
            }
        },
        Sf = so,
        Tf = j,
        Ef = yt,
        Cf = Nf,
        Af = Ul,
        Rf = No,
        _f = Kr,
        Of = Ii,
        Ff = eh,
        Df = Kl,
        Mf = Array,
        Lf = function(e) {
            var t = Ef(e),
                n = Rf(this),
                r = arguments.length,
                a = r > 1 ? arguments[1] : void 0,
                i = void 0 !== a;
            i && (a = Sf(a, r > 2 ? arguments[2] : void 0));
            var o, s, u, c, l, h, p = Df(t),
                f = 0;
            if (!p || this === Mf && Af(p))
                for (o = _f(t), s = n ? new this(o) : Mf(o); o > f; f++) h = i ? a(t[f], f) : t[f], Of(s, f, h);
            else
                for (l = (c = Ff(t, p)).next, s = n ? new this : []; !(u = Tf(l, c)).done; f++) h = i ? Cf(c, a, [u.value, f], !0) : u.value, Of(s, f, h);
            return s.length = f, s
        },
        zf = Mt("iterator"),
        Pf = !1;
    try {
        var Bf = 0,
            Wf = {
                next: function() {
                    return {
                        done: !!Bf++
                    }
                },
                return: function() {
                    Pf = !0
                }
            };
        Wf[zf] = function() {
            return this
        }, Array.from(Wf, (function() {
            throw 2
        }))
    } catch (e) {}
    var Uf = function(e, t) {
            if (!t && !Pf) return !1;
            var n = !1;
            try {
                var r = {};
                r[zf] = function() {
                    return {
                        next: function() {
                            return {
                                done: n = !0
                            }
                        }
                    }
                }, e(r)
            } catch (e) {}
            return n
        },
        Vf = Lf;
    La({
        target: "Array",
        stat: !0,
        forced: !Uf((function(e) {
            Array.from(e)
        }))
    }, {
        from: Vf
    });
    var Gf = Qr.includes,
        jf = Xh;
    La({
        target: "Array",
        proto: !0,
        forced: B((function() {
            return !Array(1).includes()
        }))
    }, {
        includes: function(e) {
            return Gf(this, e, arguments.length > 1 ? arguments[1] : void 0)
        }
    }), jf("includes");
    var Hf = La,
        qf = Qr.indexOf,
        Kf = Rp,
        Xf = ro([].indexOf),
        Yf = !!Xf && 1 / Xf([1], 1, -0) < 0;
    Hf({
        target: "Array",
        proto: !0,
        forced: Yf || !Kf("indexOf")
    }, {
        indexOf: function(e) {
            var t = arguments.length > 1 ? arguments[1] : void 0;
            return Yf ? Xf(this, e, t) || 0 : qf(this, e, t)
        }
    }), La({
        target: "Array",
        stat: !0
    }, {
        isArray: co
    });
    var Jf, Zf, Qf, $f = B,
        ed = xe,
        td = Ie,
        nd = Ll,
        rd = Or,
        ad = Mt("iterator"),
        id = !1;
    [].keys && ("next" in (Qf = [].keys()) ? (Zf = nd(nd(Qf))) !== Object.prototype && (Jf = Zf) : id = !0);
    var od = !td(Jf) || $f((function() {
        var e = {};
        return Jf[ad].call(e) !== e
    }));
    od && (Jf = {}), ed(Jf[ad]) || rd(Jf, ad, (function() {
        return this
    }));
    var sd = {
            IteratorPrototype: Jf,
            BUGGY_SAFARI_ITERATORS: id
        },
        ud = sd.IteratorPrototype,
        cd = yi,
        ld = Y,
        hd = eo,
        pd = zl,
        fd = function() {
            return this
        },
        dd = function(e, t, n, r) {
            var a = t + " Iterator";
            return e.prototype = cd(ud, {
                next: ld(+!r, n)
            }), hd(e, a, !1, !0), pd[a] = fd, e
        },
        vd = La,
        md = j,
        gd = xe,
        yd = dd,
        bd = Ll,
        xd = Tc,
        kd = eo,
        wd = Cn,
        Id = Or,
        Nd = zl,
        Sd = Mn.PROPER,
        Td = Mn.CONFIGURABLE,
        Ed = sd.IteratorPrototype,
        Cd = sd.BUGGY_SAFARI_ITERATORS,
        Ad = Mt("iterator"),
        Rd = "keys",
        _d = "values",
        Od = "entries",
        Fd = function() {
            return this
        },
        Dd = function(e, t, n, r, a, i, o) {
            yd(n, t, r);
            var s, u, c, l = function(e) {
                    if (e === a && v) return v;
                    if (!Cd && e in f) return f[e];
                    switch (e) {
                        case Rd:
                        case _d:
                        case Od:
                            return function() {
                                return new n(this, e)
                            }
                    }
                    return function() {
                        return new n(this)
                    }
                },
                h = t + " Iterator",
                p = !1,
                f = e.prototype,
                d = f[Ad] || f["@@iterator"] || a && f[a],
                v = !Cd && d || l(a),
                m = "Array" == t && f.entries || d;
            if (m && (s = bd(m.call(new e))) !== Object.prototype && s.next && (bd(s) !== Ed && (xd ? xd(s, Ed) : gd(s[Ad]) || Id(s, Ad, Fd)), kd(s, h, !0, !0)), Sd && a == _d && d && d.name !== _d && (Td ? wd(f, "name", _d) : (p = !0, v = function() {
                    return md(d, this)
                })), a)
                if (u = {
                        values: l(_d),
                        keys: i ? v : l(Rd),
                        entries: l(Od)
                    }, o)
                    for (c in u)(Cd || p || !(c in f)) && Id(f, c, u[c]);
                else vd({
                    target: t,
                    proto: !0,
                    forced: Cd || p
                }, u);
            return f[Ad] !== v && Id(f, Ad, v, {
                name: a
            }), Nd[t] = v, u
        },
        Md = function(e, t) {
            return {
                value: e,
                done: t
            }
        },
        Ld = me,
        zd = Xh,
        Pd = zl,
        Bd = cr,
        Wd = cn.f,
        Ud = Dd,
        Vd = Md,
        Gd = W,
        jd = "Array Iterator",
        Hd = Bd.set,
        qd = Bd.getterFor(jd),
        Kd = Ud(Array, "Array", (function(e, t) {
            Hd(this, {
                type: jd,
                target: Ld(e),
                index: 0,
                kind: t
            })
        }), (function() {
            var e = qd(this),
                t = e.target,
                n = e.kind,
                r = e.index++;
            return !t || r >= t.length ? (e.target = void 0, Vd(void 0, !0)) : Vd("keys" == n ? r : "values" == n ? t[r] : [r, t[r]], !1)
        }), "values"),
        Xd = Pd.Arguments = Pd.Array;
    if (zd("keys"), zd("values"), zd("entries"), Gd && "values" !== Xd.name) try {
        Wd(Xd, "name", {
            value: "values"
        })
    } catch (e) {}
    var Yd = La,
        Jd = ce,
        Zd = me,
        Qd = Rp,
        $d = ee([].join);
    Yd({
        target: "Array",
        proto: !0,
        forced: Jd != Object || !Qd("join", ",")
    }, {
        join: function(e) {
            return $d(Zd(this), void 0 === e ? "," : e)
        }
    });
    var ev = fu,
        tv = me,
        nv = Pr,
        rv = Kr,
        av = Rp,
        iv = Math.min,
        ov = [].lastIndexOf,
        sv = !!ov && 1 / [1].lastIndexOf(1, -0) < 0,
        uv = av("lastIndexOf"),
        cv = sv || !uv ? function(e) {
            if (sv) return ev(ov, this, arguments) || 0;
            var t = tv(this),
                n = rv(t),
                r = n - 1;
            for (arguments.length > 1 && (r = iv(r, nv(arguments[1]))), r < 0 && (r = n + r); r >= 0; r--)
                if (r in t && t[r] === e) return r || 0;
            return -1
        } : ov;
    La({
        target: "Array",
        proto: !0,
        forced: cv !== [].lastIndexOf
    }, {
        lastIndexOf: cv
    });
    var lv = Wo.map;
    La({
        target: "Array",
        proto: !0,
        forced: !ap("map")
    }, {
        map: function(e) {
            return lv(this, e, arguments.length > 1 ? arguments[1] : void 0)
        }
    });
    var hv = No,
        pv = Ii,
        fv = Array;
    La({
        target: "Array",
        stat: !0,
        forced: B((function() {
            function e() {}
            return !(fv.of.call(e) instanceof e)
        }))
    }, {
        of: function() {
            for (var e = 0, t = arguments.length, n = new(hv(this) ? this : fv)(t); t > e;) pv(n, e, arguments[e++]);
            return n.length = t, n
        }
    });
    var dv = W,
        vv = co,
        mv = TypeError,
        gv = Object.getOwnPropertyDescriptor,
        yv = dv && ! function() {
            if (void 0 !== this) return !0;
            try {
                Object.defineProperty([], "length", {
                    writable: !1
                }).length = 1
            } catch (e) {
                return e instanceof TypeError
            }
        }() ? function(e, t) {
            if (vv(e) && !gv(e, "length").writable) throw mv("Cannot set read only .length");
            return e.length = t
        } : function(e, t) {
            return e.length = t
        },
        bv = yt,
        xv = Kr,
        kv = yv,
        wv = ep;
    La({
        target: "Array",
        proto: !0,
        arity: 1,
        forced: B((function() {
            return 4294967297 !== [].push.call({
                length: 4294967296
            }, 1)
        })) || ! function() {
            try {
                Object.defineProperty([], "length", {
                    writable: !1
                }).push()
            } catch (e) {
                return e instanceof TypeError
            }
        }()
    }, {
        push: function(e) {
            var t = bv(this),
                n = xv(t),
                r = arguments.length;
            wv(n + r);
            for (var a = 0; a < r; a++) t[n] = arguments[a], n++;
            return kv(t, n), n
        }
    });
    var Iv = Ze,
        Nv = yt,
        Sv = ce,
        Tv = Kr,
        Ev = TypeError,
        Cv = function(e) {
            return function(t, n, r, a) {
                Iv(n);
                var i = Nv(t),
                    o = Sv(i),
                    s = Tv(i),
                    u = e ? s - 1 : 0,
                    c = e ? -1 : 1;
                if (r < 2)
                    for (;;) {
                        if (u in o) {
                            a = o[u], u += c;
                            break
                        }
                        if (u += c, e ? u < 0 : s <= u) throw Ev("Reduce of empty array with no initial value")
                    }
                for (; e ? u >= 0 : s > u; u += c) u in o && (a = n(a, o[u], u, i));
                return a
            }
        },
        Av = {
            left: Cv(!1),
            right: Cv(!0)
        },
        Rv = "undefined" != typeof process && "process" == ae(process),
        _v = Av.left;
    La({
        target: "Array",
        proto: !0,
        forced: !Rv && Le > 79 && Le < 83 || !Rp("reduce")
    }, {
        reduce: function(e) {
            var t = arguments.length;
            return _v(this, e, t, t > 1 ? arguments[1] : void 0)
        }
    });
    var Ov = Av.right;
    La({
        target: "Array",
        proto: !0,
        forced: !Rv && Le > 79 && Le < 83 || !Rp("reduceRight")
    }, {
        reduceRight: function(e) {
            return Ov(this, e, arguments.length, arguments.length > 1 ? arguments[1] : void 0)
        }
    });
    var Fv = La,
        Dv = co,
        Mv = ee([].reverse),
        Lv = [1, 2];
    Fv({
        target: "Array",
        proto: !0,
        forced: String(Lv) === String(Lv.reverse())
    }, {
        reverse: function() {
            return Dv(this) && (this.length = this.length), Mv(this)
        }
    });
    var zv = La,
        Pv = co,
        Bv = No,
        Wv = Ie,
        Uv = Vr,
        Vv = Kr,
        Gv = me,
        jv = Ii,
        Hv = Mt,
        qv = du,
        Kv = ap("slice"),
        Xv = Hv("species"),
        Yv = Array,
        Jv = Math.max;
    zv({
        target: "Array",
        proto: !0,
        forced: !Kv
    }, {
        slice: function(e, t) {
            var n, r, a, i = Gv(this),
                o = Vv(i),
                s = Uv(e, o),
                u = Uv(void 0 === t ? o : t, o);
            if (Pv(i) && (n = i.constructor, (Bv(n) && (n === Yv || Pv(n.prototype)) || Wv(n) && null === (n = n[Xv])) && (n = void 0), n === Yv || void 0 === n)) return qv(i, s, u);
            for (r = new(void 0 === n ? Yv : n)(Jv(u - s, 0)), a = 0; s < u; s++, a++) s in i && jv(r, a, i[s]);
            return r.length = a, r
        }
    });
    var Zv = Wo.some;
    La({
        target: "Array",
        proto: !0,
        forced: !Rp("some")
    }, {
        some: function(e) {
            return Zv(this, e, arguments.length > 1 ? arguments[1] : void 0)
        }
    });
    var Qv = Ai,
        $v = Math.floor,
        em = function(e, t) {
            for (var n, r, a = e.length, i = 1; i < a;) {
                for (r = i, n = e[i]; r && t(e[r - 1], n) > 0;) e[r] = e[--r];
                r !== i++ && (e[r] = n)
            }
            return e
        },
        tm = function(e, t, n, r) {
            for (var a = t.length, i = n.length, o = 0, s = 0; o < a || s < i;) e[o + s] = o < a && s < i ? r(t[o], n[s]) <= 0 ? t[o++] : n[s++] : o < a ? t[o++] : n[s++];
            return e
        },
        nm = function e(t, n) {
            var r = t.length,
                a = $v(r / 2);
            return r < 8 ? em(t, n) : tm(t, e(Qv(t, 0, a), n), e(Qv(t, a), n), n)
        },
        rm = Ae.match(/firefox\/(\d+)/i),
        am = !!rm && +rm[1],
        im = /MSIE|Trident/.test(Ae),
        om = Ae.match(/AppleWebKit\/(\d+)\./),
        sm = !!om && +om[1],
        um = La,
        cm = ee,
        lm = Ze,
        hm = yt,
        pm = Kr,
        fm = kp,
        dm = Ya,
        vm = B,
        mm = nm,
        gm = Rp,
        ym = am,
        bm = im,
        xm = Le,
        km = sm,
        wm = [],
        Im = cm(wm.sort),
        Nm = cm(wm.push),
        Sm = vm((function() {
            wm.sort(void 0)
        })),
        Tm = vm((function() {
            wm.sort(null)
        })),
        Em = gm("sort"),
        Cm = !vm((function() {
            if (xm) return xm < 70;
            if (!(ym && ym > 3)) {
                if (bm) return !0;
                if (km) return km < 603;
                var e, t, n, r, a = "";
                for (e = 65; e < 76; e++) {
                    switch (t = String.fromCharCode(e), e) {
                        case 66:
                        case 69:
                        case 70:
                        case 72:
                            n = 3;
                            break;
                        case 68:
                        case 71:
                            n = 4;
                            break;
                        default:
                            n = 2
                    }
                    for (r = 0; r < 47; r++) wm.push({
                        k: t + r,
                        v: n
                    })
                }
                for (wm.sort((function(e, t) {
                        return t.v - e.v
                    })), r = 0; r < wm.length; r++) t = wm[r].k.charAt(0), a.charAt(a.length - 1) !== t && (a += t);
                return "DGBEFHACIJK" !== a
            }
        }));
    um({
        target: "Array",
        proto: !0,
        forced: Sm || !Tm || !Em || !Cm
    }, {
        sort: function(e) {
            void 0 !== e && lm(e);
            var t = hm(this);
            if (Cm) return void 0 === e ? Im(t) : Im(t, e);
            var n, r, a = [],
                i = pm(t);
            for (r = 0; r < i; r++) r in t && Nm(a, t[r]);
            for (mm(a, function(e) {
                    return function(t, n) {
                        return void 0 === n ? -1 : void 0 === t ? 1 : void 0 !== e ? +e(t, n) || 0 : dm(t) > dm(n) ? 1 : -1
                    }
                }(e)), n = pm(a), r = 0; r < n;) t[r] = a[r++];
            for (; r < i;) fm(t, r++);
            return t
        }
    });
    var Am = Ee,
        Rm = zi,
        _m = W,
        Om = Mt("species"),
        Fm = function(e) {
            var t = Am(e);
            _m && t && !t[Om] && Rm(t, Om, {
                configurable: !0,
                get: function() {
                    return this
                }
            })
        };
    Fm("Array");
    var Dm = La,
        Mm = yt,
        Lm = Vr,
        zm = Pr,
        Pm = Kr,
        Bm = yv,
        Wm = ep,
        Um = Oo,
        Vm = Ii,
        Gm = kp,
        jm = ap("splice"),
        Hm = Math.max,
        qm = Math.min;
    Dm({
        target: "Array",
        proto: !0,
        forced: !jm
    }, {
        splice: function(e, t) {
            var n, r, a, i, o, s, u = Mm(this),
                c = Pm(u),
                l = Lm(e, c),
                h = arguments.length;
            for (0 === h ? n = r = 0 : 1 === h ? (n = 0, r = c - l) : (n = h - 2, r = qm(Hm(zm(t), 0), c - l)), Wm(c + n - r), a = Um(u, r), i = 0; i < r; i++)(o = l + i) in u && Vm(a, i, u[o]);
            if (a.length = r, n < r) {
                for (i = l; i < c - r; i++) s = i + n, (o = i + r) in u ? u[s] = u[o] : Gm(u, s);
                for (i = c; i > c - r + n; i--) Gm(u, i - 1)
            } else if (n > r)
                for (i = c - r; i > l; i--) s = i + n - 1, (o = i + r - 1) in u ? u[s] = u[o] : Gm(u, s);
            for (i = 0; i < n; i++) u[i + l] = arguments[i + 2];
            return Bm(u, c - r + n), a
        }
    });
    var Km = Kr,
        Xm = function(e, t) {
            for (var n = Km(e), r = new t(n), a = 0; a < n; a++) r[a] = e[n - a - 1];
            return r
        },
        Ym = Xm,
        Jm = me,
        Zm = Xh,
        Qm = Array;
    La({
        target: "Array",
        proto: !0
    }, {
        toReversed: function() {
            return Ym(Jm(this), Qm)
        }
    }), Zm("toReversed");
    var $m = Kr,
        eg = function(e, t) {
            for (var n = 0, r = $m(t), a = new e(r); r > n;) a[n] = t[n++];
            return a
        },
        tg = z,
        ng = function(e) {
            return tg[e].prototype
        },
        rg = La,
        ag = Ze,
        ig = me,
        og = eg,
        sg = Xh,
        ug = Array,
        cg = ee(ng("Array").sort);
    rg({
        target: "Array",
        proto: !0
    }, {
        toSorted: function(e) {
            void 0 !== e && ag(e);
            var t = ig(this),
                n = og(ug, t);
            return cg(n, e)
        }
    }), sg("toSorted");
    var lg = La,
        hg = Xh,
        pg = ep,
        fg = Kr,
        dg = Vr,
        vg = me,
        mg = Pr,
        gg = Array,
        yg = Math.max,
        bg = Math.min;
    lg({
        target: "Array",
        proto: !0
    }, {
        toSpliced: function(e, t) {
            var n, r, a, i, o = vg(this),
                s = fg(o),
                u = dg(e, s),
                c = arguments.length,
                l = 0;
            for (0 === c ? n = r = 0 : 1 === c ? (n = 0, r = s - u) : (n = c - 2, r = bg(yg(mg(t), 0), s - u)), a = pg(s + n - r), i = gg(a); l < u; l++) i[l] = o[l];
            for (; l < u + n; l++) i[l] = arguments[l - u + 2];
            for (; l < a; l++) i[l] = o[l + r - n];
            return i
        }
    }), hg("toSpliced"), Xh("flat"), Xh("flatMap");
    var xg = yt,
        kg = Kr,
        wg = yv,
        Ig = kp,
        Ng = ep;
    La({
        target: "Array",
        proto: !0,
        arity: 1,
        forced: 1 !== [].unshift(0) || ! function() {
            try {
                Object.defineProperty([], "length", {
                    writable: !1
                }).unshift()
            } catch (e) {
                return e instanceof TypeError
            }
        }()
    }, {
        unshift: function(e) {
            var t = xg(this),
                n = kg(t),
                r = arguments.length;
            if (r) {
                Ng(n + r);
                for (var a = n; a--;) {
                    var i = a + r;
                    a in t ? t[i] = t[a] : Ig(t, i)
                }
                for (var o = 0; o < r; o++) t[o] = arguments[o]
            }
            return wg(t, n + r)
        }
    });
    var Sg = Kr,
        Tg = Pr,
        Eg = RangeError,
        Cg = function(e, t, n, r) {
            var a = Sg(e),
                i = Tg(n),
                o = i < 0 ? a + i : i;
            if (o >= a || o < 0) throw Eg("Incorrect index");
            for (var s = new t(a), u = 0; u < a; u++) s[u] = u === o ? r : e[u];
            return s
        },
        Ag = Cg,
        Rg = me,
        _g = Array;
    La({
        target: "Array",
        proto: !0
    }, {
        with: function(e, t) {
            return Ag(Rg(this), _g, e, t)
        }
    });
    var Og = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView,
        Fg = Or,
        Dg = function(e, t, n) {
            for (var r in t) Fg(e, r, t[r], n);
            return e
        },
        Mg = Ce,
        Lg = TypeError,
        zg = function(e, t) {
            if (Mg(t, e)) return e;
            throw Lg("Incorrect invocation")
        },
        Pg = Pr,
        Bg = Hr,
        Wg = RangeError,
        Ug = function(e) {
            if (void 0 === e) return 0;
            var t = Pg(e),
                n = Bg(t);
            if (t !== n) throw Wg("Wrong length or index");
            return n
        },
        Vg = Array,
        Gg = Math.abs,
        jg = Math.pow,
        Hg = Math.floor,
        qg = Math.log,
        Kg = Math.LN2,
        Xg = {
            pack: function(e, t, n) {
                var r, a, i, o = Vg(n),
                    s = 8 * n - t - 1,
                    u = (1 << s) - 1,
                    c = u >> 1,
                    l = 23 === t ? jg(2, -24) - jg(2, -77) : 0,
                    h = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0,
                    p = 0;
                for ((e = Gg(e)) != e || e === 1 / 0 ? (a = e != e ? 1 : 0, r = u) : (r = Hg(qg(e) / Kg), e * (i = jg(2, -r)) < 1 && (r--, i *= 2), (e += r + c >= 1 ? l / i : l * jg(2, 1 - c)) * i >= 2 && (r++, i /= 2), r + c >= u ? (a = 0, r = u) : r + c >= 1 ? (a = (e * i - 1) * jg(2, t), r += c) : (a = e * jg(2, c - 1) * jg(2, t), r = 0)); t >= 8;) o[p++] = 255 & a, a /= 256, t -= 8;
                for (r = r << t | a, s += t; s > 0;) o[p++] = 255 & r, r /= 256, s -= 8;
                return o[--p] |= 128 * h, o
            },
            unpack: function(e, t) {
                var n, r = e.length,
                    a = 8 * r - t - 1,
                    i = (1 << a) - 1,
                    o = i >> 1,
                    s = a - 7,
                    u = r - 1,
                    c = e[u--],
                    l = 127 & c;
                for (c >>= 7; s > 0;) l = 256 * l + e[u--], s -= 8;
                for (n = l & (1 << -s) - 1, l >>= -s, s += t; s > 0;) n = 256 * n + e[u--], s -= 8;
                if (0 === l) l = 1 - o;
                else {
                    if (l === i) return n ? NaN : c ? -1 / 0 : 1 / 0;
                    n += jg(2, t), l -= o
                }
                return (c ? -1 : 1) * n * jg(2, l - t)
            }
        },
        Yg = z,
        Jg = ee,
        Zg = W,
        Qg = Og,
        $g = Mn,
        ey = Cn,
        ty = zi,
        ny = Dg,
        ry = B,
        ay = zg,
        iy = Pr,
        oy = Hr,
        sy = Ug,
        uy = Xg,
        cy = Ll,
        ly = Tc,
        hy = Fr.f,
        py = Mp,
        fy = Ai,
        dy = eo,
        vy = cr,
        my = $g.PROPER,
        gy = $g.CONFIGURABLE,
        yy = "ArrayBuffer",
        by = "DataView",
        xy = "Wrong index",
        ky = vy.getterFor(yy),
        wy = vy.getterFor(by),
        Iy = vy.set,
        Ny = Yg.ArrayBuffer,
        Sy = Ny,
        Ty = Sy && Sy.prototype,
        Ey = Yg.DataView,
        Cy = Ey && Ey.prototype,
        Ay = Object.prototype,
        Ry = Yg.Array,
        _y = Yg.RangeError,
        Oy = Jg(py),
        Fy = Jg([].reverse),
        Dy = uy.pack,
        My = uy.unpack,
        Ly = function(e) {
            return [255 & e]
        },
        zy = function(e) {
            return [255 & e, e >> 8 & 255]
        },
        Py = function(e) {
            return [255 & e, e >> 8 & 255, e >> 16 & 255, e >> 24 & 255]
        },
        By = function(e) {
            return e[3] << 24 | e[2] << 16 | e[1] << 8 | e[0]
        },
        Wy = function(e) {
            return Dy(e, 23, 4)
        },
        Uy = function(e) {
            return Dy(e, 52, 8)
        },
        Vy = function(e, t, n) {
            ty(e.prototype, t, {
                configurable: !0,
                get: function() {
                    return n(this)[t]
                }
            })
        },
        Gy = function(e, t, n, r) {
            var a = sy(n),
                i = wy(e);
            if (a + t > i.byteLength) throw _y(xy);
            var o = i.bytes,
                s = a + i.byteOffset,
                u = fy(o, s, s + t);
            return r ? u : Fy(u)
        },
        jy = function(e, t, n, r, a, i) {
            var o = sy(n),
                s = wy(e);
            if (o + t > s.byteLength) throw _y(xy);
            for (var u = s.bytes, c = o + s.byteOffset, l = r(+a), h = 0; h < t; h++) u[c + h] = l[i ? h : t - h - 1]
        };
    if (Qg) {
        var Hy = my && Ny.name !== yy;
        if (ry((function() {
                Ny(1)
            })) && ry((function() {
                new Ny(-1)
            })) && !ry((function() {
                return new Ny, new Ny(1.5), new Ny(NaN), 1 != Ny.length || Hy && !gy
            }))) Hy && gy && ey(Ny, "name", yy);
        else {
            (Sy = function(e) {
                return ay(this, Ty), new Ny(sy(e))
            }).prototype = Ty;
            for (var qy, Ky = hy(Ny), Xy = 0; Ky.length > Xy;)(qy = Ky[Xy++]) in Sy || ey(Sy, qy, Ny[qy]);
            Ty.constructor = Sy
        }
        ly && cy(Cy) !== Ay && ly(Cy, Ay);
        var Yy = new Ey(new Sy(2)),
            Jy = Jg(Cy.setInt8);
        Yy.setInt8(0, 2147483648), Yy.setInt8(1, 2147483649), !Yy.getInt8(0) && Yy.getInt8(1) || ny(Cy, {
            setInt8: function(e, t) {
                Jy(this, e, t << 24 >> 24)
            },
            setUint8: function(e, t) {
                Jy(this, e, t << 24 >> 24)
            }
        }, {
            unsafe: !0
        })
    } else Ty = (Sy = function(e) {
        ay(this, Ty);
        var t = sy(e);
        Iy(this, {
            type: yy,
            bytes: Oy(Ry(t), 0),
            byteLength: t
        }), Zg || (this.byteLength = t, this.detached = !1)
    }).prototype, Ey = function(e, t, n) {
        ay(this, Cy), ay(e, Ty);
        var r = ky(e),
            a = r.byteLength,
            i = iy(t);
        if (i < 0 || i > a) throw _y("Wrong offset");
        if (i + (n = void 0 === n ? a - i : oy(n)) > a) throw _y("Wrong length");
        Iy(this, {
            type: by,
            buffer: e,
            byteLength: n,
            byteOffset: i,
            bytes: r.bytes
        }), Zg || (this.buffer = e, this.byteLength = n, this.byteOffset = i)
    }, Cy = Ey.prototype, Zg && (Vy(Sy, "byteLength", ky), Vy(Ey, "buffer", wy), Vy(Ey, "byteLength", wy), Vy(Ey, "byteOffset", wy)), ny(Cy, {
        getInt8: function(e) {
            return Gy(this, 1, e)[0] << 24 >> 24
        },
        getUint8: function(e) {
            return Gy(this, 1, e)[0]
        },
        getInt16: function(e) {
            var t = Gy(this, 2, e, arguments.length > 1 ? arguments[1] : void 0);
            return (t[1] << 8 | t[0]) << 16 >> 16
        },
        getUint16: function(e) {
            var t = Gy(this, 2, e, arguments.length > 1 ? arguments[1] : void 0);
            return t[1] << 8 | t[0]
        },
        getInt32: function(e) {
            return By(Gy(this, 4, e, arguments.length > 1 ? arguments[1] : void 0))
        },
        getUint32: function(e) {
            return By(Gy(this, 4, e, arguments.length > 1 ? arguments[1] : void 0)) >>> 0
        },
        getFloat32: function(e) {
            return My(Gy(this, 4, e, arguments.length > 1 ? arguments[1] : void 0), 23)
        },
        getFloat64: function(e) {
            return My(Gy(this, 8, e, arguments.length > 1 ? arguments[1] : void 0), 52)
        },
        setInt8: function(e, t) {
            jy(this, 1, e, Ly, t)
        },
        setUint8: function(e, t) {
            jy(this, 1, e, Ly, t)
        },
        setInt16: function(e, t) {
            jy(this, 2, e, zy, t, arguments.length > 2 ? arguments[2] : void 0)
        },
        setUint16: function(e, t) {
            jy(this, 2, e, zy, t, arguments.length > 2 ? arguments[2] : void 0)
        },
        setInt32: function(e, t) {
            jy(this, 4, e, Py, t, arguments.length > 2 ? arguments[2] : void 0)
        },
        setUint32: function(e, t) {
            jy(this, 4, e, Py, t, arguments.length > 2 ? arguments[2] : void 0)
        },
        setFloat32: function(e, t) {
            jy(this, 4, e, Wy, t, arguments.length > 2 ? arguments[2] : void 0)
        },
        setFloat64: function(e, t) {
            jy(this, 8, e, Uy, t, arguments.length > 2 ? arguments[2] : void 0)
        }
    });
    dy(Sy, yy), dy(Ey, by);
    var Zy = {
            ArrayBuffer: Sy,
            DataView: Ey
        },
        Qy = Fm,
        $y = "ArrayBuffer",
        eb = Zy.ArrayBuffer;
    La({
        global: !0,
        constructor: !0,
        forced: z.ArrayBuffer !== eb
    }, {
        ArrayBuffer: eb
    }), Qy($y);
    var tb, nb, rb, ab = Og,
        ib = W,
        ob = z,
        sb = xe,
        ub = Ie,
        cb = kt,
        lb = qa,
        hb = Ke,
        pb = Cn,
        fb = Or,
        db = zi,
        vb = Ce,
        mb = Ll,
        gb = Tc,
        yb = Mt,
        bb = Tt,
        xb = cr.enforce,
        kb = cr.get,
        wb = ob.Int8Array,
        Ib = wb && wb.prototype,
        Nb = ob.Uint8ClampedArray,
        Sb = Nb && Nb.prototype,
        Tb = wb && mb(wb),
        Eb = Ib && mb(Ib),
        Cb = Object.prototype,
        Ab = ob.TypeError,
        Rb = yb("toStringTag"),
        _b = bb("TYPED_ARRAY_TAG"),
        Ob = "TypedArrayConstructor",
        Fb = ab && !!gb && "Opera" !== lb(ob.opera),
        Db = !1,
        Mb = {
            Int8Array: 1,
            Uint8Array: 1,
            Uint8ClampedArray: 1,
            Int16Array: 2,
            Uint16Array: 2,
            Int32Array: 4,
            Uint32Array: 4,
            Float32Array: 4,
            Float64Array: 8
        },
        Lb = {
            BigInt64Array: 8,
            BigUint64Array: 8
        },
        zb = function(e) {
            if (!ub(e)) return !1;
            var t = lb(e);
            return cb(Mb, t) || cb(Lb, t)
        };
    for (tb in Mb)(rb = (nb = ob[tb]) && nb.prototype) ? xb(rb).TypedArrayConstructor = nb : Fb = !1;
    for (tb in Lb)(rb = (nb = ob[tb]) && nb.prototype) && (xb(rb).TypedArrayConstructor = nb);
    if ((!Fb || !sb(Tb) || Tb === Function.prototype) && (Tb = function() {
            throw Ab("Incorrect invocation")
        }, Fb))
        for (tb in Mb) ob[tb] && gb(ob[tb], Tb);
    if ((!Fb || !Eb || Eb === Cb) && (Eb = Tb.prototype, Fb))
        for (tb in Mb) ob[tb] && gb(ob[tb].prototype, Eb);
    if (Fb && mb(Sb) !== Eb && gb(Sb, Eb), ib && !cb(Eb, Rb))
        for (tb in Db = !0, db(Eb, Rb, {
                configurable: !0,
                get: function() {
                    return ub(this) ? this[_b] : void 0
                }
            }), Mb) ob[tb] && pb(ob[tb], _b, tb);
    var Pb = {
        NATIVE_ARRAY_BUFFER_VIEWS: Fb,
        TYPED_ARRAY_TAG: Db && _b,
        aTypedArray: function(e) {
            if (zb(e)) return e;
            throw Ab("Target is not a typed array")
        },
        aTypedArrayConstructor: function(e) {
            if (sb(e) && (!gb || vb(Tb, e))) return e;
            throw Ab(hb(e) + " is not a typed array constructor")
        },
        exportTypedArrayMethod: function(e, t, n, r) {
            if (ib) {
                if (n)
                    for (var a in Mb) {
                        var i = ob[a];
                        if (i && cb(i.prototype, e)) try {
                            delete i.prototype[e]
                        } catch (n) {
                            try {
                                i.prototype[e] = t
                            } catch (e) {}
                        }
                    }
                Eb[e] && !n || fb(Eb, e, n ? t : Fb && Ib[e] || t, r)
            }
        },
        exportTypedArrayStaticMethod: function(e, t, n) {
            var r, a;
            if (ib) {
                if (gb) {
                    if (n)
                        for (r in Mb)
                            if ((a = ob[r]) && cb(a, e)) try {
                                delete a[e]
                            } catch (e) {}
                            if (Tb[e] && !n) return;
                    try {
                        return fb(Tb, e, n ? t : Fb && Tb[e] || t)
                    } catch (e) {}
                }
                for (r in Mb) !(a = ob[r]) || a[e] && !n || fb(a, e, t)
            }
        },
        getTypedArrayConstructor: function e(t) {
            var n = mb(t);
            if (ub(n)) {
                var r = kb(n);
                return r && cb(r, Ob) ? r.TypedArrayConstructor : e(n)
            }
        },
        isView: function(e) {
            if (!ub(e)) return !1;
            var t = lb(e);
            return "DataView" === t || cb(Mb, t) || cb(Lb, t)
        },
        isTypedArray: zb,
        TypedArray: Tb,
        TypedArrayPrototype: Eb
    };
    La({
        target: "ArrayBuffer",
        stat: !0,
        forced: !Pb.NATIVE_ARRAY_BUFFER_VIEWS
    }, {
        isView: Pb.isView
    });
    var Bb = No,
        Wb = Ke,
        Ub = TypeError,
        Vb = function(e) {
            if (Bb(e)) return e;
            throw Ub(Wb(e) + " is not a constructor")
        },
        Gb = dn,
        jb = Vb,
        Hb = le,
        qb = Mt("species"),
        Kb = function(e, t) {
            var n, r = Gb(e).constructor;
            return void 0 === r || Hb(n = Gb(r)[qb]) ? t : jb(n)
        },
        Xb = La,
        Yb = ro,
        Jb = B,
        Zb = dn,
        Qb = Vr,
        $b = Hr,
        ex = Kb,
        tx = Zy.ArrayBuffer,
        nx = Zy.DataView,
        rx = nx.prototype,
        ax = Yb(tx.prototype.slice),
        ix = Yb(rx.getUint8),
        ox = Yb(rx.setUint8);
    Xb({
        target: "ArrayBuffer",
        proto: !0,
        unsafe: !0,
        forced: Jb((function() {
            return !new tx(2).slice(1, void 0).byteLength
        }))
    }, {
        slice: function(e, t) {
            if (ax && void 0 === t) return ax(Zb(this), e);
            for (var n = Zb(this).byteLength, r = Qb(e, n), a = Qb(void 0 === t ? n : t, n), i = new(ex(this, tx))($b(a - r)), o = new nx(this), s = new nx(i), u = 0; r < a;) ox(s, u++, ix(o, r++));
            return i
        }
    }), La({
        global: !0,
        constructor: !0,
        forced: !Og
    }, {
        DataView: Zy.DataView
    });
    var sx = La,
        ux = ee,
        cx = B((function() {
            return 120 !== new Date(16e11).getYear()
        })),
        lx = ux(Date.prototype.getFullYear);
    sx({
        target: "Date",
        proto: !0,
        forced: cx
    }, {
        getYear: function() {
            return lx(this) - 1900
        }
    });
    var hx = La,
        px = Date,
        fx = ee(px.prototype.getTime);
    hx({
        target: "Date",
        stat: !0
    }, {
        now: function() {
            return fx(new px)
        }
    });
    var dx = La,
        vx = ee,
        mx = Pr,
        gx = Date.prototype,
        yx = vx(gx.getTime),
        bx = vx(gx.setFullYear);
    dx({
        target: "Date",
        proto: !0
    }, {
        setYear: function(e) {
            yx(this);
            var t = mx(e);
            return bx(this, 0 <= t && t <= 99 ? t + 1900 : t)
        }
    }), La({
        target: "Date",
        proto: !0
    }, {
        toGMTString: Date.prototype.toUTCString
    });
    var xx = Pr,
        kx = Ya,
        wx = fe,
        Ix = RangeError,
        Nx = function(e) {
            var t = kx(wx(this)),
                n = "",
                r = xx(e);
            if (r < 0 || r == 1 / 0) throw Ix("Wrong number of repetitions");
            for (; r > 0;
                (r >>>= 1) && (t += t)) 1 & r && (n += t);
            return n
        },
        Sx = ee,
        Tx = Hr,
        Ex = Ya,
        Cx = fe,
        Ax = Sx(Nx),
        Rx = Sx("".slice),
        _x = Math.ceil,
        Ox = function(e) {
            return function(t, n, r) {
                var a, i, o = Ex(Cx(t)),
                    s = Tx(n),
                    u = o.length,
                    c = void 0 === r ? " " : Ex(r);
                return s <= u || "" == c ? o : ((i = Ax(c, _x((a = s - u) / c.length))).length > a && (i = Rx(i, 0, a)), e ? o + i : i + o)
            }
        },
        Fx = {
            start: Ox(!1),
            end: Ox(!0)
        },
        Dx = ee,
        Mx = B,
        Lx = Fx.start,
        zx = RangeError,
        Px = isFinite,
        Bx = Math.abs,
        Wx = Date.prototype,
        Ux = Wx.toISOString,
        Vx = Dx(Wx.getTime),
        Gx = Dx(Wx.getUTCDate),
        jx = Dx(Wx.getUTCFullYear),
        Hx = Dx(Wx.getUTCHours),
        qx = Dx(Wx.getUTCMilliseconds),
        Kx = Dx(Wx.getUTCMinutes),
        Xx = Dx(Wx.getUTCMonth),
        Yx = Dx(Wx.getUTCSeconds),
        Jx = Mx((function() {
            return "0385-07-25T07:06:39.999Z" != Ux.call(new Date(-50000000000001))
        })) || !Mx((function() {
            Ux.call(new Date(NaN))
        })) ? function() {
            if (!Px(Vx(this))) throw zx("Invalid time value");
            var e = this,
                t = jx(e),
                n = qx(e),
                r = t < 0 ? "-" : t > 9999 ? "+" : "";
            return r + Lx(Bx(t), r ? 6 : 4, 0) + "-" + Lx(Xx(e) + 1, 2, 0) + "-" + Lx(Gx(e), 2, 0) + "T" + Lx(Hx(e), 2, 0) + ":" + Lx(Kx(e), 2, 0) + ":" + Lx(Yx(e), 2, 0) + "." + Lx(n, 3, 0) + "Z"
        } : Ux,
        Zx = Jx;
    La({
        target: "Date",
        proto: !0,
        forced: Date.prototype.toISOString !== Zx
    }, {
        toISOString: Zx
    });
    var Qx = yt,
        $x = Gt;
    La({
        target: "Date",
        proto: !0,
        arity: 1,
        forced: B((function() {
            return null !== new Date(NaN).toJSON() || 1 !== Date.prototype.toJSON.call({
                toISOString: function() {
                    return 1
                }
            })
        }))
    }, {
        toJSON: function(e) {
            var t = Qx(this),
                n = $x(t, "number");
            return "number" != typeof n || isFinite(n) ? t.toISOString() : null
        }
    });
    var ek = dn,
        tk = it,
        nk = TypeError,
        rk = function(e) {
            if (ek(this), "string" === e || "default" === e) e = "string";
            else if ("number" !== e) throw nk("Incorrect hint");
            return tk(this, e)
        },
        ak = kt,
        ik = Or,
        ok = rk,
        sk = Mt("toPrimitive"),
        uk = Date.prototype;
    ak(uk, sk) || ik(uk, sk, ok);
    var ck = ee,
        lk = Or,
        hk = Date.prototype,
        pk = "Invalid Date",
        fk = "toString",
        dk = ck(hk.toString),
        vk = ck(hk.getTime);
    String(new Date(NaN)) != pk && lk(hk, fk, (function() {
        var e = vk(this);
        return e == e ? dk(this) : pk
    }));
    var mk = La,
        gk = ee,
        yk = Ya,
        bk = gk("".charAt),
        xk = gk("".charCodeAt),
        kk = gk(/./.exec),
        wk = gk(1..toString),
        Ik = gk("".toUpperCase),
        Nk = /[\w*+\-./@]/,
        Sk = function(e, t) {
            for (var n = wk(e, 16); n.length < t;) n = "0" + n;
            return n
        };
    mk({
        global: !0
    }, {
        escape: function(e) {
            for (var t, n, r = yk(e), a = "", i = r.length, o = 0; o < i;) t = bk(r, o++), kk(Nk, t) ? a += t : a += (n = xk(t, 0)) < 256 ? "%" + Sk(n, 2) : "%u" + Ik(Sk(n, 4));
            return a
        }
    });
    var Tk = ee,
        Ek = Ze,
        Ck = Ie,
        Ak = kt,
        Rk = du,
        _k = U,
        Ok = Function,
        Fk = Tk([].concat),
        Dk = Tk([].join),
        Mk = {},
        Lk = function(e, t, n) {
            if (!Ak(Mk, t)) {
                for (var r = [], a = 0; a < t; a++) r[a] = "a[" + a + "]";
                Mk[t] = Ok("C,a", "return new C(" + Dk(r, ",") + ")")
            }
            return Mk[t](e, n)
        },
        zk = _k ? Ok.bind : function(e) {
            var t = Ek(this),
                n = t.prototype,
                r = Rk(arguments, 1),
                a = function() {
                    var n = Fk(r, Rk(arguments));
                    return this instanceof a ? Lk(t, n.length, n) : t.apply(e, n)
                };
            return Ck(n) && (a.prototype = n), a
        },
        Pk = zk;
    La({
        target: "Function",
        proto: !0,
        forced: Function.bind !== Pk
    }, {
        bind: Pk
    });
    var Bk = xe,
        Wk = Ie,
        Uk = cn,
        Vk = Ll,
        Gk = Er,
        jk = Mt("hasInstance"),
        Hk = Function.prototype;
    jk in Hk || Uk.f(Hk, jk, {
        value: Gk((function(e) {
            if (!Bk(this) || !Wk(e)) return !1;
            var t = this.prototype;
            if (!Wk(t)) return e instanceof this;
            for (; e = Vk(e);)
                if (t === e) return !0;
            return !1
        }), jk)
    });
    var qk = W,
        Kk = Mn.EXISTS,
        Xk = ee,
        Yk = zi,
        Jk = Function.prototype,
        Zk = Xk(Jk.toString),
        Qk = /function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/,
        $k = Xk(Qk.exec);
    qk && !Kk && Yk(Jk, "name", {
        configurable: !0,
        get: function() {
            try {
                return $k(Qk, Zk(this))[1]
            } catch (e) {
                return ""
            }
        }
    });
    var ew = z;
    La({
        global: !0,
        forced: ew.globalThis !== ew
    }, {
        globalThis: ew
    }), eo(z.JSON, "JSON", !0);
    var tw = {
            exports: {}
        },
        nw = B((function() {
            if ("function" == typeof ArrayBuffer) {
                var e = new ArrayBuffer(8);
                Object.isExtensible(e) && Object.defineProperty(e, "a", {
                    value: 8
                })
            }
        })),
        rw = B,
        aw = Ie,
        iw = ae,
        ow = nw,
        sw = Object.isExtensible,
        uw = rw((function() {
            sw(1)
        })) || ow ? function(e) {
            return !!aw(e) && ((!ow || "ArrayBuffer" != iw(e)) && (!sw || sw(e)))
        } : sw,
        cw = !B((function() {
            return Object.isExtensible(Object.preventExtensions({}))
        })),
        lw = (tw.exports, La),
        hw = ee,
        pw = Yn,
        fw = Ie,
        dw = kt,
        vw = cn.f,
        mw = Fr,
        gw = bi,
        yw = uw,
        bw = cw,
        xw = !1,
        kw = Tt("meta"),
        ww = 0,
        Iw = function(e) {
            vw(e, kw, {
                value: {
                    objectID: "O" + ww++,
                    weakData: {}
                }
            })
        },
        Nw = tw.exports = {
            enable: function() {
                Nw.enable = function() {}, xw = !0;
                var e = mw.f,
                    t = hw([].splice),
                    n = {};
                n[kw] = 1, e(n).length && (mw.f = function(n) {
                    for (var r = e(n), a = 0, i = r.length; a < i; a++)
                        if (r[a] === kw) {
                            t(r, a, 1);
                            break
                        }
                    return r
                }, lw({
                    target: "Object",
                    stat: !0,
                    forced: !0
                }, {
                    getOwnPropertyNames: gw.f
                }))
            },
            fastKey: function(e, t) {
                if (!fw(e)) return "symbol" == s(e) ? e : ("string" == typeof e ? "S" : "P") + e;
                if (!dw(e, kw)) {
                    if (!yw(e)) return "F";
                    if (!t) return "E";
                    Iw(e)
                }
                return e[kw].objectID
            },
            getWeakData: function(e, t) {
                if (!dw(e, kw)) {
                    if (!yw(e)) return !0;
                    if (!t) return !1;
                    Iw(e)
                }
                return e[kw].weakData
            },
            onFreeze: function(e) {
                return bw && xw && yw(e) && !dw(e, kw) && Iw(e), e
            }
        };
    pw[kw] = !0;
    var Sw = tw.exports,
        Tw = La,
        Ew = z,
        Cw = ee,
        Aw = Ca,
        Rw = Or,
        _w = Sw,
        Ow = yh,
        Fw = zg,
        Dw = xe,
        Mw = le,
        Lw = Ie,
        zw = B,
        Pw = Uf,
        Bw = eo,
        Ww = Oc,
        Uw = function(e, t, n) {
            var r = -1 !== e.indexOf("Map"),
                a = -1 !== e.indexOf("Weak"),
                i = r ? "set" : "add",
                o = Ew[e],
                s = o && o.prototype,
                u = o,
                c = {},
                l = function(e) {
                    var t = Cw(s[e]);
                    Rw(s, e, "add" == e ? function(e) {
                        return t(this, 0 === e ? 0 : e), this
                    } : "delete" == e ? function(e) {
                        return !(a && !Lw(e)) && t(this, 0 === e ? 0 : e)
                    } : "get" == e ? function(e) {
                        return a && !Lw(e) ? void 0 : t(this, 0 === e ? 0 : e)
                    } : "has" == e ? function(e) {
                        return !(a && !Lw(e)) && t(this, 0 === e ? 0 : e)
                    } : function(e, n) {
                        return t(this, 0 === e ? 0 : e, n), this
                    })
                };
            if (Aw(e, !Dw(o) || !(a || s.forEach && !zw((function() {
                    (new o).entries().next()
                }))))) u = n.getConstructor(t, e, r, i), _w.enable();
            else if (Aw(e, !0)) {
                var h = new u,
                    p = h[i](a ? {} : -0, 1) != h,
                    f = zw((function() {
                        h.has(1)
                    })),
                    d = Pw((function(e) {
                        new o(e)
                    })),
                    v = !a && zw((function() {
                        for (var e = new o, t = 5; t--;) e[i](t, t);
                        return !e.has(-0)
                    }));
                d || ((u = t((function(e, t) {
                    Fw(e, s);
                    var n = Ww(new o, e, u);
                    return Mw(t) || Ow(t, n[i], {
                        that: n,
                        AS_ENTRIES: r
                    }), n
                }))).prototype = s, s.constructor = u), (f || v) && (l("delete"), l("has"), r && l("get")), (v || p) && l(i), a && s.clear && delete s.clear
            }
            return c[e] = u, Tw({
                global: !0,
                constructor: !0,
                forced: u != o
            }, c), Bw(u, e), a || n.setStrong(u, e, r), u
        },
        Vw = yi,
        Gw = zi,
        jw = Dg,
        Hw = so,
        qw = zg,
        Kw = le,
        Xw = yh,
        Yw = Dd,
        Jw = Md,
        Zw = Fm,
        Qw = W,
        $w = Sw.fastKey,
        eI = cr.set,
        tI = cr.getterFor,
        nI = {
            getConstructor: function(e, t, n, r) {
                var a = e((function(e, a) {
                        qw(e, i), eI(e, {
                            type: t,
                            index: Vw(null),
                            first: void 0,
                            last: void 0,
                            size: 0
                        }), Qw || (e.size = 0), Kw(a) || Xw(a, e[r], {
                            that: e,
                            AS_ENTRIES: n
                        })
                    })),
                    i = a.prototype,
                    o = tI(t),
                    s = function(e, t, n) {
                        var r, a, i = o(e),
                            s = u(e, t);
                        return s ? s.value = n : (i.last = s = {
                            index: a = $w(t, !0),
                            key: t,
                            value: n,
                            previous: r = i.last,
                            next: void 0,
                            removed: !1
                        }, i.first || (i.first = s), r && (r.next = s), Qw ? i.size++ : e.size++, "F" !== a && (i.index[a] = s)), e
                    },
                    u = function(e, t) {
                        var n, r = o(e),
                            a = $w(t);
                        if ("F" !== a) return r.index[a];
                        for (n = r.first; n; n = n.next)
                            if (n.key == t) return n
                    };
                return jw(i, {
                    clear: function() {
                        for (var e = o(this), t = e.index, n = e.first; n;) n.removed = !0, n.previous && (n.previous = n.previous.next = void 0), delete t[n.index], n = n.next;
                        e.first = e.last = void 0, Qw ? e.size = 0 : this.size = 0
                    },
                    delete: function(e) {
                        var t = this,
                            n = o(t),
                            r = u(t, e);
                        if (r) {
                            var a = r.next,
                                i = r.previous;
                            delete n.index[r.index], r.removed = !0, i && (i.next = a), a && (a.previous = i), n.first == r && (n.first = a), n.last == r && (n.last = i), Qw ? n.size-- : t.size--
                        }
                        return !!r
                    },
                    forEach: function(e) {
                        for (var t, n = o(this), r = Hw(e, arguments.length > 1 ? arguments[1] : void 0); t = t ? t.next : n.first;)
                            for (r(t.value, t.key, this); t && t.removed;) t = t.previous
                    },
                    has: function(e) {
                        return !!u(this, e)
                    }
                }), jw(i, n ? {
                    get: function(e) {
                        var t = u(this, e);
                        return t && t.value
                    },
                    set: function(e, t) {
                        return s(this, 0 === e ? 0 : e, t)
                    }
                } : {
                    add: function(e) {
                        return s(this, e = 0 === e ? 0 : e, e)
                    }
                }), Qw && Gw(i, "size", {
                    configurable: !0,
                    get: function() {
                        return o(this).size
                    }
                }), a
            },
            setStrong: function(e, t, n) {
                var r = t + " Iterator",
                    a = tI(t),
                    i = tI(r);
                Yw(e, t, (function(e, t) {
                    eI(this, {
                        type: r,
                        target: e,
                        state: a(e),
                        kind: t,
                        last: void 0
                    })
                }), (function() {
                    for (var e = i(this), t = e.kind, n = e.last; n && n.removed;) n = n.previous;
                    return e.target && (e.last = n = n ? n.next : e.state.first) ? Jw("keys" == t ? n.key : "values" == t ? n.value : [n.key, n.value], !1) : (e.target = void 0, Jw(void 0, !0))
                }), n ? "entries" : "values", !n, !0), Zw(t)
            }
        };
    Uw("Map", (function(e) {
        return function() {
            return e(this, arguments.length ? arguments[0] : void 0)
        }
    }), nI);
    var rI = Math.log,
        aI = Math.log1p || function(e) {
            var t = +e;
            return t > -1e-8 && t < 1e-8 ? t - t * t / 2 : rI(1 + t)
        },
        iI = La,
        oI = aI,
        sI = Math.acosh,
        uI = Math.log,
        cI = Math.sqrt,
        lI = Math.LN2;
    iI({
        target: "Math",
        stat: !0,
        forced: !sI || 710 != Math.floor(sI(Number.MAX_VALUE)) || sI(1 / 0) != 1 / 0
    }, {
        acosh: function(e) {
            var t = +e;
            return t < 1 ? NaN : t > 94906265.62425156 ? uI(t) + lI : oI(t - 1 + cI(t - 1) * cI(t + 1))
        }
    });
    var hI = La,
        pI = Math.asinh,
        fI = Math.log,
        dI = Math.sqrt;
    hI({
        target: "Math",
        stat: !0,
        forced: !(pI && 1 / pI(0) > 0)
    }, {
        asinh: function e(t) {
            var n = +t;
            return isFinite(n) && 0 != n ? n < 0 ? -e(-n) : fI(n + dI(n * n + 1)) : n
        }
    });
    var vI = La,
        mI = Math.atanh,
        gI = Math.log;
    vI({
        target: "Math",
        stat: !0,
        forced: !(mI && 1 / mI(-0) < 0)
    }, {
        atanh: function(e) {
            var t = +e;
            return 0 == t ? t : gI((1 + t) / (1 - t)) / 2
        }
    });
    var yI = Math.sign || function(e) {
            var t = +e;
            return 0 == t || t != t ? t : t < 0 ? -1 : 1
        },
        bI = La,
        xI = yI,
        kI = Math.abs,
        wI = Math.pow;
    bI({
        target: "Math",
        stat: !0
    }, {
        cbrt: function(e) {
            var t = +e;
            return xI(t) * wI(kI(t), 1 / 3)
        }
    });
    var II = La,
        NI = Math.floor,
        SI = Math.log,
        TI = Math.LOG2E;
    II({
        target: "Math",
        stat: !0
    }, {
        clz32: function(e) {
            var t = e >>> 0;
            return t ? 31 - NI(SI(t + .5) * TI) : 32
        }
    });
    var EI = Math.expm1,
        CI = Math.exp,
        AI = !EI || EI(10) > 22025.465794806718 || EI(10) < 22025.465794806718 || -2e-17 != EI(-2e-17) ? function(e) {
            var t = +e;
            return 0 == t ? t : t > -1e-6 && t < 1e-6 ? t + t * t / 2 : CI(t) - 1
        } : EI,
        RI = La,
        _I = AI,
        OI = Math.cosh,
        FI = Math.abs,
        DI = Math.E;
    RI({
        target: "Math",
        stat: !0,
        forced: !OI || OI(710) === 1 / 0
    }, {
        cosh: function(e) {
            var t = _I(FI(e) - 1) + 1;
            return (t + 1 / (t * DI * DI)) * (DI / 2)
        }
    });
    var MI = AI;
    La({
        target: "Math",
        stat: !0,
        forced: MI != Math.expm1
    }, {
        expm1: MI
    });
    var LI = yI,
        zI = Math.abs,
        PI = Math.pow,
        BI = PI(2, -52),
        WI = PI(2, -23),
        UI = PI(2, 127) * (2 - WI),
        VI = PI(2, -126),
        GI = Math.fround || function(e) {
            var t, n, r = +e,
                a = zI(r),
                i = LI(r);
            return a < VI ? i * function(e) {
                return e + 1 / BI - 1 / BI
            }(a / VI / WI) * VI * WI : (n = (t = (1 + WI / BI) * a) - (t - a)) > UI || n != n ? i * (1 / 0) : i * n
        };
    La({
        target: "Math",
        stat: !0
    }, {
        fround: GI
    });
    var jI = La,
        HI = Math.hypot,
        qI = Math.abs,
        KI = Math.sqrt;
    jI({
        target: "Math",
        stat: !0,
        arity: 2,
        forced: !!HI && HI(1 / 0, NaN) !== 1 / 0
    }, {
        hypot: function(e, t) {
            for (var n, r, a = 0, i = 0, o = arguments.length, s = 0; i < o;) s < (n = qI(arguments[i++])) ? (a = a * (r = s / n) * r + 1, s = n) : a += n > 0 ? (r = n / s) * r : n;
            return s === 1 / 0 ? 1 / 0 : s * KI(a)
        }
    });
    var XI = La,
        YI = B,
        JI = Math.imul;
    XI({
        target: "Math",
        stat: !0,
        forced: YI((function() {
            return -5 != JI(4294967295, 5) || 2 != JI.length
        }))
    }, {
        imul: function(e, t) {
            var n = 65535,
                r = +e,
                a = +t,
                i = n & r,
                o = n & a;
            return 0 | i * o + ((n & r >>> 16) * o + i * (n & a >>> 16) << 16 >>> 0)
        }
    });
    var ZI = Math.log,
        QI = Math.LOG10E,
        $I = Math.log10 || function(e) {
            return ZI(e) * QI
        };
    La({
        target: "Math",
        stat: !0
    }, {
        log10: $I
    }), La({
        target: "Math",
        stat: !0
    }, {
        log1p: aI
    });
    var eN = La,
        tN = Math.log,
        nN = Math.LN2;
    eN({
        target: "Math",
        stat: !0
    }, {
        log2: function(e) {
            return tN(e) / nN
        }
    }), La({
        target: "Math",
        stat: !0
    }, {
        sign: yI
    });
    var rN = La,
        aN = B,
        iN = AI,
        oN = Math.abs,
        sN = Math.exp,
        uN = Math.E;
    rN({
        target: "Math",
        stat: !0,
        forced: aN((function() {
            return -2e-17 != Math.sinh(-2e-17)
        }))
    }, {
        sinh: function(e) {
            var t = +e;
            return oN(t) < 1 ? (iN(t) - iN(-t)) / 2 : (sN(t - 1) - sN(-t - 1)) * (uN / 2)
        }
    });
    var cN = La,
        lN = AI,
        hN = Math.exp;
    cN({
        target: "Math",
        stat: !0
    }, {
        tanh: function(e) {
            var t = +e,
                n = lN(t),
                r = lN(-t);
            return n == 1 / 0 ? 1 : r == 1 / 0 ? -1 : (n - r) / (hN(t) + hN(-t))
        }
    }), eo(Math, "Math", !0), La({
        target: "Math",
        stat: !0
    }, {
        trunc: Lr
    });
    var pN = ee(1..valueOf),
        fN = "\t\n\v\f\r Â áââââââââââââ¯âã\u2028\u2029\ufeff",
        dN = fe,
        vN = Ya,
        mN = fN,
        gN = ee("".replace),
        yN = RegExp("^[" + mN + "]+"),
        bN = RegExp("(^|[^" + mN + "])[" + mN + "]+$"),
        xN = function(e) {
            return function(t) {
                var n = vN(dN(t));
                return 1 & e && (n = gN(n, yN, "")), 2 & e && (n = gN(n, bN, "$1")), n
            }
        },
        kN = {
            start: xN(1),
            end: xN(2),
            trim: xN(3)
        },
        wN = La,
        IN = st,
        NN = W,
        SN = z,
        TN = Wi,
        EN = ee,
        CN = Ca,
        AN = kt,
        RN = Oc,
        _N = Ce,
        ON = He,
        FN = Gt,
        DN = B,
        MN = Fr.f,
        LN = P.f,
        zN = cn.f,
        PN = pN,
        BN = kN.trim,
        WN = "Number",
        UN = SN.Number,
        VN = (TN.Number, UN.prototype),
        GN = SN.TypeError,
        jN = EN("".slice),
        HN = EN("".charCodeAt),
        qN = function(e) {
            var t = FN(e, "number");
            return "bigint" == typeof t ? t : KN(t)
        },
        KN = function(e) {
            var t, n, r, a, i, o, s, u, c = FN(e, "number");
            if (ON(c)) throw GN("Cannot convert a Symbol value to a number");
            if ("string" == typeof c && c.length > 2)
                if (c = BN(c), 43 === (t = HN(c, 0)) || 45 === t) {
                    if (88 === (n = HN(c, 2)) || 120 === n) return NaN
                } else if (48 === t) {
                switch (HN(c, 1)) {
                    case 66:
                    case 98:
                        r = 2, a = 49;
                        break;
                    case 79:
                    case 111:
                        r = 8, a = 55;
                        break;
                    default:
                        return +c
                }
                for (o = (i = jN(c, 2)).length, s = 0; s < o; s++)
                    if ((u = HN(i, s)) < 48 || u > a) return NaN;
                return parseInt(i, r)
            }
            return +c
        },
        XN = CN(WN, !UN(" 0o1") || !UN("0b1") || UN("+0x1")),
        YN = function(e) {
            return _N(VN, e) && DN((function() {
                PN(e)
            }))
        },
        JN = function(e) {
            var t = arguments.length < 1 ? 0 : UN(qN(e));
            return YN(this) ? RN(Object(t), this, JN) : t
        };
    JN.prototype = VN, XN && (VN.constructor = JN), wN({
        global: !0,
        constructor: !0,
        wrap: !0,
        forced: XN
    }, {
        Number: JN
    });
    var ZN = function(e, t) {
        for (var n, r = NN ? MN(t) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(","), a = 0; r.length > a; a++) AN(t, n = r[a]) && !AN(e, n) && zN(e, n, LN(t, n))
    };
    XN && ZN(TN.Number, UN), La({
        target: "Number",
        stat: !0,
        nonConfigurable: !0,
        nonWritable: !0
    }, {
        EPSILON: Math.pow(2, -52)
    });
    var QN = z.isFinite,
        $N = Number.isFinite || function(e) {
            return "number" == typeof e && QN(e)
        };
    La({
        target: "Number",
        stat: !0
    }, {
        isFinite: $N
    });
    var eS = Ie,
        tS = Math.floor,
        nS = Number.isInteger || function(e) {
            return !eS(e) && isFinite(e) && tS(e) === e
        };
    La({
        target: "Number",
        stat: !0
    }, {
        isInteger: nS
    }), La({
        target: "Number",
        stat: !0
    }, {
        isNaN: function(e) {
            return e != e
        }
    });
    var rS = La,
        aS = nS,
        iS = Math.abs;
    rS({
        target: "Number",
        stat: !0
    }, {
        isSafeInteger: function(e) {
            return aS(e) && iS(e) <= 9007199254740991
        }
    }), La({
        target: "Number",
        stat: !0,
        nonConfigurable: !0,
        nonWritable: !0
    }, {
        MAX_SAFE_INTEGER: 9007199254740991
    }), La({
        target: "Number",
        stat: !0,
        nonConfigurable: !0,
        nonWritable: !0
    }, {
        MIN_SAFE_INTEGER: -9007199254740991
    });
    var oS = z,
        sS = B,
        uS = Ya,
        cS = kN.trim,
        lS = ee("".charAt),
        hS = oS.parseFloat,
        pS = oS.Symbol,
        fS = pS && pS.iterator,
        dS = 1 / hS("\t\n\v\f\r Â áââââââââââââ¯âã\u2028\u2029\ufeff-0") != -1 / 0 || fS && !sS((function() {
            hS(Object(fS))
        })) ? function(e) {
            var t = cS(uS(e)),
                n = hS(t);
            return 0 === n && "-" == lS(t, 0) ? -0 : n
        } : hS,
        vS = dS;
    La({
        target: "Number",
        stat: !0,
        forced: Number.parseFloat != vS
    }, {
        parseFloat: vS
    });
    var mS = z,
        gS = B,
        yS = ee,
        bS = Ya,
        xS = kN.trim,
        kS = fN,
        wS = mS.parseInt,
        IS = mS.Symbol,
        NS = IS && IS.iterator,
        SS = /^[+-]?0x/i,
        TS = yS(SS.exec),
        ES = 8 !== wS(kS + "08") || 22 !== wS(kS + "0x16") || NS && !gS((function() {
            wS(Object(NS))
        })) ? function(e, t) {
            var n = xS(bS(e));
            return wS(n, t >>> 0 || (TS(SS, n) ? 16 : 10))
        } : wS,
        CS = ES;
    La({
        target: "Number",
        stat: !0,
        forced: Number.parseInt != CS
    }, {
        parseInt: CS
    });
    var AS = La,
        RS = ee,
        _S = Pr,
        OS = pN,
        FS = Nx,
        DS = $I,
        MS = B,
        LS = RangeError,
        zS = String,
        PS = isFinite,
        BS = Math.abs,
        WS = Math.floor,
        US = Math.pow,
        VS = Math.round,
        GS = RS(1..toExponential),
        jS = RS(FS),
        HS = RS("".slice),
        qS = "-6.9000e-11" === GS(-69e-12, 4) && "1.25e+0" === GS(1.255, 2) && "1.235e+4" === GS(12345, 3) && "3e+1" === GS(25, 0);
    AS({
        target: "Number",
        proto: !0,
        forced: !qS || !(MS((function() {
            GS(1, 1 / 0)
        })) && MS((function() {
            GS(1, -1 / 0)
        }))) || !!MS((function() {
            GS(1 / 0, 1 / 0), GS(NaN, 1 / 0)
        }))
    }, {
        toExponential: function(e) {
            var t = OS(this);
            if (void 0 === e) return GS(t);
            var n = _S(e);
            if (!PS(t)) return String(t);
            if (n < 0 || n > 20) throw LS("Incorrect fraction digits");
            if (qS) return GS(t, n);
            var r = "",
                a = "",
                i = 0,
                o = "",
                s = "";
            if (t < 0 && (r = "-", t = -t), 0 === t) i = 0, a = jS("0", n + 1);
            else {
                var u = DS(t);
                i = WS(u);
                var c = 0,
                    l = US(10, i - n);
                2 * t >= (2 * (c = VS(t / l)) + 1) * l && (c += 1), c >= US(10, n + 1) && (c /= 10, i += 1), a = zS(c)
            }
            return 0 !== n && (a = HS(a, 0, 1) + "." + HS(a, 1)), 0 === i ? (o = "+", s = "0") : (o = i > 0 ? "+" : "-", s = zS(BS(i))), r + (a += "e" + o + s)
        }
    });
    var KS = La,
        XS = ee,
        YS = Pr,
        JS = pN,
        ZS = Nx,
        QS = B,
        $S = RangeError,
        eT = String,
        tT = Math.floor,
        nT = XS(ZS),
        rT = XS("".slice),
        aT = XS(1..toFixed),
        iT = function e(t, n, r) {
            return 0 === n ? r : n % 2 == 1 ? e(t, n - 1, r * t) : e(t * t, n / 2, r)
        },
        oT = function(e, t, n) {
            for (var r = -1, a = n; ++r < 6;) a += t * e[r], e[r] = a % 1e7, a = tT(a / 1e7)
        },
        sT = function(e, t) {
            for (var n = 6, r = 0; --n >= 0;) r += e[n], e[n] = tT(r / t), r = r % t * 1e7
        },
        uT = function(e) {
            for (var t = 6, n = ""; --t >= 0;)
                if ("" !== n || 0 === t || 0 !== e[t]) {
                    var r = eT(e[t]);
                    n = "" === n ? r : n + nT("0", 7 - r.length) + r
                }
            return n
        };
    KS({
        target: "Number",
        proto: !0,
        forced: QS((function() {
            return "0.000" !== aT(8e-5, 3) || "1" !== aT(.9, 0) || "1.25" !== aT(1.255, 2) || "1000000000000000128" !== aT(0xde0b6b3a7640080, 0)
        })) || !QS((function() {
            aT({})
        }))
    }, {
        toFixed: function(e) {
            var t, n, r, a, i = JS(this),
                o = YS(e),
                s = [0, 0, 0, 0, 0, 0],
                u = "",
                c = "0";
            if (o < 0 || o > 20) throw $S("Incorrect fraction digits");
            if (i != i) return "NaN";
            if (i <= -1e21 || i >= 1e21) return eT(i);
            if (i < 0 && (u = "-", i = -i), i > 1e-21)
                if (n = (t = function(e) {
                        for (var t = 0, n = e; n >= 4096;) t += 12, n /= 4096;
                        for (; n >= 2;) t += 1, n /= 2;
                        return t
                    }(i * iT(2, 69, 1)) - 69) < 0 ? i * iT(2, -t, 1) : i / iT(2, t, 1), n *= 4503599627370496, (t = 52 - t) > 0) {
                    for (oT(s, 0, n), r = o; r >= 7;) oT(s, 1e7, 0), r -= 7;
                    for (oT(s, iT(10, r, 1), 0), r = t - 1; r >= 23;) sT(s, 1 << 23), r -= 23;
                    sT(s, 1 << r), oT(s, 1, 1), sT(s, 2), c = uT(s)
                } else oT(s, 0, n), oT(s, 1 << -t, 0), c = uT(s) + nT("0", o);
            return c = o > 0 ? u + ((a = c.length) <= o ? "0." + nT("0", o - a) + c : rT(c, 0, a - o) + "." + rT(c, a - o)) : u + c
        }
    });
    var cT = La,
        lT = B,
        hT = pN,
        pT = ee(1..toPrecision);
    cT({
        target: "Number",
        proto: !0,
        forced: lT((function() {
            return "1" !== pT(1, void 0)
        })) || !lT((function() {
            pT({})
        }))
    }, {
        toPrecision: function(e) {
            return void 0 === e ? pT(hT(this)) : pT(hT(this), e)
        }
    });
    var fT = W,
        dT = ee,
        vT = j,
        mT = B,
        gT = $a,
        yT = ua,
        bT = H,
        xT = yt,
        kT = ce,
        wT = Object.assign,
        IT = Object.defineProperty,
        NT = dT([].concat),
        ST = !wT || mT((function() {
            if (fT && 1 !== wT({
                    b: 1
                }, wT(IT({}, "a", {
                    enumerable: !0,
                    get: function() {
                        IT(this, "b", {
                            value: 3,
                            enumerable: !1
                        })
                    }
                }), {
                    b: 2
                })).b) return !0;
            var e = {},
                t = {},
                n = Symbol(),
                r = "abcdefghijklmnopqrst";
            return e[n] = 7, r.split("").forEach((function(e) {
                t[e] = e
            })), 7 != wT({}, e)[n] || gT(wT({}, t)).join("") != r
        })) ? function(e, t) {
            for (var n = xT(e), r = arguments.length, a = 1, i = yT.f, o = bT.f; r > a;)
                for (var s, u = kT(arguments[a++]), c = i ? NT(gT(u), i(u)) : gT(u), l = c.length, h = 0; l > h;) s = c[h++], fT && !vT(o, u, s) || (n[s] = u[s]);
            return n
        } : wT,
        TT = ST;
    La({
        target: "Object",
        stat: !0,
        arity: 2,
        forced: Object.assign !== TT
    }, {
        assign: TT
    }), La({
        target: "Object",
        stat: !0,
        sham: !W
    }, {
        create: yi
    });
    var ET = z,
        CT = sm,
        AT = !B((function() {
            if (!(CT && CT < 535)) {
                var e = Math.random();
                __defineSetter__.call(null, e, (function() {})), delete ET[e]
            }
        })),
        RT = Ze,
        _T = yt,
        OT = cn;
    W && La({
        target: "Object",
        proto: !0,
        forced: AT
    }, {
        __defineGetter__: function(e, t) {
            OT.f(_T(this), e, {
                get: RT(t),
                enumerable: !0,
                configurable: !0
            })
        }
    });
    var FT = La,
        DT = W,
        MT = Ja.f;
    FT({
        target: "Object",
        stat: !0,
        forced: Object.defineProperties !== MT,
        sham: !DT
    }, {
        defineProperties: MT
    });
    var LT = La,
        zT = W,
        PT = cn.f;
    LT({
        target: "Object",
        stat: !0,
        forced: Object.defineProperty !== PT,
        sham: !zT
    }, {
        defineProperty: PT
    });
    var BT = Ze,
        WT = yt,
        UT = cn;
    W && La({
        target: "Object",
        proto: !0,
        forced: AT
    }, {
        __defineSetter__: function(e, t) {
            UT.f(WT(this), e, {
                set: BT(t),
                enumerable: !0,
                configurable: !0
            })
        }
    });
    var VT = W,
        GT = ee,
        jT = $a,
        HT = me,
        qT = GT(H.f),
        KT = GT([].push),
        XT = function(e) {
            return function(t) {
                for (var n, r = HT(t), a = jT(r), i = a.length, o = 0, s = []; i > o;) n = a[o++], VT && !qT(r, n) || KT(s, e ? [n, r[n]] : r[n]);
                return s
            }
        },
        YT = {
            entries: XT(!0),
            values: XT(!1)
        },
        JT = YT.entries;
    La({
        target: "Object",
        stat: !0
    }, {
        entries: function(e) {
            return JT(e)
        }
    });
    var ZT = La,
        QT = cw,
        $T = B,
        eE = Ie,
        tE = Sw.onFreeze,
        nE = Object.freeze;
    ZT({
        target: "Object",
        stat: !0,
        forced: $T((function() {
            nE(1)
        })),
        sham: !QT
    }, {
        freeze: function(e) {
            return nE && eE(e) ? nE(tE(e)) : e
        }
    });
    var rE = yh,
        aE = Ii;
    La({
        target: "Object",
        stat: !0
    }, {
        fromEntries: function(e) {
            var t = {};
            return rE(e, (function(e, n) {
                aE(t, e, n)
            }), {
                AS_ENTRIES: !0
            }), t
        }
    });
    var iE = La,
        oE = B,
        sE = me,
        uE = P.f,
        cE = W;
    iE({
        target: "Object",
        stat: !0,
        forced: !cE || oE((function() {
            uE(1)
        })),
        sham: !cE
    }, {
        getOwnPropertyDescriptor: function(e, t) {
            return uE(sE(e), t)
        }
    });
    var lE = da,
        hE = me,
        pE = P,
        fE = Ii;
    La({
        target: "Object",
        stat: !0,
        sham: !W
    }, {
        getOwnPropertyDescriptors: function(e) {
            for (var t, n, r = hE(e), a = pE.f, i = lE(r), o = {}, s = 0; i.length > s;) void 0 !== (n = a(r, t = i[s++])) && fE(o, t, n);
            return o
        }
    });
    var dE = La,
        vE = B,
        mE = bi.f;
    dE({
        target: "Object",
        stat: !0,
        forced: vE((function() {
            return !Object.getOwnPropertyNames(1)
        }))
    }, {
        getOwnPropertyNames: mE
    });
    var gE = yt,
        yE = Ll,
        bE = Cl;
    La({
        target: "Object",
        stat: !0,
        forced: B((function() {
            yE(1)
        })),
        sham: !bE
    }, {
        getPrototypeOf: function(e) {
            return yE(gE(e))
        }
    }), La({
        target: "Object",
        stat: !0
    }, {
        hasOwn: kt
    });
    var xE = Object.is || function(e, t) {
        return e === t ? 0 !== e || 1 / e == 1 / t : e != e && t != t
    };
    La({
        target: "Object",
        stat: !0
    }, {
        is: xE
    });
    var kE = uw;
    La({
        target: "Object",
        stat: !0,
        forced: Object.isExtensible !== kE
    }, {
        isExtensible: kE
    });
    var wE = La,
        IE = B,
        NE = Ie,
        SE = ae,
        TE = nw,
        EE = Object.isFrozen;
    wE({
        target: "Object",
        stat: !0,
        forced: TE || IE((function() {
            EE(1)
        }))
    }, {
        isFrozen: function(e) {
            return !NE(e) || (!(!TE || "ArrayBuffer" != SE(e)) || !!EE && EE(e))
        }
    });
    var CE = La,
        AE = B,
        RE = Ie,
        _E = ae,
        OE = nw,
        FE = Object.isSealed;
    CE({
        target: "Object",
        stat: !0,
        forced: OE || AE((function() {
            FE(1)
        }))
    }, {
        isSealed: function(e) {
            return !RE(e) || (!(!OE || "ArrayBuffer" != _E(e)) || !!FE && FE(e))
        }
    });
    var DE = yt,
        ME = $a;
    La({
        target: "Object",
        stat: !0,
        forced: B((function() {
            ME(1)
        }))
    }, {
        keys: function(e) {
            return ME(DE(e))
        }
    });
    var LE = La,
        zE = W,
        PE = AT,
        BE = yt,
        WE = qt,
        UE = Ll,
        VE = P.f;
    zE && LE({
        target: "Object",
        proto: !0,
        forced: PE
    }, {
        __lookupGetter__: function(e) {
            var t, n = BE(this),
                r = WE(e);
            do {
                if (t = VE(n, r)) return t.get
            } while (n = UE(n))
        }
    });
    var GE = La,
        jE = W,
        HE = AT,
        qE = yt,
        KE = qt,
        XE = Ll,
        YE = P.f;
    jE && GE({
        target: "Object",
        proto: !0,
        forced: HE
    }, {
        __lookupSetter__: function(e) {
            var t, n = qE(this),
                r = KE(e);
            do {
                if (t = YE(n, r)) return t.set
            } while (n = XE(n))
        }
    });
    var JE = La,
        ZE = Ie,
        QE = Sw.onFreeze,
        $E = cw,
        eC = B,
        tC = Object.preventExtensions;
    JE({
        target: "Object",
        stat: !0,
        forced: eC((function() {
            tC(1)
        })),
        sham: !$E
    }, {
        preventExtensions: function(e) {
            return tC && ZE(e) ? tC(QE(e)) : e
        }
    });
    var nC = W,
        rC = zi,
        aC = Ie,
        iC = yt,
        oC = fe,
        sC = Object.getPrototypeOf,
        uC = Object.setPrototypeOf,
        cC = Object.prototype,
        lC = "__proto__";
    if (nC && sC && uC && !(lC in cC)) try {
        rC(cC, lC, {
            configurable: !0,
            get: function() {
                return sC(iC(this))
            },
            set: function(e) {
                var t = oC(this);
                (aC(e) || null === e) && aC(t) && uC(t, e)
            }
        })
    } catch (e) {}
    var hC = La,
        pC = Ie,
        fC = Sw.onFreeze,
        dC = cw,
        vC = B,
        mC = Object.seal;
    hC({
        target: "Object",
        stat: !0,
        forced: vC((function() {
            mC(1)
        })),
        sham: !dC
    }, {
        seal: function(e) {
            return mC && pC(e) ? mC(fC(e)) : e
        }
    }), La({
        target: "Object",
        stat: !0
    }, {
        setPrototypeOf: Tc
    });
    var gC = qa,
        yC = Ba ? {}.toString : function() {
            return "[object " + gC(this) + "]"
        },
        bC = yC;
    Ba || Or(Object.prototype, "toString", bC, {
        unsafe: !0
    });
    var xC = YT.values;
    La({
        target: "Object",
        stat: !0
    }, {
        values: function(e) {
            return xC(e)
        }
    });
    La({
        global: !0,
        forced: parseFloat != dS
    }, {
        parseFloat: dS
    });
    La({
        global: !0,
        forced: parseInt != ES
    }, {
        parseInt: ES
    });
    var kC, wC, IC, NC, SC = TypeError,
        TC = function(e, t) {
            if (e < t) throw SC("Not enough arguments");
            return e
        },
        EC = /(?:ipad|iphone|ipod).*applewebkit/i.test(Ae),
        CC = z,
        AC = fu,
        RC = so,
        _C = xe,
        OC = kt,
        FC = B,
        DC = oi,
        MC = du,
        LC = Jt,
        zC = TC,
        PC = EC,
        BC = Rv,
        WC = CC.setImmediate,
        UC = CC.clearImmediate,
        VC = CC.process,
        GC = CC.Dispatch,
        jC = CC.Function,
        HC = CC.MessageChannel,
        qC = CC.String,
        KC = 0,
        XC = {},
        YC = "onreadystatechange";
    FC((function() {
        kC = CC.location
    }));
    var JC = function(e) {
            if (OC(XC, e)) {
                var t = XC[e];
                delete XC[e], t()
            }
        },
        ZC = function(e) {
            return function() {
                JC(e)
            }
        },
        QC = function(e) {
            JC(e.data)
        },
        $C = function(e) {
            CC.postMessage(qC(e), kC.protocol + "//" + kC.host)
        };
    WC && UC || (WC = function(e) {
        zC(arguments.length, 1);
        var t = _C(e) ? e : jC(e),
            n = MC(arguments, 1);
        return XC[++KC] = function() {
            AC(t, void 0, n)
        }, wC(KC), KC
    }, UC = function(e) {
        delete XC[e]
    }, BC ? wC = function(e) {
        VC.nextTick(ZC(e))
    } : GC && GC.now ? wC = function(e) {
        GC.now(ZC(e))
    } : HC && !PC ? (NC = (IC = new HC).port2, IC.port1.onmessage = QC, wC = RC(NC.postMessage, NC)) : CC.addEventListener && _C(CC.postMessage) && !CC.importScripts && kC && "file:" !== kC.protocol && !FC($C) ? (wC = $C, CC.addEventListener("message", QC, !1)) : wC = YC in LC("script") ? function(e) {
        DC.appendChild(LC("script")).onreadystatechange = function() {
            DC.removeChild(this), JC(e)
        }
    } : function(e) {
        setTimeout(ZC(e), 0)
    });
    var eA = {
            set: WC,
            clear: UC
        },
        tA = function() {
            this.head = null, this.tail = null
        };
    tA.prototype = {
        add: function(e) {
            var t = {
                    item: e,
                    next: null
                },
                n = this.tail;
            n ? n.next = t : this.head = t, this.tail = t
        },
        get: function() {
            var e = this.head;
            if (e) return null === (this.head = e.next) && (this.tail = null), e.item
        }
    };
    var nA, rA, aA, iA, oA, sA = tA,
        uA = /ipad|iphone|ipod/i.test(Ae) && "undefined" != typeof Pebble,
        cA = /web0s(?!.*chrome)/i.test(Ae),
        lA = z,
        hA = so,
        pA = P.f,
        fA = eA.set,
        dA = sA,
        vA = EC,
        mA = uA,
        gA = cA,
        yA = Rv,
        bA = lA.MutationObserver || lA.WebKitMutationObserver,
        xA = lA.document,
        kA = lA.process,
        wA = lA.Promise,
        IA = pA(lA, "queueMicrotask"),
        NA = IA && IA.value;
    if (!NA) {
        var SA = new dA,
            TA = function() {
                var e, t;
                for (yA && (e = kA.domain) && e.exit(); t = SA.get();) try {
                    t()
                } catch (e) {
                    throw SA.head && nA(), e
                }
                e && e.enter()
            };
        vA || yA || gA || !bA || !xA ? !mA && wA && wA.resolve ? ((iA = wA.resolve(void 0)).constructor = wA, oA = hA(iA.then, iA), nA = function() {
            oA(TA)
        }) : yA ? nA = function() {
            kA.nextTick(TA)
        } : (fA = hA(fA, lA), nA = function() {
            fA(TA)
        }) : (rA = !0, aA = xA.createTextNode(""), new bA(TA).observe(aA, {
            characterData: !0
        }), nA = function() {
            aA.data = rA = !rA
        }), NA = function(e) {
            SA.head || nA(), SA.add(e)
        }
    }
    var EA, CA, AA, RA = NA,
        _A = function(e, t) {
            try {
                1 == arguments.length ? console.error(e) : console.error(e, t)
            } catch (e) {}
        },
        OA = function(e) {
            try {
                return {
                    error: !1,
                    value: e()
                }
            } catch (e) {
                return {
                    error: !0,
                    value: e
                }
            }
        },
        FA = z.Promise,
        DA = "object" == ("undefined" == typeof Deno ? "undefined" : s(Deno)) && Deno && "object" == s(Deno.version),
        MA = !DA && !Rv && "object" == ("undefined" == typeof window ? "undefined" : s(window)) && "object" == ("undefined" == typeof document ? "undefined" : s(document)),
        LA = z,
        zA = FA,
        PA = xe,
        BA = Ca,
        WA = Vn,
        UA = Mt,
        VA = MA,
        GA = DA,
        jA = Le,
        HA = (zA && zA.prototype, UA("species")),
        qA = !1,
        KA = PA(LA.PromiseRejectionEvent),
        XA = BA("Promise", (function() {
            var e = WA(zA),
                t = e !== String(zA);
            if (!t && 66 === jA) return !0;
            if (!jA || jA < 51 || !/native code/.test(e)) {
                var n = new zA((function(e) {
                        e(1)
                    })),
                    r = function(e) {
                        e((function() {}), (function() {}))
                    };
                if ((n.constructor = {})[HA] = r, !(qA = n.then((function() {})) instanceof r)) return !0
            }
            return !t && (VA || GA) && !KA
        })),
        YA = {
            CONSTRUCTOR: XA,
            REJECTION_EVENT: KA,
            SUBCLASSING: qA
        },
        JA = {},
        ZA = Ze,
        QA = TypeError,
        $A = function(e) {
            var t, n;
            this.promise = new e((function(e, r) {
                if (void 0 !== t || void 0 !== n) throw QA("Bad Promise constructor");
                t = e, n = r
            })), this.resolve = ZA(t), this.reject = ZA(n)
        },
        eR = (JA.f = function(e) {
            return new $A(e)
        }, La),
        tR = Rv,
        nR = z,
        rR = j,
        aR = Or,
        iR = Tc,
        oR = eo,
        sR = Fm,
        uR = Ze,
        cR = xe,
        lR = Ie,
        hR = zg,
        pR = Kb,
        fR = eA.set,
        dR = RA,
        vR = _A,
        mR = OA,
        gR = sA,
        yR = cr,
        bR = FA,
        xR = JA,
        kR = "Promise",
        wR = YA.CONSTRUCTOR,
        IR = YA.REJECTION_EVENT,
        NR = YA.SUBCLASSING,
        SR = yR.getterFor(kR),
        TR = yR.set,
        ER = bR && bR.prototype,
        CR = bR,
        AR = ER,
        RR = nR.TypeError,
        _R = nR.document,
        OR = nR.process,
        FR = xR.f,
        DR = FR,
        MR = !!(_R && _R.createEvent && nR.dispatchEvent),
        LR = "unhandledrejection",
        zR = function(e) {
            var t;
            return !(!lR(e) || !cR(t = e.then)) && t
        },
        PR = function(e, t) {
            var n, r, a, i = t.value,
                o = 1 == t.state,
                s = o ? e.ok : e.fail,
                u = e.resolve,
                c = e.reject,
                l = e.domain;
            try {
                s ? (o || (2 === t.rejection && GR(t), t.rejection = 1), !0 === s ? n = i : (l && l.enter(), n = s(i), l && (l.exit(), a = !0)), n === e.promise ? c(RR("Promise-chain cycle")) : (r = zR(n)) ? rR(r, n, u, c) : u(n)) : c(i)
            } catch (e) {
                l && !a && l.exit(), c(e)
            }
        },
        BR = function(e, t) {
            e.notified || (e.notified = !0, dR((function() {
                for (var n, r = e.reactions; n = r.get();) PR(n, e);
                e.notified = !1, t && !e.rejection && UR(e)
            })))
        },
        WR = function(e, t, n) {
            var r, a;
            MR ? ((r = _R.createEvent("Event")).promise = t, r.reason = n, r.initEvent(e, !1, !0), nR.dispatchEvent(r)) : r = {
                promise: t,
                reason: n
            }, !IR && (a = nR["on" + e]) ? a(r) : e === LR && vR("Unhandled promise rejection", n)
        },
        UR = function(e) {
            rR(fR, nR, (function() {
                var t, n = e.facade,
                    r = e.value;
                if (VR(e) && (t = mR((function() {
                        tR ? OR.emit("unhandledRejection", r, n) : WR(LR, n, r)
                    })), e.rejection = tR || VR(e) ? 2 : 1, t.error)) throw t.value
            }))
        },
        VR = function(e) {
            return 1 !== e.rejection && !e.parent
        },
        GR = function(e) {
            rR(fR, nR, (function() {
                var t = e.facade;
                tR ? OR.emit("rejectionHandled", t) : WR("rejectionhandled", t, e.value)
            }))
        },
        jR = function(e, t, n) {
            return function(r) {
                e(t, r, n)
            }
        },
        HR = function(e, t, n) {
            e.done || (e.done = !0, n && (e = n), e.value = t, e.state = 2, BR(e, !0))
        },
        qR = function e(t, n, r) {
            if (!t.done) {
                t.done = !0, r && (t = r);
                try {
                    if (t.facade === n) throw RR("Promise can't be resolved itself");
                    var a = zR(n);
                    a ? dR((function() {
                        var r = {
                            done: !1
                        };
                        try {
                            rR(a, n, jR(e, r, t), jR(HR, r, t))
                        } catch (e) {
                            HR(r, e, t)
                        }
                    })) : (t.value = n, t.state = 1, BR(t, !1))
                } catch (e) {
                    HR({
                        done: !1
                    }, e, t)
                }
            }
        };
    if (wR && (AR = (CR = function(e) {
            hR(this, AR), uR(e), rR(EA, this);
            var t = SR(this);
            try {
                e(jR(qR, t), jR(HR, t))
            } catch (e) {
                HR(t, e)
            }
        }).prototype, (EA = function(e) {
            TR(this, {
                type: kR,
                done: !1,
                notified: !1,
                parent: !1,
                reactions: new gR,
                rejection: !1,
                state: 0,
                value: void 0
            })
        }).prototype = aR(AR, "then", (function(e, t) {
            var n = SR(this),
                r = FR(pR(this, CR));
            return n.parent = !0, r.ok = !cR(e) || e, r.fail = cR(t) && t, r.domain = tR ? OR.domain : void 0, 0 == n.state ? n.reactions.add(r) : dR((function() {
                PR(r, n)
            })), r.promise
        })), CA = function() {
            var e = new EA,
                t = SR(e);
            this.promise = e, this.resolve = jR(qR, t), this.reject = jR(HR, t)
        }, xR.f = FR = function(e) {
            return e === CR || undefined === e ? new CA(e) : DR(e)
        }, cR(bR) && ER !== Object.prototype)) {
        AA = ER.then, NR || aR(ER, "then", (function(e, t) {
            var n = this;
            return new CR((function(e, t) {
                rR(AA, n, e, t)
            })).then(e, t)
        }), {
            unsafe: !0
        });
        try {
            delete ER.constructor
        } catch (e) {}
        iR && iR(ER, AR)
    }
    eR({
        global: !0,
        constructor: !0,
        wrap: !0,
        forced: wR
    }, {
        Promise: CR
    }), oR(CR, kR, !1, !0), sR(kR);
    var KR = FA,
        XR = YA.CONSTRUCTOR || !Uf((function(e) {
            KR.all(e).then(void 0, (function() {}))
        })),
        YR = j,
        JR = Ze,
        ZR = JA,
        QR = OA,
        $R = yh;
    La({
        target: "Promise",
        stat: !0,
        forced: XR
    }, {
        all: function(e) {
            var t = this,
                n = ZR.f(t),
                r = n.resolve,
                a = n.reject,
                i = QR((function() {
                    var n = JR(t.resolve),
                        i = [],
                        o = 0,
                        s = 1;
                    $R(e, (function(e) {
                        var u = o++,
                            c = !1;
                        s++, YR(n, t, e).then((function(e) {
                            c || (c = !0, i[u] = e, --s || r(i))
                        }), a)
                    })), --s || r(i)
                }));
            return i.error && a(i.value), n.promise
        }
    });
    var e_ = La,
        t_ = YA.CONSTRUCTOR,
        n_ = FA,
        r_ = Ee,
        a_ = xe,
        i_ = Or,
        o_ = n_ && n_.prototype;
    if (e_({
            target: "Promise",
            proto: !0,
            forced: t_,
            real: !0
        }, {
            catch: function(e) {
                return this.then(void 0, e)
            }
        }), a_(n_)) {
        var s_ = r_("Promise").prototype.catch;
        o_.catch !== s_ && i_(o_, "catch", s_, {
            unsafe: !0
        })
    }
    var u_ = j,
        c_ = Ze,
        l_ = JA,
        h_ = OA,
        p_ = yh;
    La({
        target: "Promise",
        stat: !0,
        forced: XR
    }, {
        race: function(e) {
            var t = this,
                n = l_.f(t),
                r = n.reject,
                a = h_((function() {
                    var a = c_(t.resolve);
                    p_(e, (function(e) {
                        u_(a, t, e).then(n.resolve, r)
                    }))
                }));
            return a.error && r(a.value), n.promise
        }
    });
    var f_ = j,
        d_ = JA;
    La({
        target: "Promise",
        stat: !0,
        forced: YA.CONSTRUCTOR
    }, {
        reject: function(e) {
            var t = d_.f(this);
            return f_(t.reject, void 0, e), t.promise
        }
    });
    var v_ = dn,
        m_ = Ie,
        g_ = JA,
        y_ = function(e, t) {
            if (v_(e), m_(t) && t.constructor === e) return t;
            var n = g_.f(e);
            return (0, n.resolve)(t), n.promise
        },
        b_ = La,
        x_ = YA.CONSTRUCTOR,
        k_ = y_;
    Ee("Promise");
    b_({
        target: "Promise",
        stat: !0,
        forced: x_
    }, {
        resolve: function(e) {
            return k_(this, e)
        }
    });
    var w_ = j,
        I_ = Ze,
        N_ = JA,
        S_ = OA,
        T_ = yh;
    La({
        target: "Promise",
        stat: !0,
        forced: XR
    }, {
        allSettled: function(e) {
            var t = this,
                n = N_.f(t),
                r = n.resolve,
                a = n.reject,
                i = S_((function() {
                    var n = I_(t.resolve),
                        a = [],
                        i = 0,
                        o = 1;
                    T_(e, (function(e) {
                        var s = i++,
                            u = !1;
                        o++, w_(n, t, e).then((function(e) {
                            u || (u = !0, a[s] = {
                                status: "fulfilled",
                                value: e
                            }, --o || r(a))
                        }), (function(e) {
                            u || (u = !0, a[s] = {
                                status: "rejected",
                                reason: e
                            }, --o || r(a))
                        }))
                    })), --o || r(a)
                }));
            return i.error && a(i.value), n.promise
        }
    });
    var E_ = j,
        C_ = Ze,
        A_ = Ee,
        R_ = JA,
        __ = OA,
        O_ = yh,
        F_ = "No one promise resolved";
    La({
        target: "Promise",
        stat: !0,
        forced: XR
    }, {
        any: function(e) {
            var t = this,
                n = A_("AggregateError"),
                r = R_.f(t),
                a = r.resolve,
                i = r.reject,
                o = __((function() {
                    var r = C_(t.resolve),
                        o = [],
                        s = 0,
                        u = 1,
                        c = !1;
                    O_(e, (function(e) {
                        var l = s++,
                            h = !1;
                        u++, E_(r, t, e).then((function(e) {
                            h || c || (c = !0, a(e))
                        }), (function(e) {
                            h || c || (h = !0, o[l] = e, --u || i(new n(o, F_)))
                        }))
                    })), --u || i(new n(o, F_))
                }));
            return o.error && i(o.value), r.promise
        }
    });
    var D_ = La,
        M_ = FA,
        L_ = B,
        z_ = Ee,
        P_ = xe,
        B_ = Kb,
        W_ = y_,
        U_ = Or,
        V_ = M_ && M_.prototype;
    if (D_({
            target: "Promise",
            proto: !0,
            real: !0,
            forced: !!M_ && L_((function() {
                V_.finally.call({
                    then: function() {}
                }, (function() {}))
            }))
        }, {
            finally: function(e) {
                var t = B_(this, z_("Promise")),
                    n = P_(e);
                return this.then(n ? function(n) {
                    return W_(t, e()).then((function() {
                        return n
                    }))
                } : e, n ? function(n) {
                    return W_(t, e()).then((function() {
                        throw n
                    }))
                } : e)
            }
        }), P_(M_)) {
        var G_ = z_("Promise").prototype.finally;
        V_.finally !== G_ && U_(V_, "finally", G_, {
            unsafe: !0
        })
    }
    var j_ = fu,
        H_ = Ze,
        q_ = dn;
    La({
        target: "Reflect",
        stat: !0,
        forced: !B((function() {
            Reflect.apply((function() {}))
        }))
    }, {
        apply: function(e, t, n) {
            return j_(H_(e), t, q_(n))
        }
    });
    var K_ = La,
        X_ = fu,
        Y_ = zk,
        J_ = Vb,
        Z_ = dn,
        Q_ = Ie,
        $_ = yi,
        eO = B,
        tO = Ee("Reflect", "construct"),
        nO = Object.prototype,
        rO = [].push,
        aO = eO((function() {
            function e() {}
            return !(tO((function() {}), [], e) instanceof e)
        })),
        iO = !eO((function() {
            tO((function() {}))
        })),
        oO = aO || iO;
    K_({
        target: "Reflect",
        stat: !0,
        forced: oO,
        sham: oO
    }, {
        construct: function(e, t) {
            J_(e), Z_(t);
            var n = arguments.length < 3 ? e : J_(arguments[2]);
            if (iO && !aO) return tO(e, t, n);
            if (e == n) {
                switch (t.length) {
                    case 0:
                        return new e;
                    case 1:
                        return new e(t[0]);
                    case 2:
                        return new e(t[0], t[1]);
                    case 3:
                        return new e(t[0], t[1], t[2]);
                    case 4:
                        return new e(t[0], t[1], t[2], t[3])
                }
                var r = [null];
                return X_(rO, r, t), new(X_(Y_, e, r))
            }
            var a = n.prototype,
                i = $_(Q_(a) ? a : nO),
                o = X_(e, i, t);
            return Q_(o) ? o : i
        }
    });
    var sO = W,
        uO = dn,
        cO = qt,
        lO = cn;
    La({
        target: "Reflect",
        stat: !0,
        forced: B((function() {
            Reflect.defineProperty(lO.f({}, 1, {
                value: 1
            }), 1, {
                value: 2
            })
        })),
        sham: !sO
    }, {
        defineProperty: function(e, t, n) {
            uO(e);
            var r = cO(t);
            uO(n);
            try {
                return lO.f(e, r, n), !0
            } catch (e) {
                return !1
            }
        }
    });
    var hO = La,
        pO = dn,
        fO = P.f;
    hO({
        target: "Reflect",
        stat: !0
    }, {
        deleteProperty: function(e, t) {
            var n = fO(pO(e), t);
            return !(n && !n.configurable) && delete e[t]
        }
    });
    var dO = kt,
        vO = function(e) {
            return void 0 !== e && (dO(e, "value") || dO(e, "writable"))
        },
        mO = j,
        gO = Ie,
        yO = dn,
        bO = vO,
        xO = P,
        kO = Ll;
    La({
        target: "Reflect",
        stat: !0
    }, {
        get: function e(t, n) {
            var r, a, i = arguments.length < 3 ? t : arguments[2];
            return yO(t) === i ? t[n] : (r = xO.f(t, n)) ? bO(r) ? r.value : void 0 === r.get ? void 0 : mO(r.get, i) : gO(a = kO(t)) ? e(a, n, i) : void 0
        }
    });
    var wO = dn,
        IO = P;
    La({
        target: "Reflect",
        stat: !0,
        sham: !W
    }, {
        getOwnPropertyDescriptor: function(e, t) {
            return IO.f(wO(e), t)
        }
    });
    var NO = dn,
        SO = Ll;
    La({
        target: "Reflect",
        stat: !0,
        sham: !Cl
    }, {
        getPrototypeOf: function(e) {
            return SO(NO(e))
        }
    }), La({
        target: "Reflect",
        stat: !0
    }, {
        has: function(e, t) {
            return t in e
        }
    });
    var TO = dn,
        EO = uw;
    La({
        target: "Reflect",
        stat: !0
    }, {
        isExtensible: function(e) {
            return TO(e), EO(e)
        }
    }), La({
        target: "Reflect",
        stat: !0
    }, {
        ownKeys: da
    });
    var CO = Ee,
        AO = dn;
    La({
        target: "Reflect",
        stat: !0,
        sham: !cw
    }, {
        preventExtensions: function(e) {
            AO(e);
            try {
                var t = CO("Object", "preventExtensions");
                return t && t(e), !0
            } catch (e) {
                return !1
            }
        }
    });
    var RO = La,
        _O = j,
        OO = dn,
        FO = Ie,
        DO = vO,
        MO = cn,
        LO = P,
        zO = Ll,
        PO = Y;
    var BO = B((function() {
        var e = function() {},
            t = MO.f(new e, "a", {
                configurable: !0
            });
        return !1 !== Reflect.set(e.prototype, "a", 1, t)
    }));
    RO({
        target: "Reflect",
        stat: !0,
        forced: BO
    }, {
        set: function e(t, n, r) {
            var a, i, o, s = arguments.length < 4 ? t : arguments[3],
                u = LO.f(OO(t), n);
            if (!u) {
                if (FO(i = zO(t))) return e(i, n, r, s);
                u = PO(0)
            }
            if (DO(u)) {
                if (!1 === u.writable || !FO(s)) return !1;
                if (a = LO.f(s, n)) {
                    if (a.get || a.set || !1 === a.writable) return !1;
                    a.value = r, MO.f(s, n, a)
                } else MO.f(s, n, PO(0, r))
            } else {
                if (void 0 === (o = u.set)) return !1;
                _O(o, s, r)
            }
            return !0
        }
    });
    var WO = dn,
        UO = wc,
        VO = Tc;
    VO && La({
        target: "Reflect",
        stat: !0
    }, {
        setPrototypeOf: function(e, t) {
            WO(e), UO(t);
            try {
                return VO(e, t), !0
            } catch (e) {
                return !1
            }
        }
    });
    var GO = z,
        jO = eo;
    La({
        global: !0
    }, {
        Reflect: {}
    }), jO(GO.Reflect, "Reflect", !0);
    var HO = Ie,
        qO = ae,
        KO = Mt("match"),
        XO = function(e) {
            var t;
            return HO(e) && (void 0 !== (t = e[KO]) ? !!t : "RegExp" == qO(e))
        },
        YO = dn,
        JO = function() {
            var e = YO(this),
                t = "";
            return e.hasIndices && (t += "d"), e.global && (t += "g"), e.ignoreCase && (t += "i"), e.multiline && (t += "m"), e.dotAll && (t += "s"), e.unicode && (t += "u"), e.unicodeSets && (t += "v"), e.sticky && (t += "y"), t
        },
        ZO = j,
        QO = kt,
        $O = Ce,
        eF = JO,
        tF = RegExp.prototype,
        nF = function(e) {
            var t = e.flags;
            return void 0 !== t || "flags" in tF || QO(e, "flags") || !$O(tF, e) ? t : ZO(eF, e)
        },
        rF = B,
        aF = z.RegExp,
        iF = rF((function() {
            var e = aF("a", "y");
            return e.lastIndex = 2, null != e.exec("abcd")
        })),
        oF = iF || rF((function() {
            return !aF("a", "y").sticky
        })),
        sF = iF || rF((function() {
            var e = aF("^r", "gy");
            return e.lastIndex = 2, null != e.exec("str")
        })),
        uF = {
            BROKEN_CARET: sF,
            MISSED_STICKY: oF,
            UNSUPPORTED_Y: iF
        },
        cF = B,
        lF = z.RegExp,
        hF = cF((function() {
            var e = lF(".", "s");
            return !(e.dotAll && e.exec("\n") && "s" === e.flags)
        })),
        pF = B,
        fF = z.RegExp,
        dF = pF((function() {
            var e = fF("(?<a>b)", "g");
            return "b" !== e.exec("b").groups.a || "bc" !== "b".replace(e, "$<a>c")
        })),
        vF = W,
        mF = z,
        gF = ee,
        yF = Ca,
        bF = Oc,
        xF = Cn,
        kF = Fr.f,
        wF = Ce,
        IF = XO,
        NF = Ya,
        SF = nF,
        TF = uF,
        EF = Cc,
        CF = Or,
        AF = B,
        RF = kt,
        _F = cr.enforce,
        OF = Fm,
        FF = hF,
        DF = dF,
        MF = Mt("match"),
        LF = mF.RegExp,
        zF = LF.prototype,
        PF = mF.SyntaxError,
        BF = gF(zF.exec),
        WF = gF("".charAt),
        UF = gF("".replace),
        VF = gF("".indexOf),
        GF = gF("".slice),
        jF = /^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/,
        HF = /a/g,
        qF = /a/g,
        KF = new LF(HF) !== HF,
        XF = TF.MISSED_STICKY,
        YF = TF.UNSUPPORTED_Y,
        JF = vF && (!KF || XF || FF || DF || AF((function() {
            return qF[MF] = !1, LF(HF) != HF || LF(qF) == qF || "/a/i" != LF(HF, "i")
        })));
    if (yF("RegExp", JF)) {
        for (var ZF = function(e, t) {
                var n, r, a, i, o, s, u = wF(zF, this),
                    c = IF(e),
                    l = void 0 === t,
                    h = [],
                    p = e;
                if (!u && c && l && e.constructor === ZF) return e;
                if ((c || wF(zF, e)) && (e = e.source, l && (t = SF(p))), e = void 0 === e ? "" : NF(e), t = void 0 === t ? "" : NF(t), p = e, FF && "dotAll" in HF && (r = !!t && VF(t, "s") > -1) && (t = UF(t, /s/g, "")), n = t, XF && "sticky" in HF && (a = !!t && VF(t, "y") > -1) && YF && (t = UF(t, /y/g, "")), DF && (i = function(e) {
                        for (var t, n = e.length, r = 0, a = "", i = [], o = {}, s = !1, u = !1, c = 0, l = ""; r <= n; r++) {
                            if ("\\" === (t = WF(e, r))) t += WF(e, ++r);
                            else if ("]" === t) s = !1;
                            else if (!s) switch (!0) {
                                case "[" === t:
                                    s = !0;
                                    break;
                                case "(" === t:
                                    BF(jF, GF(e, r + 1)) && (r += 2, u = !0), a += t, c++;
                                    continue;
                                case ">" === t && u:
                                    if ("" === l || RF(o, l)) throw new PF("Invalid capture group name");
                                    o[l] = !0, i[i.length] = [l, c], u = !1, l = "";
                                    continue
                            }
                            u ? l += t : a += t
                        }
                        return [a, i]
                    }(e), e = i[0], h = i[1]), o = bF(LF(e, t), u ? this : zF, ZF), (r || a || h.length) && (s = _F(o), r && (s.dotAll = !0, s.raw = ZF(function(e) {
                        for (var t, n = e.length, r = 0, a = "", i = !1; r <= n; r++) "\\" !== (t = WF(e, r)) ? i || "." !== t ? ("[" === t ? i = !0 : "]" === t && (i = !1), a += t) : a += "[\\s\\S]" : a += t + WF(e, ++r);
                        return a
                    }(e), n)), a && (s.sticky = !0), h.length && (s.groups = h)), e !== p) try {
                    xF(o, "source", "" === p ? "(?:)" : p)
                } catch (e) {}
                return o
            }, QF = kF(LF), $F = 0; QF.length > $F;) EF(ZF, LF, QF[$F++]);
        zF.constructor = ZF, ZF.prototype = zF, CF(mF, "RegExp", ZF, {
            constructor: !0
        })
    }
    OF("RegExp");
    var eD = W,
        tD = hF,
        nD = ae,
        rD = zi,
        aD = cr.get,
        iD = RegExp.prototype,
        oD = TypeError;
    eD && tD && rD(iD, "dotAll", {
        configurable: !0,
        get: function() {
            if (this !== iD) {
                if ("RegExp" === nD(this)) return !!aD(this).dotAll;
                throw oD("Incompatible receiver, RegExp required")
            }
        }
    });
    var sD = j,
        uD = ee,
        cD = Ya,
        lD = JO,
        hD = uF,
        pD = yi,
        fD = cr.get,
        dD = hF,
        vD = dF,
        mD = vt("native-string-replace", String.prototype.replace),
        gD = RegExp.prototype.exec,
        yD = gD,
        bD = uD("".charAt),
        xD = uD("".indexOf),
        kD = uD("".replace),
        wD = uD("".slice),
        ID = function() {
            var e = /a/,
                t = /b*/g;
            return sD(gD, e, "a"), sD(gD, t, "a"), 0 !== e.lastIndex || 0 !== t.lastIndex
        }(),
        ND = hD.BROKEN_CARET,
        SD = void 0 !== /()??/.exec("")[1];
    (ID || SD || ND || dD || vD) && (yD = function(e) {
        var t, n, r, a, i, o, s, u = this,
            c = fD(u),
            l = cD(e),
            h = c.raw;
        if (h) return h.lastIndex = u.lastIndex, t = sD(yD, h, l), u.lastIndex = h.lastIndex, t;
        var p = c.groups,
            f = ND && u.sticky,
            d = sD(lD, u),
            v = u.source,
            m = 0,
            g = l;
        if (f && (d = kD(d, "y", ""), -1 === xD(d, "g") && (d += "g"), g = wD(l, u.lastIndex), u.lastIndex > 0 && (!u.multiline || u.multiline && "\n" !== bD(l, u.lastIndex - 1)) && (v = "(?: " + v + ")", g = " " + g, m++), n = new RegExp("^(?:" + v + ")", d)), SD && (n = new RegExp("^" + v + "$(?!\\s)", d)), ID && (r = u.lastIndex), a = sD(gD, f ? n : u, g), f ? a ? (a.input = wD(a.input, m), a[0] = wD(a[0], m), a.index = u.lastIndex, u.lastIndex += a[0].length) : u.lastIndex = 0 : ID && a && (u.lastIndex = u.global ? a.index + a[0].length : r), SD && a && a.length > 1 && sD(mD, a[0], n, (function() {
                for (i = 1; i < arguments.length - 2; i++) void 0 === arguments[i] && (a[i] = void 0)
            })), a && p)
            for (a.groups = o = pD(null), i = 0; i < p.length; i++) o[(s = p[i])[0]] = a[s[1]];
        return a
    });
    var TD = yD;
    La({
        target: "RegExp",
        proto: !0,
        forced: /./.exec !== TD
    }, {
        exec: TD
    });
    var ED = W,
        CD = zi,
        AD = JO,
        RD = B,
        _D = z.RegExp,
        OD = _D.prototype,
        FD = ED && RD((function() {
            var e = !0;
            try {
                _D(".", "d")
            } catch (t) {
                e = !1
            }
            var t = {},
                n = "",
                r = e ? "dgimsy" : "gimsy",
                a = function(e, r) {
                    Object.defineProperty(t, e, {
                        get: function() {
                            return n += r, !0
                        }
                    })
                },
                i = {
                    dotAll: "s",
                    global: "g",
                    ignoreCase: "i",
                    multiline: "m",
                    sticky: "y"
                };
            for (var o in e && (i.hasIndices = "d"), i) a(o, i[o]);
            return Object.getOwnPropertyDescriptor(OD, "flags").get.call(t) !== r || n !== r
        }));
    FD && CD(OD, "flags", {
        configurable: !0,
        get: AD
    });
    var DD = W,
        MD = uF.MISSED_STICKY,
        LD = ae,
        zD = zi,
        PD = cr.get,
        BD = RegExp.prototype,
        WD = TypeError;
    DD && MD && zD(BD, "sticky", {
        configurable: !0,
        get: function() {
            if (this !== BD) {
                if ("RegExp" === LD(this)) return !!PD(this).sticky;
                throw WD("Incompatible receiver, RegExp required")
            }
        }
    });
    var UD, VD, GD = La,
        jD = j,
        HD = xe,
        qD = dn,
        KD = Ya,
        XD = (UD = !1, (VD = /[ac]/).exec = function() {
            return UD = !0, /./.exec.apply(this, arguments)
        }, !0 === VD.test("abc") && UD),
        YD = /./.test;
    GD({
        target: "RegExp",
        proto: !0,
        forced: !XD
    }, {
        test: function(e) {
            var t = qD(this),
                n = KD(e),
                r = t.exec;
            if (!HD(r)) return jD(YD, t, n);
            var a = jD(r, t, n);
            return null !== a && (qD(a), !0)
        }
    });
    var JD = Mn.PROPER,
        ZD = Or,
        QD = dn,
        $D = Ya,
        eM = B,
        tM = nF,
        nM = "toString",
        rM = RegExp.prototype.toString,
        aM = eM((function() {
            return "/a/b" != rM.call({
                source: "a",
                flags: "b"
            })
        })),
        iM = JD && rM.name != nM;
    (aM || iM) && ZD(RegExp.prototype, nM, (function() {
        var e = QD(this);
        return "/" + $D(e.source) + "/" + $D(tM(e))
    }), {
        unsafe: !0
    }), Uw("Set", (function(e) {
        return function() {
            return e(this, arguments.length ? arguments[0] : void 0)
        }
    }), nI);
    var oM = La,
        sM = fe,
        uM = Pr,
        cM = Ya,
        lM = B,
        hM = ee("".charAt);
    oM({
        target: "String",
        proto: !0,
        forced: lM((function() {
            return "\ud842" !== "ð ®·".at(-2)
        }))
    }, {
        at: function(e) {
            var t = cM(sM(this)),
                n = t.length,
                r = uM(e),
                a = r >= 0 ? r : n + r;
            return a < 0 || a >= n ? void 0 : hM(t, a)
        }
    });
    var pM = ee,
        fM = Pr,
        dM = Ya,
        vM = fe,
        mM = pM("".charAt),
        gM = pM("".charCodeAt),
        yM = pM("".slice),
        bM = function(e) {
            return function(t, n) {
                var r, a, i = dM(vM(t)),
                    o = fM(n),
                    s = i.length;
                return o < 0 || o >= s ? e ? "" : void 0 : (r = gM(i, o)) < 55296 || r > 56319 || o + 1 === s || (a = gM(i, o + 1)) < 56320 || a > 57343 ? e ? mM(i, o) : r : e ? yM(i, o, o + 2) : a - 56320 + (r - 55296 << 10) + 65536
            }
        },
        xM = {
            codeAt: bM(!1),
            charAt: bM(!0)
        },
        kM = xM.codeAt;
    La({
        target: "String",
        proto: !0
    }, {
        codePointAt: function(e) {
            return kM(this, e)
        }
    });
    var wM = XO,
        IM = TypeError,
        NM = function(e) {
            if (wM(e)) throw IM("The method doesn't accept regular expressions");
            return e
        },
        SM = Mt("match"),
        TM = function(e) {
            var t = /./;
            try {
                "/./" [e](t)
            } catch (n) {
                try {
                    return t[SM] = !1, "/./" [e](t)
                } catch (e) {}
            }
            return !1
        },
        EM = La,
        CM = ro,
        AM = P.f,
        RM = Hr,
        _M = Ya,
        OM = NM,
        FM = fe,
        DM = TM,
        MM = CM("".endsWith),
        LM = CM("".slice),
        zM = Math.min,
        PM = DM("endsWith"),
        BM = !PM && !! function() {
            var e = AM(String.prototype, "endsWith");
            return e && !e.writable
        }();
    EM({
        target: "String",
        proto: !0,
        forced: !BM && !PM
    }, {
        endsWith: function(e) {
            var t = _M(FM(this));
            OM(e);
            var n = arguments.length > 1 ? arguments[1] : void 0,
                r = t.length,
                a = void 0 === n ? r : zM(RM(n), r),
                i = _M(e);
            return MM ? MM(t, i, a) : LM(t, a - i.length, a) === i
        }
    });
    var WM = La,
        UM = ee,
        VM = Vr,
        GM = RangeError,
        jM = String.fromCharCode,
        HM = String.fromCodePoint,
        qM = UM([].join);
    WM({
        target: "String",
        stat: !0,
        arity: 1,
        forced: !!HM && 1 != HM.length
    }, {
        fromCodePoint: function(e) {
            for (var t, n = [], r = arguments.length, a = 0; r > a;) {
                if (t = +arguments[a++], VM(t, 1114111) !== t) throw GM(t + " is not a valid code point");
                n[a] = t < 65536 ? jM(t) : jM(55296 + ((t -= 65536) >> 10), t % 1024 + 56320)
            }
            return qM(n, "")
        }
    });
    var KM = La,
        XM = NM,
        YM = fe,
        JM = Ya,
        ZM = TM,
        QM = ee("".indexOf);
    KM({
        target: "String",
        proto: !0,
        forced: !ZM("includes")
    }, {
        includes: function(e) {
            return !!~QM(JM(YM(this)), JM(XM(e)), arguments.length > 1 ? arguments[1] : void 0)
        }
    });
    var $M = xM.charAt,
        eL = Ya,
        tL = cr,
        nL = Dd,
        rL = Md,
        aL = "String Iterator",
        iL = tL.set,
        oL = tL.getterFor(aL);
    nL(String, "String", (function(e) {
        iL(this, {
            type: aL,
            string: eL(e),
            index: 0
        })
    }), (function() {
        var e, t = oL(this),
            n = t.string,
            r = t.index;
        return r >= n.length ? rL(void 0, !0) : (e = $M(n, r), t.index += e.length, rL(e, !1))
    }));
    var sL = ro,
        uL = Or,
        cL = TD,
        lL = B,
        hL = Mt,
        pL = Cn,
        fL = hL("species"),
        dL = RegExp.prototype,
        vL = function(e, t, n, r) {
            var a = hL(e),
                i = !lL((function() {
                    var t = {};
                    return t[a] = function() {
                        return 7
                    }, 7 != "" [e](t)
                })),
                o = i && !lL((function() {
                    var t = !1,
                        n = /a/;
                    return "split" === e && ((n = {}).constructor = {}, n.constructor[fL] = function() {
                        return n
                    }, n.flags = "", n[a] = /./ [a]), n.exec = function() {
                        return t = !0, null
                    }, n[a](""), !t
                }));
            if (!i || !o || n) {
                var s = sL(/./ [a]),
                    u = t(a, "" [e], (function(e, t, n, r, a) {
                        var o = sL(e),
                            u = t.exec;
                        return u === cL || u === dL.exec ? i && !a ? {
                            done: !0,
                            value: s(t, n, r)
                        } : {
                            done: !0,
                            value: o(n, t, r)
                        } : {
                            done: !1
                        }
                    }));
                uL(String.prototype, e, u[0]), uL(dL, a, u[1])
            }
            r && pL(dL[a], "sham", !0)
        },
        mL = xM.charAt,
        gL = function(e, t, n) {
            return t + (n ? mL(e, t).length : 1)
        },
        yL = j,
        bL = dn,
        xL = xe,
        kL = ae,
        wL = TD,
        IL = TypeError,
        NL = function(e, t) {
            var n = e.exec;
            if (xL(n)) {
                var r = yL(n, e, t);
                return null !== r && bL(r), r
            }
            if ("RegExp" === kL(e)) return yL(wL, e, t);
            throw IL("RegExp#exec called on incompatible receiver")
        },
        SL = j,
        TL = dn,
        EL = le,
        CL = Hr,
        AL = Ya,
        RL = fe,
        _L = et,
        OL = gL,
        FL = NL;
    vL("match", (function(e, t, n) {
        return [function(t) {
            var n = RL(this),
                r = EL(t) ? void 0 : _L(t, e);
            return r ? SL(r, t, n) : new RegExp(t)[e](AL(n))
        }, function(e) {
            var r = TL(this),
                a = AL(e),
                i = n(t, r, a);
            if (i.done) return i.value;
            if (!r.global) return FL(r, a);
            var o = r.unicode;
            r.lastIndex = 0;
            for (var s, u = [], c = 0; null !== (s = FL(r, a));) {
                var l = AL(s[0]);
                u[c] = l, "" === l && (r.lastIndex = OL(a, CL(r.lastIndex), o)), c++
            }
            return 0 === c ? null : u
        }]
    }));
    var DL = La,
        ML = j,
        LL = ro,
        zL = dd,
        PL = Md,
        BL = fe,
        WL = Hr,
        UL = Ya,
        VL = dn,
        GL = le,
        jL = XO,
        HL = nF,
        qL = et,
        KL = Or,
        XL = B,
        YL = Kb,
        JL = gL,
        ZL = NL,
        QL = cr,
        $L = Mt("matchAll"),
        ez = "RegExp String",
        tz = "RegExp String Iterator",
        nz = QL.set,
        rz = QL.getterFor(tz),
        az = RegExp.prototype,
        iz = TypeError,
        oz = LL("".indexOf),
        sz = LL("".matchAll),
        uz = !!sz && !XL((function() {
            sz("a", /./)
        })),
        cz = zL((function(e, t, n, r) {
            nz(this, {
                type: tz,
                regexp: e,
                string: t,
                global: n,
                unicode: r,
                done: !1
            })
        }), ez, (function() {
            var e = rz(this);
            if (e.done) return PL(void 0, !0);
            var t = e.regexp,
                n = e.string,
                r = ZL(t, n);
            return null === r ? (e.done = !0, PL(void 0, !0)) : e.global ? ("" === UL(r[0]) && (t.lastIndex = JL(n, WL(t.lastIndex), e.unicode)), PL(r, !1)) : (e.done = !0, PL(r, !1))
        })),
        lz = function(e) {
            var t, n, r, a = VL(this),
                i = UL(e),
                o = YL(a, RegExp),
                s = UL(HL(a));
            return t = new o(o === RegExp ? a.source : a, s), n = !!~oz(s, "g"), r = !!~oz(s, "u"), t.lastIndex = WL(a.lastIndex), new cz(t, i, n, r)
        };
    DL({
        target: "String",
        proto: !0,
        forced: uz
    }, {
        matchAll: function(e) {
            var t, n, r, a = BL(this);
            if (GL(e)) {
                if (uz) return sz(a, e)
            } else {
                if (jL(e) && (t = UL(BL(HL(e))), !~oz(t, "g"))) throw iz("`.matchAll` does not allow non-global regexes");
                if (uz) return sz(a, e);
                if (r = qL(e, $L)) return ML(r, e, a)
            }
            return n = UL(a), new RegExp(e, "g")[$L](n)
        }
    }), $L in az || KL(az, $L, lz);
    var hz = /Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(Ae),
        pz = Fx.end;
    La({
        target: "String",
        proto: !0,
        forced: hz
    }, {
        padEnd: function(e) {
            return pz(this, e, arguments.length > 1 ? arguments[1] : void 0)
        }
    });
    var fz = Fx.start;
    La({
        target: "String",
        proto: !0,
        forced: hz
    }, {
        padStart: function(e) {
            return fz(this, e, arguments.length > 1 ? arguments[1] : void 0)
        }
    });
    var dz = La,
        vz = ee,
        mz = me,
        gz = yt,
        yz = Ya,
        bz = Kr,
        xz = vz([].push),
        kz = vz([].join);
    dz({
        target: "String",
        stat: !0
    }, {
        raw: function(e) {
            var t = mz(gz(e).raw),
                n = bz(t);
            if (!n) return "";
            for (var r = arguments.length, a = [], i = 0;;) {
                if (xz(a, yz(t[i++])), i === n) return kz(a, "");
                i < r && xz(a, yz(arguments[i]))
            }
        }
    }), La({
        target: "String",
        proto: !0
    }, {
        repeat: Nx
    });
    var wz = ee,
        Iz = yt,
        Nz = Math.floor,
        Sz = wz("".charAt),
        Tz = wz("".replace),
        Ez = wz("".slice),
        Cz = /\$([$&'`]|\d{1,2}|<[^>]*>)/g,
        Az = /\$([$&'`]|\d{1,2})/g,
        Rz = function(e, t, n, r, a, i) {
            var o = n + e.length,
                s = r.length,
                u = Az;
            return void 0 !== a && (a = Iz(a), u = Cz), Tz(i, u, (function(i, u) {
                var c;
                switch (Sz(u, 0)) {
                    case "$":
                        return "$";
                    case "&":
                        return e;
                    case "`":
                        return Ez(t, 0, n);
                    case "'":
                        return Ez(t, o);
                    case "<":
                        c = a[Ez(u, 1, -1)];
                        break;
                    default:
                        var l = +u;
                        if (0 === l) return i;
                        if (l > s) {
                            var h = Nz(l / 10);
                            return 0 === h ? i : h <= s ? void 0 === r[h - 1] ? Sz(u, 1) : r[h - 1] + Sz(u, 1) : i
                        }
                        c = r[l - 1]
                }
                return void 0 === c ? "" : c
            }))
        },
        _z = fu,
        Oz = j,
        Fz = ee,
        Dz = vL,
        Mz = B,
        Lz = dn,
        zz = xe,
        Pz = le,
        Bz = Pr,
        Wz = Hr,
        Uz = Ya,
        Vz = fe,
        Gz = gL,
        jz = et,
        Hz = Rz,
        qz = NL,
        Kz = Mt("replace"),
        Xz = Math.max,
        Yz = Math.min,
        Jz = Fz([].concat),
        Zz = Fz([].push),
        Qz = Fz("".indexOf),
        $z = Fz("".slice),
        eP = "$0" === "a".replace(/./, "$0"),
        tP = !!/./ [Kz] && "" === /./ [Kz]("a", "$0"),
        nP = !Mz((function() {
            var e = /./;
            return e.exec = function() {
                var e = [];
                return e.groups = {
                    a: "7"
                }, e
            }, "7" !== "".replace(e, "$<a>")
        }));
    Dz("replace", (function(e, t, n) {
        var r = tP ? "$" : "$0";
        return [function(e, n) {
            var r = Vz(this),
                a = Pz(e) ? void 0 : jz(e, Kz);
            return a ? Oz(a, e, r, n) : Oz(t, Uz(r), e, n)
        }, function(e, a) {
            var i = Lz(this),
                o = Uz(e);
            if ("string" == typeof a && -1 === Qz(a, r) && -1 === Qz(a, "$<")) {
                var s = n(t, i, o, a);
                if (s.done) return s.value
            }
            var u = zz(a);
            u || (a = Uz(a));
            var c = i.global;
            if (c) {
                var l = i.unicode;
                i.lastIndex = 0
            }
            for (var h = [];;) {
                var p = qz(i, o);
                if (null === p) break;
                if (Zz(h, p), !c) break;
                "" === Uz(p[0]) && (i.lastIndex = Gz(o, Wz(i.lastIndex), l))
            }
            for (var f, d = "", v = 0, m = 0; m < h.length; m++) {
                for (var g = Uz((p = h[m])[0]), y = Xz(Yz(Bz(p.index), o.length), 0), b = [], x = 1; x < p.length; x++) Zz(b, void 0 === (f = p[x]) ? f : String(f));
                var k = p.groups;
                if (u) {
                    var w = Jz([g], b, y, o);
                    void 0 !== k && Zz(w, k);
                    var I = Uz(_z(a, void 0, w))
                } else I = Hz(g, o, y, b, k, a);
                y >= v && (d += $z(o, v, y) + I, v = y + g.length)
            }
            return d + $z(o, v)
        }]
    }), !nP || !eP || tP);
    var rP = La,
        aP = j,
        iP = ee,
        oP = fe,
        sP = xe,
        uP = le,
        cP = XO,
        lP = Ya,
        hP = et,
        pP = nF,
        fP = Rz,
        dP = Mt("replace"),
        vP = TypeError,
        mP = iP("".indexOf),
        gP = (iP("".replace), iP("".slice)),
        yP = Math.max,
        bP = function(e, t, n) {
            return n > e.length ? -1 : "" === t ? n : mP(e, t, n)
        };
    rP({
        target: "String",
        proto: !0
    }, {
        replaceAll: function(e, t) {
            var n, r, a, i, o, s, u, c, l = oP(this),
                h = 0,
                p = 0,
                f = "";
            if (!uP(e)) {
                if (cP(e) && (n = lP(oP(pP(e))), !~mP(n, "g"))) throw vP("`.replaceAll` does not allow non-global regexes");
                if (r = hP(e, dP)) return aP(r, e, l, t)
            }
            for (a = lP(l), i = lP(e), (o = sP(t)) || (t = lP(t)), s = i.length, u = yP(1, s), h = bP(a, i, 0); - 1 !== h;) c = o ? lP(t(i, h, a)) : fP(i, a, h, [], void 0, t), f += gP(a, p, h) + c, p = h + s, h = bP(a, i, h + u);
            return p < a.length && (f += gP(a, p)), f
        }
    });
    var xP = j,
        kP = dn,
        wP = le,
        IP = fe,
        NP = xE,
        SP = Ya,
        TP = et,
        EP = NL;
    vL("search", (function(e, t, n) {
        return [function(t) {
            var n = IP(this),
                r = wP(t) ? void 0 : TP(t, e);
            return r ? xP(r, t, n) : new RegExp(t)[e](SP(n))
        }, function(e) {
            var r = kP(this),
                a = SP(e),
                i = n(t, r, a);
            if (i.done) return i.value;
            var o = r.lastIndex;
            NP(o, 0) || (r.lastIndex = 0);
            var s = EP(r, a);
            return NP(r.lastIndex, o) || (r.lastIndex = o), null === s ? -1 : s.index
        }]
    }));
    var CP = fu,
        AP = j,
        RP = ee,
        _P = vL,
        OP = dn,
        FP = le,
        DP = XO,
        MP = fe,
        LP = Kb,
        zP = gL,
        PP = Hr,
        BP = Ya,
        WP = et,
        UP = Ai,
        VP = NL,
        GP = TD,
        jP = B,
        HP = uF.UNSUPPORTED_Y,
        qP = 4294967295,
        KP = Math.min,
        XP = [].push,
        YP = RP(/./.exec),
        JP = RP(XP),
        ZP = RP("".slice),
        QP = !jP((function() {
            var e = /(?:)/,
                t = e.exec;
            e.exec = function() {
                return t.apply(this, arguments)
            };
            var n = "ab".split(e);
            return 2 !== n.length || "a" !== n[0] || "b" !== n[1]
        }));
    _P("split", (function(e, t, n) {
        var r;
        return r = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function(e, n) {
            var r = BP(MP(this)),
                a = void 0 === n ? qP : n >>> 0;
            if (0 === a) return [];
            if (void 0 === e) return [r];
            if (!DP(e)) return AP(t, r, e, a);
            for (var i, o, s, u = [], c = (e.ignoreCase ? "i" : "") + (e.multiline ? "m" : "") + (e.unicode ? "u" : "") + (e.sticky ? "y" : ""), l = 0, h = new RegExp(e.source, c + "g");
                (i = AP(GP, h, r)) && !((o = h.lastIndex) > l && (JP(u, ZP(r, l, i.index)), i.length > 1 && i.index < r.length && CP(XP, u, UP(i, 1)), s = i[0].length, l = o, u.length >= a));) h.lastIndex === i.index && h.lastIndex++;
            return l === r.length ? !s && YP(h, "") || JP(u, "") : JP(u, ZP(r, l)), u.length > a ? UP(u, 0, a) : u
        } : "0".split(void 0, 0).length ? function(e, n) {
            return void 0 === e && 0 === n ? [] : AP(t, this, e, n)
        } : t, [function(t, n) {
            var a = MP(this),
                i = FP(t) ? void 0 : WP(t, e);
            return i ? AP(i, t, a, n) : AP(r, BP(a), t, n)
        }, function(e, a) {
            var i = OP(this),
                o = BP(e),
                s = n(r, i, o, a, r !== t);
            if (s.done) return s.value;
            var u = LP(i, RegExp),
                c = i.unicode,
                l = (i.ignoreCase ? "i" : "") + (i.multiline ? "m" : "") + (i.unicode ? "u" : "") + (HP ? "g" : "y"),
                h = new u(HP ? "^(?:" + i.source + ")" : i, l),
                p = void 0 === a ? qP : a >>> 0;
            if (0 === p) return [];
            if (0 === o.length) return null === VP(h, o) ? [o] : [];
            for (var f = 0, d = 0, v = []; d < o.length;) {
                h.lastIndex = HP ? 0 : d;
                var m, g = VP(h, HP ? ZP(o, d) : o);
                if (null === g || (m = KP(PP(h.lastIndex + (HP ? d : 0)), o.length)) === f) d = zP(o, d, c);
                else {
                    if (JP(v, ZP(o, f, d)), v.length === p) return v;
                    for (var y = 1; y <= g.length - 1; y++)
                        if (JP(v, g[y]), v.length === p) return v;
                    d = f = m
                }
            }
            return JP(v, ZP(o, f)), v
        }]
    }), !QP, HP);
    var $P = La,
        eB = ro,
        tB = P.f,
        nB = Hr,
        rB = Ya,
        aB = NM,
        iB = fe,
        oB = TM,
        sB = eB("".startsWith),
        uB = eB("".slice),
        cB = Math.min,
        lB = oB("startsWith"),
        hB = !lB && !! function() {
            var e = tB(String.prototype, "startsWith");
            return e && !e.writable
        }();
    $P({
        target: "String",
        proto: !0,
        forced: !hB && !lB
    }, {
        startsWith: function(e) {
            var t = rB(iB(this));
            aB(e);
            var n = nB(cB(arguments.length > 1 ? arguments[1] : void 0, t.length)),
                r = rB(e);
            return sB ? sB(t, r, n) : uB(t, n, n + r.length) === r
        }
    });
    var pB = La,
        fB = fe,
        dB = Pr,
        vB = Ya,
        mB = ee("".slice),
        gB = Math.max,
        yB = Math.min;
    pB({
        target: "String",
        proto: !0,
        forced: !"".substr || "b" !== "ab".substr(-1)
    }, {
        substr: function(e, t) {
            var n, r, a = vB(fB(this)),
                i = a.length,
                o = dB(e);
            return o === 1 / 0 && (o = 0), o < 0 && (o = gB(i + o, 0)), (n = void 0 === t ? i : dB(t)) <= 0 || n === 1 / 0 || o >= (r = yB(o + n, i)) ? "" : mB(a, o, r)
        }
    });
    var bB = Mn.PROPER,
        xB = B,
        kB = fN,
        wB = function(e) {
            return xB((function() {
                return !!kB[e]() || "âÂá " !== "âÂá " [e]() || bB && kB[e].name !== e
            }))
        },
        IB = kN.trim;
    La({
        target: "String",
        proto: !0,
        forced: wB("trim")
    }, {
        trim: function() {
            return IB(this)
        }
    });
    var NB = kN.end,
        SB = wB("trimEnd") ? function() {
            return NB(this)
        } : "".trimEnd;
    La({
        target: "String",
        proto: !0,
        name: "trimEnd",
        forced: "".trimRight !== SB
    }, {
        trimRight: SB
    });
    La({
        target: "String",
        proto: !0,
        name: "trimEnd",
        forced: "".trimEnd !== SB
    }, {
        trimEnd: SB
    });
    var TB = kN.start,
        EB = wB("trimStart") ? function() {
            return TB(this)
        } : "".trimStart;
    La({
        target: "String",
        proto: !0,
        name: "trimStart",
        forced: "".trimLeft !== EB
    }, {
        trimLeft: EB
    });
    La({
        target: "String",
        proto: !0,
        name: "trimStart",
        forced: "".trimStart !== EB
    }, {
        trimStart: EB
    });
    var CB = fe,
        AB = Ya,
        RB = /"/g,
        _B = ee("".replace),
        OB = function(e, t, n, r) {
            var a = AB(CB(e)),
                i = "<" + t;
            return "" !== n && (i += " " + n + '="' + _B(AB(r), RB, "&quot;") + '"'), i + ">" + a + "</" + t + ">"
        },
        FB = B,
        DB = function(e) {
            return FB((function() {
                var t = "" [e]('"');
                return t !== t.toLowerCase() || t.split('"').length > 3
            }))
        },
        MB = OB;
    La({
        target: "String",
        proto: !0,
        forced: DB("anchor")
    }, {
        anchor: function(e) {
            return MB(this, "a", "name", e)
        }
    });
    var LB = OB;
    La({
        target: "String",
        proto: !0,
        forced: DB("big")
    }, {
        big: function() {
            return LB(this, "big", "", "")
        }
    });
    var zB = OB;
    La({
        target: "String",
        proto: !0,
        forced: DB("blink")
    }, {
        blink: function() {
            return zB(this, "blink", "", "")
        }
    });
    var PB = OB;
    La({
        target: "String",
        proto: !0,
        forced: DB("bold")
    }, {
        bold: function() {
            return PB(this, "b", "", "")
        }
    });
    var BB = OB;
    La({
        target: "String",
        proto: !0,
        forced: DB("fixed")
    }, {
        fixed: function() {
            return BB(this, "tt", "", "")
        }
    });
    var WB = OB;
    La({
        target: "String",
        proto: !0,
        forced: DB("fontcolor")
    }, {
        fontcolor: function(e) {
            return WB(this, "font", "color", e)
        }
    });
    var UB = OB;
    La({
        target: "String",
        proto: !0,
        forced: DB("fontsize")
    }, {
        fontsize: function(e) {
            return UB(this, "font", "size", e)
        }
    });
    var VB = OB;
    La({
        target: "String",
        proto: !0,
        forced: DB("italics")
    }, {
        italics: function() {
            return VB(this, "i", "", "")
        }
    });
    var GB = OB;
    La({
        target: "String",
        proto: !0,
        forced: DB("link")
    }, {
        link: function(e) {
            return GB(this, "a", "href", e)
        }
    });
    var jB = OB;
    La({
        target: "String",
        proto: !0,
        forced: DB("small")
    }, {
        small: function() {
            return jB(this, "small", "", "")
        }
    });
    var HB = OB;
    La({
        target: "String",
        proto: !0,
        forced: DB("strike")
    }, {
        strike: function() {
            return HB(this, "strike", "", "")
        }
    });
    var qB = OB;
    La({
        target: "String",
        proto: !0,
        forced: DB("sub")
    }, {
        sub: function() {
            return qB(this, "sub", "", "")
        }
    });
    var KB = OB;
    La({
        target: "String",
        proto: !0,
        forced: DB("sup")
    }, {
        sup: function() {
            return KB(this, "sup", "", "")
        }
    });
    var XB = {
            exports: {}
        },
        YB = z,
        JB = B,
        ZB = Uf,
        QB = Pb.NATIVE_ARRAY_BUFFER_VIEWS,
        $B = YB.ArrayBuffer,
        eW = YB.Int8Array,
        tW = !QB || !JB((function() {
            eW(1)
        })) || !JB((function() {
            new eW(-1)
        })) || !ZB((function(e) {
            new eW, new eW(null), new eW(1.5), new eW(e)
        }), !0) || JB((function() {
            return 1 !== new eW(new $B(2), 1, void 0).length
        })),
        nW = Pr,
        rW = RangeError,
        aW = function(e) {
            var t = nW(e);
            if (t < 0) throw rW("The argument can't be less than 0");
            return t
        },
        iW = aW,
        oW = RangeError,
        sW = function(e, t) {
            var n = iW(e);
            if (n % t) throw oW("Wrong offset");
            return n
        },
        uW = qa,
        cW = function(e) {
            var t = uW(e);
            return "BigInt64Array" == t || "BigUint64Array" == t
        },
        lW = Gt,
        hW = TypeError,
        pW = function(e) {
            var t = lW(e, "number");
            if ("number" == typeof t) throw hW("Can't convert number to bigint");
            return BigInt(t)
        },
        fW = so,
        dW = j,
        vW = Vb,
        mW = yt,
        gW = Kr,
        yW = eh,
        bW = Kl,
        xW = Ul,
        kW = cW,
        wW = Pb.aTypedArrayConstructor,
        IW = pW,
        NW = function(e) {
            var t, n, r, a, i, o, s, u, c = vW(this),
                l = mW(e),
                h = arguments.length,
                p = h > 1 ? arguments[1] : void 0,
                f = void 0 !== p,
                d = bW(l);
            if (d && !xW(d))
                for (u = (s = yW(l, d)).next, l = []; !(o = dW(u, s)).done;) l.push(o.value);
            for (f && h > 2 && (p = fW(p, arguments[2])), n = gW(l), r = new(wW(c))(n), a = kW(r), t = 0; n > t; t++) i = f ? p(l[t], t) : l[t], r[t] = a ? IW(i) : +i;
            return r
        },
        SW = (XB.exports, La),
        TW = z,
        EW = j,
        CW = W,
        AW = tW,
        RW = Pb,
        _W = Zy,
        OW = zg,
        FW = Y,
        DW = Cn,
        MW = nS,
        LW = Hr,
        zW = Ug,
        PW = sW,
        BW = qt,
        WW = kt,
        UW = qa,
        VW = Ie,
        GW = He,
        jW = yi,
        HW = Ce,
        qW = Tc,
        KW = Fr.f,
        XW = NW,
        YW = Wo.forEach,
        JW = Fm,
        ZW = zi,
        QW = cn,
        $W = P,
        eU = Oc,
        tU = cr.get,
        nU = cr.set,
        rU = cr.enforce,
        aU = QW.f,
        iU = $W.f,
        oU = Math.round,
        sU = TW.RangeError,
        uU = _W.ArrayBuffer,
        cU = uU.prototype,
        lU = _W.DataView,
        hU = RW.NATIVE_ARRAY_BUFFER_VIEWS,
        pU = RW.TYPED_ARRAY_TAG,
        fU = RW.TypedArray,
        dU = RW.TypedArrayPrototype,
        vU = RW.aTypedArrayConstructor,
        mU = RW.isTypedArray,
        gU = "BYTES_PER_ELEMENT",
        yU = "Wrong length",
        bU = function(e, t) {
            vU(e);
            for (var n = 0, r = t.length, a = new e(r); r > n;) a[n] = t[n++];
            return a
        },
        xU = function(e, t) {
            ZW(e, t, {
                configurable: !0,
                get: function() {
                    return tU(this)[t]
                }
            })
        },
        kU = function(e) {
            var t;
            return HW(cU, e) || "ArrayBuffer" == (t = UW(e)) || "SharedArrayBuffer" == t
        },
        wU = function(e, t) {
            return mU(e) && !GW(t) && t in e && MW(+t) && t >= 0
        },
        IU = function(e, t) {
            return t = BW(t), wU(e, t) ? FW(2, e[t]) : iU(e, t)
        },
        NU = function(e, t, n) {
            return t = BW(t), !(wU(e, t) && VW(n) && WW(n, "value")) || WW(n, "get") || WW(n, "set") || n.configurable || WW(n, "writable") && !n.writable || WW(n, "enumerable") && !n.enumerable ? aU(e, t, n) : (e[t] = n.value, e)
        };
    CW ? (hU || ($W.f = IU, QW.f = NU, xU(dU, "buffer"), xU(dU, "byteOffset"), xU(dU, "byteLength"), xU(dU, "length")), SW({
        target: "Object",
        stat: !0,
        forced: !hU
    }, {
        getOwnPropertyDescriptor: IU,
        defineProperty: NU
    }), XB.exports = function(e, t, n) {
        var r = e.match(/\d+/)[0] / 8,
            a = e + (n ? "Clamped" : "") + "Array",
            i = "get" + e,
            o = "set" + e,
            s = TW[a],
            u = s,
            c = u && u.prototype,
            l = {},
            h = function(e, t) {
                aU(e, t, {
                    get: function() {
                        return function(e, t) {
                            var n = tU(e);
                            return n.view[i](t * r + n.byteOffset, !0)
                        }(this, t)
                    },
                    set: function(e) {
                        return function(e, t, a) {
                            var i = tU(e);
                            n && (a = (a = oU(a)) < 0 ? 0 : a > 255 ? 255 : 255 & a), i.view[o](t * r + i.byteOffset, a, !0)
                        }(this, t, e)
                    },
                    enumerable: !0
                })
            };
        hU ? AW && (u = t((function(e, t, n, a) {
            return OW(e, c), eU(VW(t) ? kU(t) ? void 0 !== a ? new s(t, PW(n, r), a) : void 0 !== n ? new s(t, PW(n, r)) : new s(t) : mU(t) ? bU(u, t) : EW(XW, u, t) : new s(zW(t)), e, u)
        })), qW && qW(u, fU), YW(KW(s), (function(e) {
            e in u || DW(u, e, s[e])
        })), u.prototype = c) : (u = t((function(e, t, n, a) {
            OW(e, c);
            var i, o, s, l = 0,
                p = 0;
            if (VW(t)) {
                if (!kU(t)) return mU(t) ? bU(u, t) : EW(XW, u, t);
                i = t, p = PW(n, r);
                var f = t.byteLength;
                if (void 0 === a) {
                    if (f % r) throw sU(yU);
                    if ((o = f - p) < 0) throw sU(yU)
                } else if ((o = LW(a) * r) + p > f) throw sU(yU);
                s = o / r
            } else s = zW(t), i = new uU(o = s * r);
            for (nU(e, {
                    buffer: i,
                    byteOffset: p,
                    byteLength: o,
                    length: s,
                    view: new lU(i)
                }); l < s;) h(e, l++)
        })), qW && qW(u, fU), c = u.prototype = jW(dU)), c.constructor !== u && DW(c, "constructor", u), rU(c).TypedArrayConstructor = u, pU && DW(c, pU, a);
        var p = u != s;
        l[a] = u, SW({
            global: !0,
            constructor: !0,
            forced: p,
            sham: !hU
        }, l), gU in u || DW(u, gU, r), gU in c || DW(c, gU, r), JW(a)
    }) : XB.exports = function() {};
    var SU = XB.exports;
    SU("Float32", (function(e) {
        return function(t, n, r) {
            return e(this, t, n, r)
        }
    })), SU("Float64", (function(e) {
        return function(t, n, r) {
            return e(this, t, n, r)
        }
    })), SU("Int8", (function(e) {
        return function(t, n, r) {
            return e(this, t, n, r)
        }
    })), SU("Int16", (function(e) {
        return function(t, n, r) {
            return e(this, t, n, r)
        }
    })), SU("Int32", (function(e) {
        return function(t, n, r) {
            return e(this, t, n, r)
        }
    })), SU("Uint8", (function(e) {
        return function(t, n, r) {
            return e(this, t, n, r)
        }
    })), SU("Uint8", (function(e) {
        return function(t, n, r) {
            return e(this, t, n, r)
        }
    }), !0), SU("Uint16", (function(e) {
        return function(t, n, r) {
            return e(this, t, n, r)
        }
    })), SU("Uint32", (function(e) {
        return function(t, n, r) {
            return e(this, t, n, r)
        }
    }));
    var TU = Kr,
        EU = Pr,
        CU = Pb.aTypedArray;
    (0, Pb.exportTypedArrayMethod)("at", (function(e) {
        var t = CU(this),
            n = TU(t),
            r = EU(e),
            a = r >= 0 ? r : n + r;
        return a < 0 || a >= n ? void 0 : t[a]
    }));
    var AU = Pb,
        RU = ee(Ep),
        _U = AU.aTypedArray;
    (0, AU.exportTypedArrayMethod)("copyWithin", (function(e, t) {
        return RU(_U(this), e, t, arguments.length > 2 ? arguments[2] : void 0)
    }));
    var OU = Wo.every,
        FU = Pb.aTypedArray;
    (0, Pb.exportTypedArrayMethod)("every", (function(e) {
        return OU(FU(this), e, arguments.length > 1 ? arguments[1] : void 0)
    }));
    var DU = Mp,
        MU = pW,
        LU = qa,
        zU = j,
        PU = B,
        BU = Pb.aTypedArray,
        WU = Pb.exportTypedArrayMethod,
        UU = ee("".slice),
        VU = PU((function() {
            var e = 0;
            return new Int8Array(2).fill({
                valueOf: function() {
                    return e++
                }
            }), 1 !== e
        }));
    WU("fill", (function(e) {
        var t = arguments.length;
        BU(this);
        var n = "Big" === UU(LU(this), 0, 3) ? MU(e) : +e;
        return zU(DU, this, n, t > 1 ? arguments[1] : void 0, t > 2 ? arguments[2] : void 0)
    }), VU);
    var GU = Kb,
        jU = Pb.aTypedArrayConstructor,
        HU = Pb.getTypedArrayConstructor,
        qU = function(e) {
            return jU(GU(e, HU(e)))
        },
        KU = eg,
        XU = qU,
        YU = function(e, t) {
            return KU(XU(e), t)
        },
        JU = Wo.filter,
        ZU = YU,
        QU = Pb.aTypedArray;
    (0, Pb.exportTypedArrayMethod)("filter", (function(e) {
        var t = JU(QU(this), e, arguments.length > 1 ? arguments[1] : void 0);
        return ZU(this, t)
    }));
    var $U = Wo.find,
        eV = Pb.aTypedArray;
    (0, Pb.exportTypedArrayMethod)("find", (function(e) {
        return $U(eV(this), e, arguments.length > 1 ? arguments[1] : void 0)
    }));
    var tV = Wo.findIndex,
        nV = Pb.aTypedArray;
    (0, Pb.exportTypedArrayMethod)("findIndex", (function(e) {
        return tV(nV(this), e, arguments.length > 1 ? arguments[1] : void 0)
    }));
    var rV = $p.findLast,
        aV = Pb.aTypedArray;
    (0, Pb.exportTypedArrayMethod)("findLast", (function(e) {
        return rV(aV(this), e, arguments.length > 1 ? arguments[1] : void 0)
    }));
    var iV = $p.findLastIndex,
        oV = Pb.aTypedArray;
    (0, Pb.exportTypedArrayMethod)("findLastIndex", (function(e) {
        return iV(oV(this), e, arguments.length > 1 ? arguments[1] : void 0)
    }));
    var sV = Wo.forEach,
        uV = Pb.aTypedArray;
    (0, Pb.exportTypedArrayMethod)("forEach", (function(e) {
        sV(uV(this), e, arguments.length > 1 ? arguments[1] : void 0)
    })), (0, Pb.exportTypedArrayStaticMethod)("from", NW, tW);
    var cV = Qr.includes,
        lV = Pb.aTypedArray;
    (0, Pb.exportTypedArrayMethod)("includes", (function(e) {
        return cV(lV(this), e, arguments.length > 1 ? arguments[1] : void 0)
    }));
    var hV = Qr.indexOf,
        pV = Pb.aTypedArray;
    (0, Pb.exportTypedArrayMethod)("indexOf", (function(e) {
        return hV(pV(this), e, arguments.length > 1 ? arguments[1] : void 0)
    }));
    var fV = z,
        dV = B,
        vV = ee,
        mV = Pb,
        gV = Kd,
        yV = Mt("iterator"),
        bV = fV.Uint8Array,
        xV = vV(gV.values),
        kV = vV(gV.keys),
        wV = vV(gV.entries),
        IV = mV.aTypedArray,
        NV = mV.exportTypedArrayMethod,
        SV = bV && bV.prototype,
        TV = !dV((function() {
            SV[yV].call([1])
        })),
        EV = !!SV && SV.values && SV[yV] === SV.values && "values" === SV.values.name,
        CV = function() {
            return xV(IV(this))
        };
    NV("entries", (function() {
        return wV(IV(this))
    }), TV), NV("keys", (function() {
        return kV(IV(this))
    }), TV), NV("values", CV, TV || !EV, {
        name: "values"
    }), NV(yV, CV, TV || !EV, {
        name: "values"
    });
    var AV = Pb.aTypedArray,
        RV = Pb.exportTypedArrayMethod,
        _V = ee([].join);
    RV("join", (function(e) {
        return _V(AV(this), e)
    }));
    var OV = fu,
        FV = cv,
        DV = Pb.aTypedArray;
    (0, Pb.exportTypedArrayMethod)("lastIndexOf", (function(e) {
        var t = arguments.length;
        return OV(FV, DV(this), t > 1 ? [e, arguments[1]] : [e])
    }));
    var MV = Wo.map,
        LV = qU,
        zV = Pb.aTypedArray;
    (0, Pb.exportTypedArrayMethod)("map", (function(e) {
        return MV(zV(this), e, arguments.length > 1 ? arguments[1] : void 0, (function(e, t) {
            return new(LV(e))(t)
        }))
    }));
    var PV = Pb.aTypedArrayConstructor;
    (0, Pb.exportTypedArrayStaticMethod)("of", (function() {
        for (var e = 0, t = arguments.length, n = new(PV(this))(t); t > e;) n[e] = arguments[e++];
        return n
    }), tW);
    var BV = Av.left,
        WV = Pb.aTypedArray;
    (0, Pb.exportTypedArrayMethod)("reduce", (function(e) {
        var t = arguments.length;
        return BV(WV(this), e, t, t > 1 ? arguments[1] : void 0)
    }));
    var UV = Av.right,
        VV = Pb.aTypedArray;
    (0, Pb.exportTypedArrayMethod)("reduceRight", (function(e) {
        var t = arguments.length;
        return UV(VV(this), e, t, t > 1 ? arguments[1] : void 0)
    }));
    var GV = Pb.aTypedArray,
        jV = Pb.exportTypedArrayMethod,
        HV = Math.floor;
    jV("reverse", (function() {
        for (var e, t = this, n = GV(t).length, r = HV(n / 2), a = 0; a < r;) e = t[a], t[a++] = t[--n], t[n] = e;
        return t
    }));
    var qV = z,
        KV = j,
        XV = Pb,
        YV = Kr,
        JV = sW,
        ZV = yt,
        QV = B,
        $V = qV.RangeError,
        eG = qV.Int8Array,
        tG = eG && eG.prototype,
        nG = tG && tG.set,
        rG = XV.aTypedArray,
        aG = XV.exportTypedArrayMethod,
        iG = !QV((function() {
            var e = new Uint8ClampedArray(2);
            return KV(nG, e, {
                length: 1,
                0: 3
            }, 1), 3 !== e[1]
        })),
        oG = iG && XV.NATIVE_ARRAY_BUFFER_VIEWS && QV((function() {
            var e = new eG(2);
            return e.set(1), e.set("2", 1), 0 !== e[0] || 2 !== e[1]
        }));
    aG("set", (function(e) {
        rG(this);
        var t = JV(arguments.length > 1 ? arguments[1] : void 0, 1),
            n = ZV(e);
        if (iG) return KV(nG, this, n, t);
        var r = this.length,
            a = YV(n),
            i = 0;
        if (a + t > r) throw $V("Wrong length");
        for (; i < a;) this[t + i] = n[i++]
    }), !iG || oG);
    var sG = qU,
        uG = du,
        cG = Pb.aTypedArray;
    (0, Pb.exportTypedArrayMethod)("slice", (function(e, t) {
        for (var n = uG(cG(this), e, t), r = sG(this), a = 0, i = n.length, o = new r(i); i > a;) o[a] = n[a++];
        return o
    }), B((function() {
        new Int8Array(1).slice()
    })));
    var lG = Wo.some,
        hG = Pb.aTypedArray;
    (0, Pb.exportTypedArrayMethod)("some", (function(e) {
        return lG(hG(this), e, arguments.length > 1 ? arguments[1] : void 0)
    }));
    var pG = ro,
        fG = B,
        dG = Ze,
        vG = nm,
        mG = am,
        gG = im,
        yG = Le,
        bG = sm,
        xG = Pb.aTypedArray,
        kG = Pb.exportTypedArrayMethod,
        wG = z.Uint16Array,
        IG = wG && pG(wG.prototype.sort),
        NG = !(!IG || fG((function() {
            IG(new wG(2), null)
        })) && fG((function() {
            IG(new wG(2), {})
        }))),
        SG = !!IG && !fG((function() {
            if (yG) return yG < 74;
            if (mG) return mG < 67;
            if (gG) return !0;
            if (bG) return bG < 602;
            var e, t, n = new wG(516),
                r = Array(516);
            for (e = 0; e < 516; e++) t = e % 4, n[e] = 515 - e, r[e] = e - 2 * t + 3;
            for (IG(n, (function(e, t) {
                    return (e / 4 | 0) - (t / 4 | 0)
                })), e = 0; e < 516; e++)
                if (n[e] !== r[e]) return !0
        }));
    kG("sort", (function(e) {
        return void 0 !== e && dG(e), SG ? IG(this, e) : vG(xG(this), function(e) {
            return function(t, n) {
                return void 0 !== e ? +e(t, n) || 0 : n != n ? -1 : t != t ? 1 : 0 === t && 0 === n ? 1 / t > 0 && 1 / n < 0 ? 1 : -1 : t > n
            }
        }(e))
    }), !SG || NG);
    var TG = Hr,
        EG = Vr,
        CG = qU,
        AG = Pb.aTypedArray;
    (0, Pb.exportTypedArrayMethod)("subarray", (function(e, t) {
        var n = AG(this),
            r = n.length,
            a = EG(e, r);
        return new(CG(n))(n.buffer, n.byteOffset + a * n.BYTES_PER_ELEMENT, TG((void 0 === t ? r : EG(t, r)) - a))
    }));
    var RG = fu,
        _G = Pb,
        OG = B,
        FG = du,
        DG = z.Int8Array,
        MG = _G.aTypedArray,
        LG = _G.exportTypedArrayMethod,
        zG = [].toLocaleString,
        PG = !!DG && OG((function() {
            zG.call(new DG(1))
        }));
    LG("toLocaleString", (function() {
        return RG(zG, PG ? FG(MG(this)) : MG(this), FG(arguments))
    }), OG((function() {
        return [1, 2].toLocaleString() != new DG([1, 2]).toLocaleString()
    })) || !OG((function() {
        DG.prototype.toLocaleString.call([1, 2])
    })));
    var BG = Xm,
        WG = Pb.aTypedArray,
        UG = Pb.getTypedArrayConstructor;
    (0, Pb.exportTypedArrayMethod)("toReversed", (function() {
        return BG(WG(this), UG(this))
    }));
    var VG = Ze,
        GG = eg,
        jG = Pb.aTypedArray,
        HG = Pb.getTypedArrayConstructor,
        qG = Pb.exportTypedArrayMethod,
        KG = ee(Pb.TypedArrayPrototype.sort);
    qG("toSorted", (function(e) {
        void 0 !== e && VG(e);
        var t = jG(this),
            n = GG(HG(t), t);
        return KG(n, e)
    }));
    var XG = Pb.exportTypedArrayMethod,
        YG = B,
        JG = ee,
        ZG = z.Uint8Array,
        QG = ZG && ZG.prototype || {},
        $G = [].toString,
        ej = JG([].join);
    YG((function() {
        $G.call({})
    })) && ($G = function() {
        return ej(this)
    });
    var tj = QG.toString != $G;
    XG("toString", $G, tj);
    var nj = Cg,
        rj = cW,
        aj = Pr,
        ij = pW,
        oj = Pb.aTypedArray,
        sj = Pb.getTypedArrayConstructor,
        uj = Pb.exportTypedArrayMethod,
        cj = !! function() {
            try {
                new Int8Array(1).with(2, {
                    valueOf: function() {
                        throw 8
                    }
                })
            } catch (e) {
                return 8 === e
            }
        }();
    uj("with", {
        with: function(e, t) {
            var n = oj(this),
                r = aj(e),
                a = rj(n) ? ij(t) : +t;
            return nj(n, sj(n), r, a)
        }
    }.with, !cj);
    var lj = La,
        hj = ee,
        pj = Ya,
        fj = String.fromCharCode,
        dj = hj("".charAt),
        vj = hj(/./.exec),
        mj = hj("".slice),
        gj = /^[\da-f]{2}$/i,
        yj = /^[\da-f]{4}$/i;
    lj({
        global: !0
    }, {
        unescape: function(e) {
            for (var t, n, r = pj(e), a = "", i = r.length, o = 0; o < i;) {
                if ("%" === (t = dj(r, o++)))
                    if ("u" === dj(r, o)) {
                        if (n = mj(r, o + 1, o + 5), vj(yj, n)) {
                            a += fj(parseInt(n, 16)), o += 5;
                            continue
                        }
                    } else if (n = mj(r, o, o + 2), vj(gj, n)) {
                    a += fj(parseInt(n, 16)), o += 2;
                    continue
                }
                a += t
            }
            return a
        }
    });
    var bj = ee,
        xj = Dg,
        kj = Sw.getWeakData,
        wj = zg,
        Ij = dn,
        Nj = le,
        Sj = Ie,
        Tj = yh,
        Ej = kt,
        Cj = cr.set,
        Aj = cr.getterFor,
        Rj = Wo.find,
        _j = Wo.findIndex,
        Oj = bj([].splice),
        Fj = 0,
        Dj = function(e) {
            return e.frozen || (e.frozen = new Mj)
        },
        Mj = function() {
            this.entries = []
        },
        Lj = function(e, t) {
            return Rj(e.entries, (function(e) {
                return e[0] === t
            }))
        };
    Mj.prototype = {
        get: function(e) {
            var t = Lj(this, e);
            if (t) return t[1]
        },
        has: function(e) {
            return !!Lj(this, e)
        },
        set: function(e, t) {
            var n = Lj(this, e);
            n ? n[1] = t : this.entries.push([e, t])
        },
        delete: function(e) {
            var t = _j(this.entries, (function(t) {
                return t[0] === e
            }));
            return ~t && Oj(this.entries, t, 1), !!~t
        }
    };
    var zj, Pj = {
            getConstructor: function(e, t, n, r) {
                var a = e((function(e, a) {
                        wj(e, i), Cj(e, {
                            type: t,
                            id: Fj++,
                            frozen: void 0
                        }), Nj(a) || Tj(a, e[r], {
                            that: e,
                            AS_ENTRIES: n
                        })
                    })),
                    i = a.prototype,
                    o = Aj(t),
                    s = function(e, t, n) {
                        var r = o(e),
                            a = kj(Ij(t), !0);
                        return !0 === a ? Dj(r).set(t, n) : a[r.id] = n, e
                    };
                return xj(i, {
                    delete: function(e) {
                        var t = o(this);
                        if (!Sj(e)) return !1;
                        var n = kj(e);
                        return !0 === n ? Dj(t).delete(e) : n && Ej(n, t.id) && delete n[t.id]
                    },
                    has: function(e) {
                        var t = o(this);
                        if (!Sj(e)) return !1;
                        var n = kj(e);
                        return !0 === n ? Dj(t).has(e) : n && Ej(n, t.id)
                    }
                }), xj(i, n ? {
                    get: function(e) {
                        var t = o(this);
                        if (Sj(e)) {
                            var n = kj(e);
                            return !0 === n ? Dj(t).get(e) : n ? n[t.id] : void 0
                        }
                    },
                    set: function(e, t) {
                        return s(this, e, t)
                    }
                } : {
                    add: function(e) {
                        return s(this, e, !0)
                    }
                }), a
            }
        },
        Bj = cw,
        Wj = z,
        Uj = ee,
        Vj = Dg,
        Gj = Sw,
        jj = Uw,
        Hj = Pj,
        qj = Ie,
        Kj = cr.enforce,
        Xj = B,
        Yj = Hn,
        Jj = Object,
        Zj = Array.isArray,
        Qj = Jj.isExtensible,
        $j = Jj.isFrozen,
        eH = Jj.isSealed,
        tH = Jj.freeze,
        nH = Jj.seal,
        rH = {},
        aH = {},
        iH = !Wj.ActiveXObject && "ActiveXObject" in Wj,
        oH = function(e) {
            return function() {
                return e(this, arguments.length ? arguments[0] : void 0)
            }
        },
        sH = jj("WeakMap", oH, Hj),
        uH = sH.prototype,
        cH = Uj(uH.set);
    if (Yj)
        if (iH) {
            zj = Hj.getConstructor(oH, "WeakMap", !0), Gj.enable();
            var lH = Uj(uH.delete),
                hH = Uj(uH.has),
                pH = Uj(uH.get);
            Vj(uH, {
                delete: function(e) {
                    if (qj(e) && !Qj(e)) {
                        var t = Kj(this);
                        return t.frozen || (t.frozen = new zj), lH(this, e) || t.frozen.delete(e)
                    }
                    return lH(this, e)
                },
                has: function(e) {
                    if (qj(e) && !Qj(e)) {
                        var t = Kj(this);
                        return t.frozen || (t.frozen = new zj), hH(this, e) || t.frozen.has(e)
                    }
                    return hH(this, e)
                },
                get: function(e) {
                    if (qj(e) && !Qj(e)) {
                        var t = Kj(this);
                        return t.frozen || (t.frozen = new zj), hH(this, e) ? pH(this, e) : t.frozen.get(e)
                    }
                    return pH(this, e)
                },
                set: function(e, t) {
                    if (qj(e) && !Qj(e)) {
                        var n = Kj(this);
                        n.frozen || (n.frozen = new zj), hH(this, e) ? cH(this, e, t) : n.frozen.set(e, t)
                    } else cH(this, e, t);
                    return this
                }
            })
        } else Bj && Xj((function() {
            var e = tH([]);
            return cH(new sH, e, 1), !$j(e)
        })) && Vj(uH, {
            set: function(e, t) {
                var n;
                return Zj(e) && ($j(e) ? n = rH : eH(e) && (n = aH)), cH(this, e, t), n == rH && tH(e), n == aH && nH(e), this
            }
        });
    Uw("WeakSet", (function(e) {
        return function() {
            return e(this, arguments.length ? arguments[0] : void 0)
        }
    }), Pj);
    for (var fH = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", dH = {}, vH = 0; vH < 66; vH++) dH[fH.charAt(vH)] = vH;
    var mH = {
            itoc: fH,
            ctoi: dH
        },
        gH = La,
        yH = z,
        bH = Ee,
        xH = ee,
        kH = j,
        wH = B,
        IH = Ya,
        NH = kt,
        SH = TC,
        TH = mH.ctoi,
        EH = /[^\d+/a-z]/i,
        CH = /[\t\n\f\r ]+/g,
        AH = /[=]{1,2}$/,
        RH = bH("atob"),
        _H = String.fromCharCode,
        OH = xH("".charAt),
        FH = xH("".replace),
        DH = xH(EH.exec),
        MH = wH((function() {
            return "" !== RH(" ")
        })),
        LH = !wH((function() {
            RH("a")
        })),
        zH = !MH && !LH && !wH((function() {
            RH()
        })),
        PH = !MH && !LH && 1 !== RH.length;
    gH({
        global: !0,
        bind: !0,
        enumerable: !0,
        forced: MH || LH || zH || PH
    }, {
        atob: function(e) {
            if (SH(arguments.length, 1), zH || PH) return kH(RH, yH, e);
            var t, n, r = FH(IH(e), CH, ""),
                a = "",
                i = 0,
                o = 0;
            if (r.length % 4 == 0 && (r = FH(r, AH, "")), r.length % 4 == 1 || DH(EH, r)) throw new(bH("DOMException"))("The string is not correctly encoded", "InvalidCharacterError");
            for (; t = OH(r, i++);) NH(TH, t) && (n = o % 4 ? 64 * n + TH[t] : TH[t], o++ % 4 && (a += _H(255 & n >> (-2 * o & 6))));
            return a
        }
    });
    var BH = La,
        WH = z,
        UH = Ee,
        VH = ee,
        GH = j,
        jH = B,
        HH = Ya,
        qH = TC,
        KH = mH.itoc,
        XH = UH("btoa"),
        YH = VH("".charAt),
        JH = VH("".charCodeAt),
        ZH = !!XH && !jH((function() {
            XH()
        })),
        QH = !!XH && jH((function() {
            return "bnVsbA==" !== XH(null)
        })),
        $H = !!XH && 1 !== XH.length;
    BH({
        global: !0,
        bind: !0,
        enumerable: !0,
        forced: ZH || QH || $H
    }, {
        btoa: function(e) {
            if (qH(arguments.length, 1), ZH || QH || $H) return GH(XH, WH, HH(e));
            for (var t, n, r = HH(e), a = "", i = 0, o = KH; YH(r, i) || (o = "=", i % 1);) {
                if ((n = JH(r, i += 3 / 4)) > 255) throw new(UH("DOMException"))("The string contains characters outside of the Latin1 range", "InvalidCharacterError");
                a += YH(o, 63 & (t = t << 8 | n) >> 8 - i % 1 * 8)
            }
            return a
        }
    });
    var eq = {
            CSSRuleList: 0,
            CSSStyleDeclaration: 0,
            CSSValueList: 0,
            ClientRectList: 0,
            DOMRectList: 0,
            DOMStringList: 0,
            DOMTokenList: 1,
            DataTransferItemList: 0,
            FileList: 0,
            HTMLAllCollection: 0,
            HTMLCollection: 0,
            HTMLFormElement: 0,
            HTMLSelectElement: 0,
            MediaList: 0,
            MimeTypeArray: 0,
            NamedNodeMap: 0,
            NodeList: 1,
            PaintRequestList: 0,
            Plugin: 0,
            PluginArray: 0,
            SVGLengthList: 0,
            SVGNumberList: 0,
            SVGPathSegList: 0,
            SVGPointList: 0,
            SVGStringList: 0,
            SVGTransformList: 0,
            SourceBufferList: 0,
            StyleSheetList: 0,
            TextTrackCueList: 0,
            TextTrackList: 0,
            TouchList: 0
        },
        tq = Jt("span").classList,
        nq = tq && tq.constructor && tq.constructor.prototype,
        rq = nq === Object.prototype ? void 0 : nq,
        aq = z,
        iq = eq,
        oq = rq,
        sq = kf,
        uq = Cn,
        cq = function(e) {
            if (e && e.forEach !== sq) try {
                uq(e, "forEach", sq)
            } catch (t) {
                e.forEach = sq
            }
        };
    for (var lq in iq) iq[lq] && cq(aq[lq] && aq[lq].prototype);
    cq(oq);
    var hq = z,
        pq = eq,
        fq = rq,
        dq = Kd,
        vq = Cn,
        mq = Mt,
        gq = mq("iterator"),
        yq = mq("toStringTag"),
        bq = dq.values,
        xq = function(e, t) {
            if (e) {
                if (e[gq] !== bq) try {
                    vq(e, gq, bq)
                } catch (t) {
                    e[gq] = bq
                }
                if (e[yq] || vq(e, yq, t), pq[t])
                    for (var n in dq)
                        if (e[n] !== dq[n]) try {
                            vq(e, n, dq[n])
                        } catch (t) {
                            e[n] = dq[n]
                        }
            }
        };
    for (var kq in pq) xq(hq[kq] && hq[kq].prototype, kq);
    xq(fq, "DOMTokenList");
    var wq = Rv,
        Iq = function(e) {
            try {
                if (wq) return Function('return require("' + e + '")')()
            } catch (e) {}
        },
        Nq = {
            IndexSizeError: {
                s: "INDEX_SIZE_ERR",
                c: 1,
                m: 1
            },
            DOMStringSizeError: {
                s: "DOMSTRING_SIZE_ERR",
                c: 2,
                m: 0
            },
            HierarchyRequestError: {
                s: "HIERARCHY_REQUEST_ERR",
                c: 3,
                m: 1
            },
            WrongDocumentError: {
                s: "WRONG_DOCUMENT_ERR",
                c: 4,
                m: 1
            },
            InvalidCharacterError: {
                s: "INVALID_CHARACTER_ERR",
                c: 5,
                m: 1
            },
            NoDataAllowedError: {
                s: "NO_DATA_ALLOWED_ERR",
                c: 6,
                m: 0
            },
            NoModificationAllowedError: {
                s: "NO_MODIFICATION_ALLOWED_ERR",
                c: 7,
                m: 1
            },
            NotFoundError: {
                s: "NOT_FOUND_ERR",
                c: 8,
                m: 1
            },
            NotSupportedError: {
                s: "NOT_SUPPORTED_ERR",
                c: 9,
                m: 1
            },
            InUseAttributeError: {
                s: "INUSE_ATTRIBUTE_ERR",
                c: 10,
                m: 1
            },
            InvalidStateError: {
                s: "INVALID_STATE_ERR",
                c: 11,
                m: 1
            },
            SyntaxError: {
                s: "SYNTAX_ERR",
                c: 12,
                m: 1
            },
            InvalidModificationError: {
                s: "INVALID_MODIFICATION_ERR",
                c: 13,
                m: 1
            },
            NamespaceError: {
                s: "NAMESPACE_ERR",
                c: 14,
                m: 1
            },
            InvalidAccessError: {
                s: "INVALID_ACCESS_ERR",
                c: 15,
                m: 1
            },
            ValidationError: {
                s: "VALIDATION_ERR",
                c: 16,
                m: 0
            },
            TypeMismatchError: {
                s: "TYPE_MISMATCH_ERR",
                c: 17,
                m: 1
            },
            SecurityError: {
                s: "SECURITY_ERR",
                c: 18,
                m: 1
            },
            NetworkError: {
                s: "NETWORK_ERR",
                c: 19,
                m: 1
            },
            AbortError: {
                s: "ABORT_ERR",
                c: 20,
                m: 1
            },
            URLMismatchError: {
                s: "URL_MISMATCH_ERR",
                c: 21,
                m: 1
            },
            QuotaExceededError: {
                s: "QUOTA_EXCEEDED_ERR",
                c: 22,
                m: 1
            },
            TimeoutError: {
                s: "TIMEOUT_ERR",
                c: 23,
                m: 1
            },
            InvalidNodeTypeError: {
                s: "INVALID_NODE_TYPE_ERR",
                c: 24,
                m: 1
            },
            DataCloneError: {
                s: "DATA_CLONE_ERR",
                c: 25,
                m: 1
            }
        },
        Sq = La,
        Tq = Iq,
        Eq = Ee,
        Cq = B,
        Aq = yi,
        Rq = Y,
        _q = cn.f,
        Oq = Or,
        Fq = zi,
        Dq = kt,
        Mq = zg,
        Lq = dn,
        zq = Nl,
        Pq = Dc,
        Bq = Nq,
        Wq = Gc,
        Uq = cr,
        Vq = W,
        Gq = "DOMException",
        jq = "DATA_CLONE_ERR",
        Hq = Eq("Error"),
        qq = Eq(Gq) || function() {
            try {
                (new(Eq("MessageChannel") || Tq("worker_threads").MessageChannel)).port1.postMessage(new WeakMap)
            } catch (e) {
                if (e.name == jq && 25 == e.code) return e.constructor
            }
        }(),
        Kq = qq && qq.prototype,
        Xq = Hq.prototype,
        Yq = Uq.set,
        Jq = Uq.getterFor(Gq),
        Zq = "stack" in Hq(Gq),
        Qq = function(e) {
            return Dq(Bq, e) && Bq[e].m ? Bq[e].c : 0
        },
        $q = function() {
            Mq(this, eK);
            var e = arguments.length,
                t = Pq(e < 1 ? void 0 : arguments[0]),
                n = Pq(e < 2 ? void 0 : arguments[1], "Error"),
                r = Qq(n);
            if (Yq(this, {
                    type: Gq,
                    name: n,
                    message: t,
                    code: r
                }), Vq || (this.name = n, this.message = t, this.code = r), Zq) {
                var a = Hq(t);
                a.name = Gq, _q(this, "stack", Rq(1, Wq(a.stack, 1)))
            }
        },
        eK = $q.prototype = Aq(Xq),
        tK = function(e) {
            return {
                enumerable: !0,
                configurable: !0,
                get: e
            }
        },
        nK = function(e) {
            return tK((function() {
                return Jq(this)[e]
            }))
        };
    Vq && (Fq(eK, "code", nK("code")), Fq(eK, "message", nK("message")), Fq(eK, "name", nK("name"))), _q(eK, "constructor", Rq(1, $q));
    var rK = Cq((function() {
            return !(new qq instanceof Hq)
        })),
        aK = rK || Cq((function() {
            return Xq.toString !== zq || "2: 1" !== String(new qq(1, 2))
        })),
        iK = rK || Cq((function() {
            return 25 !== new qq(1, "DataCloneError").code
        }));
    rK || 25 !== qq.DATA_CLONE_ERR || Kq.DATA_CLONE_ERR;
    Sq({
        global: !0,
        constructor: !0,
        forced: rK
    }, {
        DOMException: rK ? $q : qq
    });
    var oK = Eq(Gq),
        sK = oK.prototype;
    for (var uK in aK && qq === oK && Oq(sK, "toString", zq), iK && Vq && qq === oK && Fq(sK, "code", tK((function() {
            return Qq(Lq(this).name)
        }))), Bq)
        if (Dq(Bq, uK)) {
            var cK = Bq[uK],
                lK = cK.s,
                hK = Rq(6, cK.c);
            Dq(oK, lK) || _q(oK, lK, hK), Dq(sK, lK) || _q(sK, lK, hK)
        }
    var pK = La,
        fK = z,
        dK = Ee,
        vK = Y,
        mK = cn.f,
        gK = kt,
        yK = zg,
        bK = Oc,
        xK = Dc,
        kK = Nq,
        wK = Gc,
        IK = W,
        NK = "DOMException",
        SK = dK("Error"),
        TK = dK(NK),
        EK = function() {
            yK(this, CK);
            var e = arguments.length,
                t = xK(e < 1 ? void 0 : arguments[0]),
                n = xK(e < 2 ? void 0 : arguments[1], "Error"),
                r = new TK(t, n),
                a = SK(t);
            return a.name = NK, mK(r, "stack", vK(1, wK(a.stack, 1))), bK(r, this, EK), r
        },
        CK = EK.prototype = TK.prototype,
        AK = "stack" in SK(NK),
        RK = "stack" in new TK(1, 2),
        _K = TK && IK && Object.getOwnPropertyDescriptor(fK, NK),
        OK = !(!_K || _K.writable && _K.configurable),
        FK = AK && !OK && !RK;
    pK({
        global: !0,
        constructor: !0,
        forced: FK
    }, {
        DOMException: FK ? EK : TK
    });
    var DK = dK(NK),
        MK = DK.prototype;
    if (MK.constructor !== DK)
        for (var LK in mK(MK, "constructor", vK(1, DK)), kK)
            if (gK(kK, LK)) {
                var zK = kK[LK],
                    PK = zK.s;
                gK(DK, PK) || mK(DK, PK, vK(6, zK.c))
            }
    var BK = "DOMException";
    eo(Ee(BK), BK);
    var WK = eA.clear;
    La({
        global: !0,
        bind: !0,
        enumerable: !0,
        forced: z.clearImmediate !== WK
    }, {
        clearImmediate: WK
    });
    var UK = "function" == typeof Bun && Bun && "string" == typeof Bun.version,
        VK = z,
        GK = fu,
        jK = xe,
        HK = UK,
        qK = Ae,
        KK = du,
        XK = TC,
        YK = VK.Function,
        JK = /MSIE .\./.test(qK) || HK && function() {
            var e = VK.Bun.version.split(".");
            return e.length < 3 || 0 == e[0] && (e[1] < 3 || 3 == e[1] && 0 == e[2])
        }(),
        ZK = function(e, t) {
            var n = t ? 2 : 1;
            return JK ? function(r, a) {
                var i = XK(arguments.length, 1) > n,
                    o = jK(r) ? r : YK(r),
                    s = i ? KK(arguments, n) : [],
                    u = i ? function() {
                        GK(o, this, s)
                    } : o;
                return t ? e(u, a) : e(u)
            } : e
        },
        QK = La,
        $K = z,
        eX = eA.set,
        tX = ZK,
        nX = $K.setImmediate ? tX(eX, !1) : eX;
    QK({
        global: !0,
        bind: !0,
        enumerable: !0,
        forced: $K.setImmediate !== nX
    }, {
        setImmediate: nX
    });
    var rX = La,
        aX = RA,
        iX = Ze,
        oX = TC,
        sX = Rv,
        uX = z.process;
    rX({
        global: !0,
        enumerable: !0,
        dontCallGetSet: !0
    }, {
        queueMicrotask: function(e) {
            oX(arguments.length, 1), iX(e);
            var t = sX && uX.domain;
            aX(t ? t.bind(e) : e)
        }
    });
    var cX = La,
        lX = z,
        hX = zi,
        pX = W,
        fX = TypeError,
        dX = Object.defineProperty,
        vX = lX.self !== lX;
    try {
        if (pX) {
            var mX = Object.getOwnPropertyDescriptor(lX, "self");
            !vX && mX && mX.get && mX.enumerable || hX(lX, "self", {
                get: function() {
                    return lX
                },
                set: function(e) {
                    if (this !== lX) throw fX("Illegal invocation");
                    dX(lX, "self", {
                        value: e,
                        writable: !0,
                        configurable: !0,
                        enumerable: !0
                    })
                },
                configurable: !0,
                enumerable: !0
            })
        } else cX({
            global: !0,
            simple: !0,
            forced: vX
        }, {
            self: lX
        })
    } catch (e) {}
    var gX, yX = ee,
        bX = Map.prototype,
        xX = {
            Map: Map,
            set: yX(bX.set),
            get: yX(bX.get),
            has: yX(bX.has),
            remove: yX(bX.delete),
            proto: bX
        },
        kX = ee,
        wX = Set.prototype,
        IX = {
            Set: Set,
            add: kX(wX.add),
            has: kX(wX.has),
            remove: kX(wX.delete),
            proto: wX,
            $has: wX.has,
            $keys: wX.keys
        },
        NX = B,
        SX = Le,
        TX = MA,
        EX = DA,
        CX = Rv,
        AX = z.structuredClone,
        RX = !!AX && !NX((function() {
            if (EX && SX > 92 || CX && SX > 94 || TX && SX > 97) return !1;
            var e = new ArrayBuffer(8),
                t = AX(e, {
                    transfer: [e]
                });
            return 0 != e.byteLength || 8 != t.byteLength
        })),
        _X = La,
        OX = z,
        FX = Ee,
        DX = ee,
        MX = B,
        LX = Tt,
        zX = xe,
        PX = No,
        BX = le,
        WX = Ie,
        UX = He,
        VX = yh,
        GX = dn,
        jX = qa,
        HX = kt,
        qX = Ii,
        KX = Cn,
        XX = Kr,
        YX = TC,
        JX = nF,
        ZX = xX,
        QX = IX,
        $X = Hc,
        eY = RX,
        tY = OX.Object,
        nY = OX.Array,
        rY = OX.Date,
        aY = OX.Error,
        iY = OX.EvalError,
        oY = OX.RangeError,
        sY = OX.ReferenceError,
        uY = OX.SyntaxError,
        cY = OX.TypeError,
        lY = OX.URIError,
        hY = OX.PerformanceMark,
        pY = OX.WebAssembly,
        fY = pY && pY.CompileError || aY,
        dY = pY && pY.LinkError || aY,
        vY = pY && pY.RuntimeError || aY,
        mY = FX("DOMException"),
        gY = ZX.Map,
        yY = ZX.has,
        bY = ZX.get,
        xY = ZX.set,
        kY = QX.Set,
        wY = QX.add,
        IY = FX("Object", "keys"),
        NY = DX([].push),
        SY = DX((!0).valueOf),
        TY = DX(1..valueOf),
        EY = DX("".valueOf),
        CY = DX(rY.prototype.getTime),
        AY = LX("structuredClone"),
        RY = "DataCloneError",
        _Y = "Transferring",
        OY = function(e) {
            return !MX((function() {
                var t = new OX.Set([7]),
                    n = e(t),
                    r = e(tY(7));
                return n == t || !n.has(7) || "object" != s(r) || 7 != r
            })) && e
        },
        FY = function(e, t) {
            return !MX((function() {
                var n = new t,
                    r = e({
                        a: n,
                        b: n
                    });
                return !(r && r.a === r.b && r.a instanceof t && r.a.stack === n.stack)
            }))
        },
        DY = OX.structuredClone,
        MY = !FY(DY, aY) || !FY(DY, mY) || (gX = DY, !!MX((function() {
            var e = gX(new OX.AggregateError([1], AY, {
                cause: 3
            }));
            return "AggregateError" != e.name || 1 != e.errors[0] || e.message != AY || 3 != e.cause
        }))),
        LY = !DY && OY((function(e) {
            return new hY(AY, {
                detail: e
            }).detail
        })),
        zY = OY(DY) || LY,
        PY = function(e) {
            throw new mY("Uncloneable type: " + e, RY)
        },
        BY = function(e, t) {
            throw new mY((t || "Cloning") + " of " + e + " cannot be properly polyfilled in this engine", RY)
        },
        WY = function e(t, n) {
            if (UX(t) && PY("Symbol"), !WX(t)) return t;
            if (n) {
                if (yY(n, t)) return bY(n, t)
            } else n = new gY;
            var r, a, i, o, s, u, c, l, h, p, f, d = jX(t),
                v = !1;
            switch (d) {
                case "Array":
                    i = nY(XX(t)), v = !0;
                    break;
                case "Object":
                    i = {}, v = !0;
                    break;
                case "Map":
                    i = new gY, v = !0;
                    break;
                case "Set":
                    i = new kY, v = !0;
                    break;
                case "RegExp":
                    i = new RegExp(t.source, JX(t));
                    break;
                case "Error":
                    switch (a = t.name) {
                        case "AggregateError":
                            i = FX("AggregateError")([]);
                            break;
                        case "EvalError":
                            i = iY();
                            break;
                        case "RangeError":
                            i = oY();
                            break;
                        case "ReferenceError":
                            i = sY();
                            break;
                        case "SyntaxError":
                            i = uY();
                            break;
                        case "TypeError":
                            i = cY();
                            break;
                        case "URIError":
                            i = lY();
                            break;
                        case "CompileError":
                            i = fY();
                            break;
                        case "LinkError":
                            i = dY();
                            break;
                        case "RuntimeError":
                            i = vY();
                            break;
                        default:
                            i = aY()
                    }
                    v = !0;
                    break;
                case "DOMException":
                    i = new mY(t.message, t.name), v = !0;
                    break;
                case "DataView":
                case "Int8Array":
                case "Uint8Array":
                case "Uint8ClampedArray":
                case "Int16Array":
                case "Uint16Array":
                case "Int32Array":
                case "Uint32Array":
                case "Float32Array":
                case "Float64Array":
                case "BigInt64Array":
                case "BigUint64Array":
                    r = OX[d], WX(r) || BY(d), i = new r(e(t.buffer, n), t.byteOffset, "DataView" === d ? t.byteLength : t.length);
                    break;
                case "DOMQuad":
                    try {
                        i = new DOMQuad(e(t.p1, n), e(t.p2, n), e(t.p3, n), e(t.p4, n))
                    } catch (e) {
                        zY ? i = zY(t) : BY(d)
                    }
                    break;
                case "FileList":
                    if (o = function() {
                            var e;
                            try {
                                e = new OX.DataTransfer
                            } catch (t) {
                                try {
                                    e = new OX.ClipboardEvent("").clipboardData
                                } catch (e) {}
                            }
                            return e && e.items && e.files ? e : null
                        }()) {
                        for (s = 0, u = XX(t); s < u; s++) o.items.add(e(t[s], n));
                        i = o.files
                    } else zY ? i = zY(t) : BY(d);
                    break;
                case "ImageData":
                    try {
                        i = new ImageData(e(t.data, n), t.width, t.height, {
                            colorSpace: t.colorSpace
                        })
                    } catch (e) {
                        zY ? i = zY(t) : BY(d)
                    }
                    break;
                default:
                    if (zY) i = zY(t);
                    else switch (d) {
                        case "BigInt":
                            i = tY(t.valueOf());
                            break;
                        case "Boolean":
                            i = tY(SY(t));
                            break;
                        case "Number":
                            i = tY(TY(t));
                            break;
                        case "String":
                            i = tY(EY(t));
                            break;
                        case "Date":
                            i = new rY(CY(t));
                            break;
                        case "ArrayBuffer":
                            (r = OX.DataView) || "function" == typeof t.slice || BY(d);
                            try {
                                if ("function" != typeof t.slice || t.resizable) {
                                    u = t.byteLength, f = "maxByteLength" in t ? {
                                        maxByteLength: t.maxByteLength
                                    } : void 0, i = new ArrayBuffer(u, f), h = new r(t), p = new r(i);
                                    for (s = 0; s < u; s++) p.setUint8(s, h.getUint8(s))
                                } else i = t.slice(0)
                            } catch (e) {
                                throw new mY("ArrayBuffer is detached", RY)
                            }
                            break;
                        case "SharedArrayBuffer":
                            i = t;
                            break;
                        case "Blob":
                            try {
                                i = t.slice(0, t.size, t.type)
                            } catch (e) {
                                BY(d)
                            }
                            break;
                        case "DOMPoint":
                        case "DOMPointReadOnly":
                            r = OX[d];
                            try {
                                i = r.fromPoint ? r.fromPoint(t) : new r(t.x, t.y, t.z, t.w)
                            } catch (e) {
                                BY(d)
                            }
                            break;
                        case "DOMRect":
                        case "DOMRectReadOnly":
                            r = OX[d];
                            try {
                                i = r.fromRect ? r.fromRect(t) : new r(t.x, t.y, t.width, t.height)
                            } catch (e) {
                                BY(d)
                            }
                            break;
                        case "DOMMatrix":
                        case "DOMMatrixReadOnly":
                            r = OX[d];
                            try {
                                i = r.fromMatrix ? r.fromMatrix(t) : new r(t)
                            } catch (e) {
                                BY(d)
                            }
                            break;
                        case "AudioData":
                        case "VideoFrame":
                            zX(t.clone) || BY(d);
                            try {
                                i = t.clone()
                            } catch (e) {
                                PY(d)
                            }
                            break;
                        case "File":
                            try {
                                i = new File([t], t.name, t)
                            } catch (e) {
                                BY(d)
                            }
                            break;
                        case "CropTarget":
                        case "CryptoKey":
                        case "FileSystemDirectoryHandle":
                        case "FileSystemFileHandle":
                        case "FileSystemHandle":
                        case "GPUCompilationInfo":
                        case "GPUCompilationMessage":
                        case "ImageBitmap":
                        case "RTCCertificate":
                        case "WebAssembly.Module":
                            BY(d);
                        default:
                            PY(d)
                    }
            }
            if (xY(n, t, i), v) switch (d) {
                case "Array":
                case "Object":
                    for (c = IY(t), s = 0, u = XX(c); s < u; s++) l = c[s], qX(i, l, e(t[l], n));
                    break;
                case "Map":
                    t.forEach((function(t, r) {
                        xY(i, e(r, n), e(t, n))
                    }));
                    break;
                case "Set":
                    t.forEach((function(t) {
                        wY(i, e(t, n))
                    }));
                    break;
                case "Error":
                    KX(i, "message", e(t.message, n)), HX(t, "cause") && KX(i, "cause", e(t.cause, n)), "AggregateError" == a && (i.errors = e(t.errors, n));
                case "DOMException":
                    $X && KX(i, "stack", e(t.stack, n))
            }
            return i
        },
        UY = function(e, t) {
            if (!WX(e)) throw cY("Transfer option cannot be converted to a sequence");
            var n = [];
            VX(e, (function(e) {
                NY(n, GX(e))
            }));
            var r, a, i, o, s, u, c = 0,
                l = XX(n);
            if (eY)
                for (o = DY(n, {
                        transfer: n
                    }); c < l;) xY(t, n[c], o[c++]);
            else
                for (; c < l;) {
                    if (r = n[c++], yY(t, r)) throw new mY("Duplicate transferable", RY);
                    switch (a = jX(r)) {
                        case "ImageBitmap":
                            i = OX.OffscreenCanvas, PX(i) || BY(a, _Y);
                            try {
                                (u = new i(r.width, r.height)).getContext("bitmaprenderer").transferFromImageBitmap(r), s = u.transferToImageBitmap()
                            } catch (e) {}
                            break;
                        case "AudioData":
                        case "VideoFrame":
                            zX(r.clone) && zX(r.close) || BY(a, _Y);
                            try {
                                s = r.clone(), r.close()
                            } catch (e) {}
                            break;
                        case "ArrayBuffer":
                            zX(r.transfer) || BY(a, _Y), s = r.transfer();
                            break;
                        case "MediaSourceHandle":
                        case "MessagePort":
                        case "OffscreenCanvas":
                        case "ReadableStream":
                        case "TransformStream":
                        case "WritableStream":
                            BY(a, _Y)
                    }
                    if (void 0 === s) throw new mY("This object cannot be transferred: " + a, RY);
                    xY(t, r, s)
                }
        };
    _X({
        global: !0,
        enumerable: !0,
        sham: !eY,
        forced: MY
    }, {
        structuredClone: function(e) {
            var t, n = YX(arguments.length, 1) > 1 && !BX(arguments[1]) ? GX(arguments[1]) : void 0,
                r = n ? n.transfer : void 0;
            return void 0 !== r && (t = new gY, UY(r, t)), WY(e, t)
        }
    });
    var VY = La,
        GY = z,
        jY = ZK(GY.setInterval, !0);
    VY({
        global: !0,
        bind: !0,
        forced: GY.setInterval !== jY
    }, {
        setInterval: jY
    });
    var HY = La,
        qY = z,
        KY = ZK(qY.setTimeout, !0);
    HY({
        global: !0,
        bind: !0,
        forced: qY.setTimeout !== KY
    }, {
        setTimeout: KY
    });
    var XY = B,
        YY = W,
        JY = Mt("iterator"),
        ZY = !XY((function() {
            var e = new URL("b?a=1&b=2&c=3", "http://a"),
                t = e.searchParams,
                n = "";
            return e.pathname = "c%20d", t.forEach((function(e, r) {
                t.delete("b"), n += r + e
            })), !t.size && !YY || !t.sort || "http://a/c%20d?a=1&c=3" !== e.href || "3" !== t.get("c") || "a=1" !== String(new URLSearchParams("?a=1")) || !t[JY] || "a" !== new URL("https://a@b").username || "b" !== new URLSearchParams(new URLSearchParams("a=b")).get("a") || "xn--e1aybc" !== new URL("http://ÑÐµÑÑ").host || "#%D0%B1" !== new URL("http://a#Ð±").hash || "a1c3" !== n || "x" !== new URL("http://x", void 0).host
        })),
        QY = ee,
        $Y = 2147483647,
        eJ = /[^\0-\u007E]/,
        tJ = /[.\u3002\uFF0E\uFF61]/g,
        nJ = "Overflow: input needs wider integers to process",
        rJ = RangeError,
        aJ = QY(tJ.exec),
        iJ = Math.floor,
        oJ = String.fromCharCode,
        sJ = QY("".charCodeAt),
        uJ = QY([].join),
        cJ = QY([].push),
        lJ = QY("".replace),
        hJ = QY("".split),
        pJ = QY("".toLowerCase),
        fJ = function(e) {
            return e + 22 + 75 * (e < 26)
        },
        dJ = function(e, t, n) {
            var r = 0;
            for (e = n ? iJ(e / 700) : e >> 1, e += iJ(e / t); e > 455;) e = iJ(e / 35), r += 36;
            return iJ(r + 36 * e / (e + 38))
        },
        vJ = function(e) {
            var t = [];
            e = function(e) {
                for (var t = [], n = 0, r = e.length; n < r;) {
                    var a = sJ(e, n++);
                    if (a >= 55296 && a <= 56319 && n < r) {
                        var i = sJ(e, n++);
                        56320 == (64512 & i) ? cJ(t, ((1023 & a) << 10) + (1023 & i) + 65536) : (cJ(t, a), n--)
                    } else cJ(t, a)
                }
                return t
            }(e);
            var n, r, a = e.length,
                i = 128,
                o = 0,
                s = 72;
            for (n = 0; n < e.length; n++)(r = e[n]) < 128 && cJ(t, oJ(r));
            var u = t.length,
                c = u;
            for (u && cJ(t, "-"); c < a;) {
                var l = $Y;
                for (n = 0; n < e.length; n++)(r = e[n]) >= i && r < l && (l = r);
                var h = c + 1;
                if (l - i > iJ(($Y - o) / h)) throw rJ(nJ);
                for (o += (l - i) * h, i = l, n = 0; n < e.length; n++) {
                    if ((r = e[n]) < i && ++o > $Y) throw rJ(nJ);
                    if (r == i) {
                        for (var p = o, f = 36;;) {
                            var d = f <= s ? 1 : f >= s + 26 ? 26 : f - s;
                            if (p < d) break;
                            var v = p - d,
                                m = 36 - d;
                            cJ(t, oJ(fJ(d + v % m))), p = iJ(v / m), f += 36
                        }
                        cJ(t, oJ(fJ(p))), s = dJ(o, h, c == u), o = 0, c++
                    }
                }
                o++, i++
            }
            return uJ(t, "")
        },
        mJ = function(e) {
            var t, n, r = [],
                a = hJ(lJ(pJ(e), tJ, "."), ".");
            for (t = 0; t < a.length; t++) n = a[t], cJ(r, aJ(eJ, n) ? "xn--" + vJ(n) : n);
            return uJ(r, ".")
        },
        gJ = La,
        yJ = z,
        bJ = j,
        xJ = ee,
        kJ = W,
        wJ = ZY,
        IJ = Or,
        NJ = zi,
        SJ = Dg,
        TJ = eo,
        EJ = dd,
        CJ = cr,
        AJ = zg,
        RJ = xe,
        _J = kt,
        OJ = so,
        FJ = qa,
        DJ = dn,
        MJ = Ie,
        LJ = Ya,
        zJ = yi,
        PJ = Y,
        BJ = eh,
        WJ = Kl,
        UJ = TC,
        VJ = nm,
        GJ = Mt("iterator"),
        jJ = "URLSearchParams",
        HJ = "URLSearchParamsIterator",
        qJ = CJ.set,
        KJ = CJ.getterFor(jJ),
        XJ = CJ.getterFor(HJ),
        YJ = Object.getOwnPropertyDescriptor,
        JJ = function(e) {
            if (!kJ) return yJ[e];
            var t = YJ(yJ, e);
            return t && t.value
        },
        ZJ = JJ("fetch"),
        QJ = JJ("Request"),
        $J = JJ("Headers"),
        eZ = QJ && QJ.prototype,
        tZ = $J && $J.prototype,
        nZ = yJ.RegExp,
        rZ = yJ.TypeError,
        aZ = yJ.decodeURIComponent,
        iZ = yJ.encodeURIComponent,
        oZ = xJ("".charAt),
        sZ = xJ([].join),
        uZ = xJ([].push),
        cZ = xJ("".replace),
        lZ = xJ([].shift),
        hZ = xJ([].splice),
        pZ = xJ("".split),
        fZ = xJ("".slice),
        dZ = /\+/g,
        vZ = Array(4),
        mZ = function(e) {
            return vZ[e - 1] || (vZ[e - 1] = nZ("((?:%[\\da-f]{2}){" + e + "})", "gi"))
        },
        gZ = function(e) {
            try {
                return aZ(e)
            } catch (t) {
                return e
            }
        },
        yZ = function(e) {
            var t = cZ(e, dZ, " "),
                n = 4;
            try {
                return aZ(t)
            } catch (e) {
                for (; n;) t = cZ(t, mZ(n--), gZ);
                return t
            }
        },
        bZ = /[!'()~]|%20/g,
        xZ = {
            "!": "%21",
            "'": "%27",
            "(": "%28",
            ")": "%29",
            "~": "%7E",
            "%20": "+"
        },
        kZ = function(e) {
            return xZ[e]
        },
        wZ = function(e) {
            return cZ(iZ(e), bZ, kZ)
        },
        IZ = EJ((function(e, t) {
            qJ(this, {
                type: HJ,
                iterator: BJ(KJ(e).entries),
                kind: t
            })
        }), "Iterator", (function() {
            var e = XJ(this),
                t = e.kind,
                n = e.iterator.next(),
                r = n.value;
            return n.done || (n.value = "keys" === t ? r.key : "values" === t ? r.value : [r.key, r.value]), n
        }), !0),
        NZ = function(e) {
            this.entries = [], this.url = null, void 0 !== e && (MJ(e) ? this.parseObject(e) : this.parseQuery("string" == typeof e ? "?" === oZ(e, 0) ? fZ(e, 1) : e : LJ(e)))
        };
    NZ.prototype = {
        type: jJ,
        bindURL: function(e) {
            this.url = e, this.update()
        },
        parseObject: function(e) {
            var t, n, r, a, i, o, s, u = WJ(e);
            if (u)
                for (n = (t = BJ(e, u)).next; !(r = bJ(n, t)).done;) {
                    if (i = (a = BJ(DJ(r.value))).next, (o = bJ(i, a)).done || (s = bJ(i, a)).done || !bJ(i, a).done) throw rZ("Expected sequence with length 2");
                    uZ(this.entries, {
                        key: LJ(o.value),
                        value: LJ(s.value)
                    })
                } else
                    for (var c in e) _J(e, c) && uZ(this.entries, {
                        key: c,
                        value: LJ(e[c])
                    })
        },
        parseQuery: function(e) {
            if (e)
                for (var t, n, r = pZ(e, "&"), a = 0; a < r.length;)(t = r[a++]).length && (n = pZ(t, "="), uZ(this.entries, {
                    key: yZ(lZ(n)),
                    value: yZ(sZ(n, "="))
                }))
        },
        serialize: function() {
            for (var e, t = this.entries, n = [], r = 0; r < t.length;) e = t[r++], uZ(n, wZ(e.key) + "=" + wZ(e.value));
            return sZ(n, "&")
        },
        update: function() {
            this.entries.length = 0, this.parseQuery(this.url.query)
        },
        updateURL: function() {
            this.url && this.url.update()
        }
    };
    var SZ = function() {
            AJ(this, TZ);
            var e = arguments.length > 0 ? arguments[0] : void 0,
                t = qJ(this, new NZ(e));
            kJ || (this.length = t.entries.length)
        },
        TZ = SZ.prototype;
    if (SJ(TZ, {
            append: function(e, t) {
                UJ(arguments.length, 2);
                var n = KJ(this);
                uZ(n.entries, {
                    key: LJ(e),
                    value: LJ(t)
                }), kJ || this.length++, n.updateURL()
            },
            delete: function(e) {
                UJ(arguments.length, 1);
                for (var t = KJ(this), n = t.entries, r = LJ(e), a = 0; a < n.length;) n[a].key === r ? hZ(n, a, 1) : a++;
                kJ || (this.length = n.length), t.updateURL()
            },
            get: function(e) {
                UJ(arguments.length, 1);
                for (var t = KJ(this).entries, n = LJ(e), r = 0; r < t.length; r++)
                    if (t[r].key === n) return t[r].value;
                return null
            },
            getAll: function(e) {
                UJ(arguments.length, 1);
                for (var t = KJ(this).entries, n = LJ(e), r = [], a = 0; a < t.length; a++) t[a].key === n && uZ(r, t[a].value);
                return r
            },
            has: function(e) {
                UJ(arguments.length, 1);
                for (var t = KJ(this).entries, n = LJ(e), r = 0; r < t.length;)
                    if (t[r++].key === n) return !0;
                return !1
            },
            set: function(e, t) {
                UJ(arguments.length, 1);
                for (var n, r = KJ(this), a = r.entries, i = !1, o = LJ(e), s = LJ(t), u = 0; u < a.length; u++)(n = a[u]).key === o && (i ? hZ(a, u--, 1) : (i = !0, n.value = s));
                i || uZ(a, {
                    key: o,
                    value: s
                }), kJ || (this.length = a.length), r.updateURL()
            },
            sort: function() {
                var e = KJ(this);
                VJ(e.entries, (function(e, t) {
                    return e.key > t.key ? 1 : -1
                })), e.updateURL()
            },
            forEach: function(e) {
                for (var t, n = KJ(this).entries, r = OJ(e, arguments.length > 1 ? arguments[1] : void 0), a = 0; a < n.length;) r((t = n[a++]).value, t.key, this)
            },
            keys: function() {
                return new IZ(this, "keys")
            },
            values: function() {
                return new IZ(this, "values")
            },
            entries: function() {
                return new IZ(this, "entries")
            }
        }, {
            enumerable: !0
        }), IJ(TZ, GJ, TZ.entries, {
            name: "entries"
        }), IJ(TZ, "toString", (function() {
            return KJ(this).serialize()
        }), {
            enumerable: !0
        }), kJ && NJ(TZ, "size", {
            get: function() {
                return KJ(this).entries.length
            },
            configurable: !0,
            enumerable: !0
        }), TJ(SZ, jJ), gJ({
            global: !0,
            constructor: !0,
            forced: !wJ
        }, {
            URLSearchParams: SZ
        }), !wJ && RJ($J)) {
        var EZ = xJ(tZ.has),
            CZ = xJ(tZ.set),
            AZ = function(e) {
                if (MJ(e)) {
                    var t, n = e.body;
                    if (FJ(n) === jJ) return t = e.headers ? new $J(e.headers) : new $J, EZ(t, "content-type") || CZ(t, "content-type", "application/x-www-form-urlencoded;charset=UTF-8"), zJ(e, {
                        body: PJ(0, LJ(n)),
                        headers: PJ(0, t)
                    })
                }
                return e
            };
        if (RJ(ZJ) && gJ({
                global: !0,
                enumerable: !0,
                dontCallGetSet: !0,
                forced: !0
            }, {
                fetch: function(e) {
                    return ZJ(e, arguments.length > 1 ? AZ(arguments[1]) : {})
                }
            }), RJ(QJ)) {
            var RZ = function(e) {
                return AJ(this, eZ), new QJ(e, arguments.length > 1 ? AZ(arguments[1]) : {})
            };
            eZ.constructor = RZ, RZ.prototype = eZ, gJ({
                global: !0,
                constructor: !0,
                dontCallGetSet: !0,
                forced: !0
            }, {
                Request: RZ
            })
        }
    }
    var _Z, OZ = {
            URLSearchParams: SZ,
            getState: KJ
        },
        FZ = La,
        DZ = W,
        MZ = ZY,
        LZ = z,
        zZ = so,
        PZ = ee,
        BZ = Or,
        WZ = zi,
        UZ = zg,
        VZ = kt,
        GZ = ST,
        jZ = Lf,
        HZ = Ai,
        qZ = xM.codeAt,
        KZ = mJ,
        XZ = Ya,
        YZ = eo,
        JZ = TC,
        ZZ = OZ,
        QZ = cr,
        $Z = QZ.set,
        eQ = QZ.getterFor("URL"),
        tQ = ZZ.URLSearchParams,
        nQ = ZZ.getState,
        rQ = LZ.URL,
        aQ = LZ.TypeError,
        iQ = LZ.parseInt,
        oQ = Math.floor,
        sQ = Math.pow,
        uQ = PZ("".charAt),
        cQ = PZ(/./.exec),
        lQ = PZ([].join),
        hQ = PZ(1..toString),
        pQ = PZ([].pop),
        fQ = PZ([].push),
        dQ = PZ("".replace),
        vQ = PZ([].shift),
        mQ = PZ("".split),
        gQ = PZ("".slice),
        yQ = PZ("".toLowerCase),
        bQ = PZ([].unshift),
        xQ = "Invalid scheme",
        kQ = "Invalid host",
        wQ = "Invalid port",
        IQ = /[a-z]/i,
        NQ = /[\d+-.a-z]/i,
        SQ = /\d/,
        TQ = /^0x/i,
        EQ = /^[0-7]+$/,
        CQ = /^\d+$/,
        AQ = /^[\da-f]+$/i,
        RQ = /[\0\t\n\r #%/:<>?@[\\\]^|]/,
        _Q = /[\0\t\n\r #/:<>?@[\\\]^|]/,
        OQ = /^[\u0000-\u0020]+/,
        FQ = /(^|[^\u0000-\u0020])[\u0000-\u0020]+$/,
        DQ = /[\t\n\r]/g,
        MQ = function(e) {
            var t, n, r, a;
            if ("number" == typeof e) {
                for (t = [], n = 0; n < 4; n++) bQ(t, e % 256), e = oQ(e / 256);
                return lQ(t, ".")
            }
            if ("object" == s(e)) {
                for (t = "", r = function(e) {
                        for (var t = null, n = 1, r = null, a = 0, i = 0; i < 8; i++) 0 !== e[i] ? (a > n && (t = r, n = a), r = null, a = 0) : (null === r && (r = i), ++a);
                        return a > n && (t = r, n = a), t
                    }(e), n = 0; n < 8; n++) a && 0 === e[n] || (a && (a = !1), r === n ? (t += n ? ":" : "::", a = !0) : (t += hQ(e[n], 16), n < 7 && (t += ":")));
                return "[" + t + "]"
            }
            return e
        },
        LQ = {},
        zQ = GZ({}, LQ, {
            " ": 1,
            '"': 1,
            "<": 1,
            ">": 1,
            "`": 1
        }),
        PQ = GZ({}, zQ, {
            "#": 1,
            "?": 1,
            "{": 1,
            "}": 1
        }),
        BQ = GZ({}, PQ, {
            "/": 1,
            ":": 1,
            ";": 1,
            "=": 1,
            "@": 1,
            "[": 1,
            "\\": 1,
            "]": 1,
            "^": 1,
            "|": 1
        }),
        WQ = function(e, t) {
            var n = qZ(e, 0);
            return n > 32 && n < 127 && !VZ(t, e) ? e : encodeURIComponent(e)
        },
        UQ = {
            ftp: 21,
            file: null,
            http: 80,
            https: 443,
            ws: 80,
            wss: 443
        },
        VQ = function(e, t) {
            var n;
            return 2 == e.length && cQ(IQ, uQ(e, 0)) && (":" == (n = uQ(e, 1)) || !t && "|" == n)
        },
        GQ = function(e) {
            var t;
            return e.length > 1 && VQ(gQ(e, 0, 2)) && (2 == e.length || "/" === (t = uQ(e, 2)) || "\\" === t || "?" === t || "#" === t)
        },
        jQ = function(e) {
            return "." === e || "%2e" === yQ(e)
        },
        HQ = {},
        qQ = {},
        KQ = {},
        XQ = {},
        YQ = {},
        JQ = {},
        ZQ = {},
        QQ = {},
        $Q = {},
        e$ = {},
        t$ = {},
        n$ = {},
        r$ = {},
        a$ = {},
        i$ = {},
        o$ = {},
        s$ = {},
        u$ = {},
        c$ = {},
        l$ = {},
        h$ = {},
        p$ = function e(t, n, r) {
            var a, i, o, s = XZ(t);
            if (n) {
                if (i = this.parse(s)) throw aQ(i);
                this.searchParams = null
            } else {
                if (void 0 !== r && (a = new e(r, !0)), i = this.parse(s, null, a)) throw aQ(i);
                (o = nQ(new tQ)).bindURL(this), this.searchParams = o
            }
        };
    p$.prototype = {
        type: "URL",
        parse: function(e, t, n) {
            var r, a, i, o, s, u = this,
                c = t || HQ,
                l = 0,
                h = "",
                p = !1,
                f = !1,
                d = !1;
            for (e = XZ(e), t || (u.scheme = "", u.username = "", u.password = "", u.host = null, u.port = null, u.path = [], u.query = null, u.fragment = null, u.cannotBeABaseURL = !1, e = dQ(e, OQ, ""), e = dQ(e, FQ, "$1")), e = dQ(e, DQ, ""), r = jZ(e); l <= r.length;) {
                switch (a = r[l], c) {
                    case HQ:
                        if (!a || !cQ(IQ, a)) {
                            if (t) return xQ;
                            c = KQ;
                            continue
                        }
                        h += yQ(a), c = qQ;
                        break;
                    case qQ:
                        if (a && (cQ(NQ, a) || "+" == a || "-" == a || "." == a)) h += yQ(a);
                        else {
                            if (":" != a) {
                                if (t) return xQ;
                                h = "", c = KQ, l = 0;
                                continue
                            }
                            if (t && (u.isSpecial() != VZ(UQ, h) || "file" == h && (u.includesCredentials() || null !== u.port) || "file" == u.scheme && !u.host)) return;
                            if (u.scheme = h, t) return void(u.isSpecial() && UQ[u.scheme] == u.port && (u.port = null));
                            h = "", "file" == u.scheme ? c = a$ : u.isSpecial() && n && n.scheme == u.scheme ? c = XQ : u.isSpecial() ? c = QQ : "/" == r[l + 1] ? (c = YQ, l++) : (u.cannotBeABaseURL = !0, fQ(u.path, ""), c = c$)
                        }
                        break;
                    case KQ:
                        if (!n || n.cannotBeABaseURL && "#" != a) return xQ;
                        if (n.cannotBeABaseURL && "#" == a) {
                            u.scheme = n.scheme, u.path = HZ(n.path), u.query = n.query, u.fragment = "", u.cannotBeABaseURL = !0, c = h$;
                            break
                        }
                        c = "file" == n.scheme ? a$ : JQ;
                        continue;
                    case XQ:
                        if ("/" != a || "/" != r[l + 1]) {
                            c = JQ;
                            continue
                        }
                        c = $Q, l++;
                        break;
                    case YQ:
                        if ("/" == a) {
                            c = e$;
                            break
                        }
                        c = u$;
                        continue;
                    case JQ:
                        if (u.scheme = n.scheme, a == _Z) u.username = n.username, u.password = n.password, u.host = n.host, u.port = n.port, u.path = HZ(n.path), u.query = n.query;
                        else if ("/" == a || "\\" == a && u.isSpecial()) c = ZQ;
                        else if ("?" == a) u.username = n.username, u.password = n.password, u.host = n.host, u.port = n.port, u.path = HZ(n.path), u.query = "", c = l$;
                        else {
                            if ("#" != a) {
                                u.username = n.username, u.password = n.password, u.host = n.host, u.port = n.port, u.path = HZ(n.path), u.path.length--, c = u$;
                                continue
                            }
                            u.username = n.username, u.password = n.password, u.host = n.host, u.port = n.port, u.path = HZ(n.path), u.query = n.query, u.fragment = "", c = h$
                        }
                        break;
                    case ZQ:
                        if (!u.isSpecial() || "/" != a && "\\" != a) {
                            if ("/" != a) {
                                u.username = n.username, u.password = n.password, u.host = n.host, u.port = n.port, c = u$;
                                continue
                            }
                            c = e$
                        } else c = $Q;
                        break;
                    case QQ:
                        if (c = $Q, "/" != a || "/" != uQ(h, l + 1)) continue;
                        l++;
                        break;
                    case $Q:
                        if ("/" != a && "\\" != a) {
                            c = e$;
                            continue
                        }
                        break;
                    case e$:
                        if ("@" == a) {
                            p && (h = "%40" + h), p = !0, i = jZ(h);
                            for (var v = 0; v < i.length; v++) {
                                var m = i[v];
                                if (":" != m || d) {
                                    var g = WQ(m, BQ);
                                    d ? u.password += g : u.username += g
                                } else d = !0
                            }
                            h = ""
                        } else if (a == _Z || "/" == a || "?" == a || "#" == a || "\\" == a && u.isSpecial()) {
                            if (p && "" == h) return "Invalid authority";
                            l -= jZ(h).length + 1, h = "", c = t$
                        } else h += a;
                        break;
                    case t$:
                    case n$:
                        if (t && "file" == u.scheme) {
                            c = o$;
                            continue
                        }
                        if (":" != a || f) {
                            if (a == _Z || "/" == a || "?" == a || "#" == a || "\\" == a && u.isSpecial()) {
                                if (u.isSpecial() && "" == h) return kQ;
                                if (t && "" == h && (u.includesCredentials() || null !== u.port)) return;
                                if (o = u.parseHost(h)) return o;
                                if (h = "", c = s$, t) return;
                                continue
                            }
                            "[" == a ? f = !0 : "]" == a && (f = !1), h += a
                        } else {
                            if ("" == h) return kQ;
                            if (o = u.parseHost(h)) return o;
                            if (h = "", c = r$, t == n$) return
                        }
                        break;
                    case r$:
                        if (!cQ(SQ, a)) {
                            if (a == _Z || "/" == a || "?" == a || "#" == a || "\\" == a && u.isSpecial() || t) {
                                if ("" != h) {
                                    var y = iQ(h, 10);
                                    if (y > 65535) return wQ;
                                    u.port = u.isSpecial() && y === UQ[u.scheme] ? null : y, h = ""
                                }
                                if (t) return;
                                c = s$;
                                continue
                            }
                            return wQ
                        }
                        h += a;
                        break;
                    case a$:
                        if (u.scheme = "file", "/" == a || "\\" == a) c = i$;
                        else {
                            if (!n || "file" != n.scheme) {
                                c = u$;
                                continue
                            }
                            if (a == _Z) u.host = n.host, u.path = HZ(n.path), u.query = n.query;
                            else if ("?" == a) u.host = n.host, u.path = HZ(n.path), u.query = "", c = l$;
                            else {
                                if ("#" != a) {
                                    GQ(lQ(HZ(r, l), "")) || (u.host = n.host, u.path = HZ(n.path), u.shortenPath()), c = u$;
                                    continue
                                }
                                u.host = n.host, u.path = HZ(n.path), u.query = n.query, u.fragment = "", c = h$
                            }
                        }
                        break;
                    case i$:
                        if ("/" == a || "\\" == a) {
                            c = o$;
                            break
                        }
                        n && "file" == n.scheme && !GQ(lQ(HZ(r, l), "")) && (VQ(n.path[0], !0) ? fQ(u.path, n.path[0]) : u.host = n.host), c = u$;
                        continue;
                    case o$:
                        if (a == _Z || "/" == a || "\\" == a || "?" == a || "#" == a) {
                            if (!t && VQ(h)) c = u$;
                            else if ("" == h) {
                                if (u.host = "", t) return;
                                c = s$
                            } else {
                                if (o = u.parseHost(h)) return o;
                                if ("localhost" == u.host && (u.host = ""), t) return;
                                h = "", c = s$
                            }
                            continue
                        }
                        h += a;
                        break;
                    case s$:
                        if (u.isSpecial()) {
                            if (c = u$, "/" != a && "\\" != a) continue
                        } else if (t || "?" != a)
                            if (t || "#" != a) {
                                if (a != _Z && (c = u$, "/" != a)) continue
                            } else u.fragment = "", c = h$;
                        else u.query = "", c = l$;
                        break;
                    case u$:
                        if (a == _Z || "/" == a || "\\" == a && u.isSpecial() || !t && ("?" == a || "#" == a)) {
                            if (".." === (s = yQ(s = h)) || "%2e." === s || ".%2e" === s || "%2e%2e" === s ? (u.shortenPath(), "/" == a || "\\" == a && u.isSpecial() || fQ(u.path, "")) : jQ(h) ? "/" == a || "\\" == a && u.isSpecial() || fQ(u.path, "") : ("file" == u.scheme && !u.path.length && VQ(h) && (u.host && (u.host = ""), h = uQ(h, 0) + ":"), fQ(u.path, h)), h = "", "file" == u.scheme && (a == _Z || "?" == a || "#" == a))
                                for (; u.path.length > 1 && "" === u.path[0];) vQ(u.path);
                            "?" == a ? (u.query = "", c = l$) : "#" == a && (u.fragment = "", c = h$)
                        } else h += WQ(a, PQ);
                        break;
                    case c$:
                        "?" == a ? (u.query = "", c = l$) : "#" == a ? (u.fragment = "", c = h$) : a != _Z && (u.path[0] += WQ(a, LQ));
                        break;
                    case l$:
                        t || "#" != a ? a != _Z && ("'" == a && u.isSpecial() ? u.query += "%27" : u.query += "#" == a ? "%23" : WQ(a, LQ)) : (u.fragment = "", c = h$);
                        break;
                    case h$:
                        a != _Z && (u.fragment += WQ(a, zQ))
                }
                l++
            }
        },
        parseHost: function(e) {
            var t, n, r;
            if ("[" == uQ(e, 0)) {
                if ("]" != uQ(e, e.length - 1)) return kQ;
                if (t = function(e) {
                        var t, n, r, a, i, o, s, u = [0, 0, 0, 0, 0, 0, 0, 0],
                            c = 0,
                            l = null,
                            h = 0,
                            p = function() {
                                return uQ(e, h)
                            };
                        if (":" == p()) {
                            if (":" != uQ(e, 1)) return;
                            h += 2, l = ++c
                        }
                        for (; p();) {
                            if (8 == c) return;
                            if (":" != p()) {
                                for (t = n = 0; n < 4 && cQ(AQ, p());) t = 16 * t + iQ(p(), 16), h++, n++;
                                if ("." == p()) {
                                    if (0 == n) return;
                                    if (h -= n, c > 6) return;
                                    for (r = 0; p();) {
                                        if (a = null, r > 0) {
                                            if (!("." == p() && r < 4)) return;
                                            h++
                                        }
                                        if (!cQ(SQ, p())) return;
                                        for (; cQ(SQ, p());) {
                                            if (i = iQ(p(), 10), null === a) a = i;
                                            else {
                                                if (0 == a) return;
                                                a = 10 * a + i
                                            }
                                            if (a > 255) return;
                                            h++
                                        }
                                        u[c] = 256 * u[c] + a, 2 != ++r && 4 != r || c++
                                    }
                                    if (4 != r) return;
                                    break
                                }
                                if (":" == p()) {
                                    if (h++, !p()) return
                                } else if (p()) return;
                                u[c++] = t
                            } else {
                                if (null !== l) return;
                                h++, l = ++c
                            }
                        }
                        if (null !== l)
                            for (o = c - l, c = 7; 0 != c && o > 0;) s = u[c], u[c--] = u[l + o - 1], u[l + --o] = s;
                        else if (8 != c) return;
                        return u
                    }(gQ(e, 1, -1)), !t) return kQ;
                this.host = t
            } else if (this.isSpecial()) {
                if (e = KZ(e), cQ(RQ, e)) return kQ;
                if (t = function(e) {
                        var t, n, r, a, i, o, s, u = mQ(e, ".");
                        if (u.length && "" == u[u.length - 1] && u.length--, (t = u.length) > 4) return e;
                        for (n = [], r = 0; r < t; r++) {
                            if ("" == (a = u[r])) return e;
                            if (i = 10, a.length > 1 && "0" == uQ(a, 0) && (i = cQ(TQ, a) ? 16 : 8, a = gQ(a, 8 == i ? 1 : 2)), "" === a) o = 0;
                            else {
                                if (!cQ(10 == i ? CQ : 8 == i ? EQ : AQ, a)) return e;
                                o = iQ(a, i)
                            }
                            fQ(n, o)
                        }
                        for (r = 0; r < t; r++)
                            if (o = n[r], r == t - 1) {
                                if (o >= sQ(256, 5 - t)) return null
                            } else if (o > 255) return null;
                        for (s = pQ(n), r = 0; r < n.length; r++) s += n[r] * sQ(256, 3 - r);
                        return s
                    }(e), null === t) return kQ;
                this.host = t
            } else {
                if (cQ(_Q, e)) return kQ;
                for (t = "", n = jZ(e), r = 0; r < n.length; r++) t += WQ(n[r], LQ);
                this.host = t
            }
        },
        cannotHaveUsernamePasswordPort: function() {
            return !this.host || this.cannotBeABaseURL || "file" == this.scheme
        },
        includesCredentials: function() {
            return "" != this.username || "" != this.password
        },
        isSpecial: function() {
            return VZ(UQ, this.scheme)
        },
        shortenPath: function() {
            var e = this.path,
                t = e.length;
            !t || "file" == this.scheme && 1 == t && VQ(e[0], !0) || e.length--
        },
        serialize: function() {
            var e = this,
                t = e.scheme,
                n = e.username,
                r = e.password,
                a = e.host,
                i = e.port,
                o = e.path,
                s = e.query,
                u = e.fragment,
                c = t + ":";
            return null !== a ? (c += "//", e.includesCredentials() && (c += n + (r ? ":" + r : "") + "@"), c += MQ(a), null !== i && (c += ":" + i)) : "file" == t && (c += "//"), c += e.cannotBeABaseURL ? o[0] : o.length ? "/" + lQ(o, "/") : "", null !== s && (c += "?" + s), null !== u && (c += "#" + u), c
        },
        setHref: function(e) {
            var t = this.parse(e);
            if (t) throw aQ(t);
            this.searchParams.update()
        },
        getOrigin: function() {
            var e = this.scheme,
                t = this.port;
            if ("blob" == e) try {
                return new f$(e.path[0]).origin
            } catch (e) {
                return "null"
            }
            return "file" != e && this.isSpecial() ? e + "://" + MQ(this.host) + (null !== t ? ":" + t : "") : "null"
        },
        getProtocol: function() {
            return this.scheme + ":"
        },
        setProtocol: function(e) {
            this.parse(XZ(e) + ":", HQ)
        },
        getUsername: function() {
            return this.username
        },
        setUsername: function(e) {
            var t = jZ(XZ(e));
            if (!this.cannotHaveUsernamePasswordPort()) {
                this.username = "";
                for (var n = 0; n < t.length; n++) this.username += WQ(t[n], BQ)
            }
        },
        getPassword: function() {
            return this.password
        },
        setPassword: function(e) {
            var t = jZ(XZ(e));
            if (!this.cannotHaveUsernamePasswordPort()) {
                this.password = "";
                for (var n = 0; n < t.length; n++) this.password += WQ(t[n], BQ)
            }
        },
        getHost: function() {
            var e = this.host,
                t = this.port;
            return null === e ? "" : null === t ? MQ(e) : MQ(e) + ":" + t
        },
        setHost: function(e) {
            this.cannotBeABaseURL || this.parse(e, t$)
        },
        getHostname: function() {
            var e = this.host;
            return null === e ? "" : MQ(e)
        },
        setHostname: function(e) {
            this.cannotBeABaseURL || this.parse(e, n$)
        },
        getPort: function() {
            var e = this.port;
            return null === e ? "" : XZ(e)
        },
        setPort: function(e) {
            this.cannotHaveUsernamePasswordPort() || ("" == (e = XZ(e)) ? this.port = null : this.parse(e, r$))
        },
        getPathname: function() {
            var e = this.path;
            return this.cannotBeABaseURL ? e[0] : e.length ? "/" + lQ(e, "/") : ""
        },
        setPathname: function(e) {
            this.cannotBeABaseURL || (this.path = [], this.parse(e, s$))
        },
        getSearch: function() {
            var e = this.query;
            return e ? "?" + e : ""
        },
        setSearch: function(e) {
            "" == (e = XZ(e)) ? this.query = null: ("?" == uQ(e, 0) && (e = gQ(e, 1)), this.query = "", this.parse(e, l$)), this.searchParams.update()
        },
        getSearchParams: function() {
            return this.searchParams.facade
        },
        getHash: function() {
            var e = this.fragment;
            return e ? "#" + e : ""
        },
        setHash: function(e) {
            "" != (e = XZ(e)) ? ("#" == uQ(e, 0) && (e = gQ(e, 1)), this.fragment = "", this.parse(e, h$)) : this.fragment = null
        },
        update: function() {
            this.query = this.searchParams.serialize() || null
        }
    };
    var f$ = function(e) {
            var t = UZ(this, d$),
                n = JZ(arguments.length, 1) > 1 ? arguments[1] : void 0,
                r = $Z(t, new p$(e, !1, n));
            DZ || (t.href = r.serialize(), t.origin = r.getOrigin(), t.protocol = r.getProtocol(), t.username = r.getUsername(), t.password = r.getPassword(), t.host = r.getHost(), t.hostname = r.getHostname(), t.port = r.getPort(), t.pathname = r.getPathname(), t.search = r.getSearch(), t.searchParams = r.getSearchParams(), t.hash = r.getHash())
        },
        d$ = f$.prototype,
        v$ = function(e, t) {
            return {
                get: function() {
                    return eQ(this)[e]()
                },
                set: t && function(e) {
                    return eQ(this)[t](e)
                },
                configurable: !0,
                enumerable: !0
            }
        };
    if (DZ && (WZ(d$, "href", v$("serialize", "setHref")), WZ(d$, "origin", v$("getOrigin")), WZ(d$, "protocol", v$("getProtocol", "setProtocol")), WZ(d$, "username", v$("getUsername", "setUsername")), WZ(d$, "password", v$("getPassword", "setPassword")), WZ(d$, "host", v$("getHost", "setHost")), WZ(d$, "hostname", v$("getHostname", "setHostname")), WZ(d$, "port", v$("getPort", "setPort")), WZ(d$, "pathname", v$("getPathname", "setPathname")), WZ(d$, "search", v$("getSearch", "setSearch")), WZ(d$, "searchParams", v$("getSearchParams")), WZ(d$, "hash", v$("getHash", "setHash"))), BZ(d$, "toJSON", (function() {
            return eQ(this).serialize()
        }), {
            enumerable: !0
        }), BZ(d$, "toString", (function() {
            return eQ(this).serialize()
        }), {
            enumerable: !0
        }), rQ) {
        var m$ = rQ.createObjectURL,
            g$ = rQ.revokeObjectURL;
        m$ && BZ(f$, "createObjectURL", zZ(m$, rQ)), g$ && BZ(f$, "revokeObjectURL", zZ(g$, rQ))
    }
    YZ(f$, "URL"), FZ({
        global: !0,
        constructor: !0,
        forced: !MZ,
        sham: !DZ
    }, {
        URL: f$
    });
    var y$ = j;
    La({
        target: "URL",
        proto: !0,
        enumerable: !0
    }, {
        toJSON: function() {
            return y$(URL.prototype.toString, this)
        }
    });
    var b$ = W,
        x$ = ee,
        k$ = zi,
        w$ = URLSearchParams.prototype,
        I$ = x$(w$.forEach);
    b$ && !("size" in w$) && k$(w$, "size", {
        get: function() {
            var e = 0;
            return I$(this, (function() {
                e++
            })), e
        },
        configurable: !0,
        enumerable: !0
    });
    var N$ = {
        exports: {}
    };
    ! function(e) {
        var t = function(e) {
            var t, n = Object.prototype,
                r = n.hasOwnProperty,
                a = "function" == typeof Symbol ? Symbol : {},
                i = a.iterator || "@@iterator",
                o = a.asyncIterator || "@@asyncIterator",
                u = a.toStringTag || "@@toStringTag";

            function c(e, t, n) {
                return Object.defineProperty(e, t, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }), e[t]
            }
            try {
                c({}, "")
            } catch (e) {
                c = function(e, t, n) {
                    return e[t] = n
                }
            }

            function l(e, t, n, r) {
                var a = t && t.prototype instanceof g ? t : g,
                    i = Object.create(a.prototype),
                    o = new A(r || []);
                return i._invoke = function(e, t, n) {
                    var r = p;
                    return function(a, i) {
                        if (r === d) throw new Error("Generator is already running");
                        if (r === v) {
                            if ("throw" === a) throw i;
                            return _()
                        }
                        for (n.method = a, n.arg = i;;) {
                            var o = n.delegate;
                            if (o) {
                                var s = T(o, n);
                                if (s) {
                                    if (s === m) continue;
                                    return s
                                }
                            }
                            if ("next" === n.method) n.sent = n._sent = n.arg;
                            else if ("throw" === n.method) {
                                if (r === p) throw r = v, n.arg;
                                n.dispatchException(n.arg)
                            } else "return" === n.method && n.abrupt("return", n.arg);
                            r = d;
                            var u = h(e, t, n);
                            if ("normal" === u.type) {
                                if (r = n.done ? v : f, u.arg === m) continue;
                                return {
                                    value: u.arg,
                                    done: n.done
                                }
                            }
                            "throw" === u.type && (r = v, n.method = "throw", n.arg = u.arg)
                        }
                    }
                }(e, n, o), i
            }

            function h(e, t, n) {
                try {
                    return {
                        type: "normal",
                        arg: e.call(t, n)
                    }
                } catch (e) {
                    return {
                        type: "throw",
                        arg: e
                    }
                }
            }
            e.wrap = l;
            var p = "suspendedStart",
                f = "suspendedYield",
                d = "executing",
                v = "completed",
                m = {};

            function g() {}

            function y() {}

            function b() {}
            var x = {};
            x[i] = function() {
                return this
            };
            var k = Object.getPrototypeOf,
                w = k && k(k(R([])));
            w && w !== n && r.call(w, i) && (x = w);
            var I = b.prototype = g.prototype = Object.create(x);

            function N(e) {
                ["next", "throw", "return"].forEach((function(t) {
                    c(e, t, (function(e) {
                        return this._invoke(t, e)
                    }))
                }))
            }

            function S(e, t) {
                function n(a, i, o, u) {
                    var c = h(e[a], e, i);
                    if ("throw" !== c.type) {
                        var l = c.arg,
                            p = l.value;
                        return p && "object" === s(p) && r.call(p, "__await") ? t.resolve(p.__await).then((function(e) {
                            n("next", e, o, u)
                        }), (function(e) {
                            n("throw", e, o, u)
                        })) : t.resolve(p).then((function(e) {
                            l.value = e, o(l)
                        }), (function(e) {
                            return n("throw", e, o, u)
                        }))
                    }
                    u(c.arg)
                }
                var a;
                this._invoke = function(e, r) {
                    function i() {
                        return new t((function(t, a) {
                            n(e, r, t, a)
                        }))
                    }
                    return a = a ? a.then(i, i) : i()
                }
            }

            function T(e, n) {
                var r = e.iterator[n.method];
                if (r === t) {
                    if (n.delegate = null, "throw" === n.method) {
                        if (e.iterator.return && (n.method = "return", n.arg = t, T(e, n), "throw" === n.method)) return m;
                        n.method = "throw", n.arg = new TypeError("The iterator does not provide a 'throw' method")
                    }
                    return m
                }
                var a = h(r, e.iterator, n.arg);
                if ("throw" === a.type) return n.method = "throw", n.arg = a.arg, n.delegate = null, m;
                var i = a.arg;
                return i ? i.done ? (n[e.resultName] = i.value, n.next = e.nextLoc, "return" !== n.method && (n.method = "next", n.arg = t), n.delegate = null, m) : i : (n.method = "throw", n.arg = new TypeError("iterator result is not an object"), n.delegate = null, m)
            }

            function E(e) {
                var t = {
                    tryLoc: e[0]
                };
                1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t)
            }

            function C(e) {
                var t = e.completion || {};
                t.type = "normal", delete t.arg, e.completion = t
            }

            function A(e) {
                this.tryEntries = [{
                    tryLoc: "root"
                }], e.forEach(E, this), this.reset(!0)
            }

            function R(e) {
                if (e) {
                    var n = e[i];
                    if (n) return n.call(e);
                    if ("function" == typeof e.next) return e;
                    if (!isNaN(e.length)) {
                        var a = -1,
                            o = function n() {
                                for (; ++a < e.length;)
                                    if (r.call(e, a)) return n.value = e[a], n.done = !1, n;
                                return n.value = t, n.done = !0, n
                            };
                        return o.next = o
                    }
                }
                return {
                    next: _
                }
            }

            function _() {
                return {
                    value: t,
                    done: !0
                }
            }
            return y.prototype = I.constructor = b, b.constructor = y, y.displayName = c(b, u, "GeneratorFunction"), e.isGeneratorFunction = function(e) {
                var t = "function" == typeof e && e.constructor;
                return !!t && (t === y || "GeneratorFunction" === (t.displayName || t.name))
            }, e.mark = function(e) {
                return Object.setPrototypeOf ? Object.setPrototypeOf(e, b) : (e.__proto__ = b, c(e, u, "GeneratorFunction")), e.prototype = Object.create(I), e
            }, e.awrap = function(e) {
                return {
                    __await: e
                }
            }, N(S.prototype), S.prototype[o] = function() {
                return this
            }, e.AsyncIterator = S, e.async = function(t, n, r, a, i) {
                void 0 === i && (i = Promise);
                var o = new S(l(t, n, r, a), i);
                return e.isGeneratorFunction(n) ? o : o.next().then((function(e) {
                    return e.done ? e.value : o.next()
                }))
            }, N(I), c(I, u, "Generator"), I[i] = function() {
                return this
            }, I.toString = function() {
                return "[object Generator]"
            }, e.keys = function(e) {
                var t = [];
                for (var n in e) t.push(n);
                return t.reverse(),
                    function n() {
                        for (; t.length;) {
                            var r = t.pop();
                            if (r in e) return n.value = r, n.done = !1, n
                        }
                        return n.done = !0, n
                    }
            }, e.values = R, A.prototype = {
                constructor: A,
                reset: function(e) {
                    if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(C), !e)
                        for (var n in this) "t" === n.charAt(0) && r.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = t)
                },
                stop: function() {
                    this.done = !0;
                    var e = this.tryEntries[0].completion;
                    if ("throw" === e.type) throw e.arg;
                    return this.rval
                },
                dispatchException: function(e) {
                    if (this.done) throw e;
                    var n = this;

                    function a(r, a) {
                        return s.type = "throw", s.arg = e, n.next = r, a && (n.method = "next", n.arg = t), !!a
                    }
                    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                        var o = this.tryEntries[i],
                            s = o.completion;
                        if ("root" === o.tryLoc) return a("end");
                        if (o.tryLoc <= this.prev) {
                            var u = r.call(o, "catchLoc"),
                                c = r.call(o, "finallyLoc");
                            if (u && c) {
                                if (this.prev < o.catchLoc) return a(o.catchLoc, !0);
                                if (this.prev < o.finallyLoc) return a(o.finallyLoc)
                            } else if (u) {
                                if (this.prev < o.catchLoc) return a(o.catchLoc, !0)
                            } else {
                                if (!c) throw new Error("try statement without catch or finally");
                                if (this.prev < o.finallyLoc) return a(o.finallyLoc)
                            }
                        }
                    }
                },
                abrupt: function(e, t) {
                    for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                        var a = this.tryEntries[n];
                        if (a.tryLoc <= this.prev && r.call(a, "finallyLoc") && this.prev < a.finallyLoc) {
                            var i = a;
                            break
                        }
                    }
                    i && ("break" === e || "continue" === e) && i.tryLoc <= t && t <= i.finallyLoc && (i = null);
                    var o = i ? i.completion : {};
                    return o.type = e, o.arg = t, i ? (this.method = "next", this.next = i.finallyLoc, m) : this.complete(o)
                },
                complete: function(e, t) {
                    if ("throw" === e.type) throw e.arg;
                    return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg, this.method = "return", this.next = "end") : "normal" === e.type && t && (this.next = t), m
                },
                finish: function(e) {
                    for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                        var n = this.tryEntries[t];
                        if (n.finallyLoc === e) return this.complete(n.completion, n.afterLoc), C(n), m
                    }
                },
                catch: function(e) {
                    for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                        var n = this.tryEntries[t];
                        if (n.tryLoc === e) {
                            var r = n.completion;
                            if ("throw" === r.type) {
                                var a = r.arg;
                                C(n)
                            }
                            return a
                        }
                    }
                    throw new Error("illegal catch attempt")
                },
                delegateYield: function(e, n, r) {
                    return this.delegate = {
                        iterator: R(e),
                        resultName: n,
                        nextLoc: r
                    }, "next" === this.method && (this.arg = t), m
                }
            }, e
        }(e.exports);
        try {
            regeneratorRuntime = t
        } catch (e) {
            Function("r", "regeneratorRuntime = r")(t)
        }
    }(N$);
    var S$ = function() {
            function e(t, n) {
                l(this, e), this.backend = t, this.dataMover = n, this.data = new WeakMap, this.dataIdsCount = 0
            }
            return p(e, [{
                key: "get",
                value: function(e) {
                    return this.data.has(e) || this.dataMover.moveData(this.backend, e), this.data.get(e)
                }
            }, {
                key: "set",
                value: function(e, t) {
                    this.dataIdsCount++, this.data.set(e, t)
                }
            }, {
                key: "has",
                value: function(e) {
                    return this.data.has(e)
                }
            }, {
                key: "delete",
                value: function(e) {
                    return this.dataIdsCount--, this.data.delete(e)
                }
            }, {
                key: "numDataIds",
                value: function() {
                    return this.dataIdsCount
                }
            }]), e
        }(),
        T$ = function() {
            function e() {
                l(this, e)
            }
            return p(e, [{
                key: "refCount",
                value: function(e) {
                    return E$("refCount")
                }
            }, {
                key: "incRef",
                value: function(e) {
                    return E$("incRef")
                }
            }, {
                key: "timerAvailable",
                value: function() {
                    return !0
                }
            }, {
                key: "time",
                value: function(e) {
                    return E$("time")
                }
            }, {
                key: "read",
                value: function(e) {
                    return E$("read")
                }
            }, {
                key: "readSync",
                value: function(e) {
                    return E$("readSync")
                }
            }, {
                key: "readToGPU",
                value: function(e, t) {
                    return E$("readToGPU")
                }
            }, {
                key: "numDataIds",
                value: function() {
                    return E$("numDataIds")
                }
            }, {
                key: "disposeData",
                value: function(e, t) {
                    return E$("disposeData")
                }
            }, {
                key: "write",
                value: function(e, t, n) {
                    return E$("write")
                }
            }, {
                key: "move",
                value: function(e, t, n, r, a) {
                    return E$("move")
                }
            }, {
                key: "createTensorFromGPUData",
                value: function(e, t, n) {
                    return E$("createTensorFromGPUData")
                }
            }, {
                key: "memory",
                value: function() {
                    return E$("memory")
                }
            }, {
                key: "floatPrecision",
                value: function() {
                    return E$("floatPrecision")
                }
            }, {
                key: "epsilon",
                value: function() {
                    return 32 === this.floatPrecision() ? 1e-7 : 1e-4
                }
            }, {
                key: "dispose",
                value: function() {
                    return E$("dispose")
                }
            }]), e
        }();

    function E$(e) {
        throw new Error("'".concat(e, "' not yet implemented or not found in the registry. ") + "This kernel may not be supported by the tfjs backend you have chosen")
    }

    function C$(e) {
        for (var t = e.length, n = 0; t > 0;) n = Math.random() * t | 0, _$(e, --t, n)
    }

    function A$(e, t, n) {
        return Math.max(e, Math.min(t, n))
    }

    function R$(e) {
        return e % 2 == 0 ? e : e + 1
    }

    function _$(e, t, n) {
        var r = e[t];
        e[t] = e[n], e[n] = r
    }

    function O$(e) {
        for (var t = 0, n = 0; n < e.length; n++) t += e[n];
        return t
    }

    function F$(e, t) {
        if (!e) throw new Error("string" == typeof t ? t : t())
    }

    function D$(e, t) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "";
        F$(P$(e, t), (function() {
            return n + " Shapes ".concat(e, " and ").concat(t, " must match")
        }))
    }

    function M$(e) {
        F$(null != e, (function() {
            return "The input to the tensor constructor must be a non-null value."
        }))
    }

    function L$(e) {
        if (0 === e.length) return 1;
        for (var t = e[0], n = 1; n < e.length; n++) t *= e[n];
        return t
    }

    function z$(e, t) {
        if (e === t) return !0;
        if (null == e || null == t) return !1;
        if (e.length !== t.length) return !1;
        for (var n = 0; n < e.length; n++)
            if (null !== e[n] && null !== t[n] && e[n] !== t[n]) return !1;
        return !0
    }

    function P$(e, t) {
        if (e === t) return !0;
        if (null == e || null == t) return !1;
        if (e.length !== t.length) return !1;
        for (var n = 0; n < e.length; n++)
            if (e[n] !== t[n]) return !1;
        return !0
    }

    function B$(e) {
        return e % 1 == 0
    }

    function W$(e) {
        var t = Math.ceil(Math.sqrt(e));
        return [t, Math.ceil(e / t)]
    }

    function U$(e, t) {
        return t <= e.length ? e : e + " ".repeat(t - e.length)
    }

    function V$(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : function(e) {
                return 0
            },
            n = arguments.length > 2 ? arguments[2] : void 0,
            r = arguments.length > 3 ? arguments[3] : void 0;
        return new Promise((function(a, i) {
            var o = 0;
            ! function s() {
                if (e()) a();
                else {
                    o++;
                    var u = t(o);
                    null != n && o >= n ? i() : null != r ? r(s, u) : setTimeout(s, u)
                }
            }()
        }))
    }

    function G$(e, t) {
        for (var n = 1, r = -1, a = 0; a < e.length; ++a)
            if (e[a] >= 0) n *= e[a];
            else if (-1 === e[a]) {
            if (-1 !== r) throw Error("Shapes can only have 1 implicit size. " + "Found -1 at dim ".concat(r, " and dim ").concat(a));
            r = a
        } else if (e[a] < 0) throw Error("Shapes can not be < 0. Found ".concat(e[a], " at dim ").concat(a));
        if (-1 === r) {
            if (t > 0 && t !== n) throw Error("Size(".concat(t, ") must match the product of shape ").concat(e));
            return e
        }
        if (0 === n) throw Error("Cannot infer the missing size in [".concat(e, "] when ") + "there are 0 elements");
        if (t % n != 0) throw Error("The implicit shape can't be a fractional number. " + "Got ".concat(t, " / ").concat(n));
        var i = e.slice();
        return i[r] = t / n, i
    }

    function j$(e, t) {
        var n = t.length;
        return F$((e = null == e ? t.map((function(e, t) {
            return t
        })) : [].concat(e)).every((function(e) {
            return e >= -n && e < n
        })), (function() {
            return "All values in axis param must be in range [-".concat(n, ", ").concat(n, ") but ") + "got axis ".concat(e)
        })), F$(e.every((function(e) {
            return B$(e)
        })), (function() {
            return "All values in axis param must be integers but " + "got axis ".concat(e)
        })), e.map((function(e) {
            return e < 0 ? n + e : e
        }))
    }

    function H$(e, t) {
        for (var n = [], r = [], a = null != t && Array.isArray(t) && 0 === t.length, i = null == t || a ? null : j$(t, e).sort(), o = 0, s = 0; s < e.length; ++s) {
            if (null != i) {
                if (i[o] === s && 1 !== e[s]) throw new Error("Can't squeeze axis ".concat(s, " since its dim '").concat(e[s], "' is not 1"));
                (null == i[o] || i[o] > s) && 1 === e[s] && (n.push(e[s]), r.push(s)), i[o] <= s && o++
            }
            1 !== e[s] && (n.push(e[s]), r.push(s))
        }
        return {
            newShape: n,
            keptDims: r
        }
    }

    function q$(e, t) {
        return K$(e, t)
    }

    function K$(e, t) {
        var n = null;
        if (null == e || "float32" === e) n = new Float32Array(t);
        else if ("int32" === e) n = new Int32Array(t);
        else if ("bool" === e) n = new Uint8Array(t);
        else {
            if ("string" !== e) throw new Error("Unknown data type ".concat(e));
            n = new Array(t)
        }
        return n
    }

    function X$(e, t) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n];
            if (isNaN(r) || !isFinite(r)) throw Error("A tensor of type ".concat(t, " being uploaded contains ").concat(r, "."))
        }
    }

    function Y$(e) {
        return "bool" === e || "complex64" === e || "float32" === e || "int32" === e || "string" === e
    }

    function J$(e, t) {
        return "complex64" !== t && (("float32" !== t || "complex64" === e) && (("int32" !== t || "float32" === e || "complex64" === e) && ("bool" !== t || "bool" !== e)))
    }

    function Z$(e) {
        if ("float32" === e || "int32" === e) return 4;
        if ("complex64" === e) return 8;
        if ("bool" === e) return 1;
        throw new Error("Unknown dtype ".concat(e))
    }

    function Q$(e) {
        if (null == e) return 0;
        var t = 0;
        return e.forEach((function(e) {
            return t += e.length
        })), t
    }

    function $$(e) {
        return "string" == typeof e || e instanceof String
    }

    function e0(e) {
        return "boolean" == typeof e
    }

    function t0(e) {
        return "number" == typeof e
    }

    function n0(e) {
        return Array.isArray(e) ? n0(e[0]) : e instanceof Float32Array ? "float32" : e instanceof Int32Array || e instanceof Uint8Array || e instanceof Uint8ClampedArray ? "int32" : t0(e) ? "float32" : $$(e) ? "string" : e0(e) ? "bool" : "float32"
    }

    function r0(e) {
        return !!(e && e.constructor && e.call && e.apply)
    }

    function a0(e, t) {
        for (var n = t; n < e; ++n)
            if (e % n == 0) return n;
        return e
    }

    function i0(e) {
        var t = e.length;
        if (t < 2) return [];
        var n = new Array(t - 1);
        n[t - 2] = e[t - 1];
        for (var r = t - 3; r >= 0; --r) n[r] = n[r + 1] * e[r + 1];
        return n
    }

    function o0(e, t, n) {
        var r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
            a = new Array;
        if (1 === t.length)
            for (var i = t[0] * (r ? 2 : 1), o = 0; o < i; o++) a[o] = n[e + o];
        else
            for (var s = t[0], u = t.slice(1), c = u.reduce((function(e, t) {
                    return e * t
                })) * (r ? 2 : 1), l = 0; l < s; l++) a[l] = o0(e + l * c, u, n, r);
        return a
    }

    function s0(e, t) {
        var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        if (0 === e.length) return t[0];
        var r = e.reduce((function(e, t) {
            return e * t
        })) * (n ? 2 : 1);
        if (0 === r) return [];
        if (r !== t.length) throw new Error("[".concat(e, "] does not match the input size ").concat(t.length).concat(n ? " for a complex tensor" : "", "."));
        return o0(0, e, t, n)
    }

    function u0(e, t) {
        if (Array.isArray(e)) return e;
        if ("float32" === t) return e instanceof Float32Array ? e : new Float32Array(e);
        if ("int32" === t) return e instanceof Int32Array ? e : new Int32Array(e);
        if ("bool" === t || "string" === t) return Uint8Array.from(new Int32Array(e));
        throw new Error("Unknown dtype ".concat(t))
    }

    function c0(e, t) {
        for (var n = l0(e, t), r = 0; r < n.length; r++) n[r] = 1;
        return n
    }

    function l0(e, t) {
        if (null == t || "float32" === t || "complex64" === t) return new Float32Array(e);
        if ("int32" === t) return new Int32Array(e);
        if ("bool" === t) return new Uint8Array(e);
        throw new Error("Unknown data type ".concat(t))
    }

    function h0(e, t) {
        var n = e.reduce((function(e, t) {
            return e * t
        }), 1);
        if (null == t || "float32" === t) return s0(e, new Float32Array(n));
        if ("int32" === t) return s0(e, new Int32Array(n));
        if ("bool" === t) return s0(e, new Uint8Array(n));
        throw new Error("Unknown data type ".concat(t))
    }

    function p0(e) {
        e.forEach((function(t) {
            F$(Number.isInteger(t) && t >= 0, (function() {
                return "Tensor must have a shape comprised of positive integers but got " + "shape [".concat(e, "].")
            }))
        }))
    }

    function f0(e, t, n) {
        if (0 === t) return 0;
        if (1 === t) return e[0];
        for (var r = e[e.length - 1], a = 0; a < e.length - 1; ++a) r += n[a] * e[a];
        return r
    }

    function d0(e, t, n) {
        if (0 === t) return [];
        if (1 === t) return [e];
        for (var r = new Array(t), a = 0; a < r.length - 1; ++a) r[a] = Math.floor(e / n[a]), e -= r[a] * n[a];
        return r[r.length - 1] = e, r
    }

    function v0(e) {
        return e && e.then && "function" == typeof e.then
    }
    var m0, g0 = "tfjsflags",
        y0 = function() {
            function e(t) {
                l(this, e), this.global = t, this.flags = {}, this.flagRegistry = {}, this.urlFlags = {}, this.getQueryParams = b0, this.populateURLFlags()
            }
            var t;
            return p(e, [{
                key: "setPlatform",
                value: function(e, t) {
                    null != this.platform && (k0().getBool("IS_TEST") || k0().getBool("PROD") || console.warn("Platform ".concat(this.platformName, " has already been set. ") + "Overwriting the platform with ".concat(e, "."))), this.platformName = e, this.platform = t
                }
            }, {
                key: "registerFlag",
                value: function(e, t, n) {
                    if (this.flagRegistry[e] = {
                            evaluationFn: t,
                            setHook: n
                        }, null != this.urlFlags[e]) {
                        var r = this.urlFlags[e];
                        k0().getBool("IS_TEST") || k0().getBool("PROD") || console.warn("Setting feature override from URL ".concat(e, ": ").concat(r, ".")), this.set(e, r)
                    }
                }
            }, {
                key: "getAsync",
                value: (t = c(o().mark((function e(t) {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (!(t in this.flags)) {
                                    e.next = 2;
                                    break
                                }
                                return e.abrupt("return", this.flags[t]);
                            case 2:
                                return e.next = 4, this.evaluateFlag(t);
                            case 4:
                                return this.flags[t] = e.sent, e.abrupt("return", this.flags[t]);
                            case 6:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e) {
                    return t.apply(this, arguments)
                })
            }, {
                key: "get",
                value: function(e) {
                    if (e in this.flags) return this.flags[e];
                    var t = this.evaluateFlag(e);
                    if (v0(t)) throw new Error("Flag ".concat(e, " cannot be synchronously evaluated. ") + "Please use getAsync() instead.");
                    return this.flags[e] = t, this.flags[e]
                }
            }, {
                key: "getNumber",
                value: function(e) {
                    return this.get(e)
                }
            }, {
                key: "getBool",
                value: function(e) {
                    return this.get(e)
                }
            }, {
                key: "getString",
                value: function(e) {
                    return this.get(e)
                }
            }, {
                key: "getFlags",
                value: function() {
                    return this.flags
                }
            }, {
                key: "features",
                get: function() {
                    return this.flags
                }
            }, {
                key: "set",
                value: function(e, t) {
                    if (null == this.flagRegistry[e]) throw new Error("Cannot set flag ".concat(e, " as it has not been registered."));
                    this.flags[e] = t, null != this.flagRegistry[e].setHook && this.flagRegistry[e].setHook(t)
                }
            }, {
                key: "evaluateFlag",
                value: function(e) {
                    if (null == this.flagRegistry[e]) throw new Error("Cannot evaluate flag '".concat(e, "': no evaluation function found."));
                    return this.flagRegistry[e].evaluationFn()
                }
            }, {
                key: "setFlags",
                value: function(e) {
                    this.flags = Object.assign({}, e)
                }
            }, {
                key: "reset",
                value: function() {
                    this.flags = {}, this.urlFlags = {}, this.populateURLFlags()
                }
            }, {
                key: "populateURLFlags",
                value: function() {
                    var e = this;
                    if (void 0 !== this.global && void 0 !== this.global.location && void 0 !== this.global.location.search) {
                        var t = this.getQueryParams(this.global.location.search);
                        if (g0 in t) t.tfjsflags.split(",").forEach((function(t) {
                            var n = S(t.split(":"), 2),
                                r = n[0],
                                a = n[1];
                            e.urlFlags[r] = function(e, t) {
                                var n = t.toLowerCase();
                                return "true" === n || "false" === n ? "true" === n : "".concat(+n) === n ? +n : t
                            }(0, a)
                        }))
                    }
                }
            }]), e
        }();

    function b0(e) {
        var t = {};
        return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, (function(e) {
            for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), a = 1; a < n; a++) r[a - 1] = arguments[a];
            return x0(t, r[0], r[1]), r.join("=")
        })), t
    }

    function x0(e, t, n) {
        e[decodeURIComponent(t)] = decodeURIComponent(n || "")
    }

    function k0() {
        return e.ENV
    }

    function w0() {
        if (null == m0) {
            var e;
            if ("undefined" != typeof window) e = window;
            else if ("undefined" != typeof global) e = global;
            else if ("undefined" != typeof process) e = process;
            else {
                if ("undefined" == typeof self) throw new Error("Could not find a global object");
                e = self
            }
            m0 = e
        }
        return m0
    }

    function I0(e, t) {
        var n, r = (null == (n = w0())._tfGlobals && (n._tfGlobals = new Map), n._tfGlobals);
        if (r.has(e)) return r.get(e);
        var a = t();
        return r.set(e, a), r.get(e)
    }
    e.ENV = null;
    var N0 = "Abs",
        S0 = "Acos",
        T0 = "Acosh",
        E0 = "Add",
        C0 = "AddN",
        A0 = "All",
        R0 = "Any",
        _0 = "ArgMax",
        O0 = "ArgMin",
        F0 = "Asin",
        D0 = "Asinh",
        M0 = "Atan",
        L0 = "Atanh",
        z0 = "Atan2",
        P0 = "AvgPool",
        B0 = "AvgPoolGrad",
        W0 = "AvgPool3D",
        U0 = "AvgPool3DGrad",
        V0 = "BatchMatMul",
        G0 = "BatchToSpaceND",
        j0 = "Bincount",
        H0 = "BitwiseAnd",
        q0 = "BroadcastTo",
        K0 = "BroadcastArgs",
        X0 = "Cast",
        Y0 = "Ceil",
        J0 = "ClipByValue",
        Z0 = "Complex",
        Q0 = "ComplexAbs",
        $0 = "Concat",
        e1 = "Conv2D",
        t1 = "Conv2DBackpropFilter",
        n1 = "Conv2DBackpropInput",
        r1 = "Conv3D",
        a1 = "Conv3DBackpropFilterV2",
        i1 = "Conv3DBackpropInputV2",
        o1 = "Cos",
        s1 = "Cosh",
        u1 = "Cumprod",
        c1 = "Cumsum",
        l1 = "CropAndResize",
        h1 = "DenseBincount",
        p1 = "DepthToSpace",
        f1 = "DepthwiseConv2dNative",
        d1 = "DepthwiseConv2dNativeBackpropFilter",
        v1 = "DepthwiseConv2dNativeBackpropInput",
        m1 = "Diag",
        g1 = "Dilation2D",
        y1 = "Dilation2DBackpropInput",
        b1 = "Dilation2DBackpropFilter",
        x1 = "Draw",
        k1 = "RealDiv",
        w1 = "Einsum",
        I1 = "Elu",
        N1 = "EluGrad",
        S1 = "Erf",
        T1 = "Equal",
        E1 = "Exp",
        C1 = "ExpandDims",
        A1 = "Expm1",
        R1 = "FFT",
        _1 = "Fill",
        O1 = "FlipLeftRight",
        F1 = "Floor",
        D1 = "FloorDiv",
        M1 = "FusedBatchNorm",
        L1 = "GatherV2",
        z1 = "GatherNd",
        P1 = "Greater",
        B1 = "GreaterEqual",
        W1 = "Identity",
        U1 = "IFFT",
        V1 = "Imag",
        G1 = "IsFinite",
        j1 = "IsInf",
        H1 = "IsNan",
        q1 = "LeakyRelu",
        K1 = "Less",
        X1 = "LessEqual",
        Y1 = "LinSpace",
        J1 = "Log",
        Z1 = "Log1p",
        Q1 = "LogicalAnd",
        $1 = "LogicalNot",
        e2 = "LogicalOr",
        t2 = "LogSoftmax",
        n2 = "LRN",
        r2 = "LRNGrad",
        a2 = "Max",
        i2 = "Maximum",
        o2 = "MaxPool",
        s2 = "MaxPoolGrad",
        u2 = "MaxPool3D",
        c2 = "MaxPool3DGrad",
        l2 = "MaxPoolWithArgmax",
        h2 = "Mean",
        p2 = "Min",
        f2 = "Minimum",
        d2 = "MirrorPad",
        v2 = "Mod",
        m2 = "Multinomial",
        g2 = "Multiply",
        y2 = "Neg",
        b2 = "NotEqual",
        x2 = "NonMaxSuppressionV3",
        k2 = "NonMaxSuppressionV4",
        w2 = "NonMaxSuppressionV5",
        I2 = "OnesLike",
        N2 = "OneHot",
        S2 = "Pack",
        T2 = "PadV2",
        E2 = "Pow",
        C2 = "Prelu",
        A2 = "Prod",
        R2 = "RaggedGather",
        _2 = "RaggedRange",
        O2 = "RaggedTensorToTensor",
        F2 = "Range",
        D2 = "Real",
        M2 = "Reciprocal",
        L2 = "Relu",
        z2 = "Reshape",
        P2 = "ResizeNearestNeighbor",
        B2 = "ResizeNearestNeighborGrad",
        W2 = "ResizeBilinear",
        U2 = "ResizeBilinearGrad",
        V2 = "Relu6",
        G2 = "Reverse",
        j2 = "Round",
        H2 = "Rsqrt",
        q2 = "ScatterNd",
        K2 = "TensorScatterUpdate",
        X2 = "SearchSorted",
        Y2 = "Select",
        J2 = "Selu",
        Z2 = "Slice",
        Q2 = "Sin",
        $2 = "Sinh",
        e3 = "Sign",
        t3 = "Sigmoid",
        n3 = "Softplus",
        r3 = "Sqrt",
        a3 = "Sum",
        i3 = "SpaceToBatchND",
        o3 = "SplitV",
        s3 = "Softmax",
        u3 = "SparseFillEmptyRows",
        c3 = "SparseReshape",
        l3 = "SparseSegmentMean",
        h3 = "SparseSegmentSum",
        p3 = "SparseToDense",
        f3 = "SquaredDifference",
        d3 = "Square",
        v3 = "StaticRegexReplace",
        m3 = "StridedSlice",
        g3 = "StringNGrams",
        y3 = "StringSplit",
        b3 = "StringToHashBucketFast",
        x3 = "Sub",
        k3 = "Tan",
        w3 = "Tanh",
        I3 = "Tile",
        N3 = "TopK",
        S3 = "Transform",
        T3 = "Transpose",
        E3 = "Unique",
        C3 = "Unpack",
        A3 = "UnsortedSegmentSum",
        R3 = "ZerosLike",
        _3 = "Step",
        O3 = "FromPixels",
        F3 = "RotateWithOffset",
        D3 = "_FusedMatMul",
        M3 = "FusedConv2D",
        L3 = "FusedDepthwiseConv2D";

    function z3() {
        var e;
        k0().getBool("IS_TEST") || k0().getBool("PROD") || (e = console).warn.apply(e, arguments)
    }
    var P3 = I0("kernelRegistry", (function() {
            return new Map
        })),
        B3 = I0("gradRegistry", (function() {
            return new Map
        }));

    function W3(e, t) {
        var n = H3(e, t);
        return P3.get(n)
    }

    function U3(e) {
        return B3.get(e)
    }

    function V3(e) {
        for (var t = P3.entries(), n = [];;) {
            var r = t.next(),
                a = r.done,
                i = r.value;
            if (a) break;
            var o = S(i, 2),
                s = o[0],
                u = o[1];
            S(s.split("_"), 1)[0] === e && n.push(u)
        }
        return n
    }

    function G3(e) {
        var t = e.kernelName,
            n = e.backendName,
            r = H3(t, n);
        P3.has(r) && z3("The kernel '".concat(t, "' for backend ") + "'".concat(n, "' is already registered")), P3.set(r, e)
    }

    function j3(e) {
        var t = e.kernelName;
        B3.has(t) && k0().getBool("DEBUG") && z3("Overriding the gradient for '".concat(t, "'")), B3.set(t, e)
    }

    function H3(e, t) {
        return "".concat(t, "_").concat(e)
    }

    function q3(e) {
        return e instanceof Float32Array || e instanceof Int32Array || e instanceof Uint8Array || e instanceof Uint8ClampedArray
    }
    var K3 = Y3,
        X3 = null;
    try {
        X3 = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports
    } catch (e) {}

    function Y3(e, t, n) {
        this.low = 0 | e, this.high = 0 | t, this.unsigned = !!n
    }

    function J3(e) {
        return !0 === (e && e.__isLong__)
    }
    Y3.prototype.__isLong__, Object.defineProperty(Y3.prototype, "__isLong__", {
        value: !0
    }), Y3.isLong = J3;
    var Z3 = {},
        Q3 = {};

    function $3(e, t) {
        var n, r, a;
        return t ? (a = 0 <= (e >>>= 0) && e < 256) && (r = Q3[e]) ? r : (n = t4(e, (0 | e) < 0 ? -1 : 0, !0), a && (Q3[e] = n), n) : (a = -128 <= (e |= 0) && e < 128) && (r = Z3[e]) ? r : (n = t4(e, e < 0 ? -1 : 0, !1), a && (Z3[e] = n), n)
    }

    function e4(e, t) {
        if (isNaN(e)) return t ? l4 : c4;
        if (t) {
            if (e < 0) return l4;
            if (e >= o4) return v4
        } else {
            if (e <= -s4) return m4;
            if (e + 1 >= s4) return d4
        }
        return e < 0 ? e4(-e, t).neg() : t4(e % i4 | 0, e / i4 | 0, t)
    }

    function t4(e, t, n) {
        return new Y3(e, t, n)
    }
    Y3.fromInt = $3, Y3.fromNumber = e4, Y3.fromBits = t4;
    var n4 = Math.pow;

    function r4(e, t, n) {
        if (0 === e.length) throw Error("empty string");
        if ("NaN" === e || "Infinity" === e || "+Infinity" === e || "-Infinity" === e) return c4;
        if ("number" == typeof t ? (n = t, t = !1) : t = !!t, (n = n || 10) < 2 || 36 < n) throw RangeError("radix");
        var r;
        if ((r = e.indexOf("-")) > 0) throw Error("interior hyphen");
        if (0 === r) return r4(e.substring(1), t, n).neg();
        for (var a = e4(n4(n, 8)), i = c4, o = 0; o < e.length; o += 8) {
            var s = Math.min(8, e.length - o),
                u = parseInt(e.substring(o, o + s), n);
            if (s < 8) {
                var c = e4(n4(n, s));
                i = i.mul(c).add(e4(u))
            } else i = (i = i.mul(a)).add(e4(u))
        }
        return i.unsigned = t, i
    }

    function a4(e, t) {
        return "number" == typeof e ? e4(e, t) : "string" == typeof e ? r4(e, t) : t4(e.low, e.high, "boolean" == typeof t ? t : e.unsigned)
    }
    Y3.fromString = r4, Y3.fromValue = a4;
    var i4 = 4294967296,
        o4 = i4 * i4,
        s4 = o4 / 2,
        u4 = $3(1 << 24),
        c4 = $3(0);
    Y3.ZERO = c4;
    var l4 = $3(0, !0);
    Y3.UZERO = l4;
    var h4 = $3(1);
    Y3.ONE = h4;
    var p4 = $3(1, !0);
    Y3.UONE = p4;
    var f4 = $3(-1);
    Y3.NEG_ONE = f4;
    var d4 = t4(-1, 2147483647, !1);
    Y3.MAX_VALUE = d4;
    var v4 = t4(-1, -1, !0);
    Y3.MAX_UNSIGNED_VALUE = v4;
    var m4 = t4(0, -2147483648, !1);
    Y3.MIN_VALUE = m4;
    var g4 = Y3.prototype;
    g4.toInt = function() {
        return this.unsigned ? this.low >>> 0 : this.low
    }, g4.toNumber = function() {
        return this.unsigned ? (this.high >>> 0) * i4 + (this.low >>> 0) : this.high * i4 + (this.low >>> 0)
    }, g4.toString = function(e) {
        if ((e = e || 10) < 2 || 36 < e) throw RangeError("radix");
        if (this.isZero()) return "0";
        if (this.isNegative()) {
            if (this.eq(m4)) {
                var t = e4(e),
                    n = this.div(t),
                    r = n.mul(t).sub(this);
                return n.toString(e) + r.toInt().toString(e)
            }
            return "-" + this.neg().toString(e)
        }
        for (var a = e4(n4(e, 6), this.unsigned), i = this, o = "";;) {
            var s = i.div(a),
                u = (i.sub(s.mul(a)).toInt() >>> 0).toString(e);
            if ((i = s).isZero()) return u + o;
            for (; u.length < 6;) u = "0" + u;
            o = "" + u + o
        }
    }, g4.getHighBits = function() {
        return this.high
    }, g4.getHighBitsUnsigned = function() {
        return this.high >>> 0
    }, g4.getLowBits = function() {
        return this.low
    }, g4.getLowBitsUnsigned = function() {
        return this.low >>> 0
    }, g4.getNumBitsAbs = function() {
        if (this.isNegative()) return this.eq(m4) ? 64 : this.neg().getNumBitsAbs();
        for (var e = 0 != this.high ? this.high : this.low, t = 31; t > 0 && 0 == (e & 1 << t); t--);
        return 0 != this.high ? t + 33 : t + 1
    }, g4.isZero = function() {
        return 0 === this.high && 0 === this.low
    }, g4.eqz = g4.isZero, g4.isNegative = function() {
        return !this.unsigned && this.high < 0
    }, g4.isPositive = function() {
        return this.unsigned || this.high >= 0
    }, g4.isOdd = function() {
        return 1 == (1 & this.low)
    }, g4.isEven = function() {
        return 0 == (1 & this.low)
    }, g4.equals = function(e) {
        return J3(e) || (e = a4(e)), (this.unsigned === e.unsigned || this.high >>> 31 != 1 || e.high >>> 31 != 1) && (this.high === e.high && this.low === e.low)
    }, g4.eq = g4.equals, g4.notEquals = function(e) {
        return !this.eq(e)
    }, g4.neq = g4.notEquals, g4.ne = g4.notEquals, g4.lessThan = function(e) {
        return this.comp(e) < 0
    }, g4.lt = g4.lessThan, g4.lessThanOrEqual = function(e) {
        return this.comp(e) <= 0
    }, g4.lte = g4.lessThanOrEqual, g4.le = g4.lessThanOrEqual, g4.greaterThan = function(e) {
        return this.comp(e) > 0
    }, g4.gt = g4.greaterThan, g4.greaterThanOrEqual = function(e) {
        return this.comp(e) >= 0
    }, g4.gte = g4.greaterThanOrEqual, g4.ge = g4.greaterThanOrEqual, g4.compare = function(e) {
        if (J3(e) || (e = a4(e)), this.eq(e)) return 0;
        var t = this.isNegative(),
            n = e.isNegative();
        return t && !n ? -1 : !t && n ? 1 : this.unsigned ? e.high >>> 0 > this.high >>> 0 || e.high === this.high && e.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e).isNegative() ? -1 : 1
    }, g4.comp = g4.compare, g4.negate = function() {
        return !this.unsigned && this.eq(m4) ? m4 : this.not().add(h4)
    }, g4.neg = g4.negate, g4.add = function(e) {
        J3(e) || (e = a4(e));
        var t = this.high >>> 16,
            n = 65535 & this.high,
            r = this.low >>> 16,
            a = 65535 & this.low,
            i = e.high >>> 16,
            o = 65535 & e.high,
            s = e.low >>> 16,
            u = 0,
            c = 0,
            l = 0,
            h = 0;
        return l += (h += a + (65535 & e.low)) >>> 16, c += (l += r + s) >>> 16, u += (c += n + o) >>> 16, u += t + i, t4((l &= 65535) << 16 | (h &= 65535), (u &= 65535) << 16 | (c &= 65535), this.unsigned)
    }, g4.subtract = function(e) {
        return J3(e) || (e = a4(e)), this.add(e.neg())
    }, g4.sub = g4.subtract, g4.multiply = function(e) {
        if (this.isZero()) return c4;
        if (J3(e) || (e = a4(e)), X3) return t4(X3.mul(this.low, this.high, e.low, e.high), X3.get_high(), this.unsigned);
        if (e.isZero()) return c4;
        if (this.eq(m4)) return e.isOdd() ? m4 : c4;
        if (e.eq(m4)) return this.isOdd() ? m4 : c4;
        if (this.isNegative()) return e.isNegative() ? this.neg().mul(e.neg()) : this.neg().mul(e).neg();
        if (e.isNegative()) return this.mul(e.neg()).neg();
        if (this.lt(u4) && e.lt(u4)) return e4(this.toNumber() * e.toNumber(), this.unsigned);
        var t = this.high >>> 16,
            n = 65535 & this.high,
            r = this.low >>> 16,
            a = 65535 & this.low,
            i = e.high >>> 16,
            o = 65535 & e.high,
            s = e.low >>> 16,
            u = 65535 & e.low,
            c = 0,
            l = 0,
            h = 0,
            p = 0;
        return h += (p += a * u) >>> 16, l += (h += r * u) >>> 16, h &= 65535, l += (h += a * s) >>> 16, c += (l += n * u) >>> 16, l &= 65535, c += (l += r * s) >>> 16, l &= 65535, c += (l += a * o) >>> 16, c += t * u + n * s + r * o + a * i, t4((h &= 65535) << 16 | (p &= 65535), (c &= 65535) << 16 | (l &= 65535), this.unsigned)
    }, g4.mul = g4.multiply, g4.divide = function(e) {
        if (J3(e) || (e = a4(e)), e.isZero()) throw Error("division by zero");
        var t, n, r;
        if (X3) return this.unsigned || -2147483648 !== this.high || -1 !== e.low || -1 !== e.high ? t4((this.unsigned ? X3.div_u : X3.div_s)(this.low, this.high, e.low, e.high), X3.get_high(), this.unsigned) : this;
        if (this.isZero()) return this.unsigned ? l4 : c4;
        if (this.unsigned) {
            if (e.unsigned || (e = e.toUnsigned()), e.gt(this)) return l4;
            if (e.gt(this.shru(1))) return p4;
            r = l4
        } else {
            if (this.eq(m4)) return e.eq(h4) || e.eq(f4) ? m4 : e.eq(m4) ? h4 : (t = this.shr(1).div(e).shl(1)).eq(c4) ? e.isNegative() ? h4 : f4 : (n = this.sub(e.mul(t)), r = t.add(n.div(e)));
            if (e.eq(m4)) return this.unsigned ? l4 : c4;
            if (this.isNegative()) return e.isNegative() ? this.neg().div(e.neg()) : this.neg().div(e).neg();
            if (e.isNegative()) return this.div(e.neg()).neg();
            r = c4
        }
        for (n = this; n.gte(e);) {
            t = Math.max(1, Math.floor(n.toNumber() / e.toNumber()));
            for (var a = Math.ceil(Math.log(t) / Math.LN2), i = a <= 48 ? 1 : n4(2, a - 48), o = e4(t), s = o.mul(e); s.isNegative() || s.gt(n);) s = (o = e4(t -= i, this.unsigned)).mul(e);
            o.isZero() && (o = h4), r = r.add(o), n = n.sub(s)
        }
        return r
    }, g4.div = g4.divide, g4.modulo = function(e) {
        return J3(e) || (e = a4(e)), X3 ? t4((this.unsigned ? X3.rem_u : X3.rem_s)(this.low, this.high, e.low, e.high), X3.get_high(), this.unsigned) : this.sub(this.div(e).mul(e))
    }, g4.mod = g4.modulo, g4.rem = g4.modulo, g4.not = function() {
        return t4(~this.low, ~this.high, this.unsigned)
    }, g4.and = function(e) {
        return J3(e) || (e = a4(e)), t4(this.low & e.low, this.high & e.high, this.unsigned)
    }, g4.or = function(e) {
        return J3(e) || (e = a4(e)), t4(this.low | e.low, this.high | e.high, this.unsigned)
    }, g4.xor = function(e) {
        return J3(e) || (e = a4(e)), t4(this.low ^ e.low, this.high ^ e.high, this.unsigned)
    }, g4.shiftLeft = function(e) {
        return J3(e) && (e = e.toInt()), 0 == (e &= 63) ? this : e < 32 ? t4(this.low << e, this.high << e | this.low >>> 32 - e, this.unsigned) : t4(0, this.low << e - 32, this.unsigned)
    }, g4.shl = g4.shiftLeft, g4.shiftRight = function(e) {
        return J3(e) && (e = e.toInt()), 0 == (e &= 63) ? this : e < 32 ? t4(this.low >>> e | this.high << 32 - e, this.high >> e, this.unsigned) : t4(this.high >> e - 32, this.high >= 0 ? 0 : -1, this.unsigned)
    }, g4.shr = g4.shiftRight, g4.shiftRightUnsigned = function(e) {
        if (J3(e) && (e = e.toInt()), 0 === (e &= 63)) return this;
        var t = this.high;
        return e < 32 ? t4(this.low >>> e | t << 32 - e, t >>> e, this.unsigned) : t4(32 === e ? t : t >>> e - 32, 0, this.unsigned)
    }, g4.shru = g4.shiftRightUnsigned, g4.shr_u = g4.shiftRightUnsigned, g4.toSigned = function() {
        return this.unsigned ? t4(this.low, this.high, !1) : this
    }, g4.toUnsigned = function() {
        return this.unsigned ? this : t4(this.low, this.high, !0)
    }, g4.toBytes = function(e) {
        return e ? this.toBytesLE() : this.toBytesBE()
    }, g4.toBytesLE = function() {
        var e = this.high,
            t = this.low;
        return [255 & t, t >>> 8 & 255, t >>> 16 & 255, t >>> 24, 255 & e, e >>> 8 & 255, e >>> 16 & 255, e >>> 24]
    }, g4.toBytesBE = function() {
        var e = this.high,
            t = this.low;
        return [e >>> 24, e >>> 16 & 255, e >>> 8 & 255, 255 & e, t >>> 24, t >>> 16 & 255, t >>> 8 & 255, 255 & t]
    }, Y3.fromBytes = function(e, t, n) {
        return n ? Y3.fromBytesLE(e, t) : Y3.fromBytesBE(e, t)
    }, Y3.fromBytesLE = function(e, t) {
        return new Y3(e[0] | e[1] << 8 | e[2] << 16 | e[3] << 24, e[4] | e[5] << 8 | e[6] << 16 | e[7] << 24, t)
    }, Y3.fromBytesBE = function(e, t) {
        return new Y3(e[4] << 24 | e[5] << 16 | e[6] << 8 | e[7], e[0] << 24 | e[1] << 16 | e[2] << 8 | e[3], t)
    };
    var y4 = r(K3),
        b4 = y4 || t({
            __proto__: null,
            default: y4
        }, [K3]);

    function x4(e) {
        return b4.fromString(e, !0, 16)
    }
    var k4 = x4("c3a5c85c97cb3127"),
        w4 = x4("b492b66fbe98f273"),
        I4 = x4("9ae16a3b2f90404f");

    function N4(e) {
        return e.xor(e.shru(47))
    }

    function S4(e, t, n) {
        var r = e.slice(t, t + n);
        return b4.fromBytes(Array.from(r), !0, !0)
    }

    function T4(e, t) {
        return S4(e, t, 8)
    }

    function E4(e, t) {
        return S4(e, t, 4)
    }

    function C4(e, t) {
        return 0 === t ? e : e.shru(t).or(e.shl(64 - t))
    }

    function A4(e, t) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : x4("9ddfea08eb382d69"),
            r = e.xor(t).mul(n);
        r = r.xor(r.shru(47));
        var a = t.xor(r).mul(n);
        return a = (a = a.xor(a.shru(47))).mul(n)
    }

    function R4(e, t, n, r) {
        return function(e, t, n, r, a, i) {
            a = a.add(e), i = C4(i.add(a).add(r), 21);
            var o = a;
            return a = (a = a.add(t)).add(n), i = i.add(C4(a, 44)), [a.add(r), i.add(o)]
        }(T4(e, t), T4(e, t + 8), T4(e, t + 16), T4(e, t + 24), n, r)
    }

    function _4(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e.length;
        if (t >= 8) {
            var n = I4.add(2 * t),
                r = T4(e, 0).add(I4),
                a = T4(e, t - 8),
                i = C4(a, 37).mul(n).add(r),
                o = C4(r, 25).add(a).mul(n);
            return A4(i, o, n)
        }
        if (t >= 4) {
            var s = I4.add(2 * t),
                u = E4(e, 0);
            return A4(u.shl(3).add(t), E4(e, t - 4), s)
        }
        if (t > 0) {
            var c = e[0],
                l = e[t >> 1],
                h = e[t - 1],
                p = c + (l << 8),
                f = t + (h << 2);
            return N4(I4.mul(p).xor(k4.mul(f))).mul(I4)
        }
        return I4
    }

    function O4(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e.length,
            n = I4.add(2 * t),
            r = T4(e, 0).mul(w4),
            a = T4(e, 8),
            i = T4(e, t - 8).mul(n),
            o = T4(e, t - 16).mul(I4);
        return A4(C4(r.add(a), 43).add(C4(i, 30)).add(o), r.add(C4(a.add(I4), 18)).add(i), n)
    }

    function F4(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e.length,
            n = I4.add(2 * t),
            r = T4(e, 0).mul(I4),
            a = T4(e, 8),
            i = T4(e, t - 8).mul(n),
            o = T4(e, t - 16).mul(I4),
            s = C4(r.add(a), 43).add(C4(i, 30)).add(o),
            u = A4(s, r.add(C4(a.add(I4), 18)).add(i), n),
            c = T4(e, 16).mul(n),
            l = T4(e, 24),
            h = s.add(T4(e, t - 32)).mul(n),
            p = u.add(T4(e, t - 24)).mul(n);
        return A4(C4(c.add(l), 43).add(C4(h, 30)).add(p), c.add(C4(l.add(r), 18)).add(h), n)
    }

    function D4(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e.length,
            n = b4.fromNumber(81, !0);
        if (t <= 32) return t <= 16 ? _4(e, t) : O4(e, t);
        if (t <= 64) return F4(e, t);
        var r = n,
            a = n.mul(w4).add(113),
            i = N4(a.mul(I4).add(113)).mul(I4),
            o = [b4.UZERO, b4.UZERO],
            s = [b4.UZERO, b4.UZERO];
        r = r.mul(I4).add(T4(e, 0));
        var u = 0,
            c = 64 * (t - 1 >> 6),
            l = c + (t - 1 & 63) - 63;
        do {
            r = C4(r.add(a).add(o[0]).add(T4(e, u + 8)), 37).mul(w4), a = C4(a.add(o[1]).add(T4(e, u + 48)), 42).mul(w4), r = r.xor(s[1]), a = a.add(o[0]).add(T4(e, u + 40)), i = C4(i.add(s[0]), 33).mul(w4), o = R4(e, u, o[1].mul(w4), r.add(s[0])), s = R4(e, u + 32, i.add(s[1]), a.add(T4(e, u + 16)));
            var h = [r, i];
            i = h[0], r = h[1], u += 64
        } while (u !== c);
        var p = w4.add(i.and(255).shl(1));
        u = l, s[0] = s[0].add(t - 1 & 63), o[0] = o[0].add(s[0]), s[0] = s[0].add(o[0]), r = C4(r.add(a).add(o[0]).add(T4(e, u + 8)), 37).mul(p), a = C4(a.add(o[1]).add(T4(e, u + 48)), 42).mul(p), r = r.xor(s[1].mul(9)), a = a.add(o[0].mul(9).add(T4(e, u + 40))), i = C4(i.add(s[0]), 33).mul(p), o = R4(e, u, o[1].mul(p), r.add(s[0])), s = R4(e, u + 32, i.add(s[1]), a.add(T4(e, u + 16)));
        var f = [r, i];
        return i = f[0], r = f[1], A4(A4(o[0], s[0], p).add(N4(a).mul(k4)).add(i), A4(o[1], s[1], p).add(r), p)
    }

    function M4(e, t) {
        return "string" === t ? B4(e) : L4([e], t)
    }

    function L4(e, t) {
        if ("string" === t) throw new Error("Cannot convert a string[] to a TypedArray");
        if (Array.isArray(e) && (e = V4(e)), k0().getBool("DEBUG") && X$(e, t), function(e, t) {
                return e instanceof Float32Array && "float32" === t || e instanceof Int32Array && "int32" === t || e instanceof Uint8Array && "bool" === t
            }(e, t)) return e;
        if (null == t || "float32" === t || "complex64" === t) return new Float32Array(e);
        if ("int32" === t) return new Int32Array(e);
        if ("bool" === t) {
            for (var n = new Uint8Array(e.length), r = 0; r < n.length; ++r) 0 !== Math.round(e[r]) && (n[r] = 1);
            return n
        }
        throw new Error("Unknown data type ".concat(t))
    }

    function z4() {
        return k0().platform.now()
    }

    function P4(e, t) {
        return k0().platform.fetch(e, t)
    }

    function B4(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "utf-8";
        return t = t || "utf-8", k0().platform.encode(e, t)
    }

    function W4(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "utf-8";
        return t = t || "utf-8", k0().platform.decode(e, t)
    }

    function U4(e) {
        return null != k0().platform.isTypedArray ? k0().platform.isTypedArray(e) : q3(e)
    }

    function V4(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
            n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        if (null == t && (t = []), "boolean" == typeof e || "number" == typeof e || "string" == typeof e || v0(e) || null == e || U4(e) && n) t.push(e);
        else if (Array.isArray(e) || U4(e))
            for (var r = 0; r < e.length; ++r) V4(e[r], t, n);
        else {
            for (var a = -1, i = 0, o = Object.keys(e); i < o.length; i++) {
                var s = o[i];
                /^([1-9]+[0-9]*|0)$/.test(s) && (a = Math.max(a, Number(s)))
            }
            for (var u = 0; u <= a; u++) V4(e[u], t, n)
        }
        return t
    }
    var G4 = {
            __proto__: null,
            arraysEqual: P$,
            arraysEqualWithNull: z$,
            assert: F$,
            assertNonNegativeIntegerDimensions: p0,
            assertNonNull: M$,
            assertShapesMatch: D$,
            bytesFromStringArray: Q$,
            bytesPerElement: Z$,
            checkConversionForErrors: X$,
            clamp: A$,
            computeStrides: i0,
            convertBackendValuesAndArrayBuffer: u0,
            createScalarValue: M4,
            createShuffledIndices: function(e) {
                for (var t = new Uint32Array(e), n = 0; n < e; ++n) t[n] = n;
                return C$(t), t
            },
            decodeString: W4,
            distSquared: function(e, t) {
                for (var n = 0, r = 0; r < e.length; r++) {
                    var a = Number(e[r]) - Number(t[r]);
                    n += a * a
                }
                return n
            },
            encodeString: B4,
            fetch: P4,
            fingerPrint64: D4,
            flatten: V4,
            getArrayFromDType: K$,
            getTypedArrayFromDType: q$,
            hasEncodingLoss: J$,
            hexToLong: x4,
            indexToLoc: d0,
            inferDtype: n0,
            inferFromImplicitShape: G$,
            isBoolean: e0,
            isFunction: r0,
            isInt: B$,
            isNumber: t0,
            isPromise: v0,
            isScalarShape: function(e) {
                return 0 === e.length
            },
            isString: $$,
            isTypedArray: U4,
            isValidDtype: Y$,
            locToIndex: f0,
            makeOnesTypedArray: c0,
            makeZerosNestedTypedArray: h0,
            makeZerosTypedArray: l0,
            nearestDivisor: a0,
            nearestLargerEven: R$,
            now: z4,
            parseAxisParam: j$,
            randUniform: function(e, t) {
                var n = Math.random();
                return t * n + (1 - n) * e
            },
            repeatedTry: V$,
            rightPad: U$,
            shuffle: C$,
            shuffleCombo: function(e, t) {
                if (e.length !== t.length) throw new Error("Array sizes must match to be shuffled together " + "First array length was ".concat(e.length) + "Second array length was ".concat(t.length));
                for (var n = e.length, r = 0; n > 0;) r = Math.random() * n | 0, _$(e, --n, r), _$(t, n, r)
            },
            sizeFromShape: L$,
            sizeToSquarishShape: W$,
            squeezeShape: H$,
            sum: O$,
            swap: _$,
            tanh: function(e) {
                if (null != Math.tanh) return Math.tanh(e);
                if (e === 1 / 0) return 1;
                if (e === -1 / 0) return -1;
                var t = Math.exp(2 * e);
                return (t - 1) / (t + 1)
            },
            toNestedArray: s0,
            toTypedArray: L4
        },
        j4 = function() {
            function e(t, n) {
                l(this, e), this.backendTimer = t, this.logger = n, null == n && (this.logger = new H4)
            }
            return p(e, [{
                key: "profileKernel",
                value: function(e, t, n) {
                    var r, a, i = function() {
                            r = n()
                        },
                        o = z4();
                    if (this.backendTimer.timerAvailable()) a = this.backendTimer.time(i);
                    else {
                        i();
                        var s, u = O(r);
                        try {
                            for (u.s(); !(s = u.n()).done;) {
                                s.value.dataSync()
                            }
                        } catch (e) {
                            u.e(e)
                        } finally {
                            u.f()
                        }
                        a = Promise.resolve({
                            kernelMs: z4() - o
                        })
                    }
                    if (k0().getBool("CHECK_COMPUTATION_FOR_ERRORS"))
                        for (var c = function() {
                                var t = r[l];
                                t.data().then((function(n) {
                                    ! function(e, t, n) {
                                        if ("float32" !== t) return !1;
                                        for (var r = 0; r < e.length; r++) {
                                            var a = e[r];
                                            if (isNaN(a) || !isFinite(a)) return console.warn("Found ".concat(a, " in the result of '").concat(n, "'")), !0
                                        }
                                    }(n, t.dtype, e)
                                }))
                            }, l = 0; l < r.length; l++) c();
                    return {
                        kernelName: e,
                        outputs: r,
                        inputs: t,
                        timeMs: a.then((function(e) {
                            return e.kernelMs
                        })),
                        extraInfo: a.then((function(e) {
                            return null != e.getExtraProfileInfo ? e.getExtraProfileInfo() : ""
                        }))
                    }
                }
            }, {
                key: "logKernelProfile",
                value: function(e) {
                    var t = this,
                        n = e.kernelName,
                        r = e.outputs,
                        a = e.timeMs,
                        i = e.inputs,
                        o = e.extraInfo;
                    r.forEach((function(e) {
                        Promise.all([e.data(), a, o]).then((function(r) {
                            t.logger.logKernelProfile(n, e, r[0], r[1], i, r[2])
                        }))
                    }))
                }
            }]), e
        }();
    var H4 = function() {
        function e() {
            l(this, e)
        }
        return p(e, [{
            key: "logKernelProfile",
            value: function(e, t, n, r, a, i) {
                var o = "number" == typeof r ? U$("".concat(r, "ms"), 9) : r.error,
                    s = U$(e, 25),
                    u = t.rank,
                    c = t.size,
                    l = U$(t.shape.toString(), 14),
                    h = "";
                for (var p in a) {
                    var f = a[p];
                    if (null != f) {
                        var d = f.shape || t.shape,
                            v = d.length;
                        h += "".concat(p, ": ").concat(v, "D ").concat(v > 0 ? d : "", " ")
                    }
                }
                console.log("%c".concat(s, "\t%c").concat(o, "\t%c").concat(u, "D ").concat(l, "\t%c").concat(c, "\t%c").concat(h, "\t%c").concat(i), "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue")
            }
        }]), e
    }();

    function q4(e, t, n) {
        for (var r = {}, a = {}, i = 0; i < t.length; i++) r[t[i].id] = !0;
        for (var o = 0; o < e.length; o++) {
            var s = e[o],
                u = s.inputs;
            for (var c in u) {
                for (var l = u[c], h = !1, p = 0; p < t.length; p++)
                    if (r[l.id]) {
                        s.outputs.forEach((function(e) {
                            return r[e.id] = !0
                        })), h = !0, a[s.id] = !0;
                        break
                    }
                if (h) break
            }
        }
        var f = {};
        f[n.id] = !0;
        for (var d = {}, v = e.length - 1; v >= 0; v--)
            for (var m = e[v], g = m.inputs, y = 0; y < m.outputs.length; y++)
                if (f[m.outputs[y].id]) {
                    for (var b in g) f[g[b].id] = !0, d[m.id] = !0;
                    break
                }
        for (var x = [], k = 0; k < e.length; k++) {
            var w = e[k];
            if (a[w.id] && d[w.id]) {
                var I = {};
                for (var N in w.inputs) {
                    var S = w.inputs[N];
                    r[S.id] && (I[N] = S)
                }
                var T = Object.assign({}, w);
                T.inputs = I, T.outputs = w.outputs, x.push(T)
            }
        }
        return x
    }

    function K4(e, t, n, r) {
        for (var a = function() {
                var a = t[i],
                    o = [];
                if (a.outputs.forEach((function(t) {
                        var n = e[t.id];
                        null != n ? o.push(n) : o.push(null)
                    })), null == a.gradient) throw new Error("Cannot compute gradient: gradient function not found " + "for ".concat(a.kernelName, "."));
                var s = a.gradient(o),
                    u = function(t) {
                        if (!(t in s)) throw new Error("Cannot backprop through input ".concat(t, ". ") + "Available gradients found: ".concat(Object.keys(s), "."));
                        var i = n((function() {
                            return s[t]()
                        }));
                        if ("float32" !== i.dtype) throw new Error("Error in gradient for op ".concat(a.kernelName, ". The gradient of input ") + "".concat(t, " must have 'float32' dtype, but has '").concat(i.dtype, "'"));
                        var o = a.inputs[t];
                        if (!P$(i.shape, o.shape)) throw new Error("Error in gradient for op ".concat(a.kernelName, ". The gradient of input ") + "'".concat(t, "' has shape '").concat(i.shape, "', which does not match ") + "the shape of the input '".concat(o.shape, "'"));
                        if (null == e[o.id]) e[o.id] = i;
                        else {
                            var u = e[o.id];
                            e[o.id] = r(u, i), u.dispose()
                        }
                    };
                for (var c in a.inputs) u(c)
            }, i = t.length - 1; i >= 0; i--) a()
    }

    function X4(e, t, n, r) {
        var a = i0(t),
            i = function(e, t, n, r) {
                var a = L$(t),
                    i = r[r.length - 1],
                    o = new Array(i).fill(0),
                    s = t.length,
                    u = "complex64" === n ? Q4(e) : e;
                if (s > 1)
                    for (var c = 0; c < a / i; c++)
                        for (var l = c * i, h = 0; h < i; h++) o[h] = Math.max(o[h], Y4(u[l + h], 0, n).length);
                return o
            }(e, t, n, a),
            o = t.length,
            s = Z4(e, t, n, a, i),
            u = ["Tensor"];
        return r && (u.push("  dtype: ".concat(n)), u.push("  rank: ".concat(o)), u.push("  shape: [".concat(t, "]")), u.push("  values:")), u.push(s.map((function(e) {
            return "    " + e
        })).join("\n")), u.join("\n")
    }

    function Y4(e, t, n) {
        return U$(Array.isArray(e) ? "".concat(parseFloat(e[0].toFixed(7)), " + ") + "".concat(parseFloat(e[1].toFixed(7)), "j") : $$(e) ? "'".concat(e, "'") : "bool" === n ? J4(e) : parseFloat(e.toFixed(7)).toString(), t)
    }

    function J4(e) {
        return 0 === e ? "false" : "true"
    }

    function Z4(e, t, n, r, a) {
        var i = !(arguments.length > 5 && void 0 !== arguments[5]) || arguments[5],
            o = "complex64" === n ? 2 : 1,
            s = t[0],
            u = t.length;
        if (0 === u) {
            if ("complex64" === n) {
                var c = Q4(e);
                return [Y4(c[0], 0, n)]
            }
            return "bool" === n ? [J4(e[0])] : [e[0].toString()]
        }
        if (1 === u) {
            if (s > 20) {
                var l = 3 * o,
                    h = Array.from(e.slice(0, l)),
                    p = Array.from(e.slice((s - 3) * o, s * o));
                return "complex64" === n && (h = Q4(h), p = Q4(p)), ["[" + h.map((function(e, t) {
                    return Y4(e, a[t], n)
                })).join(", ") + ", ..., " + p.map((function(e, t) {
                    return Y4(e, a[s - 3 + t], n)
                })).join(", ") + "]"]
            }
            var f = "complex64" === n ? Q4(e) : Array.from(e);
            return ["[" + f.map((function(e, t) {
                return Y4(e, a[t], n)
            })).join(", ") + "]"]
        }
        var d = t.slice(1),
            v = r.slice(1),
            m = r[0] * o,
            g = [];
        if (s > 20) {
            for (var y = 0; y < 3; y++) {
                var b = y * m,
                    x = b + m;
                g.push.apply(g, T(Z4(e.slice(b, x), d, n, v, a, !1)))
            }
            g.push("...");
            for (var k = s - 3; k < s; k++) {
                var w = k * m,
                    I = w + m;
                g.push.apply(g, T(Z4(e.slice(w, I), d, n, v, a, k === s - 1)))
            }
        } else
            for (var N = 0; N < s; N++) {
                var S = N * m,
                    E = S + m;
                g.push.apply(g, T(Z4(e.slice(S, E), d, n, v, a, N === s - 1)))
            }
        var C = 2 === u ? "," : "";
        g[0] = "[" + (s > 0 ? g[0] + C : "");
        for (var A = 1; A < g.length - 1; A++) g[A] = " " + g[A] + C;
        for (var R = ",\n", _ = 2; _ < u; _++) R += "\n";
        return g[g.length - 1] = " " + g[g.length - 1] + "]" + (i ? "" : R), g
    }

    function Q4(e) {
        for (var t = [], n = 0; n < e.length; n += 2) t.push([e[n], e[n + 1]]);
        return t
    }
    var $4 = function() {
            function e(t, n, r) {
                var a = this;
                if (l(this, e), this.dtype = n, this.shape = t.slice(), this.size = L$(t), null != r) {
                    var i = r.length;
                    F$(i === this.size, (function() {
                        return "Length of values '".concat(i, "' does not match the size ") + "inferred by the shape '".concat(a.size, "'.")
                    }))
                }
                if ("complex64" === n) throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
                this.values = r || K$(n, this.size), this.strides = i0(t)
            }
            return p(e, [{
                key: "set",
                value: function(e) {
                    for (var t = this, n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), a = 1; a < n; a++) r[a - 1] = arguments[a];
                    0 === r.length && (r = [0]), F$(r.length === this.rank, (function() {
                        return "The number of provided coordinates (".concat(r.length, ") must ") + "match the rank (".concat(t.rank, ")")
                    }));
                    var i = this.locToIndex(r);
                    this.values[i] = e
                }
            }, {
                key: "get",
                value: function() {
                    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                    0 === t.length && (t = [0]);
                    for (var r = 0, a = 0, i = t; a < i.length; a++) {
                        var o = i[a];
                        if (o < 0 || o >= this.shape[r]) {
                            var s = "Requested out of range element at ".concat(t, ". ") + "  Buffer shape=".concat(this.shape);
                            throw new Error(s)
                        }
                        r++
                    }
                    for (var u = t[t.length - 1], c = 0; c < t.length - 1; ++c) u += this.strides[c] * t[c];
                    return this.values[u]
                }
            }, {
                key: "locToIndex",
                value: function(e) {
                    if (0 === this.rank) return 0;
                    if (1 === this.rank) return e[0];
                    for (var t = e[e.length - 1], n = 0; n < e.length - 1; ++n) t += this.strides[n] * e[n];
                    return t
                }
            }, {
                key: "indexToLoc",
                value: function(e) {
                    if (0 === this.rank) return [];
                    if (1 === this.rank) return [e];
                    for (var t = new Array(this.shape.length), n = 0; n < t.length - 1; ++n) t[n] = Math.floor(e / this.strides[n]), e -= t[n] * this.strides[n];
                    return t[t.length - 1] = e, t
                }
            }, {
                key: "rank",
                get: function() {
                    return this.shape.length
                }
            }, {
                key: "toTensor",
                value: function() {
                    return e5().makeTensor(this.values, this.shape, this.dtype)
                }
            }]), e
        }(),
        e5 = null,
        t5 = null;
    var n5 = function() {
        function e(t, n, r, a) {
            l(this, e), this.kept = !1, this.isDisposedInternal = !1, this.shape = t.slice(), this.dtype = n || "float32", this.size = L$(t), this.strides = i0(t), this.dataId = r, this.id = a, this.rankType = this.rank < 5 ? this.rank.toString() : "higher"
        }
        var t, n, r, a;
        return p(e, [{
            key: "rank",
            get: function() {
                return this.shape.length
            }
        }, {
            key: "buffer",
            value: (a = c(o().mark((function e() {
                var t;
                return o().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return e.next = 2, this.data();
                        case 2:
                            return t = e.sent, e.abrupt("return", t5.buffer(this.shape, this.dtype, t));
                        case 4:
                        case "end":
                            return e.stop()
                    }
                }), e, this)
            }))), function() {
                return a.apply(this, arguments)
            })
        }, {
            key: "bufferSync",
            value: function() {
                return t5.buffer(this.shape, this.dtype, this.dataSync())
            }
        }, {
            key: "array",
            value: (r = c(o().mark((function e() {
                var t;
                return o().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return e.next = 2, this.data();
                        case 2:
                            return t = e.sent, e.abrupt("return", s0(this.shape, t, "complex64" === this.dtype));
                        case 4:
                        case "end":
                            return e.stop()
                    }
                }), e, this)
            }))), function() {
                return r.apply(this, arguments)
            })
        }, {
            key: "arraySync",
            value: function() {
                return s0(this.shape, this.dataSync(), "complex64" === this.dtype)
            }
        }, {
            key: "data",
            value: (n = c(o().mark((function e() {
                var t, n;
                return o().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if (this.throwIfDisposed(), t = e5().read(this.dataId), "string" !== this.dtype) {
                                e.next = 13;
                                break
                            }
                            return e.next = 5, t;
                        case 5:
                            return n = e.sent, e.prev = 6, e.abrupt("return", n.map((function(e) {
                                return W4(e)
                            })));
                        case 10:
                            throw e.prev = 10, e.t0 = e.catch(6), new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
                        case 13:
                            return e.abrupt("return", t);
                        case 14:
                        case "end":
                            return e.stop()
                    }
                }), e, this, [
                    [6, 10]
                ])
            }))), function() {
                return n.apply(this, arguments)
            })
        }, {
            key: "dataToGPU",
            value: function(e) {
                return this.throwIfDisposed(), e5().readToGPU(this.dataId, e)
            }
        }, {
            key: "dataSync",
            value: function() {
                this.throwIfDisposed();
                var e = e5().readSync(this.dataId);
                if ("string" === this.dtype) try {
                    return e.map((function(e) {
                        return W4(e)
                    }))
                } catch (e) {
                    throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")
                }
                return e
            }
        }, {
            key: "bytes",
            value: (t = c(o().mark((function e() {
                var t;
                return o().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return this.throwIfDisposed(), e.next = 3, e5().read(this.dataId);
                        case 3:
                            if (t = e.sent, "string" !== this.dtype) {
                                e.next = 8;
                                break
                            }
                            return e.abrupt("return", t);
                        case 8:
                            return e.abrupt("return", new Uint8Array(t.buffer));
                        case 9:
                        case "end":
                            return e.stop()
                    }
                }), e, this)
            }))), function() {
                return t.apply(this, arguments)
            })
        }, {
            key: "dispose",
            value: function() {
                this.isDisposed || (this.kerasMask && this.kerasMask.dispose(), e5().disposeTensor(this), this.isDisposedInternal = !0)
            }
        }, {
            key: "isDisposed",
            get: function() {
                return this.isDisposedInternal
            }
        }, {
            key: "throwIfDisposed",
            value: function() {
                if (this.isDisposed) throw new Error("Tensor is disposed.")
            }
        }, {
            key: "print",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                return t5.print(this, e)
            }
        }, {
            key: "clone",
            value: function() {
                return this.throwIfDisposed(), t5.clone(this)
            }
        }, {
            key: "toString",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
                    t = this.dataSync();
                return X4(t, this.shape, this.dtype, e)
            }
        }, {
            key: "cast",
            value: function(e) {
                return this.throwIfDisposed(), t5.cast(this, e)
            }
        }, {
            key: "variable",
            value: function() {
                var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
                    t = arguments.length > 1 ? arguments[1] : void 0,
                    n = arguments.length > 2 ? arguments[2] : void 0;
                return this.throwIfDisposed(), e5().makeVariable(this, e, t, n)
            }
        }]), e
    }();

    function r5() {
        return I0("Tensor", (function() {
            return n5
        }))
    }
    Object.defineProperty(n5, Symbol.hasInstance, {
        value: function(e) {
            return !!e && null != e.data && null != e.dataSync && null != e.throwIfDisposed
        }
    }), r5();
    var a5, i5, o5, s5, u5, c5 = function(e) {
        d(n, e);
        var t = w(n);

        function n(e, r, a, i) {
            var o;
            return l(this, n), (o = t.call(this, e.shape, e.dtype, e.dataId, i)).trainable = r, o.name = a, o
        }
        return p(n, [{
            key: "assign",
            value: function(e) {
                if (e.dtype !== this.dtype) throw new Error("dtype of the new value (".concat(e.dtype, ") and ") + "previous value (".concat(this.dtype, ") must match"));
                if (!P$(e.shape, this.shape)) throw new Error("shape of the new value (".concat(e.shape, ") and ") + "previous value (".concat(this.shape, ") must match"));
                e5().disposeTensor(this), this.dataId = e.dataId, e5().incRef(this, null)
            }
        }, {
            key: "dispose",
            value: function() {
                e5().disposeVariable(this), this.isDisposedInternal = !0
            }
        }]), n
    }(n5);
    Object.defineProperty(c5, Symbol.hasInstance, {
            value: function(e) {
                return e instanceof n5 && null != e.assign && e.assign instanceof Function
            }
        }), e.Rank = void 0, (a5 = e.Rank || (e.Rank = {})).R0 = "R0", a5.R1 = "R1", a5.R2 = "R2", a5.R3 = "R3", a5.R4 = "R4", a5.R5 = "R5", a5.R6 = "R6",
        function(e) {
            e.float32 = "float32", e.int32 = "int32", e.bool = "int32", e.complex64 = "complex64"
        }(i5 || (i5 = {})),
        function(e) {
            e.float32 = "float32", e.int32 = "int32", e.bool = "bool", e.complex64 = "complex64"
        }(o5 || (o5 = {})),
        function(e) {
            e.float32 = "float32", e.int32 = "float32", e.bool = "float32", e.complex64 = "complex64"
        }(s5 || (s5 = {})),
        function(e) {
            e.float32 = "complex64", e.int32 = "complex64", e.bool = "complex64", e.complex64 = "complex64"
        }(u5 || (u5 = {}));
    var l5 = {
        float32: s5,
        int32: i5,
        bool: o5,
        complex64: u5
    };

    function h5(e, t) {
        if ("string" === e || "string" === t) {
            if ("string" === e && "string" === t) return "string";
            throw new Error("Can not upcast ".concat(e, " with ").concat(t))
        }
        return l5[e][t]
    }

    function p5(e) {
        return h5(e, "int32")
    }

    function f5(e) {
        return null != e && "object" === s(e) && "texture" in e && e.texture instanceof WebGLTexture
    }

    function d5(e) {
        return "undefined" != typeof GPUBuffer && null != e && "object" === s(e) && "buffer" in e && e.buffer instanceof GPUBuffer
    }

    function v5(e, t) {
        if (e.dtype === t.dtype) return [e, t];
        var n = h5(e.dtype, t.dtype);
        return [e.cast(n), t.cast(n)]
    }

    function m5(e, t) {
        F$(e.dtype === t.dtype, (function() {
            return "The dtypes of the first(".concat(e.dtype, ") and") + " second(".concat(t.dtype, ") input must match")
        }))
    }

    function g5(e, t) {
        return t.some((function(t) {
            return t.id === e.id
        }))
    }

    function y5(e) {
        var t = [];
        return b5(e, t, new Set), t
    }

    function b5(e, t, n) {
        if (null != e)
            if (e instanceof n5) t.push(e);
            else if (r = e, Array.isArray(r) || "object" === s(r)) {
            var r, a = e;
            for (var i in a) {
                var o = a[i];
                n.has(o) || (n.add(o), b5(o, t, n))
            }
        }
    }
    var x5 = {
        __proto__: null,
        assertTypesMatch: m5,
        getTensorsInContainer: y5,
        isTensorInList: g5,
        makeTypesMatch: v5
    };

    function k5(e) {
        return null != e.kernelName
    }
    var w5 = function() {
            function e() {
                l(this, e), this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = new WeakMap, this.profiling = !1, this.activeProfile = {
                    newBytes: 0,
                    newTensors: 0,
                    peakBytes: 0,
                    kernels: [],
                    result: null,
                    get kernelNames() {
                        return Array.from(new Set(this.kernels.map((function(e) {
                            return e.name
                        }))))
                    }
                }
            }
            return p(e, [{
                key: "dispose",
                value: function() {
                    for (var e in this.registeredVariables) this.registeredVariables[e].dispose()
                }
            }]), e
        }(),
        I5 = function() {
            function e(t) {
                l(this, e), this.ENV = t, this.registry = {}, this.registryFactory = {}, this.pendingBackendInitId = 0, this.state = new w5
            }
            var t, n, r, a;
            return p(e, [{
                key: "ready",
                value: (a = c(o().mark((function e() {
                    var t, n, r;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (null == this.pendingBackendInit) {
                                    e.next = 2;
                                    break
                                }
                                return e.abrupt("return", this.pendingBackendInit.then((function() {})));
                            case 2:
                                if (null == this.backendInstance) {
                                    e.next = 4;
                                    break
                                }
                                return e.abrupt("return");
                            case 4:
                                t = this.getSortedBackends(), n = 0;
                            case 6:
                                if (!(n < t.length)) {
                                    e.next = 18;
                                    break
                                }
                                return r = t[n], e.next = 10, this.initializeBackend(r).success;
                            case 10:
                                if (!e.sent) {
                                    e.next = 15;
                                    break
                                }
                                return e.next = 14, this.setBackend(r);
                            case 14:
                                return e.abrupt("return");
                            case 15:
                                n++, e.next = 6;
                                break;
                            case 18:
                                throw new Error("Could not initialize any backends, all backend initializations failed.");
                            case 19:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return a.apply(this, arguments)
                })
            }, {
                key: "backend",
                get: function() {
                    if (null != this.pendingBackendInit) throw new Error("Backend '".concat(this.backendName, "' has not yet been initialized. Make ") + "sure to await tf.ready() or await tf.setBackend() before calling other methods");
                    if (null == this.backendInstance) {
                        var e = this.initializeBackendsAndReturnBest(),
                            t = e.name;
                        if (e.asyncInit) throw new Error("The highest priority backend '".concat(t, "' has not yet been ") + "initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");
                        this.setBackend(t)
                    }
                    return this.backendInstance
                }
            }, {
                key: "backendNames",
                value: function() {
                    return Object.keys(this.registryFactory)
                }
            }, {
                key: "findBackend",
                value: function(e) {
                    if (!(e in this.registry)) {
                        if (!(e in this.registryFactory)) return null;
                        if (this.initializeBackend(e).asyncInit) return null
                    }
                    return this.registry[e]
                }
            }, {
                key: "findBackendFactory",
                value: function(e) {
                    return e in this.registryFactory ? this.registryFactory[e].factory : null
                }
            }, {
                key: "registerBackend",
                value: function(e, t) {
                    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                    return e in this.registryFactory ? (z3("".concat(e, " backend was already registered. ") + "Reusing existing backend factory."), !1) : (this.registryFactory[e] = {
                        factory: t,
                        priority: n
                    }, !0)
                }
            }, {
                key: "setBackend",
                value: (r = c(o().mark((function e(t) {
                    var n, r;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (null != this.registryFactory[t]) {
                                    e.next = 2;
                                    break
                                }
                                throw new Error("Backend name '".concat(t, "' not found in registry"));
                            case 2:
                                if (this.backendName = t, null != this.registry[t]) {
                                    e.next = 16;
                                    break
                                }
                                if (this.backendInstance = null, n = this.initializeBackend(t), r = n.success, !n.asyncInit) {
                                    e.next = 12;
                                    break
                                }
                                return e.next = 9, r;
                            case 9:
                                e.t0 = e.sent, e.next = 13;
                                break;
                            case 12:
                                e.t0 = r;
                            case 13:
                                if (e.t0) {
                                    e.next = 16;
                                    break
                                }
                                return e.abrupt("return", !1);
                            case 16:
                                return this.backendInstance = this.registry[t], this.setupRegisteredKernels(), this.profiler = new j4(this.backendInstance), e.abrupt("return", !0);
                            case 20:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e) {
                    return r.apply(this, arguments)
                })
            }, {
                key: "setupRegisteredKernels",
                value: function() {
                    var e = this;
                    V3(this.backendName).forEach((function(t) {
                        null != t.setupFunc && t.setupFunc(e.backendInstance)
                    }))
                }
            }, {
                key: "disposeRegisteredKernels",
                value: function(e) {
                    var t = this;
                    V3(e).forEach((function(n) {
                        null != n.disposeFunc && n.disposeFunc(t.registry[e])
                    }))
                }
            }, {
                key: "initializeBackend",
                value: function(e) {
                    var t = this,
                        n = this.registryFactory[e];
                    if (null == n) throw new Error("Cannot initialize backend ".concat(e, ", no registration found."));
                    try {
                        var r = n.factory();
                        if (!r || r instanceof T$ || "function" != typeof r.then) return this.registry[e] = r, {
                            success: !0,
                            asyncInit: !1
                        };
                        var a = ++this.pendingBackendInitId,
                            i = r.then((function(n) {
                                return !(a < t.pendingBackendInitId) && (t.registry[e] = n, t.pendingBackendInit = null, !0)
                            })).catch((function(n) {
                                return a < t.pendingBackendInitId || (t.pendingBackendInit = null, z3("Initialization of backend ".concat(e, " failed")), z3(n.stack || n.message)), !1
                            }));
                        return this.pendingBackendInit = i, {
                            success: i,
                            asyncInit: !0
                        }
                    } catch (t) {
                        return z3("Initialization of backend ".concat(e, " failed")), z3(t.stack || t.message), {
                            success: !1,
                            asyncInit: !1
                        }
                    }
                }
            }, {
                key: "removeBackend",
                value: function(e) {
                    if (!(e in this.registryFactory)) throw new Error("".concat(e, " backend not found in registry"));
                    this.backendName === e && null != this.pendingBackendInit && this.pendingBackendInitId++, e in this.registry && (this.disposeRegisteredKernels(e), this.registry[e].dispose(), delete this.registry[e]), delete this.registryFactory[e], this.backendName === e && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null)
                }
            }, {
                key: "getSortedBackends",
                value: function() {
                    var e = this;
                    if (0 === Object.keys(this.registryFactory).length) throw new Error("No backend found in registry.");
                    return Object.keys(this.registryFactory).sort((function(t, n) {
                        return e.registryFactory[n].priority - e.registryFactory[t].priority
                    }))
                }
            }, {
                key: "initializeBackendsAndReturnBest",
                value: function() {
                    for (var e = this.getSortedBackends(), t = 0; t < e.length; t++) {
                        var n = e[t],
                            r = this.initializeBackend(n),
                            a = r.success,
                            i = r.asyncInit;
                        if (i || a) return {
                            name: n,
                            asyncInit: i
                        }
                    }
                    throw new Error("Could not initialize any backends, all backend initializations failed.")
                }
            }, {
                key: "moveData",
                value: function(e, t) {
                    var n = this.state.tensorInfo.get(t),
                        r = n.backend,
                        a = this.readSync(t),
                        i = r.refCount(t);
                    r.disposeData(t, !0), n.backend = e, e.move(t, a, n.shape, n.dtype, i), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++
                }
            }, {
                key: "tidy",
                value: function(e, t) {
                    var n, r = this,
                        a = null;
                    if (null == t) {
                        if ("function" != typeof e) throw new Error("Please provide a function to tidy()");
                        t = e
                    } else {
                        if ("string" != typeof e && !(e instanceof String)) throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
                        if ("function" != typeof t) throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
                        a = e
                    }
                    return this.scopedRun((function() {
                        return r.startScope(a)
                    }), (function() {
                        return r.endScope(n)
                    }), (function() {
                        return (n = t()) instanceof Promise && console.error("Cannot return a Promise inside of tidy."), n
                    }))
                }
            }, {
                key: "scopedRun",
                value: function(e, t, n) {
                    e();
                    try {
                        var r = n();
                        return t(), r
                    } catch (e) {
                        throw t(), e
                    }
                }
            }, {
                key: "nextTensorId",
                value: function() {
                    return e.nextTensorId++
                }
            }, {
                key: "nextVariableId",
                value: function() {
                    return e.nextVariableId++
                }
            }, {
                key: "clone",
                value: function(e) {
                    var t = E5.runKernel(W1, {
                            x: e
                        }),
                        n = {
                            x: e
                        };
                    return this.addTapeNode(this.state.activeScope.name, n, [t], (function(e) {
                        return {
                            x: function() {
                                var t = {
                                        x: e
                                    },
                                    n = {
                                        dtype: "float32"
                                    };
                                return E5.runKernel(X0, t, n)
                            }
                        }
                    }), [], {}), t
                }
            }, {
                key: "runKernel",
                value: function(e, t, n) {
                    if (null == this.backendName && this.backend, !(null != W3(e, this.backendName))) throw new Error("Kernel '".concat(e, "' not registered for backend '").concat(this.backendName, "'"));
                    return this.runKernelFunc({
                        kernelName: e,
                        inputs: t,
                        attrs: n
                    })
                }
            }, {
                key: "shouldCheckForMemLeaks",
                value: function() {
                    return this.ENV.getBool("IS_TEST")
                }
            }, {
                key: "checkKernelForMemLeak",
                value: function(e, t, n) {
                    var r = this.backend.numDataIds(),
                        a = 0;
                    n.forEach((function(e) {
                        a += "complex64" === e.dtype ? 3 : 1
                    }));
                    var i = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1],
                        o = r - t - a - i;
                    if (o > 0) throw new Error("Backend '".concat(this.backendName, "' has an internal memory leak ") + "(".concat(o, " data ids) after running '").concat(e, "'"))
                }
            }, {
                key: "runKernelFunc",
                value: function(e) {
                    var t, n, r, a = this,
                        i = [],
                        o = this.isTapeOn(),
                        s = this.state.numBytes,
                        u = this.state.numTensors;
                    this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0), null == this.backendName && this.backend;
                    var c = k5(e) ? e.kernelName : null != this.state.activeScope ? this.state.activeScope.name : "";
                    if (k5(e)) {
                        var l = e.kernelName,
                            h = e.inputs,
                            p = e.attrs;
                        null == this.backendName && this.backend;
                        var f = W3(l, this.backendName);
                        F$(null != f, (function() {
                            return "Cannot find registered kernel '".concat(l, "' for backend '").concat(a.backendName, "'")
                        })), n = function() {
                            var e = a.backend.numDataIds();
                            r = f.kernelFunc({
                                inputs: h,
                                attrs: p,
                                backend: a.backend
                            });
                            var t = Array.isArray(r) ? r : [r];
                            a.shouldCheckForMemLeaks() && a.checkKernelForMemLeak(l, e, t);
                            var n = t.map((function(e) {
                                return null != e.rank ? e : a.makeTensorFromTensorInfo(e)
                            }));
                            if (o) {
                                var s = a.getTensorsForGradient(l, h, n);
                                i = a.saveTensorsForBackwardMode(s)
                            }
                            return n
                        }
                    } else {
                        var d = e.forwardFunc,
                            v = function(e) {
                                o && (i = e.map((function(e) {
                                    return a.keep(a.clone(e))
                                })))
                            };
                        n = function() {
                            var e = a.backend.numDataIds();
                            r = a.tidy((function() {
                                return d(a.backend, v)
                            }));
                            var t = Array.isArray(r) ? r : [r];
                            return a.shouldCheckForMemLeaks() && a.checkKernelForMemLeak(c, e, t), t
                        }
                    }
                    var m, g = e.inputs,
                        y = e.attrs,
                        b = k5(e) ? null : e.backwardsFunc;
                    return this.scopedRun((function() {
                        return a.state.kernelDepth++
                    }), (function() {
                        return a.state.kernelDepth--
                    }), (function() {
                        a.ENV.getBool("DEBUG") || a.state.profiling ? (m = a.profiler.profileKernel(c, g, (function() {
                            return n()
                        })), a.ENV.getBool("DEBUG") && a.profiler.logKernelProfile(m), t = m.outputs) : t = n()
                    })), o && this.addTapeNode(c, g, t, b, i, y), this.state.profiling && this.state.activeProfile.kernels.push({
                        name: c,
                        bytesAdded: this.state.numBytes - s,
                        totalBytesSnapshot: this.state.numBytes,
                        tensorsAdded: this.state.numTensors - u,
                        totalTensorsSnapshot: this.state.numTensors,
                        inputShapes: Object.keys(g).map((function(e) {
                            return null != g[e] ? g[e].shape : null
                        })),
                        outputShapes: t.map((function(e) {
                            return e.shape
                        })),
                        kernelTimeMs: m.timeMs,
                        extraInfo: m.extraInfo
                    }), Array.isArray(r) ? t : t[0]
                }
            }, {
                key: "saveTensorsForBackwardMode",
                value: function(e) {
                    var t = this,
                        n = e.map((function(e) {
                            return t.keep(t.clone(e))
                        }));
                    return n
                }
            }, {
                key: "getTensorsForGradient",
                value: function(e, t, n) {
                    var r = U3(e);
                    if (null != r) {
                        var a, i = r.inputsToSave || [],
                            o = r.outputsToSave || [];
                        r.saveAllInputs ? (F$(Array.isArray(t), (function() {
                            return "saveAllInputs is true, expected inputs to be an array."
                        })), a = Object.keys(t).map((function(e) {
                            return t[e]
                        }))) : a = i.map((function(e) {
                            return t[e]
                        }));
                        var s = n.filter((function(e, t) {
                            return o[t]
                        }));
                        return a.concat(s)
                    }
                    return []
                }
            }, {
                key: "makeTensor",
                value: function(e, t, n, r) {
                    if (null == e) throw new Error("Values passed to engine.makeTensor() are null");
                    n = n || "float32", r = r || this.backend;
                    var a = e;
                    "string" === n && $$(e[0]) && (a = e.map((function(e) {
                        return B4(e)
                    })));
                    var i = r.write(a, t, n),
                        o = new n5(t, n, i, this.nextTensorId());
                    if (this.trackTensor(o, r), "string" === n) {
                        var s = this.state.tensorInfo.get(i),
                            u = Q$(a);
                        this.state.numBytes += u - s.bytes, s.bytes = u
                    }
                    return o
                }
            }, {
                key: "makeTensorFromDataId",
                value: function(e, t, n, r) {
                    var a = {
                        dataId: e,
                        shape: t,
                        dtype: n = n || "float32"
                    };
                    return this.makeTensorFromTensorInfo(a, r)
                }
            }, {
                key: "makeTensorFromTensorInfo",
                value: function(e, t) {
                    var n = e.dataId,
                        r = e.shape,
                        a = e.dtype,
                        i = new n5(r, a, n, this.nextTensorId());
                    return this.trackTensor(i, t), i
                }
            }, {
                key: "makeVariable",
                value: function(e) {
                    var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                        n = arguments.length > 2 ? arguments[2] : void 0,
                        r = arguments.length > 3 ? arguments[3] : void 0;
                    n = n || this.nextVariableId().toString(), null != r && r !== e.dtype && (e = e.cast(r));
                    var a = new c5(e, t, n, this.nextTensorId());
                    if (null != this.state.registeredVariables[a.name]) throw new Error("Variable with name ".concat(a.name, " was already registered"));
                    return this.state.registeredVariables[a.name] = a, this.incRef(a, this.backend), a
                }
            }, {
                key: "trackTensor",
                value: function(e, t) {
                    this.state.numTensors++, "string" === e.dtype && this.state.numStringTensors++;
                    var n = 0;
                    "complex64" !== e.dtype && "string" !== e.dtype && (n = e.size * Z$(e.dtype)), this.state.numBytes += n, this.state.tensorInfo.has(e.dataId) || (this.state.numDataBuffers++, this.state.tensorInfo.set(e.dataId, {
                        backend: t || this.backend,
                        dtype: e.dtype,
                        shape: e.shape,
                        bytes: n
                    })), e instanceof c5 || this.track(e)
                }
            }, {
                key: "incRef",
                value: function(e, t) {
                    this.trackTensor(e, t), this.backend.incRef(e.dataId)
                }
            }, {
                key: "removeDataId",
                value: function(e, t) {
                    this.state.tensorInfo.has(e) && this.state.tensorInfo.get(e).backend === t && (this.state.tensorInfo.delete(e), this.state.numDataBuffers--)
                }
            }, {
                key: "disposeTensor",
                value: function(e) {
                    if (this.state.tensorInfo.has(e.dataId)) {
                        var t = this.state.tensorInfo.get(e.dataId);
                        if (this.state.numTensors--, "string" === e.dtype && (this.state.numStringTensors--, this.state.numBytes -= t.bytes), "complex64" !== e.dtype && "string" !== e.dtype) {
                            var n = e.size * Z$(e.dtype);
                            this.state.numBytes -= n
                        }
                        t.backend.disposeData(e.dataId) && this.removeDataId(e.dataId, t.backend)
                    }
                }
            }, {
                key: "disposeVariables",
                value: function() {
                    for (var e in this.state.registeredVariables) {
                        var t = this.state.registeredVariables[e];
                        this.disposeVariable(t)
                    }
                }
            }, {
                key: "disposeVariable",
                value: function(e) {
                    this.disposeTensor(e), null != this.state.registeredVariables[e.name] && delete this.state.registeredVariables[e.name]
                }
            }, {
                key: "memory",
                value: function() {
                    var e = this.backend.memory();
                    return e.numTensors = this.state.numTensors, e.numDataBuffers = this.state.numDataBuffers, e.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (e.unreliable = !0, null == e.reasons && (e.reasons = []), e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")), e
                }
            }, {
                key: "profile",
                value: (n = c(o().mark((function e(t) {
                    var n, r, a, i, s;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return this.state.profiling = !0, n = this.state.numBytes, r = this.state.numTensors, this.state.activeProfile.kernels = [], e.next = 6, t();
                            case 6:
                                this.state.activeProfile.result = e.sent, this.state.profiling = !1, this.state.activeProfile.peakBytes = Math.max.apply(Math, T(this.state.activeProfile.kernels.map((function(e) {
                                    return e.totalBytesSnapshot
                                })))), this.state.activeProfile.newBytes = this.state.numBytes - n, this.state.activeProfile.newTensors = this.state.numTensors - r, a = O(this.state.activeProfile.kernels), e.prev = 12, a.s();
                            case 14:
                                if ((i = a.n()).done) {
                                    e.next = 24;
                                    break
                                }
                                return s = i.value, e.next = 18, s.kernelTimeMs;
                            case 18:
                                return s.kernelTimeMs = e.sent, e.next = 21, s.extraInfo;
                            case 21:
                                s.extraInfo = e.sent;
                            case 22:
                                e.next = 14;
                                break;
                            case 24:
                                e.next = 29;
                                break;
                            case 26:
                                e.prev = 26, e.t0 = e.catch(12), a.e(e.t0);
                            case 29:
                                return e.prev = 29, a.f(), e.finish(29);
                            case 32:
                                return e.abrupt("return", this.state.activeProfile);
                            case 33:
                            case "end":
                                return e.stop()
                        }
                    }), e, this, [
                        [12, 26, 29, 32]
                    ])
                }))), function(e) {
                    return n.apply(this, arguments)
                })
            }, {
                key: "isTapeOn",
                value: function() {
                    return this.state.gradientDepth > 0 && 0 === this.state.kernelDepth
                }
            }, {
                key: "addTapeNode",
                value: function(e, t, n, r, a, i) {
                    var o = this,
                        s = {
                            id: this.state.nextTapeNodeId++,
                            kernelName: e,
                            inputs: t,
                            outputs: n,
                            saved: a
                        },
                        u = U3(e);
                    null != u && (r = u.gradFunc), null != r && (s.gradient = function(e) {
                        return e = e.map((function(e, t) {
                            if (null == e) {
                                var r = n[t],
                                    a = l0(r.size, r.dtype);
                                return o.makeTensor(a, r.shape, r.dtype)
                            }
                            return e
                        })), r(e.length > 1 ? e : e[0], a, i)
                    }), this.state.activeTape.push(s)
                }
            }, {
                key: "keep",
                value: function(e) {
                    return e.kept = !0, e
                }
            }, {
                key: "startTape",
                value: function() {
                    0 === this.state.gradientDepth && (this.state.activeTape = []), this.state.gradientDepth++
                }
            }, {
                key: "endTape",
                value: function() {
                    this.state.gradientDepth--
                }
            }, {
                key: "startScope",
                value: function(e) {
                    var t = {
                        track: [],
                        name: "unnamed scope",
                        id: this.state.nextScopeId++
                    };
                    e && (t.name = e), this.state.scopeStack.push(t), this.state.activeScope = t
                }
            }, {
                key: "endScope",
                value: function(e) {
                    for (var t = this, n = y5(e), r = new Set(n.map((function(e) {
                            return e.id
                        }))), a = 0; a < this.state.activeScope.track.length; a++) {
                        var i = this.state.activeScope.track[a];
                        i.kept || r.has(i.id) || i.dispose()
                    }
                    var o = this.state.scopeStack.pop();
                    this.state.activeScope = 0 === this.state.scopeStack.length ? null : this.state.scopeStack[this.state.scopeStack.length - 1], n.forEach((function(e) {
                        e.kept || e.scopeId !== o.id || t.track(e)
                    }))
                }
            }, {
                key: "gradients",
                value: function(e, t, n) {
                    var r = this,
                        a = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
                    if (F$(t.length > 0, (function() {
                            return "gradients() received an empty list of xs."
                        })), null != n && "float32" !== n.dtype) throw new Error("dy must have 'float32' dtype, but has '".concat(n.dtype, "'"));
                    var i = this.scopedRun((function() {
                        return r.startTape()
                    }), (function() {
                        return r.endTape()
                    }), (function() {
                        return r.tidy("forward", e)
                    }));
                    F$(i instanceof n5, (function() {
                        return "The result y returned by f() must be a tensor."
                    }));
                    var o = q4(this.state.activeTape, t, i);
                    if (!a && 0 === o.length && t.length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
                    return this.tidy("backward", (function() {
                        var e = {};
                        e[i.id] = null == n ? N5(i.shape) : n, K4(e, o, (function(e) {
                            return r.tidy(e)
                        }), C5);
                        var a = t.map((function(t) {
                            return e[t.id]
                        }));
                        return 0 === r.state.gradientDepth && (r.state.activeTape.forEach((function(e) {
                            var t, n = O(e.saved);
                            try {
                                for (n.s(); !(t = n.n()).done;) {
                                    t.value.dispose()
                                }
                            } catch (e) {
                                n.e(e)
                            } finally {
                                n.f()
                            }
                        })), r.state.activeTape = null), {
                            value: i,
                            grads: a
                        }
                    }))
                }
            }, {
                key: "customGrad",
                value: function(e) {
                    var t = this;
                    return F$(r0(e), (function() {
                            return "The f passed in customGrad(f) must be a function."
                        })),
                        function() {
                            for (var n = arguments.length, r = new Array(n), a = 0; a < n; a++) r[a] = arguments[a];
                            var i;
                            F$(r.every((function(e) {
                                return e instanceof n5
                            })), (function() {
                                return "The args passed in customGrad(f)(x1, x2,...) must all be tensors"
                            }));
                            var o = {};
                            r.forEach((function(e, t) {
                                o[t] = e
                            }));
                            var s = function(t, n) {
                                    return F$((i = e.apply(void 0, [].concat(r, [n]))).value instanceof n5, (function() {
                                        return "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"
                                    })), F$(r0(i.gradFunc), (function() {
                                        return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."
                                    })), i.value
                                },
                                u = function(e, t) {
                                    var n = i.gradFunc(e, t),
                                        a = Array.isArray(n) ? n : [n];
                                    F$(a.length === r.length, (function() {
                                        return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."
                                    })), F$(a.every((function(e) {
                                        return e instanceof n5
                                    })), (function() {
                                        return "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."
                                    }));
                                    var o = {};
                                    return a.forEach((function(e, t) {
                                        o[t] = function() {
                                            return e
                                        }
                                    })), o
                                };
                            return t.runKernelFunc({
                                forwardFunc: s,
                                backwardsFunc: u,
                                inputs: o
                            })
                        }
                }
            }, {
                key: "readSync",
                value: function(e) {
                    return this.state.tensorInfo.get(e).backend.readSync(e)
                }
            }, {
                key: "read",
                value: function(e) {
                    return this.state.tensorInfo.get(e).backend.read(e)
                }
            }, {
                key: "readToGPU",
                value: function(e, t) {
                    return this.state.tensorInfo.get(e).backend.readToGPU(e, t)
                }
            }, {
                key: "time",
                value: (t = c(o().mark((function e(t) {
                    var n, r;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return n = z4(), e.next = 3, this.backend.time(t);
                            case 3:
                                return (r = e.sent).wallMs = z4() - n, e.abrupt("return", r);
                            case 6:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e) {
                    return t.apply(this, arguments)
                })
            }, {
                key: "track",
                value: function(e) {
                    return null != this.state.activeScope && (e.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(e)), e
                }
            }, {
                key: "registeredVariables",
                get: function() {
                    return this.state.registeredVariables
                }
            }, {
                key: "reset",
                value: function() {
                    for (var e in this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new w5, this.registry) this.disposeRegisteredKernels(e), this.registry[e].dispose(), delete this.registry[e];
                    this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null
                }
            }]), e
        }();

    function N5(e) {
        var t = c0(L$(e), "float32");
        return E5.makeTensor(t, e, "float32")
    }

    function S5() {
        var t = w0();
        if (null == t._tfengine) {
            var n = new y0(t);
            t._tfengine = new I5(n)
        }
        return function(t) {
            e.ENV = t
        }(t._tfengine.ENV), e5 = function() {
            return t._tfengine
        }, t._tfengine
    }
    I5.nextTensorId = 0, I5.nextVariableId = 0;
    var T5, E5 = S5();

    function C5(e, t) {
        var n = {
            a: e,
            b: t
        };
        return E5.runKernel(E0, n)
    }

    function A5(e) {
        if (void 0 !== T5) return T5;
        if (e || "undefined" != typeof navigator && null != navigator) {
            if (e || (e = navigator), "ReactNative" === e.product) return !0;
            var t = e.userAgent || e.vendor || ("undefined" != typeof window ? window.opera : "");
            if (!t) {
                var n = e;
                return n.userAgentData && n.userAgentData.mobile
            }
            return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4))
        }
        return !1
    }

    function R5() {
        return "undefined" != typeof window && null != window.document || "undefined" != typeof WorkerGlobalScope
    }
    var _5 = {
            __proto__: null,
            isBrowser: R5,
            isMobile: A5,
            mockIsMobile: function(e) {
                T5 = e
            }
        },
        O5 = k0();

    function F5(e, t) {
        var n = e;
        if (U4(e)) return "string" === t ? [] : [e.length];
        if (f5(e)) {
            var r = e.channels || "RGBA";
            return [e.height, e.width * r.length]
        }
        if (d5(e)) return [e.buffer.size / (null == t ? 4 : Z$(t))];
        if (!Array.isArray(e)) return [];
        for (var a = []; Array.isArray(n) || U4(n) && "string" !== t;) a.push(n.length), n = n[0];
        return Array.isArray(e) && k0().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && D5(e, a, []), a
    }

    function D5(e, t, n) {
        if (n = n || [], Array.isArray(e) || U4(e)) {
            F$(t.length > 0, (function() {
                return "Element arr[".concat(n.join("]["), "] should be a primitive, ") + "but is an array of ".concat(e.length, " elements")
            })), F$(e.length === t[0], (function() {
                return "Element arr[".concat(n.join("]["), "] should have ").concat(t[0], " ") + "elements, but has ".concat(e.length, " elements")
            }));
            for (var r = t.slice(1), a = 0; a < e.length; ++a) D5(e[a], r, n.concat(a))
        } else F$(0 === t.length, (function() {
            return "Element arr[".concat(n.join("]["), "] is a primitive, ") + "but should be an array/TypedArray of ".concat(t[0], " elements")
        }))
    }

    function M5(e, t, n, r) {
        if ("string_or_numeric" !== e) {
            if (null == e) throw new Error("Expected dtype cannot be null.");
            if ("numeric" !== e && e !== t || "numeric" === e && "string" === t) throw new Error("Argument '".concat(n, "' passed to '").concat(r, "' must ") + "be ".concat(e, " tensor, but got ").concat(t, " tensor"))
        }
    }

    function L5(e, t, n) {
        var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "numeric";
        if (e instanceof r5()) return M5(r, e.dtype, t, n), e;
        var a = n0(e);
        if ("string" !== a && ["bool", "int32", "float32"].indexOf(r) >= 0 && (a = r), M5(r, a, t, n), null == e || !U4(e) && !Array.isArray(e) && "number" != typeof e && "boolean" != typeof e && "string" != typeof e) {
            var i = null == e ? "null" : e.constructor.name;
            throw new Error("Argument '".concat(t, "' passed to '").concat(n, "' must be a ") + "Tensor or TensorLike, but got '".concat(i, "'"))
        }
        var o = F5(e, a);
        U4(e) || Array.isArray(e) || (e = [e]);
        var s = !0,
            u = "string" !== a ? L4(e, a) : V4(e, [], s);
        return E5.makeTensor(u, o, a)
    }

    function z5(e, t, n) {
        var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "numeric";
        if (!Array.isArray(e)) throw new Error("Argument ".concat(t, " passed to ").concat(n, " must be a ") + "`Tensor[]` or `TensorLike[]`");
        var a = e;
        return a.map((function(e, a) {
            return L5(e, "".concat(t, "[").concat(a, "]"), n, r)
        }))
    }
    O5.registerFlag("DEBUG", (function() {
        return !1
    }), (function(e) {
        e && console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")
    })), O5.registerFlag("IS_BROWSER", (function() {
        return R5()
    })), O5.registerFlag("IS_NODE", (function() {
        return "undefined" != typeof process && void 0 !== process.versions && void 0 !== process.versions.node
    })), O5.registerFlag("IS_CHROME", (function() {
        return "undefined" != typeof navigator && null != navigator && null != navigator.userAgent && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor)
    })), O5.registerFlag("IS_SAFARI", (function() {
        return "undefined" != typeof navigator && null != navigator && null != navigator.userAgent && /Safari/.test(navigator.userAgent) && /Apple/.test(navigator.vendor)
    })), O5.registerFlag("PROD", (function() {
        return !1
    })), O5.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", (function() {
        return O5.getBool("DEBUG")
    })), O5.registerFlag("DEPRECATION_WARNINGS_ENABLED", (function() {
        return !0
    })), O5.registerFlag("IS_TEST", (function() {
        return !1
    })), O5.registerFlag("CHECK_COMPUTATION_FOR_ERRORS", (function() {
        return O5.getBool("DEBUG")
    })), O5.registerFlag("WRAP_TO_IMAGEBITMAP", (function() {
        return !1
    })), O5.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU", (function() {
        return !1
    })), O5.registerFlag("USE_SETTIMEOUTCUSTOM", (function() {
        return !1
    }));
    var P5 = "__op";

    function B5(e) {
        var t = Object.keys(e);
        if (1 !== t.length) throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with " + "".concat(t.length, " keys."));
        var n = t[0],
            r = e[n];
        n.endsWith("_") && (n = n.substring(0, n.length - 1)), n += P5;
        var a = function() {
            E5.startScope(n);
            try {
                var e = r.apply(void 0, arguments);
                return v0(e) && console.error("Cannot return a Promise inside of tidy."), E5.endScope(e), e
            } catch (e) {
                throw E5.endScope(null), e
            }
        };
        return Object.defineProperty(a, "name", {
            value: n,
            configurable: !0
        }), a
    }
    var W5 = B5({
        complex_: function(e, t) {
            var n = L5(e, "real", "complex"),
                r = L5(t, "imag", "complex");
            D$(n.shape, r.shape, "real and imag shapes, ".concat(n.shape, " and ").concat(r.shape, ", ") + "must match in call to tf.complex().");
            var a = {
                real: n,
                imag: r
            };
            return E5.runKernel(Z0, a)
        }
    });

    function U5(e, t, n, r) {
        if (null == r) r = n0(e);
        else if ("complex64" === r) throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
        if (d5(e) || f5(e)) {
            if ("float32" !== r && "int32" !== r) throw new Error("Creating tensor from GPU data only supports " + "'float32'|'int32' dtype, while the dtype is ".concat(r, "."));
            return E5.backend.createTensorFromGPUData(e, t || n, r)
        }
        if (!U4(e) && !Array.isArray(e) && "number" != typeof e && "boolean" != typeof e && "string" != typeof e) throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
        if (null != t) {
            p0(t);
            var a = L$(t),
                i = L$(n);
            F$(a === i, (function() {
                return "Based on the provided shape, [".concat(t, "], the tensor should have ") + "".concat(a, " values but has ").concat(i)
            }));
            for (var o = 0; o < n.length; ++o) {
                var s = n[o],
                    u = o !== n.length - 1 || s !== L$(t.slice(o));
                F$(n[o] === t[o] || !u, (function() {
                    return "Error creating a new Tensor. Inferred shape " + "(".concat(n, ") does not match the provided ") + "shape (".concat(t, "). ")
                }))
            }
        }
        return U4(e) || Array.isArray(e) || (e = [e]), t = t || n, e = "string" !== r ? L4(e, r) : V4(e, [], !0), E5.makeTensor(e, t, r)
    }

    function V5(e, t, n) {
        return U5(e, t, F5(e, n), n)
    }
    var G5 = {
            float32: 4,
            float16: 2,
            int32: 4,
            uint16: 2,
            uint8: 1,
            bool: 1,
            complex64: 8
        },
        j5 = function() {
            function e(t) {
                if (l(this, e), this.shards = [], this.previousShardIndex = 0, null != t && (t instanceof Array || (t = [t]), 0 !== (t = t.map((function(e) {
                        return U4(e) ? e.buffer : e
                    }))).length)) {
                    this.bufferUniformSize = t[0].byteLength;
                    for (var n = 0, r = 0; r < t.length; r++) {
                        var a = t[r];
                        r !== t.length - 1 && a.byteLength !== this.bufferUniformSize && (this.bufferUniformSize = void 0);
                        var i = n + a.byteLength;
                        this.shards.push({
                            buffer: a,
                            start: n,
                            end: i
                        }), n = i
                    }
                    0 === this.shards.length && (this.byteLength = 0), this.byteLength = this.shards[this.shards.length - 1].end
                }
            }
            return p(e, [{
                key: "slice",
                value: function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                        t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.byteLength;
                    if (0 === this.shards.length) return new ArrayBuffer(0);
                    if (e = isNaN(Number(e)) ? 0 : e, t = isNaN(Number(t)) ? 0 : t, e = Math.max(0, e), (t = Math.min(this.byteLength, t)) <= e) return new ArrayBuffer(0);
                    var n = this.findShardForByte(e);
                    if (-1 === n) throw new Error("Could not find start shard for byte ".concat(e));
                    for (var r = t - e, a = new ArrayBuffer(r), i = new Uint8Array(a), o = 0, s = n; s < this.shards.length; s++) {
                        var u = this.shards[s],
                            c = e + o,
                            l = c - u.start,
                            h = o,
                            p = Math.min(t, u.end),
                            f = p - u.start,
                            d = new Uint8Array(u.buffer, l, f - l);
                        if (i.set(d, h), o += d.length, t < u.end) break
                    }
                    return a
                }
            }, {
                key: "findShardForByte",
                value: function(e) {
                    if (0 === this.shards.length || e < 0 || e >= this.byteLength) return -1;
                    if (null != this.bufferUniformSize) return this.previousShardIndex = Math.floor(e / this.bufferUniformSize), this.previousShardIndex;

                    function t(t) {
                        return e < t.start ? -1 : e >= t.end ? 1 : 0
                    }
                    if (0 === t(this.shards[this.previousShardIndex])) return this.previousShardIndex;
                    var n = function(e, t) {
                        var n = 0,
                            r = e.length;
                        for (; n <= r;) {
                            var a = Math.floor((r - n) / 2) + n,
                                i = t(e[a]);
                            if (0 === i) return a;
                            i < 0 ? r = a : n = a + 1
                        }
                        return -1
                    }(this.shards, t);
                    return -1 === n ? -1 : (this.previousShardIndex = n, this.previousShardIndex)
                }
            }], [{
                key: "join",
                value: function(t) {
                    return new e(t).slice()
                }
            }]), e
        }();

    function H5(e) {
        k0().getBool("DEPRECATION_WARNINGS_ENABLED") && console.warn(e + " You can disable deprecation warnings with tf.disableDeprecationWarnings().")
    }

    function q5() {
        return E5
    }

    function K5() {
        return E5.memory()
    }

    function X5(e, t) {
        return E5.tidy(e, t)
    }

    function Y5(e) {
        y5(e).forEach((function(e) {
            return e.dispose()
        }))
    }

    function J5(e) {
        return E5.keep(e)
    }

    function Z5(e) {
        return E5.setBackend(e)
    }

    function Q5() {
        return E5.backendName
    }

    function $5(e, t) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
        return E5.registerBackend(e, t, n)
    }

    function e6() {
        return E5.backend
    }

    function t6(e, t) {
        return n6.apply(this, arguments)
    }

    function n6() {
        return n6 = c(o().mark((function e(t, n) {
            var r, a, i, s, u, l;
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        r = [], a = [], i = Array.isArray(t) ? t.map((function(e) {
                            return e.name
                        })) : Object.keys(t), s = o().mark((function e() {
                            var s, l, h, p;
                            return o().wrap((function(e) {
                                for (;;) switch (e.prev = e.next) {
                                    case 0:
                                        if (s = i[u], "float32" === (l = Array.isArray(t) ? t[u].tensor : t[s]).dtype || "int32" === l.dtype || "bool" === l.dtype || "string" === l.dtype || "complex64" === l.dtype) {
                                            e.next = 4;
                                            break
                                        }
                                        throw new Error("Unsupported dtype in weight '".concat(s, "': ").concat(l.dtype));
                                    case 4:
                                        h = {
                                            name: s,
                                            shape: l.shape,
                                            dtype: l.dtype
                                        }, "string" === l.dtype ? (p = new Promise(function() {
                                            var e = c(o().mark((function e(t) {
                                                var n, r, a, i, s, u, c;
                                                return o().wrap((function(e) {
                                                    for (;;) switch (e.prev = e.next) {
                                                        case 0:
                                                            return e.next = 2, l.bytes();
                                                        case 2:
                                                            for (n = e.sent, r = n.reduce((function(e, t) {
                                                                    return e + t.length
                                                                }), 0) + 4 * n.length, a = new Uint8Array(r), i = 0, s = 0; s < n.length; s++) u = n[s], c = new Uint8Array(new Uint32Array([u.length]).buffer), a.set(c, i), i += 4, a.set(u, i), i += u.length;
                                                            t(a);
                                                        case 8:
                                                        case "end":
                                                            return e.stop()
                                                    }
                                                }), e)
                                            })));
                                            return function(t) {
                                                return e.apply(this, arguments)
                                            }
                                        }()), a.push(p)) : a.push(l.data()), null != n && (h.group = n), r.push(h);
                                    case 8:
                                    case "end":
                                        return e.stop()
                                }
                            }), e)
                        })), u = 0;
                    case 5:
                        if (!(u < i.length)) {
                            e.next = 10;
                            break
                        }
                        return e.delegateYield(s(), "t0", 7);
                    case 7:
                        ++u, e.next = 5;
                        break;
                    case 10:
                        return e.next = 12, Promise.all(a);
                    case 12:
                        return l = e.sent, e.abrupt("return", {
                            data: p6(l),
                            specs: r
                        });
                    case 14:
                    case "end":
                        return e.stop()
                }
            }), e)
        }))), n6.apply(this, arguments)
    }

    function r6(e, t) {
        var n, r = new j5(e),
            a = {},
            i = 0,
            o = O(t);
        try {
            for (o.s(); !(n = o.n()).done;) {
                var s = n.value,
                    u = a6(s, (function(e, t) {
                        return r.slice(i + e, i + t)
                    }));
                a[s.name] = s6(s, r.slice(i, i + u)), i += u
            }
        } catch (e) {
            o.e(e)
        } finally {
            o.f()
        }
        return a
    }

    function a6(e, t) {
        var n, r = L$(e.shape);
        if ("quantization" in e) {
            var a = e.quantization;
            n = G5[a.dtype]
        } else {
            if ("string" === e.dtype) {
                for (var i = 0, o = 0; o < r; o++) i += 4 + new Uint32Array(t(i, i + 4))[0];
                return i
            }
            n = G5[e.dtype]
        }
        return r * n
    }

    function i6(e, t) {
        return o6.apply(this, arguments)
    }

    function o6() {
        return o6 = c(o().mark((function e(t, n) {
            var r, a, i, s, u;
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        if (r = L$(t.shape), !("quantization" in t)) {
                            e.next = 6;
                            break
                        }
                        i = t.quantization, a = G5[i.dtype], e.next = 25;
                        break;
                    case 6:
                        if ("string" !== t.dtype) {
                            e.next = 24;
                            break
                        }
                        s = 0, u = 0;
                    case 9:
                        if (!(u < r)) {
                            e.next = 21;
                            break
                        }
                        return e.t0 = s, e.t1 = 4, e.t2 = Uint32Array, e.next = 15, n(s, s + 4);
                    case 15:
                        e.t3 = e.sent, e.t4 = new e.t2(e.t3)[0], s = e.t0 += e.t1 + e.t4;
                    case 18:
                        u++, e.next = 9;
                        break;
                    case 21:
                        return e.abrupt("return", s);
                    case 24:
                        a = G5[t.dtype];
                    case 25:
                        return e.abrupt("return", r * a);
                    case 26:
                    case "end":
                        return e.stop()
                }
            }), e)
        }))), o6.apply(this, arguments)
    }

    function s6(e, t) {
        var n, r, a, i, o = e.name,
            s = e.dtype,
            u = e.shape,
            c = L$(u),
            l = 0;
        if ("quantization" in e) {
            var h = e.quantization;
            if ("uint8" === h.dtype || "uint16" === h.dtype) {
                if (!("min" in h) || !("scale" in h)) throw new Error("Weight ".concat(e.name, " with quantization ").concat(h.dtype, " ") + "doesn't have corresponding metadata min and scale.")
            } else {
                if ("float16" !== h.dtype) throw new Error("Weight ".concat(e.name, " has unknown ") + "quantization dtype ".concat(h.dtype, ". ") + "Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.");
                if ("float32" !== s) throw new Error("Weight ".concat(e.name, " is quantized with ").concat(h.dtype, " ") + "which only supports weights of type float32 not ".concat(s, "."))
            }
            var p = G5[h.dtype],
                f = "uint8" === h.dtype ? new Uint8Array(t) : new Uint16Array(t);
            if ("float32" === s)
                if ("uint8" === h.dtype || "uint16" === h.dtype) {
                    n = new Float32Array(f.length);
                    for (var d = 0; d < f.length; d++) {
                        var v = f[d];
                        n[d] = v * h.scale + h.min
                    }
                } else {
                    if ("float16" !== h.dtype) throw new Error("Unsupported quantization type ".concat(h.dtype, " ") + "for weight type float32.");
                    var m = (r = function() {
                        var e = function(e) {
                                for (var t = e << 13, n = 0; 0 == (8388608 & t);) n -= 8388608, t <<= 1;
                                return (t &= -8388609) | (n += 947912704)
                            },
                            t = new Uint32Array(2048);
                        t[0] = 0;
                        for (var n = 1; n < 1024; n++) t[n] = e(n);
                        for (var r = 1024; r < 2048; r++) t[r] = 939524096 + (r - 1024 << 13);
                        return t
                    }(), a = function() {
                        var e = new Uint32Array(64);
                        e[0] = 0, e[31] = 1199570944, e[32] = 2147483648, e[63] = 3347054592;
                        for (var t = 1; t < 31; t++) e[t] = t << 23;
                        for (var n = 33; n < 63; n++) e[n] = 2147483648 + (n - 32 << 23);
                        return e
                    }(), i = function() {
                        for (var e = new Uint32Array(64), t = 0; t < 64; t++) e[t] = 1024;
                        return e[0] = e[32] = 0, e
                    }(), function(e) {
                        for (var t = new ArrayBuffer(4 * e.length), n = new Uint32Array(t), o = 0; o < e.length; o++) {
                            var s = e[o],
                                u = r[i[s >> 10] + (1023 & s)] + a[s >> 10];
                            n[o] = u
                        }
                        return new Float32Array(t)
                    });
                    n = m(f)
                } else {
                if ("int32" !== s) throw new Error("Unsupported dtype in weight '".concat(o, "': ").concat(s));
                if ("uint8" !== h.dtype && "uint16" !== h.dtype) throw new Error("Unsupported quantization type ".concat(h.dtype, " ") + "for weight type int32.");
                n = new Int32Array(f.length);
                for (var g = 0; g < f.length; g++) {
                    var y = f[g];
                    n[g] = Math.round(y * h.scale + h.min)
                }
            }
            l += c * p
        } else if ("string" === s) {
            var b = L$(e.shape);
            n = [];
            for (var x = 0; x < b; x++) {
                var k = new Uint32Array(t.slice(l, l + 4))[0];
                l += 4;
                var w = new Uint8Array(t.slice(l, l + k));
                n.push(w), l += k
            }
        } else {
            var I = G5[s];
            if ("float32" === s) n = new Float32Array(t);
            else if ("int32" === s) n = new Int32Array(t);
            else {
                if ("bool" !== s) {
                    if ("complex64" === s) {
                        n = new Float32Array(t);
                        for (var N = new Float32Array(n.length / 2), S = new Float32Array(n.length / 2), T = 0; T < N.length; T++) N[T] = n[2 * T], S[T] = n[2 * T + 1];
                        var E = V5(N, u, "float32"),
                            C = V5(S, u, "float32"),
                            A = W5(E, C);
                        return E.dispose(), C.dispose(), A
                    }
                    throw new Error("Unsupported dtype in weight '".concat(o, "': ").concat(s))
                }
                n = new Uint8Array(t)
            }
            l += c * I
        }
        return V5(n, u, s)
    }

    function u6(e, t, n) {
        return c6.apply(this, arguments)
    }

    function c6() {
        return c6 = c(o().mark((function e(t, n, r) {
            var a, i, s, u, c, l;
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        a = new Uint8Array(n);
                    case 1:
                        if (!(a.byteLength < r)) {
                            e.next = 16;
                            break
                        }
                        return e.next = 4, t.read();
                    case 4:
                        if (i = e.sent, s = i.done, u = i.value, !s || null != u) {
                            e.next = 10;
                            break
                        }
                        throw c = r - a.byteLength, new Error("Reader is done but ".concat(c, " bytes are still expected"));
                    case 10:
                        (l = new Uint8Array(a.length + u.byteLength)).set(a, 0), l.set(new Uint8Array(u), a.length), a = l, e.next = 1;
                        break;
                    case 16:
                        return e.abrupt("return", a.buffer);
                    case 17:
                    case "end":
                        return e.stop()
                }
            }), e)
        }))), c6.apply(this, arguments)
    }

    function l6(e, t) {
        return h6.apply(this, arguments)
    }

    function h6() {
        return h6 = c(o().mark((function e(t, n) {
            var r, a, i, s, u, l, h, p, f, d;
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        r = {}, a = t.getReader(), i = new ArrayBuffer(0), s = O(n), e.prev = 4, s.s();
                    case 6:
                        if ((u = s.n()).done) {
                            e.next = 21;
                            break
                        }
                        return l = u.value, e.next = 10, i6(l, function() {
                            var e = c(o().mark((function e(t, n) {
                                return o().wrap((function(e) {
                                    for (;;) switch (e.prev = e.next) {
                                        case 0:
                                            return e.next = 2, u6(a, i, n);
                                        case 2:
                                            return i = e.sent, e.abrupt("return", i.slice(t, n));
                                        case 4:
                                        case "end":
                                            return e.stop()
                                    }
                                }), e)
                            })));
                            return function(t, n) {
                                return e.apply(this, arguments)
                            }
                        }());
                    case 10:
                        return h = e.sent, e.next = 13, u6(a, i, h);
                    case 13:
                        i = e.sent, p = i.slice(0, h), i = i.slice(h), f = s6(l, p), r[l.name] = f, "webgpu" === Q5() && "uploadToGPU" in (d = e6()) && L$(f.shape) >= k0().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD") && d.uploadToGPU(f.dataId);
                    case 19:
                        e.next = 6;
                        break;
                    case 21:
                        e.next = 26;
                        break;
                    case 23:
                        e.prev = 23, e.t0 = e.catch(4), s.e(e.t0);
                    case 26:
                        return e.prev = 26, s.f(), e.finish(26);
                    case 29:
                        return e.abrupt("return", r);
                    case 30:
                    case "end":
                        return e.stop()
                }
            }), e, null, [
                [4, 23, 26, 29]
            ])
        }))), h6.apply(this, arguments)
    }

    function p6(e) {
        if (null === e) throw new Error("Invalid input value: ".concat(JSON.stringify(e)));
        var t = 0,
            n = [];
        e.forEach((function(e) {
            if (t += e.byteLength, n.push(e.byteLength === e.buffer.byteLength ? e : new e.constructor(e)), !(e instanceof Float32Array || e instanceof Int32Array || e instanceof Uint8Array)) throw new Error("Unsupported TypedArray subtype: ".concat(e.constructor.name))
        }));
        var r = new Uint8Array(t),
            a = 0;
        return n.forEach((function(e) {
            r.set(new Uint8Array(e.buffer), a), a += e.byteLength
        })), r.buffer
    }
    var f6 = "undefined" != typeof Buffer && ("undefined" == typeof Blob || "undefined" == typeof atob || "undefined" == typeof btoa);

    function d6(e) {
        return f6 ? Buffer.byteLength(e, "utf8") : new Blob([e]).size
    }

    function v6(e) {
        if (f6) return Buffer.from(e).toString("base64");
        for (var t = new Uint8Array(e), n = "", r = 0, a = t.length; r < a; r++) n += String.fromCharCode(t[r]);
        return btoa(n)
    }

    function m6(e) {
        if (f6) {
            var t = Buffer.from(e, "base64");
            return t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength)
        }
        for (var n = atob(e), r = new Uint8Array(n.length), a = 0; a < n.length; ++a) r.set([n.charCodeAt(a)], a);
        return r.buffer
    }

    function g6(e) {
        return j5.join(e)
    }

    function y6(e) {
        for (e = e.trim(); e.endsWith("/");) e = e.slice(0, e.length - 1);
        var t = e.split("/");
        return t[t.length - 1]
    }

    function b6(e, t) {
        var n = {
            modelTopology: e.modelTopology,
            format: e.format,
            generatedBy: e.generatedBy,
            convertedBy: e.convertedBy,
            weightsManifest: t
        };
        return null != e.signature && (n.signature = e.signature), null != e.userDefinedMetadata && (n.userDefinedMetadata = e.userDefinedMetadata), null != e.modelInitializer && (n.modelInitializer = e.modelInitializer), null != e.initializerSignature && (n.initializerSignature = e.initializerSignature), null != e.trainingConfig && (n.trainingConfig = e.trainingConfig), n
    }

    function x6(e, t, n) {
        var r = {
            modelTopology: e.modelTopology,
            format: e.format,
            generatedBy: e.generatedBy,
            convertedBy: e.convertedBy
        };
        if (null != e.trainingConfig && (r.trainingConfig = e.trainingConfig), null != e.weightsManifest) {
            if (!t) throw new Error("modelJSON has weightsManifest but weightSpecs is null");
            if (!n) throw new Error("modelJSON has weightsManifest but weightData is null");
            r.weightSpecs = t, r.weightData = n
        }
        return null != e.signature && (r.signature = e.signature), null != e.userDefinedMetadata && (r.userDefinedMetadata = e.userDefinedMetadata), null != e.modelInitializer && (r.modelInitializer = e.modelInitializer), null != e.initializerSignature && (r.initializerSignature = e.initializerSignature), r
    }

    function k6(e, t) {
        return w6.apply(this, arguments)
    }

    function w6() {
        return w6 = c(o().mark((function e(t, n) {
            var r, a, i, s;
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        if (null == t.weightsManifest) {
                            e.next = 7;
                            break
                        }
                        return e.next = 3, n(t.weightsManifest);
                    case 3:
                        i = e.sent, s = S(i, 2), r = s[0], a = s[1];
                    case 7:
                        return e.abrupt("return", x6(t, r, a));
                    case 8:
                    case "end":
                        return e.stop()
                }
            }), e)
        }))), w6.apply(this, arguments)
    }

    function I6(e) {
        if (e.modelTopology instanceof ArrayBuffer) throw new Error("Expected JSON model topology, received ArrayBuffer.");
        return {
            dateSaved: new Date,
            modelTopologyType: "JSON",
            modelTopologyBytes: null == e.modelTopology ? 0 : d6(JSON.stringify(e.modelTopology)),
            weightSpecsBytes: null == e.weightSpecs ? 0 : d6(JSON.stringify(e.weightSpecs)),
            weightDataBytes: null == e.weightData ? 0 : new j5(e.weightData).byteLength
        }
    }

    function N6(e) {
        var t, n = [],
            r = O(e);
        try {
            for (r.s(); !(t = r.n()).done;) {
                var a = t.value;
                n.push.apply(n, T(a.weights))
            }
        } catch (e) {
            r.e(e)
        } finally {
            r.f()
        }
        return n
    }
    var S6 = function() {
            function e() {
                l(this, e), this.saveRouters = [], this.loadRouters = []
            }
            return p(e, null, [{
                key: "getInstance",
                value: function() {
                    return null == e.instance && (e.instance = new e), e.instance
                }
            }, {
                key: "registerSaveRouter",
                value: function(t) {
                    e.getInstance().saveRouters.push(t)
                }
            }, {
                key: "registerLoadRouter",
                value: function(t) {
                    e.getInstance().loadRouters.push(t)
                }
            }, {
                key: "getSaveHandlers",
                value: function(t) {
                    return e.getHandlers(t, "save")
                }
            }, {
                key: "getLoadHandlers",
                value: function(t, n) {
                    return e.getHandlers(t, "load", n)
                }
            }, {
                key: "getHandlers",
                value: function(t, n, r) {
                    var a = [];
                    return ("load" === n ? e.getInstance().loadRouters : e.getInstance().saveRouters).forEach((function(e) {
                        var n = e(t, r);
                        null !== n && a.push(n)
                    })), a
                }
            }]), e
        }(),
        T6 = function(e) {
            return S6.getSaveHandlers(e)
        },
        E6 = function(e, t) {
            return S6.getLoadHandlers(e, t)
        },
        C6 = "tensorflowjs",
        A6 = "models_store",
        R6 = "model_info_store";

    function _6() {
        if (!k0().getBool("IS_BROWSER")) throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
        var e = "undefined" == typeof window ? self : window,
            t = e.indexedDB || e.mozIndexedDB || e.webkitIndexedDB || e.msIndexedDB || e.shimIndexedDB;
        if (null == t) throw new Error("The current browser does not appear to support IndexedDB.");
        return t
    }

    function O6(e) {
        var t = e.result;
        t.createObjectStore(A6, {
            keyPath: "modelPath"
        }), t.createObjectStore(R6, {
            keyPath: "modelPath"
        })
    }
    var F6 = function() {
        function e(t) {
            if (l(this, e), this.indexedDB = _6(), null == t || !t) throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
            this.modelPath = t
        }
        var t, n;
        return p(e, [{
            key: "save",
            value: (n = c(o().mark((function e(t) {
                return o().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if (!(t.modelTopology instanceof ArrayBuffer)) {
                                e.next = 2;
                                break
                            }
                            throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
                        case 2:
                            return e.abrupt("return", this.databaseAction(this.modelPath, t));
                        case 3:
                        case "end":
                            return e.stop()
                    }
                }), e, this)
            }))), function(e) {
                return n.apply(this, arguments)
            })
        }, {
            key: "load",
            value: (t = c(o().mark((function e() {
                return o().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return e.abrupt("return", this.databaseAction(this.modelPath));
                        case 1:
                        case "end":
                            return e.stop()
                    }
                }), e, this)
            }))), function() {
                return t.apply(this, arguments)
            })
        }, {
            key: "databaseAction",
            value: function(e, t) {
                var n = this;
                return new Promise((function(e, r) {
                    var a = n.indexedDB.open(C6, 1);
                    a.onupgradeneeded = function() {
                        return O6(a)
                    }, a.onsuccess = function() {
                        var i = a.result;
                        if (null == t) {
                            var o = i.transaction(A6, "readonly"),
                                s = o.objectStore(A6).get(n.modelPath);
                            s.onsuccess = function() {
                                if (null == s.result) return i.close(), r(new Error("Cannot find model with path '".concat(n.modelPath, "' ") + "in IndexedDB."));
                                e(s.result.modelArtifacts)
                            }, s.onerror = function(e) {
                                return i.close(), r(s.error)
                            }, o.oncomplete = function() {
                                return i.close()
                            }
                        } else {
                            t.weightData = j5.join(t.weightData);
                            var u, c, l = I6(t),
                                h = i.transaction(R6, "readwrite"),
                                p = h.objectStore(R6);
                            try {
                                u = p.put({
                                    modelPath: n.modelPath,
                                    modelArtifactsInfo: l
                                })
                            } catch (e) {
                                return r(e)
                            }
                            u.onsuccess = function() {
                                var a, o = (c = i.transaction(A6, "readwrite")).objectStore(A6);
                                try {
                                    a = o.put({
                                        modelPath: n.modelPath,
                                        modelArtifacts: t,
                                        modelArtifactsInfo: l
                                    })
                                } catch (e) {
                                    return r(e)
                                }
                                a.onsuccess = function() {
                                    return e({
                                        modelArtifactsInfo: l
                                    })
                                }, a.onerror = function(e) {
                                    var t = (p = h.objectStore(R6)).delete(n.modelPath);
                                    t.onsuccess = function() {
                                        return i.close(), r(a.error)
                                    }, t.onerror = function(e) {
                                        return i.close(), r(a.error)
                                    }
                                }
                            }, u.onerror = function(e) {
                                return i.close(), r(u.error)
                            }, h.oncomplete = function() {
                                null == c ? i.close() : c.oncomplete = function() {
                                    return i.close()
                                }
                            }
                        }
                    }, a.onerror = function(e) {
                        return r(a.error)
                    }
                }))
            }
        }]), e
    }();
    F6.URL_SCHEME = "indexeddb://";
    var D6 = function(e) {
        return k0().getBool("IS_BROWSER") && !Array.isArray(e) && e.startsWith(F6.URL_SCHEME) ? (t = e.slice(F6.URL_SCHEME.length), new F6(t)) : null;
        var t
    };

    function M6(e) {
        return e.startsWith(F6.URL_SCHEME) ? e.slice(F6.URL_SCHEME.length) : e
    }
    S6.registerSaveRouter(D6), S6.registerLoadRouter(D6);
    var L6 = function() {
            function e() {
                l(this, e), this.indexedDB = _6()
            }
            return p(e, [{
                key: "listModels",
                value: function() {
                    var e = c(o().mark((function e() {
                        var t = this;
                        return o().wrap((function(e) {
                            for (;;) switch (e.prev = e.next) {
                                case 0:
                                    return e.abrupt("return", new Promise((function(e, n) {
                                        var r = t.indexedDB.open(C6, 1);
                                        r.onupgradeneeded = function() {
                                            return O6(r)
                                        }, r.onsuccess = function() {
                                            var t = r.result,
                                                a = t.transaction(R6, "readonly"),
                                                i = a.objectStore(R6).getAll();
                                            i.onsuccess = function() {
                                                var t, n = {},
                                                    r = O(i.result);
                                                try {
                                                    for (r.s(); !(t = r.n()).done;) {
                                                        var a = t.value;
                                                        n[a.modelPath] = a.modelArtifactsInfo
                                                    }
                                                } catch (e) {
                                                    r.e(e)
                                                } finally {
                                                    r.f()
                                                }
                                                e(n)
                                            }, i.onerror = function(e) {
                                                return t.close(), n(i.error)
                                            }, a.oncomplete = function() {
                                                return t.close()
                                            }
                                        }, r.onerror = function(e) {
                                            return n(r.error)
                                        }
                                    })));
                                case 1:
                                case "end":
                                    return e.stop()
                            }
                        }), e)
                    })));
                    return function() {
                        return e.apply(this, arguments)
                    }
                }()
            }, {
                key: "removeModel",
                value: function() {
                    var e = c(o().mark((function e(t) {
                        var n = this;
                        return o().wrap((function(e) {
                            for (;;) switch (e.prev = e.next) {
                                case 0:
                                    return t = M6(t), e.abrupt("return", new Promise((function(e, r) {
                                        var a = n.indexedDB.open(C6, 1);
                                        a.onupgradeneeded = function() {
                                            return O6(a)
                                        }, a.onsuccess = function() {
                                            var n, i = a.result,
                                                o = i.transaction(R6, "readwrite"),
                                                s = o.objectStore(R6),
                                                u = s.get(t);
                                            u.onsuccess = function() {
                                                if (null == u.result) return i.close(), r(new Error("Cannot find model with path '".concat(t, "' ") + "in IndexedDB."));
                                                var a = s.delete(t),
                                                    o = function() {
                                                        var a = (n = i.transaction(A6, "readwrite")).objectStore(A6).delete(t);
                                                        a.onsuccess = function() {
                                                            return e(u.result.modelArtifactsInfo)
                                                        }, a.onerror = function(e) {
                                                            return r(u.error)
                                                        }
                                                    };
                                                a.onsuccess = o, a.onerror = function(e) {
                                                    return o(), i.close(), r(u.error)
                                                }
                                            }, u.onerror = function(e) {
                                                return i.close(), r(u.error)
                                            }, o.oncomplete = function() {
                                                null == n ? i.close() : n.oncomplete = function() {
                                                    return i.close()
                                                }
                                            }
                                        }, a.onerror = function(e) {
                                            return r(a.error)
                                        }
                                    })));
                                case 2:
                                case "end":
                                    return e.stop()
                            }
                        }), e)
                    })));
                    return function(t) {
                        return e.apply(this, arguments)
                    }
                }()
            }]), e
        }(),
        z6 = "/",
        P6 = "tensorflowjs_models",
        B6 = "info",
        W6 = "model_topology",
        U6 = "weight_specs",
        V6 = "weight_data",
        G6 = "model_metadata";

    function j6(e) {
        return {
            info: [P6, e, B6].join(z6),
            topology: [P6, e, W6].join(z6),
            weightSpecs: [P6, e, U6].join(z6),
            weightData: [P6, e, V6].join(z6),
            modelMetadata: [P6, e, G6].join(z6)
        }
    }

    function H6(e) {
        for (var t = 0, n = Object.values(e); t < n.length; t++) {
            var r = n[t];
            window.localStorage.removeItem(r)
        }
    }

    function q6(e) {
        var t = e.split(z6);
        if (t.length < 3) throw new Error("Invalid key format: ".concat(e));
        return t.slice(1, t.length - 1).join(z6)
    }

    function K6(e) {
        return e.startsWith(X6.URL_SCHEME) ? e.slice(X6.URL_SCHEME.length) : e
    }
    var X6 = function() {
        function e(t) {
            if (l(this, e), !k0().getBool("IS_BROWSER") || "undefined" == typeof window || void 0 === window.localStorage) throw new Error("The current environment does not support local storage.");
            if (this.LS = window.localStorage, null == t || !t) throw new Error("For local storage, modelPath must not be null, undefined or empty.");
            this.modelPath = t, this.keys = j6(this.modelPath)
        }
        var t, n;
        return p(e, [{
            key: "save",
            value: (n = c(o().mark((function e(t) {
                var n, r, a, i, s;
                return o().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if (!(t.modelTopology instanceof ArrayBuffer)) {
                                e.next = 4;
                                break
                            }
                            throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
                        case 4:
                            return n = JSON.stringify(t.modelTopology), r = JSON.stringify(t.weightSpecs), a = I6(t), i = j5.join(t.weightData), e.prev = 8, this.LS.setItem(this.keys.info, JSON.stringify(a)), this.LS.setItem(this.keys.topology, n), this.LS.setItem(this.keys.weightSpecs, r), this.LS.setItem(this.keys.weightData, v6(i)), s = {
                                format: t.format,
                                generatedBy: t.generatedBy,
                                convertedBy: t.convertedBy,
                                signature: null != t.signature ? t.signature : void 0,
                                userDefinedMetadata: null != t.userDefinedMetadata ? t.userDefinedMetadata : void 0,
                                modelInitializer: null != t.modelInitializer ? t.modelInitializer : void 0,
                                initializerSignature: null != t.initializerSignature ? t.initializerSignature : void 0,
                                trainingConfig: null != t.trainingConfig ? t.trainingConfig : void 0
                            }, this.LS.setItem(this.keys.modelMetadata, JSON.stringify(s)), e.abrupt("return", {
                                modelArtifactsInfo: a
                            });
                        case 18:
                            throw e.prev = 18, e.t0 = e.catch(8), H6(this.keys), new Error("Failed to save model '".concat(this.modelPath, "' to local storage: ") + "size quota being exceeded is a possible cause of this failure: " + "modelTopologyBytes=".concat(a.modelTopologyBytes, ", ") + "weightSpecsBytes=".concat(a.weightSpecsBytes, ", ") + "weightDataBytes=".concat(a.weightDataBytes, "."));
                        case 22:
                        case "end":
                            return e.stop()
                    }
                }), e, this, [
                    [8, 18]
                ])
            }))), function(e) {
                return n.apply(this, arguments)
            })
        }, {
            key: "load",
            value: (t = c(o().mark((function e() {
                var t, n, r, a, i, s, u;
                return o().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if (null != (t = JSON.parse(this.LS.getItem(this.keys.info)))) {
                                e.next = 3;
                                break
                            }
                            throw new Error("In local storage, there is no model with name '".concat(this.modelPath, "'"));
                        case 3:
                            if ("JSON" === t.modelTopologyType) {
                                e.next = 5;
                                break
                            }
                            throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
                        case 5:
                            if (n = {}, null != (r = JSON.parse(this.LS.getItem(this.keys.topology)))) {
                                e.next = 9;
                                break
                            }
                            throw new Error("In local storage, the topology of model '".concat(this.modelPath, "' ") + "is missing.");
                        case 9:
                            if (n.modelTopology = r, null != (a = JSON.parse(this.LS.getItem(this.keys.weightSpecs)))) {
                                e.next = 13;
                                break
                            }
                            throw new Error("In local storage, the weight specs of model '".concat(this.modelPath, "' ") + "are missing.");
                        case 13:
                            if (n.weightSpecs = a, null != (i = this.LS.getItem(this.keys.modelMetadata)) && (s = JSON.parse(i), n.format = s.format, n.generatedBy = s.generatedBy, n.convertedBy = s.convertedBy, null != s.signature && (n.signature = s.signature), null != s.userDefinedMetadata && (n.userDefinedMetadata = s.userDefinedMetadata), null != s.modelInitializer && (n.modelInitializer = s.modelInitializer), null != s.initializerSignature && (n.initializerSignature = s.initializerSignature), null != s.trainingConfig && (n.trainingConfig = s.trainingConfig)), null != (u = this.LS.getItem(this.keys.weightData))) {
                                e.next = 19;
                                break
                            }
                            throw new Error("In local storage, the binary weight values of model " + "'".concat(this.modelPath, "' are missing."));
                        case 19:
                            return n.weightData = m6(u), e.abrupt("return", n);
                        case 21:
                        case "end":
                            return e.stop()
                    }
                }), e, this)
            }))), function() {
                return t.apply(this, arguments)
            })
        }]), e
    }();
    X6.URL_SCHEME = "localstorage://";
    var Y6 = function(e) {
        return k0().getBool("IS_BROWSER") && !Array.isArray(e) && e.startsWith(X6.URL_SCHEME) ? (t = e.slice(X6.URL_SCHEME.length), new X6(t)) : null;
        var t
    };
    S6.registerSaveRouter(Y6), S6.registerLoadRouter(Y6);
    var J6 = function() {
            function e() {
                l(this, e), F$(k0().getBool("IS_BROWSER"), (function() {
                    return "Current environment is not a web browser"
                })), F$("undefined" == typeof window || void 0 !== window.localStorage, (function() {
                    return "Current browser does not appear to support localStorage"
                })), this.LS = window.localStorage
            }
            return p(e, [{
                key: "listModels",
                value: function() {
                    var e = c(o().mark((function e() {
                        var t, n, r, a, i, s;
                        return o().wrap((function(e) {
                            for (;;) switch (e.prev = e.next) {
                                case 0:
                                    for (t = {}, n = P6 + z6, r = z6 + B6, a = 0; a < this.LS.length; ++a)(i = this.LS.key(a)).startsWith(n) && i.endsWith(r) && (s = q6(i), t[s] = JSON.parse(this.LS.getItem(i)));
                                    return e.abrupt("return", t);
                                case 5:
                                case "end":
                                    return e.stop()
                            }
                        }), e, this)
                    })));
                    return function() {
                        return e.apply(this, arguments)
                    }
                }()
            }, {
                key: "removeModel",
                value: function() {
                    var e = c(o().mark((function e(t) {
                        var n, r;
                        return o().wrap((function(e) {
                            for (;;) switch (e.prev = e.next) {
                                case 0:
                                    if (t = K6(t), n = j6(t), null != this.LS.getItem(n.info)) {
                                        e.next = 4;
                                        break
                                    }
                                    throw new Error("Cannot find model at path '".concat(t, "'"));
                                case 4:
                                    return r = JSON.parse(this.LS.getItem(n.info)), H6(n), e.abrupt("return", r);
                                case 7:
                                case "end":
                                    return e.stop()
                            }
                        }), e, this)
                    })));
                    return function(t) {
                        return e.apply(this, arguments)
                    }
                }()
            }]), e
        }(),
        Z6 = "://",
        Q6 = function() {
            function e() {
                l(this, e), this.managers = {}
            }
            return p(e, null, [{
                key: "getInstance",
                value: function() {
                    return null == e.instance && (e.instance = new e), e.instance
                }
            }, {
                key: "registerManager",
                value: function(t, n) {
                    F$(null != t, (function() {
                        return "scheme must not be undefined or null."
                    })), t.endsWith(Z6) && (t = t.slice(0, t.indexOf(Z6))), F$(t.length > 0, (function() {
                        return "scheme must not be an empty string."
                    }));
                    var r = e.getInstance();
                    F$(null == r.managers[t], (function() {
                        return "A model store manager is already registered for scheme '".concat(t, "'.")
                    })), r.managers[t] = n
                }
            }, {
                key: "getManager",
                value: function(t) {
                    var n = e.getInstance().managers[t];
                    if (null == n) throw new Error("Cannot find model manager for scheme '".concat(t, "'"));
                    return n
                }
            }, {
                key: "getSchemes",
                value: function() {
                    return Object.keys(e.getInstance().managers)
                }
            }]), e
        }();

    function $6(e) {
        if (-1 === e.indexOf(Z6)) throw new Error("The url string provided does not contain a scheme. Supported schemes are: " + "".concat(Q6.getSchemes().join(",")));
        return {
            scheme: e.split(Z6)[0],
            path: e.split(Z6)[1]
        }
    }

    function e8(e, t) {
        return t8.apply(this, arguments)
    }

    function t8() {
        return t8 = c(o().mark((function e(t, n) {
            var r, a, i, s, u, c, l, h, p, f, d = arguments;
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return r = d.length > 2 && void 0 !== d[2] && d[2], F$(t !== n, (function() {
                            return "Old path and new path are the same: '".concat(t, "'")
                        })), F$((a = S6.getLoadHandlers(t)).length > 0, (function() {
                            return "Copying failed because no load handler is found for source URL ".concat(t, ".")
                        })), F$(a.length < 2, (function() {
                            return "Copying failed because more than one (".concat(a.length, ") ") + "load handlers for source URL ".concat(t, ".")
                        })), i = a[0], F$((s = S6.getSaveHandlers(n)).length > 0, (function() {
                            return "Copying failed because no save handler is found for destination " + "URL ".concat(n, ".")
                        })), F$(s.length < 2, (function() {
                            return "Copying failed because more than one (".concat(a.length, ") ") + "save handlers for destination URL ".concat(n, ".")
                        })), u = s[0], c = $6(t).scheme, l = $6(t).path, h = c === $6(t).scheme, e.next = 15, i.load();
                    case 15:
                        if (p = e.sent, !r || !h) {
                            e.next = 19;
                            break
                        }
                        return e.next = 19, Q6.getManager(c).removeModel(l);
                    case 19:
                        return e.next = 21, u.save(p);
                    case 21:
                        if (f = e.sent, !r || h) {
                            e.next = 25;
                            break
                        }
                        return e.next = 25, Q6.getManager(c).removeModel(l);
                    case 25:
                        return e.abrupt("return", f.modelArtifactsInfo);
                    case 26:
                    case "end":
                        return e.stop()
                }
            }), e)
        }))), t8.apply(this, arguments)
    }

    function n8() {
        return n8 = c(o().mark((function e() {
            var t, n, r, a, i, s, u;
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        t = Q6.getSchemes(), n = {}, r = O(t), e.prev = 3, r.s();
                    case 5:
                        if ((a = r.n()).done) {
                            e.next = 13;
                            break
                        }
                        return i = a.value, e.next = 9, Q6.getManager(i).listModels();
                    case 9:
                        for (u in s = e.sent) n[i + Z6 + u] = s[u];
                    case 11:
                        e.next = 5;
                        break;
                    case 13:
                        e.next = 18;
                        break;
                    case 15:
                        e.prev = 15, e.t0 = e.catch(3), r.e(e.t0);
                    case 18:
                        return e.prev = 18, r.f(), e.finish(18);
                    case 21:
                        return e.abrupt("return", n);
                    case 22:
                    case "end":
                        return e.stop()
                }
            }), e, null, [
                [3, 15, 18, 21]
            ])
        }))), n8.apply(this, arguments)
    }

    function r8() {
        return (r8 = c(o().mark((function e(t) {
            var n, r;
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return n = $6(t), r = Q6.getManager(n.scheme), e.abrupt("return", r.removeModel(n.path));
                    case 3:
                    case "end":
                        return e.stop()
                }
            }), e)
        })))).apply(this, arguments)
    }

    function a8() {
        return (a8 = c(o().mark((function e(t, n) {
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return !1, e.abrupt("return", e8(t, n, false));
                    case 2:
                    case "end":
                        return e.stop()
                }
            }), e)
        })))).apply(this, arguments)
    }

    function i8() {
        return (i8 = c(o().mark((function e(t, n) {
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return !0, e.abrupt("return", e8(t, n, true));
                    case 2:
                    case "end":
                        return e.stop()
                }
            }), e)
        })))).apply(this, arguments)
    }
    var o8 = function() {
        function e() {
            l(this, e), this.messageName = "setTimeoutCustom", this.functionRefs = [], this.handledMessageCount = 0, this.hasEventListener = !1
        }
        return p(e, [{
            key: "fetch",
            value: function(e) {
                function t(t, n) {
                    return e.apply(this, arguments)
                }
                return t.toString = function() {
                    return e.toString()
                }, t
            }((function(e, t) {
                return fetch(e, t)
            }))
        }, {
            key: "now",
            value: function() {
                return performance.now()
            }
        }, {
            key: "encode",
            value: function(e, t) {
                if ("utf-8" !== t && "utf8" !== t) throw new Error("Browser's encoder only supports utf-8, but got ".concat(t));
                return null == this.textEncoder && (this.textEncoder = new TextEncoder), this.textEncoder.encode(e)
            }
        }, {
            key: "decode",
            value: function(e, t) {
                return new TextDecoder(t).decode(e)
            }
        }, {
            key: "setTimeoutCustom",
            value: function(e, t) {
                var n = this;
                "undefined" != typeof window && k0().getBool("USE_SETTIMEOUTCUSTOM") ? (this.functionRefs.push(e), setTimeout((function() {
                    window.postMessage({
                        name: n.messageName,
                        index: n.functionRefs.length - 1
                    }, "*")
                }), t), this.hasEventListener || (this.hasEventListener = !0, window.addEventListener("message", (function(e) {
                    e.source === window && e.data.name === n.messageName && (e.stopPropagation(), (0, n.functionRefs[e.data.index])(), n.handledMessageCount++, n.handledMessageCount === n.functionRefs.length && (n.functionRefs = [], n.handledMessageCount = 0))
                }), !0))) : setTimeout(e, t)
            }
        }, {
            key: "isTypedArray",
            value: function(e) {
                return q3(e)
            }
        }]), e
    }();
    if (k0().get("IS_BROWSER")) {
        k0().setPlatform("browser", new o8);
        try {
            Q6.registerManager(X6.URL_SCHEME, new J6)
        } catch (e) {}
        try {
            Q6.registerManager(F6.URL_SCHEME, new L6)
        } catch (e) {}
    }
    var s8, u8 = function() {
        return require("node-fetch")
    };
    var c8 = function() {
        function e() {
            l(this, e), this.util = require("util"), this.textEncoder = new this.util.TextEncoder
        }
        return p(e, [{
            key: "fetch",
            value: function(e, t) {
                return null != k0().global.fetch ? k0().global.fetch(e, t) : (null == s8 && (s8 = u8()), s8(e, t))
            }
        }, {
            key: "now",
            value: function() {
                var e = process.hrtime();
                return 1e3 * e[0] + e[1] / 1e6
            }
        }, {
            key: "encode",
            value: function(e, t) {
                if ("utf-8" !== t && "utf8" !== t) throw new Error("Node built-in encoder only supports utf-8, but got ".concat(t));
                return this.textEncoder.encode(e)
            }
        }, {
            key: "decode",
            value: function(e, t) {
                return 0 === e.length ? "" : new this.util.TextDecoder(t).decode(e)
            }
        }, {
            key: "isTypedArray",
            value: function(e) {
                return this.util.types.isFloat32Array(e) || this.util.types.isInt32Array(e) || this.util.types.isUint8Array(e) || this.util.types.isUint8ClampedArray(e)
            }
        }]), e
    }();

    function l8(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "float32",
            n = arguments.length > 2 ? arguments[2] : void 0;
        return t = t || "float32", p0(e), new $4(e, t, n)
    }
    k0().get("IS_NODE") && !k0().get("IS_BROWSER") && k0().setPlatform("node", new c8);
    var h8 = B5({
        cast_: function(e, t) {
            var n = L5(e, "x", "cast");
            if (!Y$(t)) throw new Error("Failed to cast to unknown dtype ".concat(t));
            if ("string" === t && "string" !== n.dtype || "string" !== t && "string" === n.dtype) throw new Error("Only strings can be casted to strings");
            var r = {
                    x: n
                },
                a = {
                    dtype: t
                };
            return E5.runKernel(X0, r, a)
        }
    });
    var p8 = B5({
        clone_: function(e) {
            var t = {
                x: L5(e, "x", "clone", "string_or_numeric")
            };
            return E5.runKernel(W1, t)
        }
    });

    function f8(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        console.log(e.toString(t))
    }
    S5(), t5 = {
        buffer: l8,
        cast: h8,
        clone: p8,
        print: f8
    };
    var d8 = B5({
        add_: function(e, t) {
            var n = L5(e, "a", "add"),
                r = L5(t, "b", "add"),
                a = S(v5(n, r), 2),
                i = {
                    a: n = a[0],
                    b: r = a[1]
                };
            return E5.runKernel(E0, i)
        }
    });
    var v8 = B5({
        floorDiv_: function(e, t) {
            var n = L5(e, "a", "floorDiv"),
                r = L5(t, "b", "floorDiv"),
                a = S(v5(n, r), 2),
                i = {
                    a: n = a[0],
                    b: r = a[1]
                };
            return E5.runKernel(D1, i)
        }
    });
    var m8 = B5({
        div_: function(e, t) {
            var n = L5(e, "a", "div"),
                r = L5(t, "b", "div"),
                a = S(v5(n, r), 2);
            if (n = a[0], r = a[1], "int32" === n.dtype && "int32" === r.dtype) return v8(n, r);
            var i = {
                a: n,
                b: r
            };
            return E5.runKernel(k1, i, {})
        }
    });
    var g8 = B5({
        mul_: function(e, t) {
            var n = L5(e, "a", "mul"),
                r = L5(t, "b", "mul"),
                a = S(v5(n, r), 2),
                i = {
                    a: n = a[0],
                    b: r = a[1]
                };
            return E5.runKernel(g2, i)
        }
    });
    var y8 = B5({
        abs_: function(e) {
            var t = L5(e, "x", "abs");
            if ("complex64" === t.dtype) {
                var n = {
                    x: t
                };
                return E5.runKernel(Q0, n)
            }
            var r = {
                x: t
            };
            return E5.runKernel(N0, r)
        }
    });
    var b8 = B5({
        acos_: function(e) {
            var t = {
                x: L5(e, "x", "acos")
            };
            return E5.runKernel(S0, t)
        }
    });
    var x8 = B5({
        acosh_: function(e) {
            var t = {
                x: L5(e, "x", "acosh")
            };
            return E5.runKernel(T0, t)
        }
    });
    var k8 = B5({
        addN_: function(e) {
            F$(Array.isArray(e), (function() {
                return "The argument passed to tf.addN() must be a list of tensors"
            })), F$(e.length >= 1, (function() {
                return "Must pass at least one tensor to tf.addN(), but got " + "".concat(e.length)
            }));
            var t = e.map((function(e, t) {
                    return L5(e, "tensors".concat(t), "addN")
                })),
                n = t[0];
            t.forEach((function(e) {
                if (e.dtype !== n.dtype) throw new Error("All tensors passed to tf.addN() must have the same dtype")
            })), t.forEach((function(e) {
                if (!P$(e.shape, n.shape)) throw new Error("All tensors passed to tf.addN() must have the same shape")
            }));
            var r = t;
            return E5.runKernel(C0, r)
        }
    });
    var w8 = B5({
        all_: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                r = L5(e, "x", "all", "bool"),
                a = {
                    x: r
                },
                i = {
                    axis: t,
                    keepDims: n
                };
            return E5.runKernel(A0, a, i)
        }
    });
    var I8 = B5({
        any_: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                r = L5(e, "x", "any", "bool"),
                a = {
                    x: r
                },
                i = {
                    axis: t,
                    keepDims: n
                };
            return E5.runKernel(R0, a, i)
        }
    });
    var N8 = B5({
        argMax_: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                n = L5(e, "x", "argMax"),
                r = {
                    x: n
                },
                a = {
                    axis: t
                };
            return E5.runKernel(_0, r, a)
        }
    });
    var S8 = B5({
        argMin_: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                n = L5(e, "x", "argMin"),
                r = {
                    x: n
                },
                a = {
                    axis: t
                };
            return E5.runKernel(O0, r, a)
        }
    });
    var T8 = B5({
        asin_: function(e) {
            var t = {
                x: L5(e, "x", "asin")
            };
            return E5.runKernel(F0, t)
        }
    });
    var E8 = B5({
        asinh_: function(e) {
            var t = {
                x: L5(e, "x", "asinh")
            };
            return E5.runKernel(D0, t)
        }
    });
    var C8 = B5({
        atan_: function(e) {
            var t = {
                x: L5(e, "x", "atan")
            };
            return E5.runKernel(M0, t)
        }
    });
    var A8 = B5({
        atan2_: function(e, t) {
            var n = L5(e, "a", "atan2"),
                r = L5(t, "b", "atan2"),
                a = S(v5(n, r), 2),
                i = {
                    a: n = a[0],
                    b: r = a[1]
                };
            return E5.runKernel(z0, i)
        }
    });
    var R8 = B5({
        atanh_: function(e) {
            var t = {
                x: L5(e, "x", "atanh")
            };
            return E5.runKernel(L0, t)
        }
    });

    function _8(e, t, n, r) {
        var a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "NHWC",
            i = arguments.length > 5 ? arguments[5] : void 0,
            o = e[3],
            s = [].concat(T(t), [o]),
            u = q8(a);
        return D8(e, s, n, i, r, null, null, u)
    }

    function O8(e, t, n, r, a, i) {
        var o, s = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : "channelsLast",
            u = z8(t),
            c = S(u, 2),
            l = c[0],
            h = c[1];
        if ("channelsLast" === s) o = [l, h, e[3], e[3]];
        else {
            if ("channelsFirst" !== s) throw new Error("Unknown dataFormat ".concat(s));
            o = [l, h, e[1], e[1]]
        }
        return D8(e, o, n, r, a, i, !1, s)
    }

    function F8(e, t, n, r, a, i) {
        var o, s, u = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : "NDHWC",
            c = P8(t),
            l = S(c, 3),
            h = l[0],
            p = l[1],
            f = l[2];
        if ("NDHWC" === u) s = "channelsLast", o = [h, p, f, e[4], e[4]];
        else {
            if ("NCDHW" !== u) throw new Error("Unknown dataFormat ".concat(u));
            s = "channelsFirst", o = [h, p, f, e[1], e[1]]
        }
        return M8(e, o, n, r, a, !1, s, i)
    }

    function D8(e, t, n, r, a, i) {
        var o = arguments.length > 6 && void 0 !== arguments[6] && arguments[6],
            s = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : "channelsLast",
            u = -1,
            c = -1,
            l = -1,
            h = -1;
        if ("channelsLast" === s) {
            var p = S(e, 4);
            u = p[0], c = p[1], l = p[2], h = p[3]
        } else {
            if ("channelsFirst" !== s) throw new Error("Unknown dataFormat ".concat(s));
            var f = S(e, 4);
            u = f[0], h = f[1], c = f[2], l = f[3]
        }
        var d, v = S(t, 4),
            m = v[0],
            g = v[1],
            y = v[3],
            b = z8(n),
            x = S(b, 2),
            k = x[0],
            w = x[1],
            I = z8(r),
            N = S(I, 2),
            T = N[0],
            E = N[1],
            C = B8(m, T),
            A = B8(g, E),
            R = W8(a, c, l, k, w, C, A, i, s),
            _ = R.padInfo,
            O = R.outHeight,
            F = R.outWidth,
            D = o ? y * h : y;
        return "channelsFirst" === s ? d = [u, D, O, F] : "channelsLast" === s && (d = [u, O, F, D]), {
            batchSize: u,
            dataFormat: s,
            inHeight: c,
            inWidth: l,
            inChannels: h,
            outHeight: O,
            outWidth: F,
            outChannels: D,
            padInfo: _,
            strideHeight: k,
            strideWidth: w,
            filterHeight: m,
            filterWidth: g,
            effectiveFilterHeight: C,
            effectiveFilterWidth: A,
            dilationHeight: T,
            dilationWidth: E,
            inShape: e,
            outShape: d,
            filterShape: t
        }
    }

    function M8(e, t, n, r, a) {
        var i = arguments.length > 5 && void 0 !== arguments[5] && arguments[5],
            o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : "channelsLast",
            s = arguments.length > 7 ? arguments[7] : void 0,
            u = -1,
            c = -1,
            l = -1,
            h = -1,
            p = -1;
        if ("channelsLast" === o) {
            var f = S(e, 5);
            u = f[0], c = f[1], l = f[2], h = f[3], p = f[4]
        } else {
            if ("channelsFirst" !== o) throw new Error("Unknown dataFormat ".concat(o));
            var d = S(e, 5);
            u = d[0], p = d[1], c = d[2], l = d[3], h = d[4]
        }
        var v, m = S(t, 5),
            g = m[0],
            y = m[1],
            b = m[2],
            x = m[4],
            k = P8(n),
            w = S(k, 3),
            I = w[0],
            N = w[1],
            T = w[2],
            E = P8(r),
            C = S(E, 3),
            A = C[0],
            R = C[1],
            _ = C[2],
            O = B8(g, A),
            F = B8(y, R),
            D = B8(b, _),
            M = U8(a, c, l, h, I, N, T, O, F, D, s),
            L = M.padInfo,
            z = M.outDepth,
            P = M.outHeight,
            B = M.outWidth,
            W = i ? x * p : x;
        return "channelsFirst" === o ? v = [u, W, z, P, B] : "channelsLast" === o && (v = [u, z, P, B, W]), {
            batchSize: u,
            dataFormat: o,
            inDepth: c,
            inHeight: l,
            inWidth: h,
            inChannels: p,
            outDepth: z,
            outHeight: P,
            outWidth: B,
            outChannels: W,
            padInfo: L,
            strideDepth: I,
            strideHeight: N,
            strideWidth: T,
            filterDepth: g,
            filterHeight: y,
            filterWidth: b,
            effectiveFilterDepth: O,
            effectiveFilterHeight: F,
            effectiveFilterWidth: D,
            dilationDepth: A,
            dilationHeight: R,
            dilationWidth: _,
            inShape: e,
            outShape: v,
            filterShape: t
        }
    }

    function L8(e, t, n) {
        var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1,
            a = B8(t, r);
        return Math.floor((e[0] * (n - 1) - n + a) / 2)
    }

    function z8(e) {
        return "number" == typeof e ? [e, e, e] : 2 === e.length ? [e[0], e[1], 1] : e
    }

    function P8(e) {
        return "number" == typeof e ? [e, e, e] : e
    }

    function B8(e, t) {
        return t <= 1 ? e : e + (e - 1) * (t - 1)
    }

    function W8(e, t, n, r, a, i, o, u, c) {
        var l, h, p;
        if ("number" == typeof e) {
            l = {
                top: e,
                bottom: e,
                left: e,
                right: e,
                type: 0 === e ? "VALID" : "NUMBER"
            };
            var f = function(e, t, n, r, a) {
                null == r && (r = L8(e, t, n));
                var i = e[0],
                    o = e[1];
                return [V8((i - t + 2 * r) / n + 1, a), V8((o - t + 2 * r) / n + 1, a)]
            }([t, n], i, r, e, u);
            h = f[0], p = f[1]
        } else if ("same" === e) {
            h = Math.ceil(t / r), p = Math.ceil(n / a);
            var d = Math.max(0, (h - 1) * r + i - t),
                v = Math.max(0, (p - 1) * a + o - n),
                m = Math.floor(d / 2),
                g = d - m,
                y = Math.floor(v / 2);
            l = {
                top: m,
                bottom: g,
                left: y,
                right: v - y,
                type: "SAME"
            }
        } else if ("valid" === e) l = {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0,
            type: "VALID"
        }, h = Math.ceil((t - i + 1) / r), p = Math.ceil((n - o + 1) / a);
        else {
            if ("object" !== s(e)) throw Error("Unknown padding parameter: ".concat(e));
            var b = "channelsLast" === c ? e[1][0] : e[2][0],
                x = "channelsLast" === c ? e[1][1] : e[2][1],
                k = "channelsLast" === c ? e[2][0] : e[3][0],
                w = "channelsLast" === c ? e[2][1] : e[3][1];
            l = {
                top: b,
                bottom: x,
                left: k,
                right: w,
                type: 0 === b && 0 === x && 0 === k && 0 === w ? "VALID" : "EXPLICIT"
            }, h = V8((t - i + b + x) / r + 1, u), p = V8((n - o + k + w) / a + 1, u)
        }
        return {
            padInfo: l,
            outHeight: h,
            outWidth: p
        }
    }

    function U8(e, t, n, r, a, i, o, s, u, c, l) {
        var h, p, f, d;
        if ("valid" === e && (e = 0), "number" == typeof e) {
            h = {
                top: e,
                bottom: e,
                left: e,
                right: e,
                front: e,
                back: e,
                type: 0 === e ? "VALID" : "NUMBER"
            };
            var v = function(e, t, n, r, a, i) {
                null == a && (a = L8(e, t[0], r[0]));
                for (var o = [0, 0, 0, n], s = 0; s < 3; s++) e[s] + 2 * a >= t[s] && (o[s] = V8((e[s] - t[s] + 2 * a) / r[s] + 1, i));
                return o
            }([t, n, r, 1], [s, u, c], 1, [a, i, o], e, l);
            p = v[0], f = v[1], d = v[2]
        } else {
            if ("same" !== e) throw Error("Unknown padding parameter: ".concat(e));
            var m = ((p = Math.ceil(t / a)) - 1) * a + s - t,
                g = ((f = Math.ceil(n / i)) - 1) * i + u - n,
                y = ((d = Math.ceil(r / o)) - 1) * o + c - r,
                b = Math.floor(m / 2),
                x = m - b,
                k = Math.floor(g / 2),
                w = g - k,
                I = Math.floor(y / 2);
            h = {
                top: k,
                bottom: w,
                left: I,
                right: y - I,
                front: b,
                back: x,
                type: "SAME"
            }
        }
        return {
            padInfo: h,
            outDepth: p,
            outHeight: f,
            outWidth: d
        }
    }

    function V8(e, t) {
        if (!t) return Math.trunc(e);
        switch (t) {
            case "round":
                return Math.round(e);
            case "ceil":
                return Math.ceil(e);
            case "floor":
                return Math.floor(e);
            default:
                throw new Error("Unknown roundingMode ".concat(t))
        }
    }

    function G8(e) {
        var t = S(z8(e), 3),
            n = t[0],
            r = t[1],
            a = t[2];
        return 1 === n && 1 === r && 1 === a
    }

    function j8(e, t) {
        return G8(e) || G8(t)
    }

    function H8(e) {
        return z8(e).every((function(e) {
            return e > 0
        }))
    }

    function q8(e) {
        if ("NHWC" === e) return "channelsLast";
        if ("NCHW" === e) return "channelsFirst";
        throw new Error("Unknown dataFormat ".concat(e))
    }

    function K8(e, t, n) {
        if (null != n) {
            if ("string" == typeof t) throw Error("Error in ".concat(e, ": pad must be an integer when using ") + "dimRoundingMode ".concat(n, " but got pad ").concat(t, "."));
            if ("number" == typeof t) F$(B$(t), (function() {
                return "Error in ".concat(e, ": pad must be an integer when using ") + "dimRoundingMode ".concat(n, " but got pad ").concat(t, ".")
            }));
            else {
                if ("object" !== s(t)) throw Error("Error in ".concat(e, ": Unknown padding parameter: ").concat(t));
                t.forEach((function(t) {
                    t.forEach((function(t) {
                        F$(B$(t), (function() {
                            return "Error in ".concat(e, ": pad must be an integer when using ") + "dimRoundingMode ".concat(n, " but got pad ").concat(t, ".")
                        }))
                    }))
                }))
            }
        }
    }
    var X8 = B5({
        reshape_: function(e, t) {
            var n = {
                    x: L5(e, "x", "reshape", "string_or_numeric")
                },
                r = {
                    shape: t
                };
            return E5.runKernel(z2, n, r)
        }
    });
    var Y8 = B5({
        avgPool_: function(e, t, n, r, a) {
            var i = L5(e, "x", "avgPool", "float32");
            F$(j8(n, 1), (function() {
                return "Error in avgPool: Either strides or dilations must be 1. " + "Got strides ".concat(n, " and dilations '").concat(1, "'")
            }));
            var o = i,
                s = !1;
            3 === i.rank && (s = !0, o = X8(i, [1, i.shape[0], i.shape[1], i.shape[2]])), F$(4 === o.rank, (function() {
                return "Error in avgPool: x must be rank 4 but got rank ".concat(o.rank, ".")
            })), K8("avgPool", r, a);
            var u = {
                    x: o
                },
                c = {
                    filterSize: t,
                    strides: n,
                    pad: r,
                    dimRoundingMode: a
                },
                l = E5.runKernel(P0, u, c);
            return l = h8(l, i.dtype), s ? X8(l, [l.shape[1], l.shape[2], l.shape[3]]) : l
        }
    });
    var J8 = B5({
        avgPool3d_: function(e, t, n, r, a) {
            var i = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "NDHWC",
                o = L5(e, "x", "avgPool3d", "float32"),
                s = o,
                u = !1;
            4 === o.rank && (u = !0, s = X8(o, [1, o.shape[0], o.shape[1], o.shape[2], o.shape[3]])), F$(5 === s.rank, (function() {
                return "Error in avgPool3d: x must be rank 5 but got rank ".concat(s.rank, ".")
            })), F$("NDHWC" === i, (function() {
                return "Error in avgPool3d: Only NDHWC is currently supported, " + "but got dataFormat of ".concat(i)
            })), F$("number" == typeof n && n > 0 || Array.isArray(n) && n[0] > 0 && n[1] > 0 && n[2] > 0, (function() {
                return "Error in avgPool3d: Stride must be > 0, but got '".concat(n, "'")
            })), K8("avgPool3d", r, a);
            var c = {
                    x: s
                },
                l = {
                    filterSize: t,
                    strides: n,
                    pad: r,
                    dimRoundingMode: a,
                    dataFormat: i
                },
                h = E5.runKernel(W0, c, l);
            return h = h8(h, s.dtype), u ? X8(h, [h.shape[1], h.shape[2], h.shape[3], h.shape[4]]) : h
        }
    });
    var Z8 = B5({
        concat_: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            F$(e.length >= 1, (function() {
                return "Pass at least one tensor to concat"
            }));
            var n = z5(e, "tensors", "concat", "string_or_numeric");
            if ("complex64" === n[0].dtype && n.forEach((function(e) {
                    if ("complex64" !== e.dtype) throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype ".concat(e.dtype, ". "))
                })), 1 === n.length) return p8(n[0]);
            var r = n,
                a = {
                    axis: t
                };
            return E5.runKernel($0, r, a)
        }
    });
    var Q8 = B5({
        matMul_: function(e, t) {
            var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
                a = L5(e, "a", "matMul"),
                i = L5(t, "b", "matMul"),
                o = v5(a, i),
                s = S(o, 2),
                u = {
                    a: a = s[0],
                    b: i = s[1]
                },
                c = {
                    transposeA: n,
                    transposeB: r
                };
            return E5.runKernel(V0, u, c)
        }
    });
    var $8 = B5({
        sigmoid_: function(e) {
            var t = {
                x: L5(e, "x", "sigmoid", "float32")
            };
            return E5.runKernel(t3, t)
        }
    });
    var e7 = B5({
        slice_: function(e, t, n) {
            var r = L5(e, "x", "slice", "string_or_numeric");
            if (0 === r.rank) throw new Error("Slicing scalar is not possible");
            var a = {
                    x: r
                },
                i = {
                    begin: t,
                    size: n
                };
            return E5.runKernel(Z2, a, i)
        }
    });
    var t7 = B5({
        tanh_: function(e) {
            var t = {
                x: L5(e, "x", "tanh", "float32")
            };
            return E5.runKernel(w3, t)
        }
    });
    var n7 = B5({
        basicLSTMCell_: function(e, t, n, r, a, i) {
            var o = L5(e, "forgetBias", "basicLSTMCell"),
                s = L5(t, "lstmKernel", "basicLSTMCell"),
                u = L5(n, "lstmBias", "basicLSTMCell"),
                c = L5(r, "data", "basicLSTMCell"),
                l = L5(a, "c", "basicLSTMCell"),
                h = L5(i, "h", "basicLSTMCell"),
                p = Z8([c, h], 1),
                f = Q8(p, s),
                d = d8(f, u),
                v = d.shape[0],
                m = d.shape[1] / 4,
                g = [v, m],
                y = e7(d, [0, 0], g),
                b = e7(d, [0, m], g),
                x = e7(d, [0, 2 * m], g),
                k = e7(d, [0, 3 * m], g),
                w = d8(g8($8(y), t7(b)), g8(l, $8(d8(o, x))));
            return [w, g8(t7(w), $8(k))]
        }
    });
    var r7 = B5({
        batchToSpaceND_: function(e, t, n) {
            var r = L5(e, "x", "batchToSpaceND"),
                a = t.reduce((function(e, t) {
                    return e * t
                }));
            F$(r.rank >= 1 + t.length, (function() {
                return "input rank is ".concat(r.rank, " but should be > than blockShape.length ").concat(t.length)
            })), F$(n.length === t.length, (function() {
                return "crops.length is ".concat(n.length, " but should be equal to blockShape.length  ").concat(t.length)
            })), F$(r.shape[0] % a == 0, (function() {
                return "input tensor batch is ".concat(r.shape[0], " but is not divisible by the product of ") + "the elements of blockShape ".concat(t.join(" * "), " === ").concat(a)
            }));
            var i = {
                    x: r
                },
                o = {
                    blockShape: t,
                    crops: n
                };
            return E5.runKernel(G0, i, o)
        }
    });
    var a7 = B5({
        batchNorm_: function(e, t, n, r, a, i) {
            null == i && (i = .001);
            var o, s, u = L5(e, "x", "batchNorm"),
                c = L5(t, "mean", "batchNorm"),
                l = L5(n, "variance", "batchNorm");
            null != a && (o = L5(a, "scale", "batchNorm")), null != r && (s = L5(r, "offset", "batchNorm")), F$(c.rank === l.rank, (function() {
                return "Batch normalization gradient requires mean and variance to have equal ranks."
            })), F$(null == s || c.rank === s.rank, (function() {
                return "Batch normalization gradient requires mean and offset to have equal ranks."
            })), F$(null == o || c.rank === o.rank, (function() {
                return "Batch normalization gradient requires mean and scale to have equal ranks."
            }));
            var h = function(e) {
                    return 0 === e.rank || 1 === e.rank ? X8(e, [1, 1, 1, e.size]) : 2 === e.rank ? X8(e, [1, 1, e.shape[0], e.shape[1]]) : 3 === e.rank ? X8(e, [1, e.shape[0], e.shape[1], e.shape[2]]) : e
                }(u),
                p = {
                    x: h,
                    scale: o,
                    offset: s,
                    mean: c,
                    variance: l
                },
                f = {
                    varianceEpsilon: i
                },
                d = E5.runKernel(M1, p, f);
            return X8(d, u.shape)
        }
    });
    var i7 = B5({
        batchNorm2d_: function(e, t, n, r, a, i) {
            var o, s, u = L5(e, "x", "batchNorm"),
                c = L5(t, "mean", "batchNorm"),
                l = L5(n, "variance", "batchNorm");
            return null != a && (o = L5(a, "scale", "batchNorm")), null != r && (s = L5(r, "offset", "batchNorm")), F$(2 === u.rank, (function() {
                return "Error in batchNorm2D: x must be rank 2 but got rank " + "".concat(u.rank, ".")
            })), F$(2 === c.rank || 1 === c.rank, (function() {
                return "Error in batchNorm2D: mean must be rank 2 or rank 1 but " + "got rank ".concat(c.rank, ".")
            })), F$(2 === l.rank || 1 === l.rank, (function() {
                return "Error in batchNorm2D: variance must be rank 2 or rank 1 " + "but got rank ".concat(l.rank, ".")
            })), null != o && F$(2 === o.rank || 1 === o.rank, (function() {
                return "Error in batchNorm2D: scale must be rank 2 or rank 1 " + "but got rank ".concat(o.rank, ".")
            })), null != s && F$(2 === s.rank || 1 === s.rank, (function() {
                return "Error in batchNorm2D: offset must be rank 2 or rank 1 " + "but got rank ".concat(s.rank, ".")
            })), a7(u, c, l, s, o, i)
        }
    });
    var o7 = B5({
        batchNorm3d_: function(e, t, n, r, a, i) {
            var o, s, u = L5(e, "x", "batchNorm"),
                c = L5(t, "mean", "batchNorm"),
                l = L5(n, "variance", "batchNorm");
            return null != a && (o = L5(a, "scale", "batchNorm")), null != r && (s = L5(r, "offset", "batchNorm")), F$(3 === u.rank, (function() {
                return "Error in batchNorm3D: x must be rank 3 but got rank " + "".concat(u.rank, ".")
            })), F$(3 === c.rank || 1 === c.rank, (function() {
                return "Error in batchNorm3D: mean must be rank 3 or rank 1 but " + "got rank ".concat(c.rank, ".")
            })), F$(3 === l.rank || 1 === l.rank, (function() {
                return "Error in batchNorm3D: variance must be rank 3 or rank 1 " + "but got rank ".concat(l.rank, ".")
            })), null != o && F$(3 === o.rank || 1 === o.rank, (function() {
                return "Error in batchNorm3D: scale must be rank 3 or rank 1 " + "but got rank ".concat(o.rank, ".")
            })), null != s && F$(3 === s.rank || 1 === s.rank, (function() {
                return "Error in batchNorm3D: offset must be rank 3 or rank 1 " + "but got rank ".concat(s.rank, ".")
            })), a7(u, c, l, s, o, i)
        }
    });
    var s7 = B5({
        batchNorm4d_: function(e, t, n, r, a, i) {
            var o, s, u = L5(e, "x", "batchNorm"),
                c = L5(t, "mean", "batchNorm"),
                l = L5(n, "variance", "batchNorm");
            return null != a && (o = L5(a, "scale", "batchNorm")), null != r && (s = L5(r, "offset", "batchNorm")), F$(4 === u.rank, (function() {
                return "Error in batchNorm4D: x must be rank 4 but got rank " + "".concat(u.rank, ".")
            })), F$(4 === c.rank || 1 === c.rank, (function() {
                return "Error in batchNorm4D: mean must be rank 4 or rank 1 but " + "got rank ".concat(c.rank, ".")
            })), F$(4 === l.rank || 1 === l.rank, (function() {
                return "Error in batchNorm4D: variance must be rank 4 or rank 1 " + "but got rank ".concat(l.rank, ".")
            })), null != o && F$(4 === o.rank || 1 === o.rank, (function() {
                return "Error in batchNorm4D: scale must be rank 4 or rank 1 " + "but got rank ".concat(o.rank, ".")
            })), null != s && F$(4 === s.rank || 1 === s.rank, (function() {
                return "Error in batchNorm4D: offset must be rank 4 or rank 1 " + "but got rank ".concat(s.rank, ".")
            })), a7(u, c, l, s, o, i)
        }
    });
    var u7 = B5({
        bincount_: function(e, t, n) {
            var r = L5(e, "x", "bincount"),
                a = L5(t, "weights", "bincount");
            F$("int32" === r.dtype, (function() {
                return "Error in bincount: input " + "dtype must be int32, but got ".concat(r.dtype)
            })), F$(n >= 0, (function() {
                return "size must be non-negative, but got ".concat(n, ".")
            })), F$(a.size === r.size || 0 === a.size, (function() {
                return "Error in bincount: weights must have the same size as input or" + "0-length, but got input shape: ".concat(r.shape, ", weights shape: ") + "".concat(a.shape, ".")
            }));
            var i = {
                    x: r,
                    weights: a
                },
                o = {
                    size: n
                };
            return E5.runKernel(j0, i, o)
        }
    });
    var c7 = B5({
        bitwiseAnd_: function(e, t) {
            var n = L5(e, "x", "bitwiseAnd"),
                r = L5(t, "y", "bitwiseAnd");
            if (!P$(n.shape, r.shape)) throw new Error("BitwiseAnd: Tensors must have the same shape. x: ".concat(n.shape, ", y: ").concat(r.shape));
            if ("int32" !== n.dtype || "int32" !== r.dtype) throw new Error("BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ".concat(n.dtype, " and type of y: ").concat(r.dtype));
            var a = {
                a: n,
                b: r
            };
            return E5.runKernel(H0, a)
        }
    });
    var l7 = B5({
        broadcastArgs_: function(e, t) {
            var n = L5(e, "s0", "broadcastArgs", "int32"),
                r = L5(t, "s1", "broadcastArgs", "int32");
            if (1 !== n.rank) throw new Error("broadcastArgs(): first input must be a vector (rank=1). " + "Has rank ".concat(n.rank));
            if (1 !== r.rank) throw new Error("broadcastArgs(): second input must be a vector (rank=1). " + "Has rank ".concat(r.rank));
            var a = {
                s0: n,
                s1: r
            };
            return E5.runKernel(K0, a)
        }
    });
    var h7 = B5({
        broadcastTo_: function(e, t) {
            var n = L5(e, "broadcastTo", "x"),
                r = n.shape;
            if (p0(t), t.length < n.rank) throw new Error("broadcastTo(): shape.length=".concat(t.length, " < input.rank=").concat(n.rank, "."));
            if (t.length > n.rank) {
                for (var a = n.shape.slice(); a.length < t.length;) a.unshift(1);
                n = X8(n, a)
            }
            for (var i = n.shape, o = Array.from(t), s = t.length - 1; s >= 0; s--)
                if (i[s] === t[s]) o[s] = 1;
                else if (1 !== n.shape[s]) throw new Error("broadcastTo(): [".concat(r, "] cannot be broadcast to [").concat(t, "]."));
            var u = o.map((function(e, t) {
                return e > 1 ? t : -1
            })).filter((function(e) {
                return e >= 0
            }));
            if (0 === u.length) return p8(n);
            var c = {
                    x: n
                },
                l = {
                    reps: o
                };
            return E5.runKernel(I3, c, l)
        }
    });
    var p7 = B5({
        ceil_: function(e) {
            var t = {
                x: L5(e, "x", "ceil", "float32")
            };
            return E5.runKernel(Y0, t)
        }
    });

    function f7(e, t, n) {
        p0(e);
        var r = {
            shape: e,
            value: t,
            dtype: n = n || n0(t)
        };
        return E5.runKernel(_1, {}, r)
    }
    var d7 = B5({
        clipByValue_: function(e, t, n) {
            var r = L5(e, "x", "clipByValue");
            if (F$(t <= n, (function() {
                    return "Error in clip: min (".concat(t, ") must be ") + "less than or equal to max (".concat(n, ").")
                })), t === n) return f7(r.shape, t, r.dtype);
            var a = {
                    x: r
                },
                i = {
                    clipValueMin: t,
                    clipValueMax: n
                };
            return E5.runKernel(J0, a, i)
        }
    });
    var v7 = B5({
        concat1d_: function(e) {
            return Z8(e, 0)
        }
    });
    var m7 = B5({
        concat2d_: function(e, t) {
            return Z8(e, t)
        }
    });
    var g7 = B5({
        concat3d_: function(e, t) {
            return Z8(e, t)
        }
    });
    var y7 = B5({
        concat4d_: function(e, t) {
            return Z8(e, t)
        }
    });
    var b7 = B5({
        conv2d_: function(e, t, n, r) {
            var a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "NHWC",
                i = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : [1, 1],
                o = arguments.length > 6 ? arguments[6] : void 0,
                s = L5(e, "x", "conv2d", "float32"),
                u = L5(t, "filter", "conv2d", "float32"),
                c = s,
                l = !1;
            3 === s.rank && (l = !0, c = X8(s, [1, s.shape[0], s.shape[1], s.shape[2]])), F$(4 === c.rank, (function() {
                return "Error in conv2d: input must be rank 4, but got rank ".concat(c.rank, ".")
            })), F$(4 === u.rank, (function() {
                return "Error in conv2d: filter must be rank 4, but got rank " + "".concat(u.rank, ".")
            })), K8("conv2d", r, o);
            var h = "NHWC" === a ? c.shape[3] : c.shape[1];
            F$(h === u.shape[2], (function() {
                return "Error in conv2d: depth of input (".concat(h, ") must match ") + "input depth for filter ".concat(u.shape[2], ".")
            })), F$(j8(n, i), (function() {
                return "Error in conv2D: Either strides or dilations must be 1. " + "Got strides ".concat(n, " and dilations '").concat(i, "'")
            })), F$(H8(i), (function() {
                return "Error in conv2D: Dilated rates should be larger than 0."
            })), F$(H8(n), (function() {
                return "Error in conv2D: Strides should be larger than 0."
            }));
            var p = {
                    x: c,
                    filter: u
                },
                f = {
                    strides: n,
                    pad: r,
                    dataFormat: a,
                    dilations: i,
                    dimRoundingMode: o
                },
                d = E5.runKernel(e1, p, f);
            return l ? X8(d, [d.shape[1], d.shape[2], d.shape[3]]) : d
        }
    });
    var x7 = B5({
        conv1d_: function(e, t, n, r) {
            var a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "NWC",
                i = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1,
                o = arguments.length > 6 ? arguments[6] : void 0,
                s = L5(e, "x", "conv1d"),
                u = L5(t, "filter", "conv1d"),
                c = s,
                l = !1;
            2 === s.rank && (l = !0, c = X8(s, [1, s.shape[0], s.shape[1]])), F$(3 === c.rank, (function() {
                return "Error in conv1d: input must be rank 3, but got rank ".concat(c.rank, ".")
            })), F$(3 === u.rank, (function() {
                return "Error in conv1d: filter must be rank 3, but got rank " + "".concat(u.rank, ".")
            })), K8("conv1d", r, o), F$(c.shape[2] === u.shape[1], (function() {
                return "Error in conv1d: depth of input (".concat(c.shape[2], ") must match ") + "input depth for filter ".concat(u.shape[1], ".")
            })), F$(j8(n, i), (function() {
                return "Error in conv1D: Either stride or dilation must be 1. " + "Got stride ".concat(n, " and dilation '").concat(i, "'")
            })), F$(H8(i), (function() {
                return "Error in conv1D: Dilated rates should be larger than 0."
            })), F$(H8(n), (function() {
                return "Error in conv1D: Stride should be larger than 0."
            })), F$("NWC" === a, (function() {
                return "Error in conv1d: got dataFormat of ".concat(a, " but only NWC is currently supported.")
            }));
            var h = X8(u, [1, u.shape[0], u.shape[1], u.shape[2]]),
                p = X8(c, [c.shape[0], 1, c.shape[1], c.shape[2]]),
                f = [1, n],
                d = [1, i],
                v = "NHWC",
                m = b7(p, h, f, r, v, d, o);
            return X8(m, l ? [m.shape[2], m.shape[3]] : [m.shape[0], m.shape[2], m.shape[3]])
        }
    });
    var k7 = B5({
        conv2DBackpropInput_: function(e, t, n, r, a) {
            var i = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "NHWC",
                o = arguments.length > 6 ? arguments[6] : void 0;
            F$(e.length === t.rank, (function() {
                return "Length of inShape " + "(".concat(e.length, ") and rank of dy (").concat(t.rank, ") must match")
            }));
            var s = e,
                u = t,
                c = !1;
            3 === t.rank && (c = !0, u = X8(t, [1, t.shape[0], t.shape[1], t.shape[2]]), s = [1, e[0], e[1], e[2]]), F$(4 === s.length, (function() {
                return "Error in conv2dDerInput: inShape must be length 4, but got length " + "".concat(s.length, ".")
            })), F$(4 === u.rank, (function() {
                return "Error in conv2dDerInput: dy must be rank 4, but got " + "rank ".concat(u.rank)
            })), F$(4 === n.rank, (function() {
                return "Error in conv2dDerInput: filter must be rank 4, but got " + "rank ".concat(n.rank)
            }));
            var l = "NHWC" === i ? s[3] : s[1],
                h = "NHWC" === i ? u.shape[3] : u.shape[1];
            F$(l === n.shape[2], (function() {
                return "Error in conv2dDerInput: depth of input (".concat(l, ") must ") + "match input depth for filter ".concat(n.shape[2], ".")
            })), F$(h === n.shape[3], (function() {
                return "Error in conv2dDerInput: depth of output (".concat(h, ") must ") + "match output depth for filter ".concat(n.shape[3], ".")
            })), K8("conv2dDerInput", a, o);
            var p = {
                    dy: u,
                    filter: n
                },
                f = {
                    strides: r,
                    pad: a,
                    dataFormat: i,
                    dimRoundingMode: o,
                    inputShape: s
                },
                d = E5.runKernel(n1, p, f);
            return c ? X8(d, [d.shape[1], d.shape[2], d.shape[3]]) : d
        }
    });
    var w7 = B5({
        conv2dTranspose_: function(e, t, n, r, a, i) {
            var o = L5(e, "x", "conv2dTranspose"),
                s = L5(t, "filter", "conv2dTranspose");
            return k7(n, o, s, r, a, "NHWC", i)
        }
    });
    var I7 = B5({
        conv3d_: function(e, t, n, r) {
            var a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "NDHWC",
                i = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : [1, 1, 1],
                o = L5(e, "x", "conv3d"),
                s = L5(t, "filter", "conv3d"),
                u = o,
                c = !1;
            4 === o.rank && (c = !0, u = X8(o, [1, o.shape[0], o.shape[1], o.shape[2], o.shape[3]])), F$(5 === u.rank, (function() {
                return "Error in conv3d: input must be rank 5, but got rank ".concat(u.rank, ".")
            })), F$(5 === s.rank, (function() {
                return "Error in conv3d: filter must be rank 5, but got rank " + "".concat(s.rank, ".")
            })), F$(u.shape[4] === s.shape[3], (function() {
                return "Error in conv3d: depth of input (".concat(u.shape[4], ") must match ") + "input depth for filter ".concat(s.shape[3], ".")
            })), F$(j8(n, i), (function() {
                return "Error in conv3D: Either strides or dilations must be 1. " + "Got strides ".concat(n, " and dilations '").concat(i, "'")
            })), F$("NDHWC" === a, (function() {
                return "Error in conv3d: got dataFormat of ".concat(a, " but only NDHWC is currently supported.")
            })), F$(H8(i), (function() {
                return "Error in conv3D: Dilated rates should be larger than 0."
            })), F$(H8(n), (function() {
                return "Error in conv3D: Strides should be larger than 0."
            }));
            var l = {
                    x: u,
                    filter: s
                },
                h = {
                    strides: n,
                    pad: r,
                    dataFormat: a,
                    dilations: i
                },
                p = E5.runKernel(r1, l, h);
            return c ? X8(p, [p.shape[1], p.shape[2], p.shape[3], p.shape[4]]) : p
        }
    });
    var N7 = B5({
        conv3DBackpropInput_: function(e, t, n, r, a) {
            F$(e.length === t.rank, (function() {
                return "Length of inShape " + "(".concat(e.length, ") and rank of dy (").concat(t.rank, ") must match")
            }));
            var i = e,
                o = t,
                s = !1;
            4 === t.rank && (s = !0, o = X8(t, [1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]]), i = [1, e[0], e[1], e[2], e[3]]);
            var u = i[4],
                c = o.shape[4];
            F$(5 === i.length, (function() {
                return "Error in conv3dDerInput: inShape must be length 5, but got length " + "".concat(i.length, ".")
            })), F$(5 === o.rank, (function() {
                return "Error in conv3dDerInput: dy must be rank 5, but got " + "rank ".concat(o.rank)
            })), F$(5 === n.rank, (function() {
                return "Error in conv3dDerInput: filter must be rank 5, but got " + "rank ".concat(n.rank)
            })), F$(u === n.shape[3], (function() {
                return "Error in conv3dDerInput: depth of input (".concat(u, ") must ") + "match input depth for filter ".concat(n.shape[3], ".")
            })), F$(c === n.shape[4], (function() {
                return "Error in conv3dDerInput: depth of output (".concat(c, ") must ") + "match output depth for filter ".concat(n.shape[4], ".")
            }));
            var l = {
                    dy: o,
                    filter: n
                },
                h = {
                    pad: a,
                    strides: r,
                    inputShape: i
                },
                p = E5.runKernel(i1, l, h);
            return s ? X8(p, [p.shape[1], p.shape[2], p.shape[3], p.shape[4]]) : p
        }
    });
    var S7 = B5({
        conv3dTranspose_: function(e, t, n, r, a) {
            var i = L5(e, "x", "conv3dTranspose"),
                o = L5(t, "filter", "conv3dTranspose");
            return N7(n, i, o, r, a)
        }
    });
    var T7 = B5({
        cos_: function(e) {
            var t = {
                x: L5(e, "x", "cos", "float32")
            };
            return E5.runKernel(o1, t)
        }
    });
    var E7 = B5({
        cosh_: function(e) {
            var t = {
                x: L5(e, "x", "cosh", "float32")
            };
            return E5.runKernel(s1, t)
        }
    });
    var C7 = B5({
        cumprod_: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
                a = L5(e, "x", "cumprod"),
                i = {
                    x: a
                },
                o = {
                    axis: t,
                    exclusive: n,
                    reverse: r
                };
            return E5.runKernel(u1, i, o)
        }
    });
    var A7 = B5({
        cumsum_: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
                a = L5(e, "x", "cumsum"),
                i = {
                    x: a
                },
                o = {
                    axis: t,
                    exclusive: n,
                    reverse: r
                };
            return E5.runKernel(c1, i, o)
        }
    });
    var R7 = B5({
        denseBincount_: function(e, t, n) {
            var r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
                a = L5(e, "x", "denseBincount"),
                i = L5(t, "weights", "denseBincount");
            F$("int32" === a.dtype, (function() {
                return "Error in denseBincount: input " + "dtype must be int32, but got ".concat(a.dtype)
            })), F$(a.rank <= 2, (function() {
                return "Error in denseBincount: input must be at most rank 2, but got " + "rank ".concat(a.rank, ".")
            })), F$(n >= 0, (function() {
                return "size must be non-negative, but got ".concat(n, ".")
            })), F$(i.size === a.size || 0 === i.size, (function() {
                return "Error in denseBincount: weights must have the same shape as x or " + "0-length, but got x shape: ".concat(a.shape, ", weights shape: ") + "".concat(i.shape, ".")
            }));
            var o = {
                    x: a,
                    weights: i
                },
                s = {
                    size: n,
                    binaryOutput: r
                };
            return E5.runKernel(h1, o, s)
        }
    });
    var _7 = B5({
        depthToSpace_: function(e, t) {
            var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "NHWC",
                r = L5(e, "x", "depthToSpace", "float32"),
                a = "NHWC" === n ? r.shape[1] : r.shape[2],
                i = "NHWC" === n ? r.shape[2] : r.shape[3],
                o = "NHWC" === n ? r.shape[3] : r.shape[1];
            F$(t > 1, (function() {
                return "blockSize should be > 1 for depthToSpace, but was: ".concat(t)
            })), F$(a * t >= 0, (function() {
                return "Negative dimension size caused by overflow when multiplying\n    ".concat(a, " and ").concat(t, "  for depthToSpace with input shape\n    ").concat(r.shape)
            })), F$(i * t >= 0, (function() {
                return "Negative dimension size caused by overflow when multiplying\n    ".concat(i, " and ").concat(t, " for depthToSpace with input shape\n        ").concat(r.shape)
            })), F$(o % (t * t) == 0, (function() {
                return "Dimension size must be evenly divisible by ".concat(t * t, " but is ").concat(o, " for depthToSpace with input shape ").concat(r.shape)
            }));
            var s = {
                    x: r
                },
                u = {
                    blockSize: t,
                    dataFormat: n
                };
            return E5.runKernel(p1, s, u)
        }
    });
    var O7 = B5({
        depthwiseConv2d_: function(e, t, n, r) {
            var a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "NHWC",
                i = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : [1, 1],
                o = arguments.length > 6 ? arguments[6] : void 0,
                s = L5(e, "x", "depthwiseConv2d", "float32"),
                u = L5(t, "filter", "depthwiseConv2d", "float32"),
                c = s,
                l = !1;
            3 === s.rank && (l = !0, c = X8(s, [1, s.shape[0], s.shape[1], s.shape[2]])), F$(4 === c.rank, (function() {
                return "Error in depthwiseConv2d: input must be rank 4, but got " + "rank ".concat(c.rank, ".")
            })), F$(4 === u.rank, (function() {
                return "Error in depthwiseConv2d: filter must be rank 4, but got rank " + "".concat(u.rank, ".")
            }));
            var h = "NHWC" === a ? c.shape[3] : c.shape[1];
            F$(h === u.shape[2], (function() {
                return "Error in depthwiseConv2d: number of input channels " + "(".concat(h, ") must match the inChannels dimension in ") + "filter ".concat(u.shape[2], ".")
            })), K8("depthwiseConv2d", r, o);
            var p = {
                    x: c,
                    filter: u
                },
                f = {
                    strides: n,
                    pad: r,
                    dataFormat: a,
                    dilations: i,
                    dimRoundingMode: o
                },
                d = E5.runKernel(f1, p, f);
            return l ? X8(d, [d.shape[1], d.shape[2], d.shape[3]]) : d
        }
    });
    var F7 = B5({
        diag_: function(e) {
            var t = {
                x: L5(e, "x", "diag")
            };
            return E5.runKernel(m1, t)
        }
    });
    var D7 = B5({
        dilation2d_: function(e, t, n, r) {
            var a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : [1, 1],
                i = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "NHWC",
                o = L5(e, "x", "dilation2d"),
                s = L5(t, "filter", "dilation2d");
            F$(3 === o.rank || 4 === o.rank, (function() {
                return "Error in dilation2d: input must be rank 3 or 4, but got rank " + "".concat(o.rank, ".")
            })), F$(3 === s.rank, (function() {
                return "Error in dilation2d: filter must be rank 3, but got rank " + "".concat(s.rank, ".")
            })), F$("NHWC" === i, (function() {
                return "Error in dilation2d: Only NHWC is currently supported, " + "but got dataFormat of ".concat(i)
            }));
            var u = o,
                c = !1;
            3 === o.rank && (u = X8(o, [1, o.shape[0], o.shape[1], o.shape[2]]), c = !0), F$(u.shape[3] === s.shape[2], (function() {
                return "Error in dilation2d:  input and filter must have the same depth: ".concat(u.shape[3], " vs ").concat(s.shape[2])
            }));
            var l = {
                    x: u,
                    filter: s
                },
                h = {
                    strides: n,
                    pad: r,
                    dilations: a
                },
                p = E5.runKernel(g1, l, h);
            return c ? X8(p, [p.shape[1], p.shape[2], p.shape[3]]) : p
        }
    });

    function M7(e, t) {
        for (var n = e.length, r = [], a = 0; a < n; a++) {
            var i = n - 1 - a,
                o = e[i] || 1;
            (t[t.length - 1 - a] || 1) > 1 && 1 === o && r.unshift(i)
        }
        return r
    }

    function L7(e, t) {
        for (var n = [], r = 0; r < t.length; r++) {
            var a = e[e.length - r - 1],
                i = t.length - r - 1,
                o = t[i];
            (null == a || 1 === a && o > 1) && n.unshift(i)
        }
        return n
    }

    function z7(e, t) {
        for (var n = Math.max(e.length, t.length), r = new Array(n), a = 0; a < n; a++) {
            var i = e[e.length - a - 1];
            null == i && (i = 1);
            var o = t[t.length - a - 1];
            if (null == o && (o = 1), 1 === i) r[n - a - 1] = o;
            else if (1 === o) r[n - a - 1] = i;
            else {
                if (i !== o) {
                    var s = "Operands could not be broadcast together with shapes " + "".concat(e, " and ").concat(t, ".");
                    throw Error(s)
                }
                r[n - a - 1] = i
            }
        }
        return r
    }
    var P7 = {
        __proto__: null,
        assertAndGetBroadcastShape: z7,
        getBroadcastDims: M7,
        getReductionAxes: L7
    };
    var B7 = B5({
        equal_: function(e, t) {
            var n = L5(e, "a", "equal", "string_or_numeric"),
                r = L5(t, "b", "equal", "string_or_numeric"),
                a = S(v5(n, r), 2);
            n = a[0], r = a[1], z7(n.shape, r.shape);
            var i = {
                a: n,
                b: r
            };
            return E5.runKernel(T1, i)
        }
    });
    var W7 = B5({
        where_: function(e, t, n) {
            var r = L5(t, "a", "where"),
                a = L5(n, "b", "where"),
                i = L5(e, "condition", "where", "bool"),
                o = z7(z7(i.shape, r.shape), a.shape),
                s = {
                    condition: h7(i, o),
                    t: h7(r, o),
                    e: h7(a, o)
                };
            return E5.runKernel(Y2, s)
        }
    });
    var U7 = B5({
        zerosLike_: function(e) {
            var t = {
                x: L5(e, "x", "zerosLike")
            };
            return E5.runKernel(R3, t)
        }
    });
    var V7 = B5({
        divNoNan_: function(e, t) {
            var n = L5(e, "a", "div"),
                r = L5(t, "b", "div"),
                a = S(v5(n, r), 2);
            n = a[0], r = a[1];
            var i = m8(n, r),
                o = U7(i),
                s = B7(r, o);
            return W7(s, o, i)
        }
    });
    var G7 = B5({
        dot_: function(e, t) {
            var n = L5(e, "t1", "dot"),
                r = L5(t, "t2", "dot");
            F$(!(1 !== n.rank && 2 !== n.rank || 1 !== r.rank && 2 !== r.rank), (function() {
                return "Error in dot: inputs must all be rank 1 or 2, but got ranks " + "".concat(n.rank, " and ").concat(r.rank, ".")
            }));
            var a = 1 === n.rank ? n.size : n.shape[1],
                i = 1 === r.rank ? r.size : r.shape[0];
            if (F$(a === i, (function() {
                    return "Error in dot: inner dimensions of inputs must match, but got " + "".concat(a, " and ").concat(i, ".")
                })), 1 === n.rank && 1 === r.rank) {
                var o = X8(n, [1, -1]),
                    s = X8(r, [-1, 1]),
                    u = Q8(o, s);
                return X8(u, [])
            }
            if (1 === n.rank && 2 === r.rank) {
                var c = X8(n, [1, -1]),
                    l = X8(r, [r.shape[0], r.shape[1]]),
                    h = Q8(c, l);
                return X8(h, [h.size])
            }
            if (2 === n.rank && 1 === r.rank) {
                var p = X8(r, [-1, 1]),
                    f = Q8(n, p);
                return X8(f, [f.size])
            }
            var d = X8(r, [r.shape[0], r.shape[1]]);
            return Q8(n, d)
        }
    });
    var j7 = B5({
        einsum_: function(e) {
            for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) n[r - 1] = arguments[r];
            var a = n.map((function(e, t) {
                    return L5(e, "tensors".concat(t), "einsum")
                })),
                i = {
                    equation: e
                };
            return E5.runKernel(w1, a, i)
        }
    });
    var H7 = B5({
        elu_: function(e) {
            var t = {
                x: L5(e, "x", "elu", "float32")
            };
            return E5.runKernel(I1, t)
        }
    });
    var q7 = B5({
        ensureShape_: function(e, t) {
            var n = L5(e, "x", "ensureShape", "string_or_numeric");
            if (!z$(n.shape, t)) throw new Error("EnsureShape: Shape of tensor ".concat(n.shape, " is not compatible with expected shape ").concat(t));
            return e
        }
    });
    var K7 = B5({
        erf_: function(e) {
            var t = L5(e, "x", "erf");
            F$("int32" === t.dtype || "float32" === t.dtype, (function() {
                return "Input dtype must be `int32` or `float32`."
            })), "int32" === t.dtype && (t = h8(t, "float32"));
            var n = {
                x: t
            };
            return E5.runKernel(S1, n)
        }
    });

    function X7(e, t) {
        for (var n = 0; n < e.length; ++n)
            if (e[e.length - n - 1] !== t - 1 - n) return !1;
        return !0
    }

    function Y7(e, t, n) {
        for (var r = e.length + t.length, a = [], i = 0, o = 0, s = 0; s < r; s++) - 1 === n.indexOf(s) ? a.push(e[i++]) : a.push(t[o++]);
        return a
    }

    function J7(e, t) {
        for (var n = [], r = e.length, a = 0; a < r; a++) - 1 === t.indexOf(a) && n.push(e[a]);
        var i = t.map((function(t) {
            return e[t]
        }));
        return [n, i]
    }

    function Z7(e, t) {
        return Y7(e, t.map((function(e) {
            return 1
        })), t)
    }

    function Q7(e, t, n) {
        F$(X7(t, n), (function() {
            return "".concat(e, " supports only inner-most axes for now. ") + "Got axes ".concat(t, " and rank-").concat(n, " input.")
        }))
    }

    function $7(e, t) {
        if (X7(e, t)) return null;
        for (var n = [], r = 0; r < t; ++r) - 1 === e.indexOf(r) && n.push(r);
        return e.forEach((function(e) {
            return n.push(e)
        })), n
    }

    function e9(e) {
        return e.map((function(e, t) {
            return [t, e]
        })).sort((function(e, t) {
            return e[1] - t[1]
        })).map((function(e) {
            return e[0]
        }))
    }

    function t9(e, t) {
        for (var n = [], r = t - e; r < t; ++r) n.push(r);
        return n
    }
    var n9 = B5({
        max_: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                r = L5(e, "x", "max"),
                a = {
                    x: r
                },
                i = {
                    reductionIndices: t,
                    keepDims: n
                };
            return E5.runKernel(a2, a, i)
        }
    });
    var r9 = B5({
        min_: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                r = L5(e, "x", "min"),
                a = {
                    x: r
                },
                i = {
                    axis: t,
                    keepDims: n
                };
            return E5.runKernel(p2, a, i)
        }
    });
    var a9 = B5({
        pow_: function(e, t) {
            var n = L5(e, "base", "pow"),
                r = L5(t, "exp", "pow"),
                a = S(v5(n, r), 2),
                i = {
                    a: n = a[0],
                    b: r = a[1]
                };
            return E5.runKernel(E2, i)
        }
    });

    function i9(e, t) {
        if ((U4(e) && "string" !== t || Array.isArray(e)) && "complex64" !== t) throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
        if ("string" === t && U4(e) && !(e instanceof Uint8Array)) throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
        return U5(e, [], [], t)
    }
    var o9 = B5({
        sqrt_: function(e) {
            var t = {
                x: L5(e, "x", "sqrt", "float32")
            };
            return E5.runKernel(r3, t)
        }
    });
    var s9 = B5({
        square_: function(e) {
            var t = L5(e, "x", "square");
            return E5.runKernel("Square", {
                x: t
            }, {})
        }
    });
    var u9 = B5({
        sum_: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                r = L5(e, "x", "sum");
            "bool" === r.dtype && (r = h8(r, "int32"));
            var a = {
                    x: r
                },
                i = {
                    axis: t,
                    keepDims: n
                };
            return E5.runKernel(a3, a, i)
        }
    });

    function c9(e, t) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
        if (0 === e.rank) return y8(e);
        if (1 !== e.rank && null === n) return c9(X8(e, [-1]), t, n);
        if (1 === e.rank || "number" == typeof n || Array.isArray(n) && 1 === n.length) {
            if (1 === t) return u9(y8(e), n);
            if (t === 1 / 0) return n9(y8(e), n);
            if (t === -1 / 0) return r9(y8(e), n);
            if ("euclidean" === t || 2 === t) return o9(u9(a9(y8(e), i9(2, "int32")), n));
            throw new Error("Error in norm: invalid ord value: ".concat(t))
        }
        if (Array.isArray(n) && 2 === n.length) {
            if (1 === t) return n9(u9(y8(e), n[0]), n[1] - 1);
            if (t === 1 / 0) return n9(u9(y8(e), n[1]), n[0]);
            if (t === -1 / 0) return r9(u9(y8(e), n[1]), n[0]);
            if ("fro" === t || "euclidean" === t) return o9(u9(s9(e), n));
            throw new Error("Error in norm: invalid ord value: ".concat(t))
        }
        throw new Error("Error in norm: invalid axis: ".concat(n))
    }
    var l9 = B5({
        norm_: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "euclidean",
                n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
                a = c9(e = L5(e, "x", "norm"), t, n),
                i = a.shape;
            if (r) {
                var o = j$(n, e.shape);
                i = Z7(a.shape, o)
            }
            return X8(a, i)
        }
    });
    var h9 = B5({
        euclideanNorm_: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            return l9(e, "euclidean", t, n)
        }
    });
    var p9 = B5({
        exp_: function(e) {
            var t = {
                x: L5(e, "x", "exp")
            };
            return E5.runKernel(E1, t)
        }
    });
    var f9 = B5({
        expandDims_: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                n = L5(e, "x", "expandDims", "string_or_numeric");
            F$(t <= n.rank, (function() {
                return "Axis must be <= rank of the tensor"
            }));
            var r = {
                    input: n
                },
                a = {
                    dim: t
                };
            return E5.runKernel(C1, r, a)
        }
    });
    var d9 = B5({
        expm1_: function(e) {
            var t = {
                x: L5(e, "x", "expm1")
            };
            return E5.runKernel(A1, t)
        }
    });
    var v9 = B5({
        tile_: function(e, t) {
            var n = L5(e, "x", "tile", "string_or_numeric");
            F$(n.rank === t.length, (function() {
                return "Error in transpose: rank of input ".concat(n.rank, " ") + "must match length of reps ".concat(t, ".")
            }));
            var r = {
                    x: n
                },
                a = {
                    reps: t
                };
            return E5.runKernel(I3, r, a)
        }
    });
    var m9 = B5({
        eye_: function(e, t, n) {
            var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "float32";
            null == t && (t = e);
            for (var a = l8([e, t], r), i = e <= t ? e : t, o = 0; o < i; ++o) a.set(1, o, o);
            var s = X8(a.toTensor(), [e, t]);
            if (null == n) return s;
            if (1 === n.length) return v9(f9(s, 0), [n[0], 1, 1]);
            if (2 === n.length) return v9(f9(f9(s, 0), 0), [n[0], n[1], 1, 1]);
            if (3 === n.length) return v9(f9(f9(f9(s, 0), 0), 0), [n[0], n[1], n[2], 1, 1]);
            throw new Error("eye() currently supports only 1D and 2D " + "batchShapes, but received ".concat(n.length, "D."))
        }
    });
    var g9 = B5({
        floor_: function(e) {
            var t = {
                x: L5(e, "x", "floor", "float32")
            };
            return E5.runKernel(F1, t)
        }
    });
    var y9 = B5({
        gather_: function(e, t) {
            var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                a = L5(e, "x", "gather"),
                i = L5(t, "indices", "gather", "int32"),
                o = {
                    x: a,
                    indices: i
                },
                s = {
                    axis: n,
                    batchDims: r
                };
            return E5.runKernel(L1, o, s)
        }
    });
    var b9 = B5({
        greater_: function(e, t) {
            var n = L5(e, "a", "greater", "string_or_numeric"),
                r = L5(t, "b", "greater", "string_or_numeric"),
                a = S(v5(n, r), 2);
            n = a[0], r = a[1], z7(n.shape, r.shape);
            var i = {
                a: n,
                b: r
            };
            return E5.runKernel(P1, i)
        }
    });
    var x9 = B5({
        greaterEqual_: function(e, t) {
            var n = L5(e, "a", "greaterEqual", "string_or_numeric"),
                r = L5(t, "b", "greaterEqual", "string_or_numeric"),
                a = S(v5(n, r), 2);
            n = a[0], r = a[1], z7(n.shape, r.shape);
            var i = {
                a: n,
                b: r
            };
            return E5.runKernel(B1, i)
        }
    });
    var k9 = B5({
        imag_: function(e) {
            var t = {
                input: L5(e, "input", "imag")
            };
            return E5.runKernel(V1, t)
        }
    });
    var w9 = B5({
        isFinite_: function(e) {
            var t = {
                x: L5(e, "x", "isFinite")
            };
            return E5.runKernel(G1, t)
        }
    });
    var I9 = B5({
        isInf_: function(e) {
            var t = {
                x: L5(e, "x", "isInf")
            };
            return E5.runKernel(j1, t)
        }
    });
    var N9 = B5({
        isNaN_: function(e) {
            var t = {
                x: L5(e, "x", "isNaN")
            };
            return E5.runKernel(H1, t)
        }
    });
    var S9 = B5({
        leakyRelu_: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .2,
                n = L5(e, "x", "leakyRelu"),
                r = {
                    x: n
                },
                a = {
                    alpha: t
                };
            return E5.runKernel(q1, r, a)
        }
    });
    var T9 = B5({
        less_: function(e, t) {
            var n = L5(e, "a", "less", "string_or_numeric"),
                r = L5(t, "b", "less", "string_or_numeric"),
                a = S(v5(n, r), 2);
            n = a[0], r = a[1], z7(n.shape, r.shape);
            var i = {
                a: n,
                b: r
            };
            return E5.runKernel(K1, i)
        }
    });
    var E9 = B5({
        lessEqual_: function(e, t) {
            var n = L5(e, "a", "lessEqual", "string_or_numeric"),
                r = L5(t, "b", "lessEqual", "string_or_numeric"),
                a = S(v5(n, r), 2);
            n = a[0], r = a[1], z7(n.shape, r.shape);
            var i = {
                a: n,
                b: r
            };
            return E5.runKernel(X1, i)
        }
    });

    function C9(e, t, n) {
        if (n <= 0) throw new Error("The number of values should be positive.");
        var r = {
            start: e,
            stop: t,
            num: n
        };
        return E5.runKernel(Y1, {}, r)
    }
    var A9 = B5({
        localResponseNormalization_: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5,
                n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1,
                a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : .5,
                i = L5(e, "x", "localResponseNormalization");
            F$(4 === i.rank || 3 === i.rank, (function() {
                return "Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ".concat(i.rank, ".")
            })), F$(B$(t), (function() {
                return "Error in localResponseNormalization: depthRadius must be an " + "integer but got depthRadius ".concat(t, ".")
            }));
            var o = i,
                s = !1;
            3 === i.rank && (s = !0, o = X8(i, [1, i.shape[0], i.shape[1], i.shape[2]]));
            var u = {
                    x: o
                },
                c = {
                    depthRadius: t,
                    bias: n,
                    alpha: r,
                    beta: a
                },
                l = E5.runKernel(n2, u, c);
            return s ? X8(l, [l.shape[1], l.shape[2], l.shape[3]]) : l
        }
    });
    var R9 = B5({
        log_: function(e) {
            var t = {
                x: L5(e, "x", "log", "float32")
            };
            return E5.runKernel(J1, t)
        }
    });
    var _9 = B5({
        log1p_: function(e) {
            var t = {
                x: L5(e, "x", "log1p")
            };
            return E5.runKernel(Z1, t)
        }
    });

    function O9(e, t) {
        F$(r0(e), (function() {
            return "The f passed in variableGrads(f) must be a function"
        })), F$(null == t || Array.isArray(t) && t.every((function(e) {
            return e instanceof c5
        })), (function() {
            return "The varList passed in variableGrads(f, varList) must be an array of variables"
        }));
        var n = null != t;
        if (!n)
            for (var r in t = [], E5.registeredVariables) t.push(E5.registeredVariables[r]);
        var a = n ? t.filter((function(e) {
                return !e.trainable
            })) : null,
            i = t.length;
        t = t.filter((function(e) {
            return e.trainable
        })), F$(t.length > 0, (function() {
            return "variableGrads() expects at least one of the input variables to " + "be trainable, but none of the ".concat(i, " variables is ") + "trainable."
        }));
        var o = E5.gradients(e, t, null, !0),
            s = o.value,
            u = o.grads;
        F$(u.some((function(e) {
            return null != e
        })), (function() {
            return "Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."
        })), F$(0 === s.rank, (function() {
            return "The f passed in variableGrads(f) must return a scalar, but it " + "returned a rank-".concat(s.rank, " tensor")
        }));
        var c = {};
        return t.forEach((function(e, t) {
            null != u[t] && (c[e.name] = u[t])
        })), null != a && a.forEach((function(e) {
            return c[e.name] = null
        })), {
            value: s,
            grads: c
        }
    }

    function F9(e) {
        return E5.customGrad(e)
    }

    function D9(e) {
        if (e.filter((function(e) {
                return null == e
            })).length > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")
    }
    var M9 = B5({
        neg_: function(e) {
            var t = {
                x: L5(e, "x", "neg")
            };
            return E5.runKernel(y2, t)
        }
    });
    var L9 = B5({
        softplus_: function(e) {
            var t = {
                x: L5(e, "x", "softplus")
            };
            return E5.runKernel(n3, t)
        }
    });
    var z9 = B5({
        logSigmoid_: function(e) {
            var t = L5(e, "x", "logSigmoid"),
                n = F9((function(e) {
                    return {
                        value: M9(L9(M9(e))),
                        gradFunc: function(t) {
                            return g8(t, $8(M9(e)))
                        }
                    }
                }));
            return n(t)
        }
    });
    var P9 = B5({
        sub_: function(e, t) {
            var n = L5(e, "a", "sub"),
                r = L5(t, "b", "sub"),
                a = S(v5(n, r), 2),
                i = {
                    a: n = a[0],
                    b: r = a[1]
                };
            return E5.runKernel(x3, i)
        }
    });
    var B9 = B5({
        logSoftmax_: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1,
                n = L5(e, "logits", "logSoftmax");
            if (-1 === t && (t = n.rank - 1), t !== n.rank - 1) throw Error("Log Softmax along a non-last dimension is not yet supported. " + "Logits was rank ".concat(n.rank, " and axis was ").concat(t));
            var r = F9((function(e, n) {
                var r = n9(e, t, !0),
                    a = P9(e, r),
                    i = P9(h8(a, "float32"), R9(u9(p9(a), t, !0)));
                n([i]);
                return {
                    value: i,
                    gradFunc: function(e, n) {
                        var r = S(n, 1)[0],
                            a = p9(r);
                        return P9(e, g8(u9(e, t, !0), a))
                    }
                }
            }));
            return r(n)
        }
    });
    var W9 = B5({
        logSumExp_: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                r = L5(e, "x", "logSumExp"),
                a = j$(t, r.shape),
                i = n9(r, a, !0),
                o = P9(r, i),
                s = p9(o),
                u = u9(s, a),
                c = R9(u),
                l = d8(X8(i, c.shape), c);
            if (n) {
                var h = Z7(l.shape, a);
                return X8(l, h)
            }
            return l
        }
    });
    var U9 = B5({
        logicalAnd_: function(e, t) {
            var n = L5(e, "a", "logicalAnd", "bool"),
                r = L5(t, "b", "logicalAnd", "bool");
            z7(n.shape, r.shape);
            var a = {
                a: n,
                b: r
            };
            return E5.runKernel(Q1, a)
        }
    });
    var V9 = B5({
        logicalNot_: function(e) {
            var t = {
                x: L5(e, "x", "logicalNot", "bool")
            };
            return E5.runKernel($1, t)
        }
    });
    var G9 = B5({
        logicalOr_: function(e, t) {
            var n = L5(e, "a", "logicalOr", "bool"),
                r = L5(t, "b", "logicalOr", "bool");
            z7(n.shape, r.shape);
            var a = {
                a: n,
                b: r
            };
            return E5.runKernel(e2, a)
        }
    });
    var j9 = B5({
            logicalXor_: function(e, t) {
                var n = L5(e, "a", "logicalXor", "bool"),
                    r = L5(t, "b", "logicalXor", "bool");
                return z7(n.shape, r.shape), U9(G9(e, t), V9(U9(e, t)))
            }
        }),
        H9 = 2147483648;
    var q9 = B5({
        searchSorted_: function(e, t) {
            var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "left",
                r = L5(e, "sortedSequence", "searchSorted"),
                a = L5(t, "values", "searchSorted"),
                i = r.shape[r.shape.length - 1],
                o = a.shape[a.shape.length - 1],
                s = X8(r, [-1, i]),
                u = X8(a, [-1, o]);
            if (s.rank < 2) throw new Error("Sorted input argument must be at least 2-dimensional");
            if (s.shape[0] !== u.shape[0]) throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");
            if (L$(u.shape) >= H9) throw new Error("values tensor size must less than ".concat(H9));
            if (s.shape[1] >= H9) throw new Error("trailing dim_size must less than ".concat(H9, " for int32 output type, was ").concat(s.shape[1]));
            var c = {
                    sortedSequence: s,
                    values: u
                },
                l = {
                    side: n
                };
            return E5.runKernel(X2, c, l)
        }
    });

    function K9(e, t) {
        return q9(e, t, "left")
    }
    var X9 = B5({
        maxPool_: function(e, t, n, r, a) {
            var i = L5(e, "x", "maxPool"),
                o = i,
                s = !1;
            3 === i.rank && (s = !0, o = X8(i, [1, i.shape[0], i.shape[1], i.shape[2]])), F$(4 === o.rank, (function() {
                return "Error in maxPool: input must be rank 4 but got rank ".concat(o.rank, ".")
            })), F$(j8(n, 1), (function() {
                return "Error in maxPool: Either strides or dilations must be 1. " + "Got strides ".concat(n, " and dilations '").concat(1, "'")
            })), K8("maxPool", r, a);
            var u = {
                    x: o
                },
                c = {
                    filterSize: t,
                    strides: n,
                    pad: r,
                    dimRoundingMode: a
                },
                l = E5.runKernel(o2, u, c);
            return s ? X8(l, [l.shape[1], l.shape[2], l.shape[3]]) : l
        }
    });
    var Y9 = B5({
        maxPool3d_: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [1, 1, 1],
                n = arguments.length > 2 ? arguments[2] : void 0,
                r = arguments.length > 3 ? arguments[3] : void 0,
                a = arguments.length > 4 ? arguments[4] : void 0,
                i = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "NDHWC",
                o = L5(e, "x", "maxPool3d"),
                s = o,
                u = !1;
            4 === o.rank && (u = !0, s = X8(o, [1, o.shape[0], o.shape[1], o.shape[2], o.shape[3]])), F$(5 === s.rank, (function() {
                return "Error in maxPool3d: x must be rank 5 but got rank ".concat(s.rank, ".")
            })), F$("NDHWC" === i, (function() {
                return "Error in maxPool3d: Only NDHWC is currently supported, " + "but got dataFormat of ".concat(i)
            })), K8("maxPool3d", r, a);
            var c = {
                    x: s
                },
                l = {
                    filterSize: t,
                    strides: n,
                    pad: r,
                    dimRoundingMode: a,
                    dataFormat: i
                },
                h = E5.runKernel(u2, c, l);
            return u ? X8(h, [h.shape[1], h.shape[2], h.shape[3], h.shape[4]]) : h
        }
    });
    var J9 = B5({
        maxPoolWithArgmax_: function(e, t, n, r) {
            var a = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
                i = L5(e, "x", "maxPoolWithArgmax"),
                o = {
                    x: i
                },
                s = {
                    filterSize: t,
                    strides: n,
                    pad: r,
                    includeBatchInIndex: a
                },
                u = E5.runKernel(l2, o, s);
            return {
                result: u[0],
                indexes: u[1]
            }
        }
    });
    var Z9 = B5({
        maximum_: function(e, t) {
            var n = L5(e, "a", "maximum"),
                r = L5(t, "b", "maximum"),
                a = S(v5(n, r), 2);
            n = a[0], r = a[1], "bool" === n.dtype && (n = h8(n, "int32"), r = h8(r, "int32")), z7(n.shape, r.shape);
            var i = {
                a: n,
                b: r
            };
            return E5.runKernel(i2, i)
        }
    });
    var Q9 = B5({
        mean_: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                r = L5(e, "x", "mean"),
                a = {
                    x: r
                },
                i = {
                    axis: t,
                    keepDims: n
                };
            return E5.runKernel(h2, a, i)
        }
    });

    function $9(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "float32";
        if (p0(e), "complex64" === t) {
            var n = $9(e, "float32"),
                r = $9(e, "float32");
            return W5(n, r)
        }
        var a = l0(L$(e), t);
        return E5.makeTensor(a, e, t)
    }

    function eee(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "float32";
        if (p0(e), "complex64" === t) {
            var n = eee(e, "float32"),
                r = $9(e, "float32");
            return W5(n, r)
        }
        var a = c0(L$(e), t);
        return E5.makeTensor(a, e, t)
    }

    function tee(e, t) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
            r = n.indexing,
            a = void 0 === r ? "xy" : r;
        if ("xy" !== a && "ij" !== a) throw new TypeError("".concat(a, " is not a valid third argument to meshgrid"));
        if (void 0 === e) return [];
        var i = L5(e, "x", "meshgrid", e instanceof n5 ? e.dtype : "float32");
        if (void 0 === t) return [i];
        var o = L5(t, "y", "meshgrid", t instanceof n5 ? t.dtype : "float32"),
            s = L$(i.shape),
            u = L$(o.shape);
        return "xy" === a ? (i = X8(i, [1, -1]), o = X8(o, [-1, 1]), [Q8(eee([u, 1], i.dtype), i), Q8(o, eee([1, s], o.dtype))]) : (i = X8(i, [-1, 1]), o = X8(o, [1, -1]), [Q8(i, eee([1, u], i.dtype)), Q8(eee([s, 1], o.dtype), o)])
    }
    var nee = B5({
        minimum_: function(e, t) {
            var n = L5(e, "a", "minimum"),
                r = L5(t, "b", "minimum"),
                a = S(v5(n, r), 2);
            n = a[0], r = a[1], "bool" === n.dtype && (n = h8(n, "int32"), r = h8(r, "int32")), z7(n.shape, r.shape);
            var i = {
                a: n,
                b: r
            };
            return E5.runKernel(f2, i)
        }
    });
    var ree = B5({
        mirrorPad_: function(e, t, n) {
            F$("reflect" === n || "symmetric" === n, (function() {
                return "Invalid mode. Mode must be either reflect or symmetric. " + "Got ".concat(n, ".")
            }));
            var r = L5(e, "x", "mirrorPad");
            if (0 === r.rank) throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");
            F$(t.length === r.rank, (function() {
                return "Padding doesn't match input. Must be ".concat(r.rank, ". ") + "Got ".concat(t.length, ".")
            }));
            for (var a = "reflect" === n ? 1 : 0, i = function(e) {
                    F$(2 === t[e].length, (function() {
                        return "Invalid number of paddings. Must be length of 2 each."
                    })), F$(t[e][0] >= 0 && t[e][0] <= r.shape[e] - a && t[e][1] >= 0 && t[e][1] <= r.shape[e] - a, (function() {
                        return "Padding in dimension ".concat(e, " cannot be greater than or equal ") + "to ".concat(r.shape[e] - a, " or less than 0 for input of ") + "shape ".concat(r.shape)
                    }))
                }, o = 0; o < r.rank; o++) i(o);
            var s = {
                    paddings: t,
                    mode: n
                },
                u = {
                    x: r
                };
            return E5.runKernel(d2, u, s)
        }
    });
    var aee = B5({
        mod_: function(e, t) {
            var n = L5(e, "a", "mod"),
                r = L5(t, "b", "mod"),
                a = S(v5(n, r), 2),
                i = {
                    a: n = a[0],
                    b: r = a[1]
                };
            return E5.runKernel(v2, i)
        }
    });
    var iee = B5({
        moments_: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                r = j$(t, (e = L5(e, "x", "moments")).shape),
                a = Q9(e, r, n),
                i = a.shape;
            n || (i = Z7(a.shape, r));
            var o = s9(P9(h8(e, "float32"), X8(a, i))),
                s = Q9(o, r, n);
            return {
                mean: a,
                variance: s
            }
        }
    });
    var oee = B5({
        multiRNNCell_: function(e, t, n, r) {
            for (var a = L5(t, "data", "multiRNNCell"), i = z5(n, "c", "multiRNNCell"), o = z5(r, "h", "multiRNNCell"), s = a, u = [], c = 0; c < e.length; c++) {
                var l = e[c](s, i[c], o[c]);
                u.push(l[0]), u.push(l[1]), s = l[1]
            }
            for (var h = [], p = [], f = 0; f < u.length; f += 2) h.push(u[f]), p.push(u[f + 1]);
            return [h, p]
        }
    });
    var see = B5({
        multinomial_: function(e, t, n) {
            var r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
                a = L5(e, "logits", "multinomial"),
                i = a.size,
                o = a.rank;
            if (i < 2) throw new Error("Error in multinomial: you need at least 2 outcomes, but got " + "".concat(i, "."));
            if (o > 2) throw new Error("Rank of probabilities must be 1 or 2, but is ".concat(o));
            n = n || Math.random();
            var s = 1 === o ? X8(a, [1, -1]) : a,
                u = {
                    logits: s
                },
                c = {
                    numSamples: t,
                    seed: n,
                    normalized: r
                },
                l = E5.runKernel(m2, u, c);
            return 1 === o ? X8(l, [l.size]) : l
        }
    });
    var uee = B5({
        notEqual_: function(e, t) {
            var n = L5(e, "a", "notEqual", "string_or_numeric"),
                r = L5(t, "b", "notEqual", "string_or_numeric"),
                a = S(v5(n, r), 2);
            n = a[0], r = a[1], z7(n.shape, r.shape);
            var i = {
                a: n,
                b: r
            };
            return E5.runKernel(b2, i)
        }
    });
    var cee = B5({
        oneHot_: function(e, t) {
            var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "int32";
            if (t < 2) throw new Error("Error in oneHot: depth must be >=2, but it is ".concat(t));
            var i = L5(e, "indices", "oneHot", "int32"),
                o = {
                    indices: i
                },
                s = {
                    dtype: a,
                    depth: t,
                    onValue: n,
                    offValue: r
                };
            return E5.runKernel(N2, o, s)
        }
    });
    var lee = B5({
        onesLike_: function(e) {
            var t = {
                x: L5(e, "x", "onesLike")
            };
            return E5.runKernel(I2, t)
        }
    });
    var hee = B5({
        outerProduct_: function(e, t) {
            var n = L5(e, "v1", "outerProduct"),
                r = L5(t, "v2", "outerProduct");
            F$(1 === n.rank && 1 === r.rank, (function() {
                return "Error in outerProduct: inputs must be rank 1, but got ranks " + "".concat(n.rank, " and ").concat(r.rank, ".")
            }));
            var a = X8(n, [-1, 1]),
                i = X8(r, [1, -1]);
            return Q8(a, i)
        }
    });
    var pee = B5({
        pad_: function(e, t) {
            var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                r = L5(e, "x", "pad");
            if (0 === r.rank) throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
            var a = {
                    paddings: t,
                    constantValue: n
                },
                i = {
                    x: r
                };
            return E5.runKernel(T2, i, a)
        }
    });
    var fee = B5({
        pad1d_: function(e, t) {
            var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            return F$(2 === t.length, (function() {
                return "Invalid number of paddings. Must be length of 2."
            })), pee(e, [t], n)
        }
    });
    var dee = B5({
        pad2d_: function(e, t) {
            var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            return F$(2 === t.length && 2 === t[0].length && 2 === t[1].length, (function() {
                return "Invalid number of paddings. Must be length of 2 each."
            })), pee(e, t, n)
        }
    });
    var vee = B5({
        pad3d_: function(e, t) {
            var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            return F$(3 === t.length && 2 === t[0].length && 2 === t[1].length && 2 === t[2].length, (function() {
                return "Invalid number of paddings. Must be length of 2 each."
            })), pee(e, t, n)
        }
    });
    var mee = B5({
        pad4d_: function(e, t) {
            var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            return F$(4 === t.length && 2 === t[0].length && 2 === t[1].length && 2 === t[2].length && 2 === t[3].length, (function() {
                return "Invalid number of paddings. Must be length of 2 each."
            })), pee(e, t, n)
        }
    });
    var gee = B5({
        spaceToBatchND_: function(e, t, n) {
            var r = L5(e, "x", "spaceToBatchND");
            F$(r.rank >= 1 + t.length, (function() {
                return "input rank ".concat(r.rank, " should be > than [blockShape] ").concat(t.length)
            })), F$(n.length === t.length, (function() {
                return "paddings.shape[0] ".concat(n.length, " must be equal to [blockShape] ").concat(t.length)
            })), F$(r.shape.reduce((function(e, r, a) {
                return a > 0 && a <= t.length ? e && (r + n[a - 1][0] + n[a - 1][1]) % t[a - 1] == 0 : e
            }), !0), (function() {
                return "input spatial dimensions ".concat(r.shape.slice(1), " with paddings ").concat(n.toString(), " must be divisible by blockShapes ").concat(t.toString())
            }));
            var a = {
                    x: r
                },
                i = {
                    blockShape: t,
                    paddings: n
                };
            return E5.runKernel(i3, a, i)
        }
    });
    var yee = B5({
        pool_: function(e, t, n, r, a, i, o) {
            null == a && (a = [1, 1]), null == i && (i = 1), 0 === r && (r = "valid");
            var s = L5(e, "x", "maxPool"),
                u = s,
                c = !1;
            3 === s.rank && (c = !0, u = X8(s, [1, s.shape[0], s.shape[1], s.shape[2]])), F$(j8(i, a), (function() {
                return "Error in pool: Either strides or dilations must be 1. " + "Got strides ".concat(i, " and dilations '").concat(a, "'")
            }));
            var l, h = O8(u.shape, t, i, a, r),
                p = [h.dilationHeight, h.dilationWidth];
            l = "same" === r ? function(e, t) {
                var n = e.map((function(e, n) {
                        return e + (e - 1) * (t[n] - 1)
                    })).map((function(e) {
                        return e - 1
                    })),
                    r = n.map((function(e) {
                        return Math.floor(e / 2)
                    })),
                    a = n.map((function(e, t) {
                        return e - r[t]
                    }));
                return n.map((function(e, t) {
                    return [r[t], a[t]]
                }))
            }([h.filterHeight, h.filterWidth], p) : [
                [0, 0],
                [0, 0]
            ];
            var f = 1 === p[0] && 1 === p[1],
                d = function(e, t, n) {
                    var r = n.map((function(e) {
                            return e[0]
                        })),
                        a = n.map((function(e) {
                            return e[1]
                        })),
                        i = e.concat(r, a),
                        o = t.map((function(e, t) {
                            return (e - i[t] % e) % e
                        })),
                        s = a.map((function(e, t) {
                            return e + o[t]
                        })),
                        u = t.map((function(e, t) {
                            return [r[t], s[t]]
                        })),
                        c = t.map((function(e, t) {
                            return [0, o[t]]
                        }));
                    return [u, c]
                }([h.inHeight, h.inWidth], p, l),
                v = S(d, 2),
                m = v[0],
                g = v[1],
                y = f ? r : "valid",
                b = f ? u : gee(u, p, m),
                x = ("avg" === n ? function() {
                    return Y8(b, t, i, y, o)
                } : function() {
                    return X9(b, t, i, y, o)
                })(),
                k = f ? x : r7(x, p, g);
            return c ? X8(k, [k.shape[1], k.shape[2], k.shape[3]]) : k
        }
    });
    var bee = B5({
        prelu_: function(e, t) {
            var n = {
                x: L5(e, "x", "prelu"),
                alpha: L5(t, "alpha", "prelu")
            };
            return E5.runKernel(C2, n)
        }
    });
    var xee = B5({
        prod_: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                r = L5(e, "x", "prod");
            "bool" === r.dtype && (r = h8(r, "int32"));
            var a = {
                    x: r
                },
                i = {
                    axis: t,
                    keepDims: n
                };
            return E5.runKernel(A2, a, i)
        }
    });
    var kee = B5({
        raggedGather_: function(e, t, n, r) {
            var a = {
                    paramsNestedSplits: e.map((function(e, t) {
                        return L5(e, "tensors".concat(t), "raggedGather", "int32")
                    })),
                    paramsDenseValues: L5(t, "paramsDenseValues", "raggedGather"),
                    indices: L5(n, "indices", "raggedGather", "int32")
                },
                i = {
                    outputRaggedRank: r
                },
                o = E5.runKernel(R2, a, i);
            return {
                outputNestedSplits: o.slice(0, o.length - 1),
                outputDenseValues: o[o.length - 1]
            }
        }
    });
    var wee = B5({
        raggedRange_: function(e, t, n) {
            var r = L5(e, "starts", "raggedRange"),
                a = {
                    starts: r,
                    limits: L5(t, "limits", "raggedRange", r.dtype),
                    deltas: L5(n, "deltas", "raggedRange", r.dtype)
                },
                i = E5.runKernel(_2, a);
            return {
                rtNestedSplits: i[0],
                rtDenseValues: i[1]
            }
        }
    });
    var Iee = B5({
        raggedTensorToTensor_: function(e, t, n, r, a) {
            var i = L5(e, "shape", "raggedTensorToTensor", "int32"),
                o = L5(t, "values", "raggedTensorToTensor"),
                s = {
                    shape: i,
                    values: o,
                    defaultValue: L5(n, "defaultValue", "raggedTensorToTensor", o.dtype),
                    rowPartitionTensors: r.map((function(e, t) {
                        return L5(e, "tensors".concat(t), "raggedTensorToTensor", "int32")
                    }))
                },
                u = {
                    rowPartitionTypes: a
                };
            return E5.runKernel(O2, s, u)
        }
    });
    var Nee = B5({
            rand_: function(e, t, n) {
                p0(e);
                var r = L$(e),
                    a = null;
                if (null == n || "float32" === n) a = new Float32Array(r);
                else if ("int32" === n) a = new Int32Array(r);
                else {
                    if ("bool" !== n) throw new Error("Unknown data type ".concat(n));
                    a = new Uint8Array(r)
                }
                for (var i = 0; i < r; i++) a[i] = t();
                return E5.makeTensor(a, e, n)
            }
        }),
        See = {
            exports: {}
        };
    ! function(e) {
        ! function(e, t, n) {
            function r(e) {
                var t = this,
                    n = function() {
                        var e = 4022871197,
                            t = function(t) {
                                t = String(t);
                                for (var n = 0; n < t.length; n++) {
                                    var r = .02519603282416938 * (e += t.charCodeAt(n));
                                    r -= e = r >>> 0, e = (r *= e) >>> 0, e += 4294967296 * (r -= e)
                                }
                                return 2.3283064365386963e-10 * (e >>> 0)
                            };
                        return t
                    }();
                t.next = function() {
                    var e = 2091639 * t.s0 + 2.3283064365386963e-10 * t.c;
                    return t.s0 = t.s1, t.s1 = t.s2, t.s2 = e - (t.c = 0 | e)
                }, t.c = 1, t.s0 = n(" "), t.s1 = n(" "), t.s2 = n(" "), t.s0 -= n(e), t.s0 < 0 && (t.s0 += 1), t.s1 -= n(e), t.s1 < 0 && (t.s1 += 1), t.s2 -= n(e), t.s2 < 0 && (t.s2 += 1), n = null
            }

            function a(e, t) {
                return t.c = e.c, t.s0 = e.s0, t.s1 = e.s1, t.s2 = e.s2, t
            }

            function i(e, t) {
                var n = new r(e),
                    i = t && t.state,
                    o = n.next;
                return o.int32 = function() {
                    return 4294967296 * n.next() | 0
                }, o.double = function() {
                    return o() + 11102230246251565e-32 * (2097152 * o() | 0)
                }, o.quick = o, i && ("object" == s(i) && a(i, n), o.state = function() {
                    return a(n, {})
                }), o
            }
            t && t.exports ? t.exports = i : n && n.amd ? n((function() {
                return i
            })) : this.alea = i
        }(0, e, !1)
    }(See);
    var Tee = See.exports,
        Eee = {
            exports: {}
        };
    ! function(e) {
        ! function(e, t, n) {
            function r(e) {
                var t = this,
                    n = "";
                t.x = 0, t.y = 0, t.z = 0, t.w = 0, t.next = function() {
                    var e = t.x ^ t.x << 11;
                    return t.x = t.y, t.y = t.z, t.z = t.w, t.w ^= t.w >>> 19 ^ e ^ e >>> 8
                }, e === (0 | e) ? t.x = e : n += e;
                for (var r = 0; r < n.length + 64; r++) t.x ^= 0 | n.charCodeAt(r), t.next()
            }

            function a(e, t) {
                return t.x = e.x, t.y = e.y, t.z = e.z, t.w = e.w, t
            }

            function i(e, t) {
                var n = new r(e),
                    i = t && t.state,
                    o = function() {
                        return (n.next() >>> 0) / 4294967296
                    };
                return o.double = function() {
                    do {
                        var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
                    } while (0 === e);
                    return e
                }, o.int32 = n.next, o.quick = o, i && ("object" == s(i) && a(i, n), o.state = function() {
                    return a(n, {})
                }), o
            }
            t && t.exports ? t.exports = i : n && n.amd ? n((function() {
                return i
            })) : this.xor128 = i
        }(0, e, !1)
    }(Eee);
    var Cee = Eee.exports,
        Aee = {
            exports: {}
        };
    ! function(e) {
        ! function(e, t, n) {
            function r(e) {
                var t = this,
                    n = "";
                t.next = function() {
                    var e = t.x ^ t.x >>> 2;
                    return t.x = t.y, t.y = t.z, t.z = t.w, t.w = t.v, (t.d = t.d + 362437 | 0) + (t.v = t.v ^ t.v << 4 ^ e ^ e << 1) | 0
                }, t.x = 0, t.y = 0, t.z = 0, t.w = 0, t.v = 0, e === (0 | e) ? t.x = e : n += e;
                for (var r = 0; r < n.length + 64; r++) t.x ^= 0 | n.charCodeAt(r), r == n.length && (t.d = t.x << 10 ^ t.x >>> 4), t.next()
            }

            function a(e, t) {
                return t.x = e.x, t.y = e.y, t.z = e.z, t.w = e.w, t.v = e.v, t.d = e.d, t
            }

            function i(e, t) {
                var n = new r(e),
                    i = t && t.state,
                    o = function() {
                        return (n.next() >>> 0) / 4294967296
                    };
                return o.double = function() {
                    do {
                        var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
                    } while (0 === e);
                    return e
                }, o.int32 = n.next, o.quick = o, i && ("object" == s(i) && a(i, n), o.state = function() {
                    return a(n, {})
                }), o
            }
            t && t.exports ? t.exports = i : n && n.amd ? n((function() {
                return i
            })) : this.xorwow = i
        }(0, e, !1)
    }(Aee);
    var Ree = Aee.exports,
        _ee = {
            exports: {}
        };
    ! function(e) {
        ! function(e, t, n) {
            function r(e) {
                var t = this;
                t.next = function() {
                        var e, n, r = t.x,
                            a = t.i;
                        return e = r[a], n = (e ^= e >>> 7) ^ e << 24, n ^= (e = r[a + 1 & 7]) ^ e >>> 10, n ^= (e = r[a + 3 & 7]) ^ e >>> 3, n ^= (e = r[a + 4 & 7]) ^ e << 7, e = r[a + 7 & 7], n ^= (e ^= e << 13) ^ e << 9, r[a] = n, t.i = a + 1 & 7, n
                    },
                    function(e, t) {
                        var n, r = [];
                        if (t === (0 | t)) r[0] = t;
                        else
                            for (t = "" + t, n = 0; n < t.length; ++n) r[7 & n] = r[7 & n] << 15 ^ t.charCodeAt(n) + r[n + 1 & 7] << 13;
                        for (; r.length < 8;) r.push(0);
                        for (n = 0; n < 8 && 0 === r[n]; ++n);
                        for (8 == n ? r[7] = -1 : r[n], e.x = r, e.i = 0, n = 256; n > 0; --n) e.next()
                    }(t, e)
            }

            function a(e, t) {
                return t.x = e.x.slice(), t.i = e.i, t
            }

            function i(e, t) {
                null == e && (e = +new Date);
                var n = new r(e),
                    i = t && t.state,
                    o = function() {
                        return (n.next() >>> 0) / 4294967296
                    };
                return o.double = function() {
                    do {
                        var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
                    } while (0 === e);
                    return e
                }, o.int32 = n.next, o.quick = o, i && (i.x && a(i, n), o.state = function() {
                    return a(n, {})
                }), o
            }
            t && t.exports ? t.exports = i : n && n.amd ? n((function() {
                return i
            })) : this.xorshift7 = i
        }(0, e, !1)
    }(_ee);
    var Oee = _ee.exports,
        Fee = {
            exports: {}
        };
    ! function(e) {
        ! function(e, t, n) {
            function r(e) {
                var t = this;
                t.next = function() {
                        var e, n, r = t.w,
                            a = t.X,
                            i = t.i;
                        return t.w = r = r + 1640531527 | 0, n = a[i + 34 & 127], e = a[i = i + 1 & 127], n ^= n << 13, e ^= e << 17, n ^= n >>> 15, e ^= e >>> 12, n = a[i] = n ^ e, t.i = i, n + (r ^ r >>> 16) | 0
                    },
                    function(e, t) {
                        var n, r, a, i, o, s = [],
                            u = 128;
                        for (t === (0 | t) ? (r = t, t = null) : (t += "\0", r = 0, u = Math.max(u, t.length)), a = 0, i = -32; i < u; ++i) t && (r ^= t.charCodeAt((i + 32) % t.length)), 0 === i && (o = r), r ^= r << 10, r ^= r >>> 15, r ^= r << 4, r ^= r >>> 13, i >= 0 && (o = o + 1640531527 | 0, a = 0 == (n = s[127 & i] ^= r + o) ? a + 1 : 0);
                        for (a >= 128 && (s[127 & (t && t.length || 0)] = -1), a = 127, i = 512; i > 0; --i) r = s[a + 34 & 127], n = s[a = a + 1 & 127], r ^= r << 13, n ^= n << 17, r ^= r >>> 15, n ^= n >>> 12, s[a] = r ^ n;
                        e.w = o, e.X = s, e.i = a
                    }(t, e)
            }

            function a(e, t) {
                return t.i = e.i, t.w = e.w, t.X = e.X.slice(), t
            }

            function i(e, t) {
                null == e && (e = +new Date);
                var n = new r(e),
                    i = t && t.state,
                    o = function() {
                        return (n.next() >>> 0) / 4294967296
                    };
                return o.double = function() {
                    do {
                        var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
                    } while (0 === e);
                    return e
                }, o.int32 = n.next, o.quick = o, i && (i.X && a(i, n), o.state = function() {
                    return a(n, {})
                }), o
            }
            t && t.exports ? t.exports = i : n && n.amd ? n((function() {
                return i
            })) : this.xor4096 = i
        }(0, e, !1)
    }(Fee);
    var Dee = Fee.exports,
        Mee = {
            exports: {}
        };
    ! function(e) {
        ! function(e, t, n) {
            function r(e) {
                var t = this,
                    n = "";
                t.next = function() {
                    var e = t.b,
                        n = t.c,
                        r = t.d,
                        a = t.a;
                    return e = e << 25 ^ e >>> 7 ^ n, n = n - r | 0, r = r << 24 ^ r >>> 8 ^ a, a = a - e | 0, t.b = e = e << 20 ^ e >>> 12 ^ n, t.c = n = n - r | 0, t.d = r << 16 ^ n >>> 16 ^ a, t.a = a - e | 0
                }, t.a = 0, t.b = 0, t.c = -1640531527, t.d = 1367130551, e === Math.floor(e) ? (t.a = e / 4294967296 | 0, t.b = 0 | e) : n += e;
                for (var r = 0; r < n.length + 20; r++) t.b ^= 0 | n.charCodeAt(r), t.next()
            }

            function a(e, t) {
                return t.a = e.a, t.b = e.b, t.c = e.c, t.d = e.d, t
            }

            function i(e, t) {
                var n = new r(e),
                    i = t && t.state,
                    o = function() {
                        return (n.next() >>> 0) / 4294967296
                    };
                return o.double = function() {
                    do {
                        var e = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21)
                    } while (0 === e);
                    return e
                }, o.int32 = n.next, o.quick = o, i && ("object" == s(i) && a(i, n), o.state = function() {
                    return a(n, {})
                }), o
            }
            t && t.exports ? t.exports = i : n && n.amd ? n((function() {
                return i
            })) : this.tychei = i
        }(0, e, !1)
    }(Mee);
    var Lee = Mee.exports,
        zee = {
            exports: {}
        };
    ! function(e) {
        ! function(t, n, r) {
            var a, i = 256,
                o = r.pow(i, 6),
                u = r.pow(2, 52),
                c = 2 * u,
                l = 255;

            function h(e, s, l) {
                var h = [],
                    g = v(d((s = 1 == s ? {
                        entropy: !0
                    } : s || {}).entropy ? [e, m(n)] : null == e ? function() {
                        try {
                            var e;
                            return a && (e = a.randomBytes) ? e = e(i) : (e = new Uint8Array(i), (t.crypto || t.msCrypto).getRandomValues(e)), m(e)
                        } catch (e) {
                            var r = t.navigator,
                                o = r && r.plugins;
                            return [+new Date, t, o, t.screen, m(n)]
                        }
                    }() : e, 3), h),
                    y = new p(h),
                    b = function() {
                        for (var e = y.g(6), t = o, n = 0; e < u;) e = (e + n) * i, t *= i, n = y.g(1);
                        for (; e >= c;) e /= 2, t /= 2, n >>>= 1;
                        return (e + n) / t
                    };
                return b.int32 = function() {
                    return 0 | y.g(4)
                }, b.quick = function() {
                    return y.g(4) / 4294967296
                }, b.double = b, v(m(y.S), n), (s.pass || l || function(e, t, n, a) {
                    return a && (a.S && f(a, y), e.state = function() {
                        return f(y, {})
                    }), n ? (r.random = e, t) : e
                })(b, g, "global" in s ? s.global : this == r, s.state)
            }

            function p(e) {
                var t, n = e.length,
                    r = this,
                    a = 0,
                    o = r.i = r.j = 0,
                    s = r.S = [];
                for (n || (e = [n++]); a < i;) s[a] = a++;
                for (a = 0; a < i; a++) s[a] = s[o = l & o + e[a % n] + (t = s[a])], s[o] = t;
                (r.g = function(e) {
                    for (var t, n = 0, a = r.i, o = r.j, s = r.S; e--;) t = s[a = l & a + 1], n = n * i + s[l & (s[a] = s[o = l & o + t]) + (s[o] = t)];
                    return r.i = a, r.j = o, n
                })(i)
            }

            function f(e, t) {
                return t.i = e.i, t.j = e.j, t.S = e.S.slice(), t
            }

            function d(e, t) {
                var n, r = [],
                    a = s(e);
                if (t && "object" == a)
                    for (n in e) try {
                        r.push(d(e[n], t - 1))
                    } catch (e) {}
                return r.length ? r : "string" == a ? e : e + "\0"
            }

            function v(e, t) {
                for (var n, r = e + "", a = 0; a < r.length;) t[l & a] = l & (n ^= 19 * t[l & a]) + r.charCodeAt(a++);
                return m(t)
            }

            function m(e) {
                return String.fromCharCode.apply(0, e)
            }
            if (v(r.random(), n), e.exports) {
                e.exports = h;
                try {
                    a = require("crypto")
                } catch (e) {}
            } else r.seedrandom = h
        }("undefined" != typeof self ? self : n, [], Math)
    }(zee);
    var Pee = zee.exports,
        Bee = Tee,
        Wee = Cee,
        Uee = Ree,
        Vee = Oee,
        Gee = Dee,
        jee = Lee,
        Hee = Pee;
    Hee.alea = Bee, Hee.xor128 = Wee, Hee.xorwow = Uee, Hee.xorshift7 = Vee, Hee.xor4096 = Gee, Hee.tychei = jee;
    var qee = Hee;

    function Kee() {
        return 32 === E5.backend.floatPrecision() ? .001 : .1
    }

    function Xee(e, t, n) {
        var r = !0;
        if ((U4(e) || U4(t)) && (r = !1), U4(e) && U4(t) && (r = !0), r) {
            var a = e.constructor.name,
                i = t.constructor.name;
            if (a !== i) throw new Error("Arrays are of different type. Actual: ".concat(a, ". ") + "Expected: ".concat(i))
        }
        if (Array.isArray(e) && Array.isArray(t)) {
            var o = F5(e),
                s = F5(t);
            if (!P$(o, s)) throw new Error("Arrays have different shapes. " + "Actual: [".concat(o, "]. Expected: [").concat(s, "]"))
        }
        var u = U4(e) ? e : V4(e),
            c = U4(t) ? t : V4(t);
        if (u.length !== c.length) throw new Error("Arrays have different lengths actual: ".concat(u.length, " vs ") + "expected: ".concat(c.length, ".\n") + "Actual:   ".concat(u, ".\n") + "Expected: ".concat(c, "."));
        for (var l = 0; l < c.length; ++l) {
            var h = u[l],
                p = c[l];
            if (!n(h, p)) throw new Error("Arrays differ: actual[".concat(l, "] = ").concat(h, ", expected[").concat(l, "] = ").concat(p, ".\n") + "Actual:   ".concat(u, ".\n") + "Expected: ".concat(c, "."))
        }
        "undefined" != typeof expect && expect().nothing()
    }

    function Yee(e, t, n) {
        if (null == n && (n = Kee()), !Jee(e, t, n)) throw new Error("Numbers differ: actual === ".concat(e, ", expected === ").concat(t));
        "undefined" != typeof expect && expect().nothing()
    }

    function Jee(e, t, n) {
        return !isFinite(e) && !isFinite(t) || !(isNaN(e) || isNaN(t) || Math.abs(e - t) > n)
    }

    function Zee() {
        return (Zee = c(o().mark((function e(t) {
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return e.next = 2, t.play();
                    case 2:
                        if (!("requestVideoFrameCallback" in t)) {
                            e.next = 5;
                            break
                        }
                        return e.next = 5, new Promise((function(e) {
                            t.requestVideoFrameCallback(e)
                        }));
                    case 5:
                    case "end":
                        return e.stop()
                }
            }), e)
        })))).apply(this, arguments)
    }
    var Qee = {
            __proto__: null,
            TEST_EPSILON_FLOAT16: .1,
            createVideoElement: function(e) {
                var t = document.createElement("video");
                return "playsInline" in t && (t.playsInline = !0), t.muted = !0, t.loop = !0, t.style.position = "fixed", t.style.left = "0px", t.style.top = "0px", t.preload = "auto", t.appendChild(e), new Promise((function(e) {
                    t.addEventListener("loadeddata", (function(n) {
                        return e(t)
                    })), t.load()
                }))
            },
            encodeStrings: function e(t) {
                for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    Array.isArray(r) ? e(r) : t[n] = B4(r)
                }
                return t
            },
            expectArrayBuffersEqual: function(e, t) {
                var n = new Float32Array(e),
                    r = new Float32Array(t);
                if (n.length !== r.length) throw new Error("Expected ArrayBuffer to be of length " + "".concat(r.length, ", but it was ").concat(n.length));
                for (var a = 0; a < r.length; a++)
                    if (n[a] !== r[a]) throw new Error("Expected ArrayBuffer value at ".concat(a, " to be ") + "".concat(r[a], " but got ").concat(n[a], " instead"))
            },
            expectArraysClose: function(e, t, n) {
                return null == n && (n = Kee()), Xee(e, t, (function(e, t) {
                    return Jee(e, t, n)
                }))
            },
            expectArraysEqual: function(e, t) {
                var n = "string" == typeof t || "number" == typeof t || "boolean" == typeof t ? [t] : t;
                return $$(e) || $$(e[0]) || $$(t) || $$(t[0]) ? Xee(e, n, (function(e, t) {
                    return e == t
                })) : Xee(e, t, (function(e, t) {
                    return Jee(e, t, 0)
                }))
            },
            expectNumbersClose: Yee,
            expectPromiseToFail: function(e, t) {
                e().then((function() {
                    return t.fail()
                }), (function() {
                    return t()
                })), "undefined" != typeof expect && expect().nothing()
            },
            expectValuesInRange: function(e, t, n) {
                for (var r = 0; r < e.length; r++)
                    if (e[r] < t || e[r] > n) throw new Error("Value out of range:".concat(e[r], " low: ").concat(t, ", high: ").concat(n))
            },
            play: function(e) {
                return Zee.apply(this, arguments)
            },
            testEpsilon: Kee
        },
        $ee = function() {
            function e(t, n, r, a, i) {
                l(this, e), this.mean = t, this.stdDev = n, this.dtype = r, this.nextVal = NaN, this.truncated = a, this.truncated && (this.upper = this.mean + 2 * this.stdDev, this.lower = this.mean - 2 * this.stdDev);
                var o = i || Math.random();
                this.random = qee.alea(o.toString())
            }
            return p(e, [{
                key: "nextValue",
                value: function() {
                    if (!isNaN(this.nextVal)) {
                        var e = this.nextVal;
                        return this.nextVal = NaN, e
                    }
                    for (var t, n, r = !1; !r;) {
                        var a = void 0,
                            i = void 0,
                            o = void 0;
                        do {
                            o = (a = 2 * this.random() - 1) * a + (i = 2 * this.random() - 1) * i
                        } while (o >= 1 || 0 === o);
                        var s = Math.sqrt(-2 * Math.log(o) / o);
                        t = this.mean + this.stdDev * a * s, n = this.mean + this.stdDev * i * s, this.truncated && !this.isValidTruncated(t) || (r = !0)
                    }
                    return this.truncated && !this.isValidTruncated(n) || (this.nextVal = this.convertValue(n)), this.convertValue(t)
                }
            }, {
                key: "convertValue",
                value: function(e) {
                    return null == this.dtype || "float32" === this.dtype ? e : Math.round(e)
                }
            }, {
                key: "isValidTruncated",
                value: function(e) {
                    return e <= this.upper && e >= this.lower
                }
            }]), e
        }(),
        ete = function() {
            function e(t, n, r, a) {
                l(this, e), this.alpha = t, this.beta = 1 / n, this.dtype = r;
                var i = a || Math.random();
                this.randu = qee.alea(i.toString()), this.randn = new $ee(0, 1, r, !1, this.randu()), this.d = t < 1 ? t + 2 / 3 : t - 1 / 3, this.c = 1 / Math.sqrt(9 * this.d)
            }
            return p(e, [{
                key: "nextValue",
                value: function() {
                    for (var e, t, n, r, a, i;;) {
                        do {
                            r = this.randn.nextValue(), i = 1 + this.c * r
                        } while (i <= 0);
                        if (i *= i * i, t = 1 - .331 * (e = r * r) * e, n = .5 * e + this.d * (1 - i + Math.log(i)), (a = this.randu()) < t || Math.log(a) < n) break
                    }
                    return i = 1 / this.beta * this.d * i, this.alpha < 1 && (i *= Math.pow(this.randu(), 1 / this.alpha)), this.convertValue(i)
                }
            }, {
                key: "convertValue",
                value: function(e) {
                    return "float32" === this.dtype ? e : Math.round(e)
                }
            }]), e
        }(),
        tte = function() {
            function e() {
                var t = this,
                    n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                    r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                    a = arguments.length > 2 ? arguments[2] : void 0,
                    i = arguments.length > 3 ? arguments[3] : void 0;
                if (l(this, e), this.canReturnFloat = function() {
                        return null == t.dtype || "float32" === t.dtype
                    }, this.min = n, this.range = r - n, this.dtype = a, null == i && (i = Math.random()), "number" == typeof i && (i = i.toString()), !this.canReturnFloat() && this.range <= 1) throw new Error("The difference between ".concat(n, " - ").concat(r, " <= 1 and dtype is not float"));
                this.random = qee.alea(i)
            }
            return p(e, [{
                key: "convertValue",
                value: function(e) {
                    return this.canReturnFloat() ? e : Math.round(e)
                }
            }, {
                key: "nextValue",
                value: function() {
                    return this.convertValue(this.min + this.range * this.random())
                }
            }]), e
        }();
    var nte = B5({
        randomGamma_: function(e, t) {
            var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "float32",
                a = arguments.length > 4 ? arguments[4] : void 0;
            if (p0(e), null == n && (n = 1), null == r && (r = "float32"), "float32" !== r && "int32" !== r) throw new Error("Unsupported data type ".concat(r));
            for (var i = new ete(t, n, r, a), o = l8(e, r), s = 0; s < o.values.length; s++) o.values[s] = i.nextValue();
            return o.toTensor()
        }
    });
    var rte = B5({
        randomNormal_: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                r = arguments.length > 3 ? arguments[3] : void 0,
                a = arguments.length > 4 ? arguments[4] : void 0;
            if (p0(e), null != r && "bool" === r) throw new Error("Unsupported data type ".concat(r));
            for (var i = new $ee(t, n, r, !1, a), o = l8(e, r), s = 0; s < o.values.length; s++) o.values[s] = i.nextValue();
            return o.toTensor()
        }
    });
    var ate = B5({
        randomStandardNormal_: function(e, t, n) {
            if (null != t && "bool" === t) throw new Error("Unsupported data type ".concat(t));
            return rte(e, 0, 1, t, n)
        }
    });
    var ite = B5({
        randomUniform_: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "float32",
                a = arguments.length > 4 ? arguments[4] : void 0;
            p0(e);
            for (var i = l8(e, r), o = new tte(t, n, null, a), s = 0; s < i.values.length; s++) i.values[s] = o.nextValue();
            return i.toTensor()
        }
    });
    var ote = B5({
        randomUniformInt_: function(e, t, n, r) {
            return ite(e, t, n, "int32", r)
        }
    });

    function ste(e, t) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
            r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "float32";
        if (0 === n) throw new Error("Cannot have a step of zero");
        var a = {
            start: e,
            stop: t,
            step: n,
            dtype: r
        };
        return E5.runKernel(F2, {}, a)
    }
    var ute = B5({
        real_: function(e) {
            var t = {
                input: L5(e, "input", "real")
            };
            return E5.runKernel(D2, t)
        }
    });
    var cte = B5({
        reciprocal_: function(e) {
            var t = {
                x: L5(e, "x", "reciprocal")
            };
            return E5.runKernel(M2, t)
        }
    });
    var lte = B5({
        relu_: function(e) {
            var t = {
                x: L5(e, "x", "relu")
            };
            return E5.runKernel(L2, t)
        }
    });
    var hte = B5({
        relu6_: function(e) {
            var t = {
                x: L5(e, "x", "relu6")
            };
            return E5.runKernel(V2, t)
        }
    });
    var pte = B5({
        reverse_: function(e, t) {
            var n = {
                    x: L5(e, "x", "reverse")
                },
                r = {
                    dims: t
                };
            return E5.runKernel(G2, n, r)
        }
    });
    var fte = B5({
        reverse1d_: function(e) {
            var t = L5(e, "x", "reverse");
            return F$(1 === t.rank, (function() {
                return "Error in reverse1D: x must be rank 1 but got rank ".concat(t.rank, ".")
            })), pte(t, 0)
        }
    });
    var dte = B5({
        reverse2d_: function(e, t) {
            var n = L5(e, "x", "reverse");
            return F$(2 === n.rank, (function() {
                return "Error in reverse2D: x must be rank 2 but got rank ".concat(n.rank, ".")
            })), pte(n, t)
        }
    });
    var vte = B5({
        reverse3d_: function(e, t) {
            var n = L5(e, "x", "reverse");
            return F$(3 === n.rank, (function() {
                return "Error in reverse3D: x must be rank 3 but got rank ".concat(n.rank, ".")
            })), pte(n, t)
        }
    });
    var mte = B5({
        reverse4d_: function(e, t) {
            var n = L5(e, "x", "reverse");
            return F$(4 === n.rank, (function() {
                return "Error in reverse4D: x must be rank 4 but got rank ".concat(n.rank, ".")
            })), pte(n, t)
        }
    });
    var gte = B5({
        round_: function(e) {
            var t = {
                x: L5(e, "x", "round")
            };
            return E5.runKernel(j2, t)
        }
    });
    var yte = B5({
        rsqrt_: function(e) {
            var t = {
                x: L5(e, "x", "rsqrt", "float32")
            };
            return E5.runKernel(H2, t)
        }
    });
    var bte = B5({
        selu_: function(e) {
            var t = {
                x: L5(e, "x", "selu")
            };
            return E5.runKernel(J2, t)
        }
    });
    var xte = B5({
        separableConv2d_: function(e, t, n, r, a) {
            var i = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : [1, 1],
                o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : "NHWC",
                s = L5(e, "x", "separableConv2d"),
                u = L5(t, "depthwiseFilter", "separableConv2d"),
                c = L5(n, "pointwiseFilter", "separableConv2d"),
                l = s,
                h = !1;
            if (3 === s.rank && (h = !0, l = X8(s, [1, s.shape[0], s.shape[1], s.shape[2]])), "NCHW" === o) throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");
            F$(4 === l.rank, (function() {
                return "Error in separableConv2d: input must be rank 4, but got " + "rank ".concat(l.rank, ".")
            })), F$(4 === u.rank, (function() {
                return "Error in separableConv2d: depthwise filter must be rank 4, but " + "got rank ".concat(u.rank, ".")
            })), F$(4 === c.rank, (function() {
                return "Error in separableConv2d: pointwise filter must be rank 4, but " + "got rank ".concat(u.rank, ".")
            })), F$(1 === c.shape[0], (function() {
                return "Error in separableConv2d: the first dimension of pointwise filter " + " must be 1, but got ".concat(c.shape[0], ".")
            })), F$(1 === c.shape[1], (function() {
                return "Error in separableConv2d: the second dimension of pointwise " + "filter must be 1, but got ".concat(c.shape[1], ".")
            }));
            var p = u.shape[2],
                f = u.shape[3];
            F$(c.shape[2] === p * f, (function() {
                return "Error in separableConv2d: the third dimension of pointwise filter " + "must be ".concat(p * f, ", ") + "but got ".concat(c.shape[2], ".")
            }));
            var d = O7(l, u, r, a, o, i),
                v = 1,
                m = b7(d, c, v, "valid", o);
            return h ? X8(m, [m.shape[1], m.shape[2], m.shape[3]]) : m
        }
    });

    function kte() {
        return kte = c(o().mark((function e(t, n) {
            var r, a, i, s, u, c, l, h, p, f, d;
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return r = L5(t, "x", "setdiff1d"), a = L5(n, "y", "setdiff1d"), F$(r.dtype === a.dtype, (function() {
                            return "x and y should have the same dtype, but got x (".concat(r.dtype, ") and y (").concat(a.dtype, ").")
                        })), F$(1 === r.rank, (function() {
                            return "x should be 1D tensor, but got x (".concat(r.shape, ").")
                        })), F$(1 === a.rank, (function() {
                            return "y should be 1D tensor, but got y (".concat(a.shape, ").")
                        })), e.next = 7, r.data();
                    case 7:
                        return i = e.sent, e.next = 10, a.data();
                    case 10:
                        for (s = e.sent, u = new Set(s), c = 0, l = 0; l < i.length; l++) u.has(i[l]) || c++;
                        for (h = new $4([c], r.dtype), p = new $4([c], "int32"), f = 0, d = 0; f < i.length; f++) u.has(i[f]) || (h.values[d] = i[f], p.values[d] = f, d++);
                        return e.abrupt("return", [h.toTensor(), p.toTensor()]);
                    case 18:
                    case "end":
                        return e.stop()
                }
            }), e)
        }))), kte.apply(this, arguments)
    }
    var wte = function(e, t) {
        return kte.apply(this, arguments)
    };
    var Ite = B5({
        sign_: function(e) {
            var t = {
                x: L5(e, "x", "sign")
            };
            return E5.runKernel(e3, t)
        }
    });
    var Nte = B5({
        sin_: function(e) {
            var t = {
                x: L5(e, "x", "sin", "float32")
            };
            return E5.runKernel(Q2, t)
        }
    });
    var Ste = B5({
        sinh_: function(e) {
            var t = {
                x: L5(e, "x", "sinh")
            };
            return E5.runKernel($2, t)
        }
    });
    var Tte = B5({
        slice1d_: function(e, t, n) {
            var r = L5(e, "x", "slice1d");
            return F$(1 === r.rank, (function() {
                return "slice1d expects a rank-1 tensor, but got a rank-".concat(r.rank, " tensor")
            })), e7(r, [t], [n])
        }
    });
    var Ete = B5({
        slice2d_: function(e, t, n) {
            var r = L5(e, "x", "slice2d");
            return F$(2 === r.rank, (function() {
                return "slice2d expects a rank-2 tensor, but got a rank-".concat(r.rank, " tensor")
            })), e7(r, t, n)
        }
    });
    var Cte = B5({
        slice3d_: function(e, t, n) {
            var r = L5(e, "x", "slice3d");
            return F$(3 === r.rank, (function() {
                return "slice3d expects a rank-3 tensor, but got a rank-".concat(r.rank, " tensor")
            })), e7(r, t, n)
        }
    });
    var Ate = B5({
        slice4d_: function(e, t, n) {
            var r = L5(e, "x", "slice4d");
            return F$(4 === r.rank, (function() {
                return "slice4d expects a rank-4 tensor, but got a rank-".concat(r.rank, " tensor")
            })), e7(r, t, n)
        }
    });
    var Rte = B5({
        softmax_: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1,
                n = L5(e, "logits", "softmax", "float32");
            if (-1 === t && (t = n.rank - 1), t !== n.rank - 1) throw Error("Softmax along a non-last dimension is not yet supported. " + "Logits was rank ".concat(n.rank, " and dim was ").concat(t));
            var r = {
                    logits: n
                },
                a = {
                    dim: t
                };
            return E5.runKernel(s3, r, a)
        }
    });
    var _te = B5({
        fft_: function(e) {
            F$("complex64" === e.dtype, (function() {
                return "The dtype for tf.spectral.fft() must be complex64 " + "but got ".concat(e.dtype, ".")
            }));
            var t = {
                input: e
            };
            return E5.runKernel(R1, t)
        }
    });
    var Ote = B5({
        ifft_: function(e) {
            F$("complex64" === e.dtype, (function() {
                return "The dtype for tf.spectral.ifft() must be complex64 " + "but got ".concat(e.dtype, ".")
            }));
            var t = {
                input: e
            };
            return E5.runKernel(U1, t)
        }
    });
    var Fte = B5({
        irfft_: function(e) {
            var t, n = e.shape[e.shape.length - 1],
                r = e.size / n;
            if (n <= 2) {
                var a = X8(e, [r, n]);
                t = Ote(a)
            } else {
                var i = [r, 2 * (n - 1)],
                    o = X8(ute(e), [r, n]),
                    s = X8(k9(e), [r, n]),
                    u = pte(e7(o, [0, 1], [r, n - 2]), 1),
                    c = g8(pte(e7(s, [0, 1], [r, n - 2]), 1), i9(-1)),
                    l = Z8([o, u], 1),
                    h = Z8([s, c], 1),
                    p = X8(W5(l, h), [i[0], i[1]]);
                t = Ote(p)
            }
            if (t = ute(t), 3 === e.rank && 0 !== e.shape[0]) {
                var f = t,
                    d = e.shape[0];
                t = X8(t, [d, t.shape[0] / d, t.shape[1]]), f.dispose()
            }
            return t
        }
    });
    var Dte = B5({
        split_: function(e, t) {
            var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                r = L5(e, "x", "split"),
                a = {
                    x: r
                },
                i = {
                    numOrSizeSplits: t,
                    axis: n
                };
            return E5.runKernel(o3, a, i)
        }
    });
    var Mte = B5({
        rfft_: function(e, t) {
            F$("float32" === e.dtype, (function() {
                return "The dtype for rfft() must be real value but got ".concat(e.dtype)
            }));
            var n, r = e.shape[e.shape.length - 1],
                a = e.size / r;
            if (null != t && t < r) {
                var i = e.shape.map((function(e) {
                        return 0
                    })),
                    o = e.shape.map((function(e) {
                        return e
                    }));
                o[e.shape.length - 1] = t, n = e7(e, i, o), r = t
            } else if (null != t && t > r) {
                var s = e.shape.map((function(e) {
                    return e
                }));
                s[e.shape.length - 1] = t - r, n = Z8([e, $9(s)], e.shape.length - 1), r = t
            } else n = e;
            var u = U7(n),
                c = X8(W5(n, u), [a, r]),
                l = _te(c),
                h = Math.floor(r / 2) + 1,
                p = ute(l),
                f = k9(l),
                d = Dte(p, [h, r - h], p.shape.length - 1),
                v = Dte(f, [h, r - h], f.shape.length - 1),
                m = n.shape.slice();
            return m[n.shape.length - 1] = h, X8(W5(d[0], v[0]), m)
        }
    });
    var Lte = B5({
        squaredDifference_: function(e, t) {
            var n = L5(e, "a", "squaredDifference"),
                r = L5(t, "b", "squaredDifference"),
                a = S(v5(n, r), 2);
            n = a[0], r = a[1], z7(n.shape, r.shape);
            var i = {
                a: n,
                b: r
            };
            return E5.runKernel(f3, i, {})
        }
    });
    var zte = B5({
        squeeze_: function(e, t) {
            var n = L5(e, "x", "squeeze", "string_or_numeric");
            return X8(n, H$(n.shape, t).newShape)
        }
    });
    var Pte = B5({
        stack_: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                n = z5(e, "tensors", "stack", "string_or_numeric");
            F$(n.length >= 1, (function() {
                return "Pass at least one tensor to tf.stack"
            })), n.length > 0 && F$(t <= n[0].rank, (function() {
                return "Axis must be <= rank of the tensor"
            }));
            var r = n,
                a = {
                    axis: t
                };
            return E5.runKernel(S2, r, a)
        }
    });
    var Bte = B5({
        step_: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                n = L5(e, "x", "step"),
                r = {
                    x: n
                },
                a = {
                    alpha: t
                };
            return E5.runKernel(_3, r, a)
        }
    });
    var Wte = B5({
        stridedSlice_: function(e, t, n, r) {
            var a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0,
                i = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0,
                o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0,
                s = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0,
                u = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0,
                c = L5(e, "x", "stridedSlice", "string_or_numeric"),
                l = {
                    x: c
                },
                h = {
                    begin: t,
                    end: n,
                    strides: r,
                    beginMask: a,
                    endMask: i,
                    ellipsisMask: o,
                    newAxisMask: s,
                    shrinkAxisMask: u
                };
            return E5.runKernel(m3, l, h)
        }
    });
    var Ute = B5({
        tan_: function(e) {
            var t = {
                x: L5(e, "x", "tan", "float32")
            };
            return E5.runKernel(k3, t)
        }
    });

    function Vte(e, t) {
        M$(e);
        var n = F5(e, t);
        if (1 !== n.length) throw new Error("tensor1d() requires values to be a flat/TypedArray");
        return U5(e, null, n, t)
    }

    function Gte(e, t, n) {
        if (M$(e), null != t && 2 !== t.length) throw new Error("tensor2d() requires shape to have two numbers");
        var r = F5(e, n);
        if (2 !== r.length && 1 !== r.length) throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
        if (1 === r.length && null == t) throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
        return U5(e, t, r, n)
    }

    function jte(e, t, n) {
        if (M$(e), null != t && 3 !== t.length) throw new Error("tensor3d() requires shape to have three numbers");
        var r = F5(e, n);
        if (3 !== r.length && 1 !== r.length) throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
        if (1 === r.length && null == t) throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
        return U5(e, t, r, n)
    }

    function Hte(e, t, n) {
        if (M$(e), null != t && 4 !== t.length) throw new Error("tensor4d() requires shape to have four numbers");
        var r = F5(e, n);
        if (4 !== r.length && 1 !== r.length) throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");
        if (1 === r.length && null == t) throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");
        return U5(e, t, r, n)
    }

    function qte(e, t, n) {
        if (M$(e), null != t && 5 !== t.length) throw new Error("tensor5d() requires shape to have five numbers");
        var r = F5(e, n);
        if (5 !== r.length && 1 !== r.length) throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");
        if (1 === r.length && null == t) throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");
        return U5(e, t, r, n)
    }

    function Kte(e, t, n) {
        if (M$(e), null != t && 6 !== t.length) throw new Error("tensor6d() requires shape to have six numbers");
        var r = F5(e, n);
        if (6 !== r.length && 1 !== r.length) throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");
        if (1 === r.length && null == t) throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");
        return U5(e, t = t || r, r, n)
    }

    function Xte(e, t, n) {
        var r = t.rank > 1 ? t.shape[t.rank - 1] : 1,
            a = t.rank > 1 ? t.rank - 1 : 1,
            i = "Must have updates.shape = indices.shape[:batchDim] + " + "shape[sliceDim:], got updates.shape: ".concat(n.shape) + ", indices.shape: ".concat(t.shape, ", shape: ").concat(e) + ", sliceDim: ".concat(r, ", and batchDim: ").concat(a, ".");
        if (n.rank < a) throw new Error(i + " update.rank < ".concat(a, ". "));
        if (e.length < r + (n.rank - a)) throw new Error(i + " Output shape length < ".concat(r + (n.rank - a)));
        if (n.rank !== a + e.length - r) throw new Error(i + " update.rank != ".concat(a + e.length - r));
        for (var o = 0; o < a; ++o)
            if (n.shape[o] !== t.shape[o]) throw new Error(i + " updates.shape[".concat(o, "] (").concat(n.shape[o], ") != indices.shape[").concat(o, "] (").concat(t.shape[o], ")."));
        for (var s = 0; s < n.rank - a; ++s)
            if (n.shape[s + a] !== e[s + r]) throw new Error(i + " updates.shape[".concat(s + a, "] (").concat(n.shape[s + a], ") != shape[").concat(s + a, "] (").concat(e[s + a], ")"))
    }

    function Yte(e, t, n) {
        if (t.rank < 1) throw new Error("tf.scatterND() expects the indices to be rank 1 or higher," + " but the rank was ".concat(t.rank, "."));
        if (e.rank < 1) throw new Error("tf.scatterND() expects the updates to be rank 1 or higher," + " but the rank was ".concat(e.rank, "."));
        if ("int32" !== t.dtype) throw new Error("The dtype of 'indices' should be int32, but got dtype: ".concat(t.dtype));
        if (n.length < 1) throw new Error("Output rank must be greater or equal to 1, but got shape: ".concat(n));
        if (0 === n.length) {
            if (0 === t.size) throw new Error("Indices specified for empty output. indices shape: ".concat(t.shape));
            if (0 === e.size) throw new Error("Updates specified for empty output. updates shape: ".concat(e.shape))
        }
        Xte(n, t, e)
    }

    function Jte(e, t, n) {
        for (var r = t.shape.length, a = r > 1 ? t.shape[r - 1] : 1, i = n.length, o = 1, s = a; s < i; ++s) o *= n[s];
        var u = a < 1 ? 1 : a;
        return {
            sliceRank: a,
            numUpdates: L$(t.shape) / u,
            sliceSize: o,
            strides: [].concat(T(i0(n.slice(0, a))), [1]),
            outputSize: L$(n)
        }
    }
    var Zte = {
        __proto__: null,
        calculateShapes: Jte,
        validateInput: Yte,
        validateUpdateShape: Xte
    };
    var Qte = B5({
        tensorScatterUpdate_: function(e, t, n) {
            var r = L5(e, "tensor", "tensorScatterupdate"),
                a = L5(t, "indices", "tensorScatterupdate", "int32"),
                i = L5(n, "updates", "tensorScatterupdate");
            if (Yte(i, a, r.shape), r.dtype !== i.dtype) throw new Error("tensor and updates must have the same dtype, instead they are ".concat(r.dtype, " and ").concat(i.dtype, "."));
            var o = {
                tensor: r,
                indices: a,
                updates: i
            };
            return E5.runKernel(K2, o, {})
        }
    });
    var $te = B5({
        topk_: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                r = L5(e, "x", "topk");
            if (0 === r.rank) throw new Error("topk() expects the input to be of rank 1 or higher");
            var a = r.shape[r.shape.length - 1];
            if (t < 0) throw new Error("'k' passed to topk() must be >= 0 but got ".concat(t));
            if (t > a) throw new Error("'k' passed to topk() must be <= the last dimension (".concat(a, ") ") + "but got ".concat(t));
            var i = {
                    x: r
                },
                o = {
                    k: t,
                    sorted: n
                },
                s = E5.runKernel(N3, i, o),
                u = S(s, 2),
                c = u[0],
                l = u[1];
            return {
                values: c,
                indices: l
            }
        }
    });
    var ene = B5({
        truncatedNormal_: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                r = arguments.length > 3 ? arguments[3] : void 0,
                a = arguments.length > 4 ? arguments[4] : void 0;
            if (p0(e), null != r && "bool" === r) throw new Error("Unsupported data type $ { dtype }");
            for (var i = new $ee(t, n, r, !0, a), o = l8(e, r), s = 0; s < o.values.length; s++) o.values[s] = i.nextValue();
            return o.toTensor()
        }
    });
    var tne = B5({
        unique_: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                n = L5(e, "x", "unique", "string_or_numeric");
            F$(n.rank > 0, (function() {
                return "The input tensor must be at least 1D"
            }));
            var r = {
                    x: n
                },
                a = {
                    axis: t
                },
                i = E5.runKernel(E3, r, a),
                o = S(i, 2),
                s = o[0],
                u = o[1];
            return {
                values: s,
                indices: u
            }
        }
    });
    var nne = B5({
        unsortedSegmentSum_: function(e, t, n) {
            var r = L5(e, "x", "unsortedSegmentSum"),
                a = L5(t, "segmentIds", "unsortedSegmentSum", "int32");
            F$(B$(n), (function() {
                return "numSegments must be of dtype int"
            }));
            var i = {
                    x: r,
                    segmentIds: a
                },
                o = {
                    numSegments: n
                };
            return E5.runKernel(A3, i, o)
        }
    });
    var rne = B5({
        unstack_: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                n = L5(e, "x", "unstack", "string_or_numeric");
            F$(t >= -n.shape.length && t < n.shape.length, (function() {
                return "Axis = ".concat(t, " is not in [-").concat(n.shape.length, ", ").concat(n.shape.length, ")")
            }));
            var r = {
                    value: n
                },
                a = {
                    axis: t
                };
            return E5.runKernel(C3, r, a)
        }
    });

    function ane(e, t) {
        return q9(e, t, "right")
    }

    function ine(e) {
        var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
            n = arguments.length > 2 ? arguments[2] : void 0,
            r = arguments.length > 3 ? arguments[3] : void 0;
        return E5.makeVariable(e, t, n, r)
    }

    function one(e, t) {
        for (var n = [], r = 0; r < t.length; r++) t[r] && n.push(r);
        for (var a = l8(e, "int32"), i = l8([n.length, e.length], "int32"), o = 0; o < n.length; o++) {
            var s = a.indexToLoc(n[o]),
                u = o * e.length;
            i.values.set(s, u)
        }
        return i.toTensor()
    }

    function sne() {
        return (sne = c(o().mark((function e(t) {
            var n, r, a;
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return n = L5(t, "condition", "whereAsync", "bool"), e.next = 3, n.data();
                    case 3:
                        return r = e.sent, a = one(n.shape, r), t !== n && n.dispose(), e.abrupt("return", a);
                    case 7:
                    case "end":
                        return e.stop()
                }
            }), e)
        })))).apply(this, arguments)
    }
    var une = function(e) {
        return sne.apply(this, arguments)
    };

    function cne() {
        return cne = c(o().mark((function e(t, n, r) {
            var a, i, s, u, c, l, h, p, f, d, v, m, g;
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        for (a = L5(t, "tensor", "boolMask"), i = L5(n, "mask", "boolMask", "bool"), s = null == r ? 0 : r, u = i.rank, c = a.shape, F$(u > 0, (function() {
                                return "mask cannot be scalar"
                            })), D$(c.slice(s, s + u), i.shape, "mask's shape must match the first K dimensions of tensor's shape,"), l = 1, h = s; h < s + u; h++) l *= c[h];
                        return p = c.slice(0, s).concat([l], c.slice(s + u)), f = X8(a, p), d = X8(i, [-1]), e.next = 14, une(d);
                    case 14:
                        return v = e.sent, m = zte(v, [1]), g = y9(f, m, s), t !== a && a.dispose(), n !== i && i.dispose(), m.dispose(), f.dispose(), d.dispose(), v.dispose(), e.abrupt("return", g);
                    case 24:
                    case "end":
                        return e.stop()
                }
            }), e)
        }))), cne.apply(this, arguments)
    }
    var lne = function(e, t, n) {
        return cne.apply(this, arguments)
    };
    var hne = B5({
        transpose_: function(e, t, n) {
            var r = L5(e, "x", "transpose");
            if (null == t && (t = r.shape.map((function(e, t) {
                    return t
                })).reverse()), F$(r.rank === t.length, (function() {
                    return "Error in transpose: rank of input ".concat(r.rank, " ") + "must match length of perm ".concat(t, ".")
                })), t.forEach((function(e) {
                    F$(e >= 0 && e < r.rank, (function() {
                        return "All entries in 'perm' must be between 0 and ".concat(r.rank - 1) + " but got ".concat(t)
                    }))
                })), r.rank <= 1) return r.clone();
            var a = {
                    x: r
                },
                i = {
                    perm: t
                };
            return "complex64" === r.dtype ? X5((function() {
                var e = ute(r),
                    t = k9(r);
                return e = E5.runKernel(T3, {
                    x: e
                }, i), t = E5.runKernel(T3, {
                    x: t
                }, i), n && (t = M9(t)), W5(e, t)
            })) : E5.runKernel(T3, a, i)
        }
    });
    var pne = B5({
        movingAverage_: function(e, t, n, r) {
            var a = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4],
                i = L5(e, "v", "movingAverage"),
                o = L5(t, "x", "movingAverage"),
                s = L5(n, "decay", "movingAverage");
            m5(i, o), F$(P$(i.shape, o.shape), (function() {
                return "Shape mismatch in v and x"
            }));
            var u = i9(1),
                c = P9(u, s),
                l = g8(P9(o, i), c);
            if (a) {
                F$(null != r, (function() {
                    return "When using zeroDebias: true, step is required."
                }));
                var h = L5(r, "step", "movingAverage");
                l = m8(l, P9(u, a9(s, h)))
            }
            return d8(i, l)
        }
    });
    var fne = B5({
        scatterND_: function(e, t, n) {
            p0(n);
            var r = L5(e, "indices", "scatterND", "int32"),
                a = L5(t, "updates", "scatterND");
            Yte(a, r, n);
            var i = {
                    indices: r,
                    updates: a
                },
                o = {
                    shape: n
                };
            return E5.runKernel(q2, i, o)
        }
    });

    function dne(e, t, n, r) {
        if ("int32" !== e.dtype) throw new Error("tf.sparseToDense() expects the indices to be int32 type," + " but the dtype was ".concat(e.dtype, "."));
        if (e.rank > 2) throw new Error("sparseIndices should be a scalar, vector, or matrix," + " but got shape ".concat(e.shape, "."));
        var a = e.rank > 0 ? e.shape[0] : 1,
            i = e.rank > 1 ? e.shape[1] : 1;
        if (n.length !== i) throw new Error("outputShape has incorrect number of elements:," + " ".concat(n.length, ", should be: ").concat(i, "."));
        var o = t.size;
        if (0 !== t.rank && (1 !== t.rank || o !== a)) throw new Error("sparseValues has incorrect shape " + "".concat(t.shape, ", should be [] or [").concat(a, "]"));
        if (t.dtype !== r.dtype) throw new Error("sparseValues.dtype must match defaultValues.dtype")
    }
    var vne = B5({
        sparseToDense_: function(e, t, n) {
            var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
            p0(n);
            var a = L5(e, "sparseIndices", "sparseToDense", "int32"),
                i = L5(t, "sparseValues", "sparseToDense", "string_or_numeric"),
                o = L5(r, "defaultValue", "sparseToDense", i.dtype);
            dne(a, i, n, o);
            var s = {
                    sparseIndices: a,
                    sparseValues: i,
                    defaultValue: o
                },
                u = {
                    outputShape: n
                };
            return E5.runKernel(p3, s, u)
        }
    });
    var mne = B5({
        gatherND_: function(e, t) {
            var n = L5(t, "indices", "gatherND", "int32"),
                r = {
                    params: L5(e, "x", "gatherND", "string_or_numeric"),
                    indices: n
                };
            return E5.runKernel(z1, r)
        }
    });
    var gne = B5({
        dropout_: function(e, t, n, r) {
            var a = L5(e, "x", "dropout");
            if (F$("float32" === a.dtype, (function() {
                    return "x has to be a floating point tensor since it's going to be " + "scaled, but got a ".concat(a.dtype, " tensor instead.")
                })), F$(t >= 0 && t < 1, (function() {
                    return "rate must be a float in the range [0, 1), but got ".concat(t, ".")
                })), 0 === t) return e instanceof n5 ? a.clone() : a;
            var i = function(e, t) {
                    if (null == t) return e.shape.slice();
                    if (P$(e.shape, t)) return t;
                    if (e.shape.length === t.length) {
                        for (var n = [], r = 0; r < e.shape.length; r++) null == t[r] && null != e.shape[r] ? n.push(e.shape[r]) : n.push(t[r]);
                        return n
                    }
                    return t
                }(a, n),
                o = 1 - t,
                s = m8(g9(d8(ite(i, 0, 1, "float32", r), o)), o);
            return g8(a, s)
        }
    });

    function yne(e) {
        return Math.floor(Math.pow(2, Math.ceil(Math.log(e) / Math.log(2))))
    }

    function bne(e, t, n) {
        for (var r = 1 - e % 2, a = new Float32Array(e), i = 0; i < e; ++i) {
            var o = 2 * Math.PI * i / (e + r - 1);
            a[i] = t - n * Math.cos(o)
        }
        return Vte(a, "float32")
    }

    function xne() {
        return xne = c(o().mark((function e(t, n) {
            var r, a, i, s, u, c, l, h, p, f, d, v, m, g, y, b = arguments;
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return r = b.length > 2 && void 0 !== b[2] ? b[2] : 1, a = L5(t, "predictions", "inTopK"), i = L5(n, "targets", "inTopK"), F$(a.rank > 1, (function() {
                            return "inTopK() expects the predictions to be of rank 2 or higher, " + "but got ".concat(a.rank)
                        })), F$(a.rank - 1 === i.rank, (function() {
                            return "predictions rank should be 1 larger than targets rank, but got predictions rank " + "".concat(a.rank, " and targets rank ").concat(i.rank)
                        })), D$(a.shape.slice(0, a.shape.length - 1), i.shape, "predictions's shape should be align with the targets' shape, except the last dimension."), s = a.shape[a.shape.length - 1], F$(r > 0 && r <= s, (function() {
                            return "'k' passed to inTopK() must be > 0 && <= the predictions last " + "dimension (".concat(s, "), but got ").concat(r)
                        })), e.next = 10, a.data();
                    case 10:
                        return u = e.sent, e.next = 13, i.data();
                    case 13:
                        c = e.sent, l = u.length / s, h = s, p = q$("bool", l), f = 0;
                    case 17:
                        if (!(f < l)) {
                            e.next = 35;
                            break
                        }
                        for (d = f * h, v = u.subarray(d, d + h), m = [], g = 0; g < v.length; g++) m.push({
                            value: v[g],
                            index: g
                        });
                        m.sort((function(e, t) {
                            return t.value - e.value
                        })), p[f] = 0, y = 0;
                    case 25:
                        if (!(y < r)) {
                            e.next = 32;
                            break
                        }
                        if (m[y].index !== c[f]) {
                            e.next = 29;
                            break
                        }
                        return p[f] = 1, e.abrupt("break", 32);
                    case 29:
                        y++, e.next = 25;
                        break;
                    case 32:
                        f++, e.next = 17;
                        break;
                    case 35:
                        return t !== a && a.dispose(), n !== i && i.dispose(), e.abrupt("return", V5(p, i.shape, "bool"));
                    case 38:
                    case "end":
                        return e.stop()
                }
            }), e)
        }))), xne.apply(this, arguments)
    }
    var kne = function(e, t) {
        return xne.apply(this, arguments)
    };
    var wne = B5({
        conv2DBackpropFilter_: function(e, t, n, r, a) {
            var i = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "NHWC",
                o = arguments.length > 6 ? arguments[6] : void 0,
                s = e;
            3 === e.rank && (s = X8(e, [1, e.shape[0], e.shape[1], e.shape[2]]));
            var u = t;
            3 === u.rank && (u = X8(t, [1, t.shape[0], t.shape[1], t.shape[2]])), F$(4 === s.rank, (function() {
                return "Error in conv2dDerFilter: input must be rank 4, but got shape " + "".concat(s.shape, ".")
            })), F$(4 === u.rank, (function() {
                return "Error in conv2dDerFilter: dy must be rank 4, but got shape " + "".concat(u.shape, ".")
            })), F$(4 === n.length, (function() {
                return "Error in conv2dDerFilter: filterShape must be length 4, but got " + "".concat(n, ".")
            }));
            var c = "NHWC" === i ? s.shape[3] : s.shape[1],
                l = "NHWC" === i ? u.shape[3] : u.shape[1];
            F$(c === n[2], (function() {
                return "Error in conv2dDerFilter: depth of input ".concat(c, ") must ") + "match input depth in filter (".concat(n[2], ".")
            })), F$(l === n[3], (function() {
                return "Error in conv2dDerFilter: depth of dy (".concat(l, ") must ") + "match output depth for filter (".concat(n[3], ").")
            })), K8("conv2dDerFilter", a, o);
            var h = {
                    x: s,
                    dy: u
                },
                p = {
                    strides: r,
                    pad: a,
                    dataFormat: i,
                    dimRoundingMode: o,
                    filterShape: n
                };
            return E5.runKernel(t1, h, p)
        }
    });

    function Ine(e, t, n) {
        if (null == n || "linear" === n) return e;
        if ("relu" === n) return g8(e, Bte(t));
        throw new Error("Cannot compute gradient for fused activation ".concat(n, "."))
    }

    function Nne(e, t) {
        var n = t,
            r = L7(e.shape, t.shape);
        return r.length > 0 && (n = u9(n, r)), X8(n, e.shape)
    }

    function Sne(e, t, n, r) {
        if ("linear" === t) return e;
        if ("relu" === t) return lte(e);
        if ("elu" === t) return H7(e);
        if ("relu6" === t) return hte(e);
        if ("prelu" === t) return bee(e, n);
        if ("leakyrelu" === t) return S9(e, r);
        if ("sigmoid" === t) return $8(e);
        throw new Error("Unknown fused activation ".concat(t, "."))
    }
    var Tne = function(e, t) {
        return !(e > 0) || "linear" === t
    };
    var Ene = B5({
        fusedConv2d_: function(e) {
            var t = e.x,
                n = e.filter,
                r = e.strides,
                a = e.pad,
                i = e.dataFormat,
                o = void 0 === i ? "NHWC" : i,
                s = e.dilations,
                u = void 0 === s ? [1, 1] : s,
                c = e.dimRoundingMode,
                l = e.bias,
                h = e.activation,
                p = void 0 === h ? "linear" : h,
                f = e.preluActivationWeights,
                d = e.leakyreluAlpha;
            if (p = p || "linear", !1 === Tne(E5.state.gradientDepth, p)) {
                F$("NHWC" === o, (function() {
                    return "Error in fused conv2d: got dataFormat of ".concat(o, " but ") + "only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear."
                }));
                var v = b7(t, n, r, a, o, u, c);
                return null != l && (v = d8(v, l)), Sne(v, p, f, d)
            }
            var m = L5(t, "x", "conv2d", "float32"),
                g = L5(n, "filter", "conv2d", "float32"),
                y = m,
                b = !1;
            3 === m.rank && (b = !0, y = X8(m, [1, m.shape[0], m.shape[1], m.shape[2]])), F$(4 === y.rank, (function() {
                return "Error in fused conv2d: input must be rank 4, but got rank " + "".concat(y.rank, ".")
            })), F$(4 === g.rank, (function() {
                return "Error in fused conv2d: filter must be rank 4, but got rank " + "".concat(g.rank, ".")
            })), K8("fused conv2d", a, c);
            var x = "NHWC" === o ? y.shape[3] : y.shape[1];
            F$(g.shape[2] === x, (function() {
                return "Error in conv2d: depth of input (".concat(x, ") must match ") + "input depth for filter ".concat(g.shape[2], ".")
            })), F$(j8(r, u), (function() {
                return "Error in conv2D: Either strides or dilations must be 1. " + "Got strides ".concat(r, " and dilations '").concat(u, "'")
            }));
            var k, w, I = D8(y.shape, g.shape, r, u, a, c);
            if (null != l) {
                var N = S(v5(k = L5(l, "bias", "fused conv2d"), m), 1);
                k = N[0], "NHWC" === o ? z7(I.outShape, k.shape) : (F$(k.shape.length <= 1, (function() {
                    return "Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of " + "rank-".concat(k.shape.length, ".")
                })), F$(0 === k.shape.length || k.shape[0] === I.outChannels || 1 === k.shape[0], (function() {
                    return "Error in fused conv2d: bias shape (".concat(k.shape, ") is not ") + "compatible with the number of output channels " + "(".concat(I.outChannels, ")")
                })))
            }
            if (null != f) {
                var T = f.shape;
                if (F$(T.length <= 1 || 3 === T.length, (function() {
                        return "Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of " + "rank-".concat(T.length, ".")
                    })), 1 === T.length) F$(1 === T[0] || T[0] === I.outChannels, (function() {
                    return "Error in fused conv2d: PReLU activation weights " + "(".concat(T, ") is not compatible with the number of output ") + "channels (".concat(I.outChannels, ").")
                }));
                else if (3 === T.length) try {
                    z7(T, I.outShape)
                } catch (e) {
                    var E = "Error in fused conv2d: PReLU activation weights (".concat(T, ") ") + "is not compatible with the output shape of the conv2d " + "(".concat(I.outShape, ").");
                    throw Error(E)
                }
                w = L5(f, "prelu weights", "fused conv2d")
            }
            var C = function(e, t) {
                    F$("NHWC" === o, (function() {
                        return "Error in gradient of fused conv2D: got dataFormat of ".concat(o, " but only NHWC is currently supported.")
                    }));
                    var n = S(t, 4),
                        i = n[0],
                        s = n[1],
                        c = n[2],
                        l = n[3],
                        h = Ine(e, c, p);
                    F$(G8(u), (function() {
                        return "Error in gradient of fused conv2D: dilation rates greater than 1 " + "are not yet supported in gradients. Got dilations '".concat(u, "'")
                    }));
                    var f = [k7(s.shape, h, i, r, a), wne(s, h, i.shape, r, a)];
                    if (null != l) {
                        var d = Nne(l, h);
                        f.push(d)
                    }
                    return f
                },
                A = {
                    x: y,
                    filter: g,
                    bias: k,
                    preluActivationWeights: w
                },
                R = {
                    strides: r,
                    pad: a,
                    dataFormat: o,
                    dilations: u,
                    dimRoundingMode: c,
                    activation: p,
                    leakyreluAlpha: d
                };
            if (null == l) {
                var _ = F9((function(e, t, n) {
                    var r = E5.runKernel(M3, A, R);
                    return n([t, e, r]), b && (r = X8(r, [r.shape[1], r.shape[2], r.shape[3]])), {
                        value: r,
                        gradFunc: C
                    }
                }));
                return _(y, g)
            }
            var O = F9((function(e, t, n, r) {
                var a = E5.runKernel(M3, A, R);
                return r([t, e, a, n]), b && (a = X8(a, [a.shape[1], a.shape[2], a.shape[3]])), {
                    value: a,
                    gradFunc: C
                }
            }));
            return O(y, g, k)
        }
    });
    var Cne = B5({
        depthwiseConv2dNativeBackpropFilter_: function(e, t, n, r, a) {
            var i = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : [1, 1],
                o = arguments.length > 6 ? arguments[6] : void 0,
                s = e;
            3 === e.rank && (s = X8(e, [1, e.shape[0], e.shape[1], e.shape[2]]));
            var u = t;
            3 === u.rank && (u = X8(t, [1, t.shape[0], t.shape[1], t.shape[2]]));
            var c = {
                    x: s,
                    dy: u
                },
                l = {
                    strides: r,
                    pad: a,
                    dimRoundingMode: o,
                    dilations: i,
                    filterShape: n
                };
            return E5.runKernel(d1, c, l)
        }
    });
    var Ane = B5({
        depthwiseConv2dNativeBackpropInput_: function(e, t, n, r, a) {
            var i = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : [1, 1],
                o = arguments.length > 6 ? arguments[6] : void 0,
                s = t,
                u = !1;
            3 === t.rank && (u = !0, s = X8(t, [1, t.shape[0], t.shape[1], t.shape[2]]));
            var c = {
                    dy: s,
                    filter: n
                },
                l = {
                    strides: r,
                    pad: a,
                    dimRoundingMode: o,
                    dilations: i,
                    inputShape: e
                },
                h = E5.runKernel(v1, c, l);
            return u ? X8(h, [h.shape[1], h.shape[2], h.shape[3]]) : h
        }
    });
    var Rne = B5({
        fusedDepthwiseConv2d_: function(e) {
            var t = e.x,
                n = e.filter,
                r = e.strides,
                a = e.pad,
                i = e.dataFormat,
                o = void 0 === i ? "NHWC" : i,
                s = e.dilations,
                u = void 0 === s ? [1, 1] : s,
                c = e.dimRoundingMode,
                l = e.bias,
                h = e.activation,
                p = void 0 === h ? "linear" : h,
                f = e.preluActivationWeights,
                d = e.leakyreluAlpha;
            if (!1 === Tne(E5.state.gradientDepth, p)) {
                var v = O7(t, n, r, a, o, u, c);
                return null != l && (v = d8(v, l)), Sne(v, p, f, d)
            }
            var m = L5(t, "x", "depthwiseConv2d", "float32"),
                g = L5(n, "filter", "depthwiseConv2d", "float32"),
                y = m,
                b = !1;
            3 === m.rank && (b = !0, y = X8(m, [1, m.shape[0], m.shape[1], m.shape[2]])), F$(4 === y.rank, (function() {
                return "Error in fused depthwiseConv2d: input must be rank 4, but got " + "rank ".concat(y.rank, ".")
            })), F$(4 === g.rank, (function() {
                return "Error in fused depthwiseConv2d: filter must be rank 4, " + "but got rank ".concat(g.rank, ".")
            })), F$(y.shape[3] === g.shape[2], (function() {
                return "Error in fused depthwiseConv2d: number of input channels " + "(".concat(y.shape[3], ") must match the inChannels dimension in ") + "filter ".concat(g.shape[2], ".")
            })), null == u && (u = [1, 1]), F$(j8(r, u), (function() {
                return "Error in fused depthwiseConv2d: Either strides or dilations must " + "be 1. Got strides ".concat(r, " and dilations '").concat(u, "'")
            })), K8("fused depthwiseConv2d", a, c);
            var x, k, w = D8(y.shape, g.shape, r, u, a, c, !0);
            if (null != l) {
                var I = S(v5(x = L5(l, "bias", "fused conv2d"), m), 1);
                x = I[0], z7(w.outShape, x.shape)
            }
            null != f && (k = L5(f, "prelu weights", "fused depthwiseConv2d"));
            var N = function(e, t) {
                    F$(G8(u), (function() {
                        return "Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations " + "'".concat(u, "'")
                    }));
                    var n = S(t, 4),
                        i = n[0],
                        o = n[1],
                        s = n[2],
                        l = n[3],
                        h = Ine(e, s, p),
                        f = Ane(o.shape, h, i, r, a, u, c),
                        d = Cne(o, h, i.shape, r, a, u, c);
                    return null != l ? [f, d, Nne(x, h)] : [f, d]
                },
                T = {
                    x: y,
                    filter: g,
                    bias: x,
                    preluActivationWeights: k
                },
                E = {
                    strides: r,
                    pad: a,
                    dataFormat: o,
                    dilations: u,
                    dimRoundingMode: c,
                    activation: p,
                    leakyreluAlpha: d
                };
            if (null == l) {
                var C = F9((function(e, t, n) {
                    var r = E5.runKernel(L3, T, E);
                    return n([t, e, r]), b && (r = X8(r, [r.shape[1], r.shape[2], r.shape[3]])), {
                        value: r,
                        gradFunc: N
                    }
                }));
                return C(y, g)
            }
            var A = F9((function(e, t, n, r) {
                var a = E5.runKernel(L3, T, E);
                return r([t, e, a, n]), b && (a = X8(a, [a.shape[1], a.shape[2], a.shape[3]])), {
                    value: a,
                    gradFunc: N
                }
            }));
            return A(y, g, x)
        }
    });
    var _ne = B5({
            fusedMatMul_: function(e) {
                var t = e.a,
                    n = e.b,
                    r = e.transposeA,
                    a = void 0 !== r && r,
                    i = e.transposeB,
                    o = void 0 !== i && i,
                    s = e.bias,
                    u = e.activation,
                    c = void 0 === u ? "linear" : u,
                    l = e.preluActivationWeights,
                    h = e.leakyreluAlpha,
                    p = void 0 === h ? .2 : h;
                if (!1 === Tne(E5.state.gradientDepth, c)) {
                    var f = Q8(t, n, a, o);
                    return null != s && (f = d8(f, s)), Sne(f, c, l, p)
                }
                var d = L5(t, "a", "fused matMul"),
                    v = L5(n, "b", "fused matMul"),
                    m = S(v5(d, v), 2);
                d = m[0], v = m[1];
                var g = a ? d.shape[d.rank - 2] : d.shape[d.rank - 1],
                    y = o ? v.shape[v.rank - 1] : v.shape[v.rank - 2],
                    b = a ? d.shape[d.rank - 1] : d.shape[d.rank - 2],
                    x = o ? v.shape[v.rank - 2] : v.shape[v.rank - 1],
                    k = d.shape.slice(0, -2),
                    w = v.shape.slice(0, -2),
                    I = L$(k),
                    N = L$(w);
                F$(g === y, (function() {
                    return "Error in fused matMul: inner shapes (".concat(g, ") and (") + "".concat(y, ") of Tensors with shapes ").concat(d.shape, " and ") + "".concat(v.shape, " and transposeA=").concat(a) + " and transposeB=".concat(o, " must match.")
                }));
                var T, E, C = z7(d.shape.slice(0, -2), v.shape.slice(0, -2)).concat([b, x]),
                    A = X8(d, a ? [I, g, b] : [I, b, g]),
                    R = X8(v, o ? [N, x, y] : [N, y, x]);
                null != s && (T = S(v5(T = L5(s, "bias", "fused matMul"), d), 1)[0], z7(C, T.shape)), null != l && (E = L5(l, "prelu weights", "fused matMul"));
                var _ = function(e, t) {
                        var n, r, i = S(t, 4),
                            u = i[0],
                            l = i[1],
                            h = i[2],
                            p = i[3],
                            f = Ine(X8(e, h.shape), h, c);
                        return a || o ? !a && o ? (n = Q8(f, l, !1, !1), r = Q8(f, u, !0, !1)) : a && !o ? (n = Q8(l, f, !1, !0), r = Q8(u, f, !1, !1)) : (n = Q8(l, f, !0, !0), r = Q8(f, u, !0, !0)) : (n = Q8(f, l, !1, !0), r = Q8(u, f, !0, !1)), null != s ? [n, r, Nne(p, f)] : [n, r]
                    },
                    O = {
                        a: A,
                        b: R,
                        bias: T,
                        preluActivationWeights: E
                    },
                    F = {
                        transposeA: a,
                        transposeB: o,
                        activation: c,
                        leakyreluAlpha: p
                    };
                if (null == s) {
                    var D = F9((function(e, t, n) {
                        var r = E5.runKernel(D3, O, F);
                        return n([e, t, r]), {
                            value: X8(r, C),
                            gradFunc: _
                        }
                    }));
                    return D(A, R)
                }
                var M = F9((function(e, t, n, r) {
                    var a = E5.runKernel(D3, O, F);
                    return r([e, t, a, n]), {
                        value: X8(a, C),
                        gradFunc: _
                    }
                }));
                return M(A, R, T)
            }
        }),
        One = {
            __proto__: null,
            conv2d: Ene,
            depthwiseConv2d: Rne,
            matMul: _ne
        };
    var Fne = B5({
        hammingWindow_: function(e) {
            return bne(e, .54, .46)
        }
    });
    var Dne = B5({
        hannWindow_: function(e) {
            return bne(e, .5, .5)
        }
    });
    var Mne = B5({
        frame_: function(e, t, n) {
            for (var r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, i = 0, o = []; i + t <= e.size;) o.push(e7(e, i, t)), i += n;
            if (r)
                for (; i < e.size;) {
                    var s = i + t - e.size,
                        u = Z8([e7(e, i, t - s), f7([s], a)]);
                    o.push(u), i += n
                }
            return 0 === o.length ? Gte([], [0, t]) : X8(Z8(o), [o.length, t])
        }
    });
    var Lne = B5({
        stft_: function(e, t, n, r) {
            var a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : Dne;
            null == r && (r = yne(t));
            var i = Mne(e, t, n),
                o = g8(i, a(t));
            return Mte(o, r)
        }
    });
    var zne = B5({
        cropAndResize_: function(e, t, n, r) {
            var a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "bilinear",
                i = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0,
                o = L5(e, "image", "cropAndResize"),
                s = L5(t, "boxes", "cropAndResize", "float32"),
                u = L5(n, "boxInd", "cropAndResize", "int32"),
                c = s.shape[0];
            F$(4 === o.rank, (function() {
                return "Error in cropAndResize: image must be rank 4," + "but got rank ".concat(o.rank, ".")
            })), F$(2 === s.rank && 4 === s.shape[1], (function() {
                return "Error in cropAndResize: boxes must be have size [".concat(c, ",4] ") + "but had shape ".concat(s.shape, ".")
            })), F$(1 === u.rank && u.shape[0] === c, (function() {
                return "Error in cropAndResize: boxInd must be have size [".concat(c, "] ") + "but had shape ".concat(s.shape, ".")
            })), F$(2 === r.length, (function() {
                return "Error in cropAndResize: cropSize must be of length 2, but got " + "length ".concat(r.length, ".")
            })), F$(r[0] >= 1 && r[1] >= 1, (function() {
                return "cropSize must be atleast [1,1], but was ".concat(r)
            })), F$("bilinear" === a || "nearest" === a, (function() {
                return "method must be bilinear or nearest, but was ".concat(a)
            }));
            var l = {
                    image: o,
                    boxes: s,
                    boxInd: u
                },
                h = {
                    method: a,
                    extrapolationValue: i,
                    cropSize: r
                },
                p = E5.runKernel(l1, l, h);
            return p
        }
    });
    var Pne = B5({
        flipLeftRight_: function(e) {
            var t = L5(e, "image", "flipLeftRight", "float32");
            F$(4 === t.rank, (function() {
                return "Error in flipLeftRight: image must be rank 4," + "but got rank ".concat(t.rank, ".")
            }));
            var n = {
                image: t
            };
            return E5.runKernel(O1, n, {})
        }
    });
    var Bne = B5({
        grayscaleToRGB_: function(e) {
            var t = L5(e, "image", "grayscaleToRGB"),
                n = t.rank - 1,
                r = t.shape[n];
            F$(t.rank >= 2, (function() {
                return "Error in grayscaleToRGB: images must be at least rank 2, " + "but got rank ".concat(t.rank, ".")
            })), F$(1 === r, (function() {
                return "Error in grayscaleToRGB: last dimension of a grayscale image " + "should be size 1, but got size ".concat(r, ".")
            }));
            var a = new Array(t.rank);
            return a.fill(1, 0, n), a[n] = 3, v9(t, a)
        }
    });
    var Wne = B5({
        rgbToGrayscale_: function(e) {
            var t = L5(e, "image", "RGBToGrayscale"),
                n = t.rank - 1,
                r = t.shape[n];
            F$(t.rank >= 2, (function() {
                return "Error in RGBToGrayscale: images must be at least rank 2, " + "but got rank ".concat(t.rank, ".")
            })), F$(3 === r, (function() {
                return "Error in RGBToGrayscale: last dimension of an RGB image " + "should be size 3, but got size ".concat(r, ".")
            }));
            var a, i = t.dtype,
                o = h8(t, "float32"),
                s = Vte([.2989, .587, .114]);
            switch (t.rank) {
                case 2:
                    a = j7("ij,j->i", o, s);
                    break;
                case 3:
                    a = j7("ijk,k->ij", o, s);
                    break;
                case 4:
                    a = j7("ijkl,l->ijk", o, s);
                    break;
                case 5:
                    a = j7("ijklm,m->ijkl", o, s);
                    break;
                case 6:
                    a = j7("ijklmn,n->ijklm", o, s);
                    break;
                default:
                    throw new Error("Not a valid tensor rank.")
            }
            return a = f9(a, -1), h8(a, i)
        }
    });
    var Une = B5({
        rotateWithOffset_: function(e, t) {
            var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : .5,
                a = L5(e, "image", "rotateWithOffset", "float32");
            F$(4 === a.rank, (function() {
                return "Error in rotateWithOffset: image must be rank 4," + "but got rank ".concat(a.rank, ".")
            }));
            var i = {
                    image: a
                },
                o = {
                    radians: t,
                    fillValue: n,
                    center: r
                },
                s = E5.runKernel(F3, i, o);
            return s
        }
    });

    function Vne(e, t, n, r, a, i) {
        null == r && (r = .5), null == a && (a = Number.NEGATIVE_INFINITY), null == i && (i = 0);
        var o = e.shape[0];
        return n = Math.min(n, o), F$(0 <= r && r <= 1, (function() {
            return "iouThreshold must be in [0, 1], but was '".concat(r, "'")
        })), F$(2 === e.rank, (function() {
            return "boxes must be a 2D tensor, but was of rank '".concat(e.rank, "'")
        })), F$(4 === e.shape[1], (function() {
            return "boxes must have 4 columns, but 2nd dimension was ".concat(e.shape[1])
        })), F$(1 === t.rank, (function() {
            return "scores must be a 1D tensor"
        })), F$(t.shape[0] === o, (function() {
            return "scores has incompatible shape with boxes. Expected ".concat(o, ", ") + "but was ".concat(t.shape[0])
        })), F$(0 <= i && i <= 1, (function() {
            return "softNmsSigma must be in [0, 1], but was '".concat(i, "'")
        })), {
            maxOutputSize: n,
            iouThreshold: r,
            scoreThreshold: a,
            softNmsSigma: i
        }
    }
    var Gne = B5({
        nonMaxSuppression_: function(e, t, n) {
            var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : .5,
                a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : Number.NEGATIVE_INFINITY,
                i = L5(e, "boxes", "nonMaxSuppression", "float32"),
                o = L5(t, "scores", "nonMaxSuppression", "float32"),
                s = Vne(i, o, n, r, a),
                u = {
                    maxOutputSize: n = s.maxOutputSize,
                    iouThreshold: r = s.iouThreshold,
                    scoreThreshold: a = s.scoreThreshold
                };
            return E5.runKernel(x2, {
                boxes: i,
                scores: o
            }, u)
        }
    });

    function jne(e, t, n) {
        var r = function(e, t, n) {
                return function(e, t, n) {
                    var r = 0,
                        a = e.length,
                        i = 0,
                        o = !1;
                    for (; r < a;) {
                        var s = n(t, e[i = r + (a - r >>> 1)]);
                        s > 0 ? r = i + 1 : (a = i, o = !s)
                    }
                    return o ? r : -r - 1
                }(e, t, n || Hne)
            }(e, t, n),
            a = r < 0 ? -(r + 1) : r;
        e.splice(a, 0, t)
    }

    function Hne(e, t) {
        return e > t ? 1 : e < t ? -1 : 0
    }

    function qne(e, t, n, r, a) {
        return Yne(e, t, n, r, a, 0)
    }

    function Kne(e, t, n, r, a, i) {
        return Yne(e, t, n, r, a, 0, !1, i, !0)
    }

    function Xne(e, t, n, r, a, i) {
        return Yne(e, t, n, r, a, i, !0)
    }

    function Yne(e, t, n, r, a, i) {
        for (var o = arguments.length > 6 && void 0 !== arguments[6] && arguments[6], s = arguments.length > 7 && void 0 !== arguments[7] && arguments[7], u = arguments.length > 8 && void 0 !== arguments[8] && arguments[8], c = [], l = 0; l < t.length; l++) t[l] > a && c.push({
            score: t[l],
            boxIndex: l,
            suppressBeginIndex: 0
        });
        c.sort(Qne);
        for (var h = i > 0 ? -.5 / i : 0, p = [], f = []; p.length < n && c.length > 0;) {
            var d = c.pop(),
                v = d.score,
                m = d.boxIndex,
                g = d.suppressBeginIndex;
            if (v < a) break;
            for (var y = !1, b = p.length - 1; b >= g; --b) {
                var x = Jne(e, m, p[b]);
                if (x >= r) {
                    y = !0;
                    break
                }
                if (d.score = d.score * Zne(r, h, x), d.score <= a) break
            }
            d.suppressBeginIndex = p.length, y || (d.score === v ? (p.push(m), f.push(d.score)) : d.score > a && jne(c, d, Qne))
        }
        var k = p.length,
            w = n - k;
        s && w > 0 && (p.push.apply(p, T(new Array(w).fill(0))), f.push.apply(f, T(new Array(w).fill(0))));
        var I = {
            selectedIndices: p
        };
        return o && (I.selectedScores = f), u && (I.validOutputs = k), I
    }

    function Jne(e, t, n) {
        var r = e.subarray(4 * t, 4 * t + 4),
            a = e.subarray(4 * n, 4 * n + 4),
            i = Math.min(r[0], r[2]),
            o = Math.min(r[1], r[3]),
            s = Math.max(r[0], r[2]),
            u = Math.max(r[1], r[3]),
            c = Math.min(a[0], a[2]),
            l = Math.min(a[1], a[3]),
            h = Math.max(a[0], a[2]),
            p = Math.max(a[1], a[3]),
            f = (s - i) * (u - o),
            d = (h - c) * (p - l);
        if (f <= 0 || d <= 0) return 0;
        var v = Math.max(i, c),
            m = Math.max(o, l),
            g = Math.min(s, h),
            y = Math.min(u, p),
            b = Math.max(g - v, 0) * Math.max(y - m, 0);
        return b / (f + d - b)
    }

    function Zne(e, t, n) {
        var r = Math.exp(t * n * n);
        return n <= e ? r : 0
    }

    function Qne(e, t) {
        return e.score - t.score || e.score === t.score && t.boxIndex - e.boxIndex
    }

    function $ne() {
        return $ne = c(o().mark((function e(t, n, r) {
            var a, i, s, u, c, l, h, p, f, d, v = arguments;
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return a = v.length > 3 && void 0 !== v[3] ? v[3] : .5, i = v.length > 4 && void 0 !== v[4] ? v[4] : Number.NEGATIVE_INFINITY, s = L5(t, "boxes", "nonMaxSuppressionAsync"), u = L5(n, "scores", "nonMaxSuppressionAsync"), c = Vne(s, u, r, a, i), r = c.maxOutputSize, a = c.iouThreshold, i = c.scoreThreshold, e.next = 10, Promise.all([s.data(), u.data()]);
                    case 10:
                        return l = e.sent, h = l[0], p = l[1], f = qne(h, p, r, a, i), d = f.selectedIndices, s !== t && s.dispose(), u !== n && u.dispose(), e.abrupt("return", Vte(d, "int32"));
                    case 17:
                    case "end":
                        return e.stop()
                }
            }), e)
        }))), $ne.apply(this, arguments)
    }
    var ere = function(e, t, n) {
        return $ne.apply(this, arguments)
    };
    var tre = B5({
        nonMaxSuppressionWithScore_: function(e, t, n) {
            var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : .5,
                a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : Number.NEGATIVE_INFINITY,
                i = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0,
                o = L5(e, "boxes", "nonMaxSuppression"),
                s = L5(t, "scores", "nonMaxSuppression"),
                u = Vne(o, s, n, r, a, i),
                c = {
                    boxes: o,
                    scores: s
                },
                l = {
                    maxOutputSize: n = u.maxOutputSize,
                    iouThreshold: r = u.iouThreshold,
                    scoreThreshold: a = u.scoreThreshold,
                    softNmsSigma: i = u.softNmsSigma
                },
                h = E5.runKernel(w2, c, l);
            return {
                selectedIndices: h[0],
                selectedScores: h[1]
            }
        }
    });

    function nre() {
        return nre = c(o().mark((function e(t, n, r) {
            var a, i, s, u, c, l, h, p, f, d, v, m, g = arguments;
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return a = g.length > 3 && void 0 !== g[3] ? g[3] : .5, i = g.length > 4 && void 0 !== g[4] ? g[4] : Number.NEGATIVE_INFINITY, s = g.length > 5 && void 0 !== g[5] ? g[5] : 0, u = L5(t, "boxes", "nonMaxSuppressionAsync"), c = L5(n, "scores", "nonMaxSuppressionAsync"), l = Vne(u, c, r, a, i, s), r = l.maxOutputSize, a = l.iouThreshold, i = l.scoreThreshold, s = l.softNmsSigma, e.next = 12, Promise.all([u.data(), c.data()]);
                    case 12:
                        return h = e.sent, p = h[0], f = h[1], d = Xne(p, f, r, a, i, s), v = d.selectedIndices, m = d.selectedScores, u !== t && u.dispose(), c !== n && c.dispose(), e.abrupt("return", {
                            selectedIndices: Vte(v, "int32"),
                            selectedScores: Vte(m)
                        });
                    case 19:
                    case "end":
                        return e.stop()
                }
            }), e)
        }))), nre.apply(this, arguments)
    }
    var rre = function(e, t, n) {
        return nre.apply(this, arguments)
    };
    var are = B5({
        nonMaxSuppressionPadded_: function(e, t, n) {
            var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : .5,
                a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : Number.NEGATIVE_INFINITY,
                i = arguments.length > 5 && void 0 !== arguments[5] && arguments[5],
                o = L5(e, "boxes", "nonMaxSuppression"),
                s = L5(t, "scores", "nonMaxSuppression"),
                u = Vne(o, s, n, r, a, null),
                c = u.maxOutputSize,
                l = u.iouThreshold,
                h = u.scoreThreshold,
                p = {
                    boxes: o,
                    scores: s
                },
                f = {
                    maxOutputSize: c,
                    iouThreshold: l,
                    scoreThreshold: h,
                    padToMaxOutputSize: i
                },
                d = E5.runKernel(k2, p, f);
            return {
                selectedIndices: d[0],
                validOutputs: d[1]
            }
        }
    });

    function ire() {
        return ire = c(o().mark((function e(t, n, r) {
            var a, i, s, u, c, l, h, p, f, d, v, m, g, y, b, x, k = arguments;
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return a = k.length > 3 && void 0 !== k[3] ? k[3] : .5, i = k.length > 4 && void 0 !== k[4] ? k[4] : Number.NEGATIVE_INFINITY, s = k.length > 5 && void 0 !== k[5] && k[5], u = L5(t, "boxes", "nonMaxSuppressionAsync"), c = L5(n, "scores", "nonMaxSuppressionAsync"), l = Vne(u, c, r, a, i, null), h = l.maxOutputSize, p = l.iouThreshold, f = l.scoreThreshold, e.next = 11, Promise.all([u.data(), c.data()]);
                    case 11:
                        return d = e.sent, v = S(d, 2), m = v[0], g = v[1], y = Kne(m, g, h, p, f, s), b = y.selectedIndices, x = y.validOutputs, u !== t && u.dispose(), c !== n && c.dispose(), e.abrupt("return", {
                            selectedIndices: Vte(b, "int32"),
                            validOutputs: i9(x, "int32")
                        });
                    case 19:
                    case "end":
                        return e.stop()
                }
            }), e)
        }))), ire.apply(this, arguments)
    }
    var ore = function(e, t, n) {
        return ire.apply(this, arguments)
    };
    var sre = B5({
        resizeBilinear_: function(e, t) {
            var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
                a = L5(e, "images", "resizeBilinear");
            F$(3 === a.rank || 4 === a.rank, (function() {
                return "Error in resizeBilinear: x must be rank 3 or 4, but got " + "rank ".concat(a.rank, ".")
            })), F$(2 === t.length, (function() {
                return "Error in resizeBilinear: new shape must 2D, but got shape " + "".concat(t, ".")
            })), F$(!1 === r || !1 === n, (function() {
                return "Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."
            }));
            var i = a,
                o = !1;
            3 === a.rank && (o = !0, i = X8(a, [1, a.shape[0], a.shape[1], a.shape[2]])), S(t, 0);
            var s = {
                    images: i
                },
                u = {
                    alignCorners: n,
                    halfPixelCenters: r,
                    size: t
                },
                c = E5.runKernel(W2, s, u);
            return o ? X8(c, [c.shape[1], c.shape[2], c.shape[3]]) : c
        }
    });
    var ure = B5({
        resizeNearestNeighbor_: function(e, t) {
            var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
                a = L5(e, "images", "resizeNearestNeighbor");
            F$(3 === a.rank || 4 === a.rank, (function() {
                return "Error in resizeNearestNeighbor: x must be rank 3 or 4, but got " + "rank ".concat(a.rank, ".")
            })), F$(2 === t.length, (function() {
                return "Error in resizeNearestNeighbor: new shape must 2D, but got shape " + "".concat(t, ".")
            })), F$("float32" === a.dtype || "int32" === a.dtype, (function() {
                return "`images` must have `int32` or `float32` as dtype"
            })), F$(!1 === r || !1 === n, (function() {
                return "Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."
            }));
            var i = a,
                o = !1;
            3 === a.rank && (o = !0, i = X8(a, [1, a.shape[0], a.shape[1], a.shape[2]])), S(t, 0);
            var s = {
                    images: i
                },
                u = {
                    alignCorners: n,
                    halfPixelCenters: r,
                    size: t
                },
                c = E5.runKernel(P2, s, u);
            return o ? X8(c, [c.shape[1], c.shape[2], c.shape[3]]) : c
        }
    });

    function cre(e, t) {
        for (var n, r, a, i, o, s, u = Vte([-1]), c = Vte([0]), l = Vte([0]), h = 0; h < e.size - 1; h++) {
            n = e7(e, 0, h + 1), r = e7(e, h + 1), o = m8(u9(n), t), s = m8(u9(r), t);
            var p = u9(g8(n, ste(0, n.size)));
            a = m8(p, u9(n));
            var f = f7(r.shape, n.size),
                d = d8(ste(0, r.size), f),
                v = g8(r, d);
            i = m8(u9(v), u9(r));
            var m = P9(a, i),
                g = P9(a, i),
                y = g8(o, s);
            l = g8(g8(y, m), g);
            var b = b9(l, c);
            c = W7(b, l, c), u = W7(b, Vte([h]), u)
        }
        return u
    }
    var lre = B5({
        threshold_: function(e) {
            var t, n, r, a, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "binary",
                o = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : .5,
                u = L5(e, "image", "threshold"),
                c = .2989,
                l = .587,
                h = .114,
                p = u.shape[0] * u.shape[1],
                f = g8(Vte([s]), 255);
            if (F$(3 === u.rank, (function() {
                    return "Error in threshold: image must be rank 3," + "but got rank ".concat(u.rank, ".")
                })), F$(3 === u.shape[2] || 1 === u.shape[2], (function() {
                    return "Error in threshold: image color channel must be equal to 3 or 1" + "but got ".concat(u.shape[2], ".")
                })), F$("int32" === u.dtype || "float32" === u.dtype, (function() {
                    return "Error in dtype: image dtype must be int32 or float32," + "but got dtype ".concat(u.dtype, ".")
                })), F$("otsu" === i || "binary" === i, (function() {
                    return "Method must be binary or otsu, but was ".concat(i)
                })), 3 === u.shape[2]) {
                var d = Dte(u, [1, 1, 1], -1),
                    v = S(d, 3);
                t = v[0], n = v[1], r = v[2];
                var m = g8(t, c),
                    g = g8(n, l),
                    y = g8(r, h);
                a = d8(d8(m, g), y)
            } else a = e;
            if ("otsu" === i) {
                var b = u7(h8(gte(a), "int32"), V5([]), 256);
                f = cre(b, p)
            }
            var x = o ? E9(a, f) : b9(a, f),
                k = h8(g8(x, 255), "int32");
            return k
        }
    });
    var hre = B5({
        transform_: function(e, t) {
            var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "nearest",
                r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "constant",
                a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0,
                i = arguments.length > 5 ? arguments[5] : void 0,
                o = L5(e, "image", "transform", "float32"),
                s = L5(t, "transforms", "transform", "float32");
            F$(4 === o.rank, (function() {
                return "Error in transform: image must be rank 4," + "but got rank ".concat(o.rank, ".")
            })), F$(2 === s.rank && (s.shape[0] === o.shape[0] || 1 === s.shape[0]) && 8 === s.shape[1], (function() {
                return "Error in transform: Input transform should be batch x 8 or 1 x 8"
            })), F$(null == i || 2 === i.length, (function() {
                return "Error in transform: outputShape must be [height, width] or null, " + "but got ".concat(i, ".")
            }));
            var u = {
                    image: o,
                    transforms: s
                },
                c = {
                    interpolation: n,
                    fillMode: r,
                    fillValue: a,
                    outputShape: i
                };
            return E5.runKernel(S3, u, c)
        }
    });
    var pre = B5({
        bandPart_: function(e, t, n) {
            var r = L5(e, "a", "bandPart");
            F$(r.rank >= 2, (function() {
                return "bandPart(): Rank must be at least 2, got ".concat(r.rank, ".")
            }));
            var a, i, o = r.shape,
                s = S(r.shape.slice(-2), 2),
                u = s[0],
                c = s[1];
            "number" == typeof t ? (F$(t % 1 == 0, (function() {
                return "bandPart(): numLower must be an integer, got ".concat(t, ".")
            })), F$(t <= u, (function() {
                return "bandPart(): numLower (".concat(t, ")") + " must not be greater than the number of rows (".concat(u, ").")
            })), a = L5(t < 0 ? u : t, "numLower", "bandPart")) : (F$("int32" === t.dtype, (function() {
                return "bandPart(): numLower's dtype must be an int32."
            })), a = W7(T9(t, 0), u, nee(t, u))), "number" == typeof n ? (F$(n % 1 == 0, (function() {
                return "bandPart(): numUpper must be an integer, got ".concat(n, ".")
            })), F$(n <= c, (function() {
                return "bandPart(): numUpper (".concat(n, ")") + " must not be greater than the number of columns (".concat(c, ").")
            })), i = L5(n < 0 ? c : n, "numUpper", "bandPart")) : (F$("int32" === n.dtype, (function() {
                return "bandPart(): numUpper's dtype must be an int32."
            })), i = W7(T9(n, 0), c, nee(n, c)));
            var l = X8(ste(0, u, 1, "int32"), [-1, 1]),
                h = ste(0, c, 1, "int32"),
                p = P9(l, h),
                f = U9(E9(p, a), x9(p, M9(i))),
                d = $9([u, c], r.dtype);
            return X8(Pte(rne(X8(r, [-1, u, c])).map((function(e) {
                return W7(f, e, d)
            }))), o)
        }
    });
    var fre = B5({
        gramSchmidt_: function(e) {
            var t;
            if (Array.isArray(e)) {
                t = !1, F$(null != e && e.length > 0, (function() {
                    return "Gram-Schmidt process: input must not be null, undefined, or empty"
                }));
                for (var n = e[0].shape[0], r = function(t) {
                        F$(e[t].shape[0] === n, (function() {
                            return "Gram-Schmidt: Non-unique lengths found in the input vectors: " + "(".concat(e[t].shape[0], " vs. ").concat(n, ")")
                        }))
                    }, a = 1; a < e.length; ++a) r(a)
            } else t = !0, e = Dte(e, e.shape[0], 0).map((function(e) {
                return zte(e, [0])
            }));
            F$(e.length <= e[0].shape[0], (function() {
                return "Gram-Schmidt: Number of vectors (".concat(e.length, ") exceeds ") + "number of dimensions (".concat(e[0].shape[0], ").")
            }));
            for (var i = [], o = e, s = function(e) {
                    i.push(E5.tidy((function() {
                        var t = o[e];
                        if (e > 0)
                            for (var n = 0; n < e; ++n) {
                                var r = g8(u9(g8(i[n], t)), i[n]);
                                t = P9(t, r)
                            }
                        return m8(t, l9(t, "euclidean"))
                    })))
                }, u = 0; u < e.length; ++u) s(u);
            return t ? Pte(i, 0) : i
        }
    });

    function dre(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        return E5.tidy((function() {
            F$(2 === e.shape.length, (function() {
                return "qr2d() requires a 2D Tensor, but got a ".concat(e.shape.length, "D Tensor.")
            }));
            for (var n = e.shape[0], r = e.shape[1], a = m9(n), i = p8(e), o = Gte([
                    [1]
                ], [1, 1]), s = p8(o), u = n >= r ? r : n, c = function(e) {
                    var t = i,
                        u = s,
                        c = a,
                        l = S(E5.tidy((function() {
                            var t = e7(i, [e, e], [n - e, 1]),
                                u = l9(t),
                                c = e7(i, [e, e], [1, 1]),
                                l = W7(b9(c, 0), Gte([
                                    [-1]
                                ]), Gte([
                                    [1]
                                ])),
                                h = P9(c, g8(l, u)),
                                p = m8(t, h);
                            s = 1 === p.shape[0] ? p8(o) : Z8([o, e7(p, [1, 0], [p.shape[0] - 1, p.shape[1]])], 0);
                            var f = M9(m8(Q8(l, h), u)),
                                d = e7(i, [e, 0], [n - e, r]),
                                v = g8(f, s),
                                m = hne(s);
                            if (0 === e) i = P9(d, Q8(v, Q8(m, d)));
                            else {
                                var g = P9(d, Q8(v, Q8(m, d)));
                                i = Z8([e7(i, [0, 0], [e, r]), g], 0)
                            }
                            var y = hne(v),
                                b = e7(a, [0, e], [n, a.shape[1] - e]);
                            if (0 === e) a = P9(b, Q8(Q8(b, s), y));
                            else {
                                var x = P9(b, Q8(Q8(b, s), y));
                                a = Z8([e7(a, [0, 0], [n, e]), x], 1)
                            }
                            return [s, i, a]
                        })), 3);
                    s = l[0], i = l[1], a = l[2], Y5([t, u, c])
                }, l = 0; l < u; ++l) c(l);
            return !t && n > r && (a = e7(a, [0, 0], [n, r]), i = e7(i, [0, 0], [r, r])), [a, i]
        }))
    }
    var vre, mre = B5({
        qr_: function(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            if (F$(e.rank >= 2, (function() {
                    return "qr() requires input tensor to have a rank >= 2, but got rank ".concat(e.rank)
                })), 2 === e.rank) return dre(e, t);
            var n = e.shape.slice(0, e.shape.length - 2).reduce((function(e, t) {
                    return e * t
                })),
                r = rne(X8(e, [n, e.shape[e.shape.length - 2], e.shape[e.shape.length - 1]]), 0),
                a = [],
                i = [];
            r.forEach((function(e) {
                var n = S(dre(e, t), 2),
                    r = n[0],
                    o = n[1];
                a.push(r), i.push(o)
            }));
            var o = X8(Pte(a, 0), e.shape),
                s = X8(Pte(i, 0), e.shape);
            return [o, s]
        }
    });
    e.Reduction = void 0, (vre = e.Reduction || (e.Reduction = {}))[vre.NONE = 0] = "NONE", vre[vre.MEAN = 1] = "MEAN", vre[vre.SUM = 2] = "SUM", vre[vre.SUM_BY_NONZERO_WEIGHTS = 3] = "SUM_BY_NONZERO_WEIGHTS";
    var gre = B5({
        computeWeightedLoss_: function(t, n) {
            var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e.Reduction.SUM_BY_NONZERO_WEIGHTS,
                a = L5(t, "losses", "computeWeightedLoss"),
                i = null;
            null != n && (i = L5(n, "weights", "computeWeightedLoss"));
            var o = null == i ? a : g8(a, i);
            if (r === e.Reduction.NONE) return o;
            if (r === e.Reduction.SUM) return u9(o);
            if (r === e.Reduction.MEAN) {
                if (null == i) return Q9(o);
                var s = a.size / i.size,
                    u = m8(u9(o), u9(i));
                return s > 1 ? m8(u, i9(s)) : u
            }
            if (r === e.Reduction.SUM_BY_NONZERO_WEIGHTS) {
                if (null == i) return m8(u9(o), i9(a.size));
                var c = g8(i, eee(a.shape)),
                    l = h8(u9(uee(c, i9(0))), "float32");
                return m8(u9(o), l)
            }
            throw Error("Unknown reduction: ".concat(r))
        }
    });
    var yre = B5({
        absoluteDifference_: function(t, n, r) {
            var a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e.Reduction.SUM_BY_NONZERO_WEIGHTS,
                i = L5(t, "labels", "absoluteDifference"),
                o = L5(n, "predictions", "absoluteDifference"),
                s = null;
            null != r && (s = L5(r, "weights", "absoluteDifference")), D$(i.shape, o.shape, "Error in absoluteDifference: ");
            var u = y8(P9(i, o));
            return gre(u, s, a)
        }
    });
    var bre = B5({
        cosineDistance_: function(t, n, r, a) {
            var i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : e.Reduction.SUM_BY_NONZERO_WEIGHTS,
                o = L5(t, "labels", "cosineDistance"),
                s = L5(n, "predictions", "cosineDistance"),
                u = null;
            null != a && (u = L5(a, "weights", "cosineDistance")), D$(o.shape, s.shape, "Error in cosineDistance: ");
            var c = i9(1),
                l = P9(c, u9(g8(o, s), r, !0));
            return gre(l, u, i)
        }
    });
    var xre = B5({
        hingeLoss_: function(t, n, r) {
            var a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e.Reduction.SUM_BY_NONZERO_WEIGHTS,
                i = L5(t, "labels", "hingeLoss"),
                o = L5(n, "predictions", "hingeLoss"),
                s = null;
            null != r && (s = L5(r, "weights", "hingeLoss")), D$(i.shape, o.shape, "Error in hingeLoss: ");
            var u = i9(1);
            i = P9(g8(i9(2), i), u);
            var c = lte(P9(u, g8(i, o)));
            return gre(c, s, a)
        }
    });
    var kre = B5({
        huberLoss_: function(t, n, r) {
            var a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1,
                i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : e.Reduction.SUM_BY_NONZERO_WEIGHTS,
                o = L5(t, "labels", "huberLoss"),
                s = L5(n, "predictions", "huberLoss"),
                u = null;
            null != r && (u = L5(r, "weights", "huberLoss")), D$(o.shape, s.shape, "Error in huberLoss: ");
            var c = i9(a),
                l = y8(P9(s, o)),
                h = nee(l, c),
                p = P9(l, h),
                f = d8(g8(i9(.5), s9(h)), g8(c, p));
            return gre(f, u, i)
        }
    });
    var wre = B5({
        logLoss_: function(t, n, r) {
            var a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e-7,
                i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : e.Reduction.SUM_BY_NONZERO_WEIGHTS,
                o = L5(t, "labels", "logLoss"),
                s = L5(n, "predictions", "logLoss"),
                u = null;
            null != r && (u = L5(r, "weights", "logLoss")), D$(o.shape, s.shape, "Error in logLoss: ");
            var c = i9(1),
                l = i9(a),
                h = M9(g8(o, R9(d8(s, l)))),
                p = g8(P9(c, o), R9(d8(P9(c, s), l))),
                f = P9(h, p);
            return gre(f, u, i)
        }
    });
    var Ire = B5({
        meanSquaredError_: function(t, n, r) {
            var a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e.Reduction.SUM_BY_NONZERO_WEIGHTS,
                i = L5(t, "labels", "meanSquaredError"),
                o = L5(n, "predictions", "meanSquaredError"),
                s = null;
            null != r && (s = L5(r, "weights", "meanSquaredError")), D$(i.shape, o.shape, "Error in meanSquaredError: ");
            var u = Lte(i, o);
            return gre(u, s, a)
        }
    });

    function Nre(e, t) {
        var n = L5(e, "labels", "sigmoidCrossEntropyWithLogits"),
            r = L5(t, "logits", "sigmoidCrossEntropyWithLogits");
        D$(n.shape, r.shape, "Error in sigmoidCrossEntropyWithLogits: ");
        var a = lte(r),
            i = g8(r, n),
            o = _9(p9(M9(y8(r))));
        return d8(P9(a, i), o)
    }
    var Sre = B5({
        sigmoidCrossEntropy_: function(t, n, r) {
            var a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : e.Reduction.SUM_BY_NONZERO_WEIGHTS,
                o = L5(t, "multiClassLabels", "sigmoidCrossEntropy"),
                s = L5(n, "logits", "sigmoidCrossEntropy"),
                u = null;
            if (null != r && (u = L5(r, "weights", "sigmoidCrossEntropy")), D$(o.shape, s.shape, "Error in sigmoidCrossEntropy: "), a > 0) {
                var c = i9(a),
                    l = i9(1),
                    h = i9(.5);
                o = d8(g8(o, P9(l, c)), g8(h, c))
            }
            var p = Nre(o, s);
            return gre(p, u, i)
        }
    });

    function Tre(e, t) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -1;
        if (-1 === n && (n = t.rank - 1), n !== t.rank - 1) throw Error("Softmax cross entropy along a non-last dimension is not yet " + "supported. Labels / logits was rank ".concat(t.rank, " ") + "and dim was ".concat(n));
        var r = F9((function(e, t, r) {
            var a = W9(t, [n], !0),
                i = P9(h8(t, "float32"), a);
            r([e, i]);
            var o = M9(g8(i, e));
            return {
                value: u9(o, [n]),
                gradFunc: function(e, t) {
                    var r = S(t, 2),
                        a = r[0],
                        i = r[1],
                        o = Z7(e.shape, [n]);
                    return [g8(X8(e, o), P9(h8(a, "float32"), p9(i))), g8(X8(e, o), P9(p9(i), h8(a, "float32")))]
                }
            }
        }));
        return r(e, t)
    }
    var Ere = B5({
        softmaxCrossEntropy_: function(t, n, r) {
            var a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : e.Reduction.SUM_BY_NONZERO_WEIGHTS,
                o = L5(t, "onehotLabels", "softmaxCrossEntropy"),
                s = L5(n, "logits", "softmaxCrossEntropy"),
                u = null;
            if (null != r && (u = L5(r, "weights", "softmaxCrossEntropy")), D$(o.shape, s.shape, "Error in softmaxCrossEntropy: "), a > 0) {
                var c = i9(a),
                    l = i9(1),
                    h = i9(o.shape[1]);
                o = d8(g8(o, P9(l, c)), m8(c, h))
            }
            var p = Tre(o, s);
            return gre(p, u, i)
        }
    });
    var Cre = B5({
        sparseFillEmptyRows_: function(e, t, n, r) {
            var a = L5(e, "indices", "sparseFillEmptyRows", "int32"),
                i = L5(t, "values", "sparseFillEmptyRows"),
                o = L5(n, "denseShape", "sparseFillEmptyRows", "int32"),
                s = L5(r, "defaultValue", "sparseFillEmptyRows", i.dtype);
            if (2 !== a.rank) throw new Error("Indices should be Tensor2D but received shape\n        ".concat(a.shape));
            if (1 !== i.rank) throw new Error("Values should be Tensor1D but received shape ".concat(i.shape));
            if (1 !== o.rank) throw new Error("Dense shape should be Tensor1D but received shape ".concat(o.shape));
            if (0 !== s.rank) throw new Error("Default value should be a scalar but received shape ".concat(s.shape));
            var u = {
                    indices: a,
                    values: i,
                    denseShape: o,
                    defaultValue: s
                },
                c = E5.runKernel(u3, u);
            return {
                outputIndices: c[0],
                outputValues: c[1],
                emptyRowIndicator: c[2],
                reverseIndexMap: c[3]
            }
        }
    });
    var Are = B5({
        sparseReshape_: function(e, t, n) {
            var r = L5(e, "inputIndices", "sparseReshape", "int32"),
                a = L5(t, "inputShape", "sparseReshape", "int32"),
                i = L5(n, "newShape", "sparseReshape", "int32");
            if (2 !== r.rank) throw new Error("Input indices should be Tensor2D but received shape\n        ".concat(r.shape));
            if (1 !== a.rank) throw new Error("Input shape should be Tensor1D but received shape ".concat(a.shape));
            if (1 !== i.rank) throw new Error("New shape should be Tensor1D but received shape ".concat(i.shape));
            var o = {
                    inputIndices: r,
                    inputShape: a,
                    newShape: i
                },
                s = E5.runKernel(c3, o);
            return {
                outputIndices: s[0],
                outputShape: s[1]
            }
        }
    });
    var Rre = B5({
        sparseSegmentMean_: function(e, t, n) {
            var r = L5(e, "data", "sparseSegmentMean"),
                a = L5(t, "indices", "sparseSegmentMean", "int32"),
                i = L5(n, "segmentIds", "sparseSegmentMean", "int32");
            if (r.rank < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
            if (1 !== a.rank) throw new Error("Indices should be Tensor1D but received shape\n          ".concat(a.shape));
            if (1 !== i.rank) throw new Error("Segment ids should be Tensor1D but received shape\n          ".concat(i.shape));
            var o = {
                data: r,
                indices: a,
                segmentIds: i
            };
            return E5.runKernel(l3, o)
        }
    });
    var _re = B5({
        sparseSegmentSum_: function(e, t, n) {
            var r = L5(e, "data", "sparseSegmentSum"),
                a = L5(t, "indices", "sparseSegmentSum", "int32"),
                i = L5(n, "segmentIds", "sparseSegmentSum", "int32");
            if (r.rank < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
            if (1 !== a.rank) throw new Error("Indices should be Tensor1D but received shape\n         ".concat(a.shape));
            if (1 !== i.rank) throw new Error("Segment ids should be Tensor1D but received shape\n         ".concat(i.shape));
            var o = {
                data: r,
                indices: a,
                segmentIds: i
            };
            return E5.runKernel(h3, o)
        }
    });
    var Ore = B5({
        stringNGrams_: function(e, t, n, r, a, i, o, s) {
            var u = L5(e, "data", "stringNGrams", "string");
            if ("string" !== u.dtype) throw new Error("Data must be of datatype string");
            if (1 !== u.shape.length) throw new Error("Data must be a vector, saw: ".concat(u.shape));
            var c = L5(t, "dataSplits", "stringNGrams");
            if ("int32" !== c.dtype) throw new Error("Data splits must be of datatype int32");
            var l = {
                    separator: n,
                    nGramWidths: r,
                    leftPad: a,
                    rightPad: i,
                    padWidth: o,
                    preserveShortSequences: s
                },
                h = {
                    data: u,
                    dataSplits: c
                },
                p = E5.runKernel(g3, h, l);
            return {
                nGrams: p[0],
                nGramsSplits: p[1]
            }
        }
    });
    var Fre = B5({
        stringSplit_: function(e, t) {
            var n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                r = L5(e, "input", "stringSplit", "string"),
                a = L5(t, "delimiter", "stringSplit", "string");
            if (1 !== r.rank) throw new Error("Input should be Tensor1D but received shape ".concat(r.shape));
            if (0 !== a.rank) throw new Error("Delimiter should be a scalar but received shape ".concat(a.shape));
            var i = {
                    skipEmpty: n
                },
                o = {
                    input: r,
                    delimiter: a
                },
                s = E5.runKernel(y3, o, i);
            return {
                indices: s[0],
                values: s[1],
                shape: s[2]
            }
        }
    });
    var Dre = B5({
        stringToHashBucketFast_: function(e, t) {
            var n = L5(e, "input", "stringToHashBucketFast", "string"),
                r = {
                    numBuckets: t
                };
            if (t <= 0) throw new Error("Number of buckets must be at least 1");
            var a = {
                input: n
            };
            return E5.runKernel(b3, a, r)
        }
    });
    var Mre = B5({
            staticRegexReplace_: function(e, t, n) {
                var r = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
                    a = L5(e, "input", "staticRegexReplace", "string"),
                    i = {
                        pattern: t,
                        rewrite: n,
                        replaceGlobal: r
                    };
                return E5.runKernel(v3, {
                    x: a
                }, i)
            }
        }),
        Lre = {
            fft: _te,
            ifft: Ote,
            rfft: Mte,
            irfft: Fte
        },
        zre = {
            hammingWindow: Fne,
            hannWindow: Dne,
            frame: Mne,
            stft: Lne
        },
        Pre = {
            flipLeftRight: Pne,
            grayscaleToRGB: Bne,
            resizeNearestNeighbor: ure,
            resizeBilinear: sre,
            rgbToGrayscale: Wne,
            rotateWithOffset: Une,
            cropAndResize: zne,
            nonMaxSuppression: Gne,
            nonMaxSuppressionAsync: ere,
            nonMaxSuppressionWithScore: tre,
            nonMaxSuppressionWithScoreAsync: rre,
            nonMaxSuppressionPadded: are,
            nonMaxSuppressionPaddedAsync: ore,
            threshold: lre,
            transform: hre
        },
        Bre = {
            bandPart: pre,
            gramSchmidt: fre,
            qr: mre
        },
        Wre = {
            absoluteDifference: yre,
            computeWeightedLoss: gre,
            cosineDistance: bre,
            hingeLoss: xre,
            huberLoss: kre,
            logLoss: wre,
            meanSquaredError: Ire,
            sigmoidCrossEntropy: Sre,
            softmaxCrossEntropy: Ere
        },
        Ure = {
            sparseFillEmptyRows: Cre,
            sparseReshape: Are,
            sparseSegmentMean: Rre,
            sparseSegmentSum: _re
        },
        Vre = {
            stringNGrams: Ore,
            stringSplit: Fre,
            stringToHashBucketFast: Dre,
            staticRegexReplace: Mre
        },
        Gre = new Map,
        jre = new Map,
        Hre = function() {
            function e() {
                l(this, e)
            }
            return p(e, [{
                key: "getClassName",
                value: function() {
                    return this.constructor.className
                }
            }], [{
                key: "fromConfig",
                value: function(e, t) {
                    return new e(t)
                }
            }]), e
        }(),
        qre = function() {
            function e() {
                l(this, e), this.classNameMap = {}
            }
            return p(e, null, [{
                key: "getMap",
                value: function() {
                    return null == e.instance && (e.instance = new e), e.instance
                }
            }, {
                key: "register",
                value: function(t) {
                    e.getMap().classNameMap[t.className] = [t, t.fromConfig]
                }
            }]), e
        }();

    function Kre(e, t, n) {
        F$(null != e.className, (function() {
            return "Class being registered does not have the static className property defined."
        })), F$("string" == typeof e.className, (function() {
            return "className is required to be a string, but got type " + s(e.className)
        })), F$(e.className.length > 0, (function() {
            return "Class being registered has an empty-string as its className, which is disallowed."
        })), void 0 === t && (t = "Custom"), void 0 === n && (n = e.className);
        var r = t + ">" + n;
        return qre.register(e), Gre.set(r, e), jre.set(e, r), e
    }
    var Xre = {
            __proto__: null,
            Serializable: Hre,
            SerializationMap: qre,
            getRegisteredName: function(e) {
                return jre.has(e) ? jre.get(e) : e.className
            },
            registerClass: Kre
        },
        Yre = function(e) {
            d(s, e);
            var t, n, r, a, i = w(s);

            function s() {
                return l(this, s), i.apply(this, arguments)
            }
            return p(s, [{
                key: "minimize",
                value: function(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                        n = arguments.length > 2 ? arguments[2] : void 0,
                        r = this.computeGradients(e, n),
                        a = r.value,
                        i = r.grads;
                    if (null != n) {
                        var o = n.map((function(e) {
                            return {
                                name: e.name,
                                tensor: i[e.name]
                            }
                        }));
                        this.applyGradients(o)
                    } else this.applyGradients(i);
                    return Y5(i), t ? a : (a.dispose(), null)
                }
            }, {
                key: "iterations",
                get: function() {
                    return null == this.iterations_ && (this.iterations_ = 0), this.iterations_
                }
            }, {
                key: "incrementIterations",
                value: function() {
                    this.iterations_ = this.iterations + 1
                }
            }, {
                key: "computeGradients",
                value: function(e, t) {
                    return O9(e, t)
                }
            }, {
                key: "dispose",
                value: function() {
                    null != this.iterations_ && Y5(this.iterations_)
                }
            }, {
                key: "saveIterations",
                value: (a = c(o().mark((function e() {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return null == this.iterations_ && (this.iterations_ = 0), e.abrupt("return", {
                                    name: "iter",
                                    tensor: i9(this.iterations_, "int32")
                                });
                            case 2:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return a.apply(this, arguments)
                })
            }, {
                key: "getWeights",
                value: (r = c(o().mark((function e() {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                throw new Error("getWeights() is not implemented for this optimizer yet.");
                            case 1:
                            case "end":
                                return e.stop()
                        }
                    }), e)
                }))), function() {
                    return r.apply(this, arguments)
                })
            }, {
                key: "setWeights",
                value: (n = c(o().mark((function e(t) {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                throw new Error("setWeights() is not implemented for this optimizer class " + "".concat(this.getClassName()));
                            case 1:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e) {
                    return n.apply(this, arguments)
                })
            }, {
                key: "extractIterations",
                value: (t = c(o().mark((function e(t) {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, t[0].tensor.data();
                            case 2:
                                return this.iterations_ = e.sent[0], e.abrupt("return", t.slice(1));
                            case 4:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e) {
                    return t.apply(this, arguments)
                })
            }]), s
        }(Hre);
    Object.defineProperty(Yre, Symbol.hasInstance, {
        value: function(e) {
            return null != e.minimize && null != e.computeGradients && null != e.applyGradients
        }
    });
    var Jre = function(e) {
            d(a, e);
            var t, n, r = w(a);

            function a(e, t) {
                var n, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
                return l(this, a), (n = r.call(this)).learningRate = e, n.rho = t, n.epsilon = i, n.accumulatedGrads = [], n.accumulatedUpdates = [], null == i && (n.epsilon = E5.backend.epsilon()), n
            }
            return p(a, [{
                key: "applyGradients",
                value: function(e) {
                    var t = this;
                    (Array.isArray(e) ? e.map((function(e) {
                        return e.name
                    })) : Object.keys(e)).forEach((function(n, r) {
                        var a = E5.registeredVariables[n];
                        null == t.accumulatedGrads[r] && (t.accumulatedGrads[r] = {
                            originalName: "".concat(n, "/accum_grad"),
                            variable: X5((function() {
                                return U7(a).variable(false)
                            }))
                        }), null == t.accumulatedUpdates[r] && (t.accumulatedUpdates[r] = {
                            originalName: "".concat(n, "/accum_var"),
                            variable: X5((function() {
                                return U7(a).variable(false)
                            }))
                        });
                        var i = Array.isArray(e) ? e[r].tensor : e[n];
                        if (null != i) {
                            var o = t.accumulatedGrads[r].variable,
                                s = t.accumulatedUpdates[r].variable;
                            X5((function() {
                                var e = d8(g8(o, t.rho), g8(s9(i), 1 - t.rho)),
                                    n = g8(m8(o9(d8(s, t.epsilon)), o9(d8(o, t.epsilon))), i),
                                    r = d8(g8(s, t.rho), g8(s9(n), 1 - t.rho));
                                o.assign(e), s.assign(r);
                                var u = d8(g8(n, -t.learningRate), a);
                                a.assign(u)
                            }))
                        }
                    })), this.incrementIterations()
                }
            }, {
                key: "dispose",
                value: function() {
                    null != this.accumulatedUpdates && (Y5(this.accumulatedGrads.map((function(e) {
                        return e.variable
                    }))), Y5(this.accumulatedUpdates.map((function(e) {
                        return e.variable
                    }))))
                }
            }, {
                key: "getWeights",
                value: (n = c(o().mark((function e() {
                    var t;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return t = [].concat(T(this.accumulatedGrads), T(this.accumulatedUpdates)), e.next = 3, this.saveIterations();
                            case 3:
                                return e.t0 = e.sent, e.abrupt("return", [e.t0].concat(t.map((function(e) {
                                    return {
                                        name: e.originalName,
                                        tensor: e.variable
                                    }
                                }))));
                            case 5:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return n.apply(this, arguments)
                })
            }, {
                key: "setWeights",
                value: (t = c(o().mark((function e(t) {
                    var n;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.extractIterations(t);
                            case 2:
                                t = e.sent, n = t.length / 2, this.accumulatedGrads = t.slice(0, n).map((function(e) {
                                    return {
                                        originalName: e.name,
                                        variable: e.tensor.variable(!1)
                                    }
                                })), this.accumulatedUpdates = t.slice(n, 2 * n).map((function(e) {
                                    return {
                                        originalName: e.name,
                                        variable: e.tensor.variable(!1)
                                    }
                                }));
                            case 7:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e) {
                    return t.apply(this, arguments)
                })
            }, {
                key: "getConfig",
                value: function() {
                    return {
                        learningRate: this.learningRate,
                        rho: this.rho,
                        epsilon: this.epsilon
                    }
                }
            }], [{
                key: "className",
                get: function() {
                    return "Adadelta"
                }
            }, {
                key: "fromConfig",
                value: function(e, t) {
                    return new e(t.learningRate, t.rho, t.epsilon)
                }
            }]), a
        }(Yre),
        Zre = function(e) {
            d(a, e);
            var t, n, r = w(a);

            function a(e) {
                var t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .1;
                return l(this, a), (t = r.call(this)).learningRate = e, t.initialAccumulatorValue = n, t.accumulatedGrads = [], t
            }
            return p(a, [{
                key: "applyGradients",
                value: function(e) {
                    var t = this;
                    (Array.isArray(e) ? e.map((function(e) {
                        return e.name
                    })) : Object.keys(e)).forEach((function(n, r) {
                        var a = E5.registeredVariables[n];
                        if (null == t.accumulatedGrads[r]) {
                            t.accumulatedGrads[r] = {
                                originalName: "".concat(n, "/accumulator"),
                                variable: X5((function() {
                                    return f7(a.shape, t.initialAccumulatorValue).variable(false)
                                }))
                            }
                        }
                        var i = Array.isArray(e) ? e[r].tensor : e[n];
                        if (null != i) {
                            var o = t.accumulatedGrads[r].variable;
                            X5((function() {
                                var e = d8(o, s9(i));
                                o.assign(e);
                                var n = d8(g8(m8(i, o9(d8(e, E5.backend.epsilon()))), -t.learningRate), a);
                                a.assign(n)
                            }))
                        }
                    })), this.incrementIterations()
                }
            }, {
                key: "dispose",
                value: function() {
                    null != this.accumulatedGrads && Y5(this.accumulatedGrads.map((function(e) {
                        return e.variable
                    })))
                }
            }, {
                key: "getWeights",
                value: (n = c(o().mark((function e() {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.saveIterations();
                            case 2:
                                return e.t0 = e.sent, e.abrupt("return", [e.t0].concat(this.accumulatedGrads.map((function(e) {
                                    return {
                                        name: e.originalName,
                                        tensor: e.variable
                                    }
                                }))));
                            case 4:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return n.apply(this, arguments)
                })
            }, {
                key: "setWeights",
                value: (t = c(o().mark((function e(t) {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.extractIterations(t);
                            case 2:
                                t = e.sent, this.accumulatedGrads = t.map((function(e) {
                                    return {
                                        originalName: e.name,
                                        variable: e.tensor.variable(!1)
                                    }
                                }));
                            case 5:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e) {
                    return t.apply(this, arguments)
                })
            }, {
                key: "getConfig",
                value: function() {
                    return {
                        learningRate: this.learningRate,
                        initialAccumulatorValue: this.initialAccumulatorValue
                    }
                }
            }], [{
                key: "className",
                get: function() {
                    return "Adagrad"
                }
            }, {
                key: "fromConfig",
                value: function(e, t) {
                    return new e(t.learningRate, t.initialAccumulatorValue)
                }
            }]), a
        }(Yre),
        Qre = function(e) {
            d(a, e);
            var t, n, r = w(a);

            function a(e, t, n) {
                var i, o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
                return l(this, a), (i = r.call(this)).learningRate = e, i.beta1 = t, i.beta2 = n, i.epsilon = o, i.accumulatedFirstMoment = [], i.accumulatedSecondMoment = [], X5((function() {
                    i.accBeta1 = i9(t).variable(), i.accBeta2 = i9(n).variable()
                })), null == o && (i.epsilon = E5.backend.epsilon()), i
            }
            return p(a, [{
                key: "applyGradients",
                value: function(e) {
                    var t = this,
                        n = Array.isArray(e) ? e.map((function(e) {
                            return e.name
                        })) : Object.keys(e);
                    X5((function() {
                        var r = P9(1, t.accBeta1),
                            a = P9(1, t.accBeta2);
                        n.forEach((function(n, i) {
                            var o = E5.registeredVariables[n];
                            null == t.accumulatedFirstMoment[i] && (t.accumulatedFirstMoment[i] = {
                                originalName: "".concat(n, "/m"),
                                variable: X5((function() {
                                    return U7(o).variable(false)
                                }))
                            }), null == t.accumulatedSecondMoment[i] && (t.accumulatedSecondMoment[i] = {
                                originalName: "".concat(n, "/v"),
                                variable: X5((function() {
                                    return U7(o).variable(false)
                                }))
                            });
                            var s = Array.isArray(e) ? e[i].tensor : e[n];
                            if (null != s) {
                                var u = t.accumulatedFirstMoment[i].variable,
                                    c = t.accumulatedSecondMoment[i].variable,
                                    l = d8(g8(u, t.beta1), g8(s, 1 - t.beta1)),
                                    h = d8(g8(c, t.beta2), g8(s9(s), 1 - t.beta2)),
                                    p = m8(l, r),
                                    f = m8(h, a);
                                u.assign(l), c.assign(h);
                                var d = d8(g8(m8(p, d8(o9(f), t.epsilon)), -t.learningRate), o);
                                o.assign(d)
                            }
                        })), t.accBeta1.assign(g8(t.accBeta1, t.beta1)), t.accBeta2.assign(g8(t.accBeta2, t.beta2))
                    })), this.incrementIterations()
                }
            }, {
                key: "dispose",
                value: function() {
                    this.accBeta1.dispose(), this.accBeta2.dispose(), null != this.accumulatedFirstMoment && Y5(this.accumulatedFirstMoment.map((function(e) {
                        return e.variable
                    }))), null != this.accumulatedSecondMoment && Y5(this.accumulatedSecondMoment.map((function(e) {
                        return e.variable
                    })))
                }
            }, {
                key: "getWeights",
                value: (n = c(o().mark((function e() {
                    var t;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return t = [].concat(T(this.accumulatedFirstMoment), T(this.accumulatedSecondMoment)), e.next = 3, this.saveIterations();
                            case 3:
                                return e.t0 = e.sent, e.abrupt("return", [e.t0].concat(t.map((function(e) {
                                    return {
                                        name: e.originalName,
                                        tensor: e.variable
                                    }
                                }))));
                            case 5:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return n.apply(this, arguments)
                })
            }, {
                key: "setWeights",
                value: (t = c(o().mark((function e(t) {
                    var n, r = this;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.extractIterations(t);
                            case 2:
                                t = e.sent, X5((function() {
                                    r.accBeta1.assign(a9(r.beta1, r.iterations_ + 1)), r.accBeta2.assign(a9(r.beta2, r.iterations_ + 1))
                                })), n = t.length / 2, this.accumulatedFirstMoment = t.slice(0, n).map((function(e) {
                                    return {
                                        originalName: e.name,
                                        variable: e.tensor.variable(!1)
                                    }
                                })), this.accumulatedSecondMoment = t.slice(n, 2 * n).map((function(e) {
                                    return {
                                        originalName: e.name,
                                        variable: e.tensor.variable(!1)
                                    }
                                }));
                            case 8:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e) {
                    return t.apply(this, arguments)
                })
            }, {
                key: "getConfig",
                value: function() {
                    return {
                        learningRate: this.learningRate,
                        beta1: this.beta1,
                        beta2: this.beta2,
                        epsilon: this.epsilon
                    }
                }
            }], [{
                key: "className",
                get: function() {
                    return "Adam"
                }
            }, {
                key: "fromConfig",
                value: function(e, t) {
                    return new e(t.learningRate, t.beta1, t.beta2, t.epsilon)
                }
            }]), a
        }(Yre),
        $re = function(e) {
            d(a, e);
            var t, n, r = w(a);

            function a(e, t, n) {
                var i, o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
                    s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
                return l(this, a), (i = r.call(this)).learningRate = e, i.beta1 = t, i.beta2 = n, i.epsilon = o, i.decay = s, i.accumulatedFirstMoment = [], i.accumulatedWeightedInfNorm = [], X5((function() {
                    i.iteration = i9(0).variable(), i.accBeta1 = i9(t).variable()
                })), null == o && (i.epsilon = E5.backend.epsilon()), i
            }
            return p(a, [{
                key: "applyGradients",
                value: function(e) {
                    var t = this,
                        n = Array.isArray(e) ? e.map((function(e) {
                            return e.name
                        })) : Object.keys(e);
                    X5((function() {
                        var r = P9(1, t.accBeta1),
                            a = m8(-t.learningRate, d8(g8(t.iteration, t.decay), 1));
                        n.forEach((function(n, i) {
                            var o = E5.registeredVariables[n];
                            null == t.accumulatedFirstMoment[i] && (t.accumulatedFirstMoment[i] = {
                                originalName: "".concat(n, "/m"),
                                variable: U7(o).variable(false)
                            }), null == t.accumulatedWeightedInfNorm[i] && (t.accumulatedWeightedInfNorm[i] = {
                                originalName: "".concat(n, "/v"),
                                variable: U7(o).variable(false)
                            });
                            var s = Array.isArray(e) ? e[i].tensor : e[n];
                            if (null != s) {
                                var u = t.accumulatedFirstMoment[i].variable,
                                    c = t.accumulatedWeightedInfNorm[i].variable,
                                    l = d8(g8(u, t.beta1), g8(s, 1 - t.beta1)),
                                    h = g8(c, t.beta2),
                                    p = y8(s),
                                    f = Z9(h, p);
                                u.assign(l), c.assign(f);
                                var d = d8(g8(m8(a, r), m8(l, d8(f, t.epsilon))), o);
                                o.assign(d)
                            }
                        })), t.iteration.assign(d8(t.iteration, 1)), t.accBeta1.assign(g8(t.accBeta1, t.beta1))
                    })), this.incrementIterations()
                }
            }, {
                key: "dispose",
                value: function() {
                    this.accBeta1.dispose(), this.iteration.dispose(), null != this.accumulatedFirstMoment && Y5(this.accumulatedFirstMoment.map((function(e) {
                        return e.variable
                    }))), null != this.accumulatedWeightedInfNorm && Y5(this.accumulatedWeightedInfNorm.map((function(e) {
                        return e.variable
                    })))
                }
            }, {
                key: "getWeights",
                value: (n = c(o().mark((function e() {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                throw new Error("getWeights() is not implemented for Adamax yet.");
                            case 1:
                            case "end":
                                return e.stop()
                        }
                    }), e)
                }))), function() {
                    return n.apply(this, arguments)
                })
            }, {
                key: "setWeights",
                value: (t = c(o().mark((function e(t) {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                throw new Error("setWeights() is not implemented for Adamax yet.");
                            case 1:
                            case "end":
                                return e.stop()
                        }
                    }), e)
                }))), function(e) {
                    return t.apply(this, arguments)
                })
            }, {
                key: "getConfig",
                value: function() {
                    return {
                        learningRate: this.learningRate,
                        beta1: this.beta1,
                        beta2: this.beta2,
                        epsilon: this.epsilon,
                        decay: this.decay
                    }
                }
            }], [{
                key: "className",
                get: function() {
                    return "Adamax"
                }
            }, {
                key: "fromConfig",
                value: function(e, t) {
                    return new e(t.learningRate, t.beta1, t.beta2, t.epsilon, t.decay)
                }
            }]), a
        }(Yre),
        eae = function(e) {
            d(a, e);
            var t, n, r = w(a);

            function a(e) {
                var t;
                return l(this, a), (t = r.call(this)).learningRate = e, t.setLearningRate(e), t
            }
            return p(a, [{
                key: "applyGradients",
                value: function(e) {
                    var t = this;
                    (Array.isArray(e) ? e.map((function(e) {
                        return e.name
                    })) : Object.keys(e)).forEach((function(n, r) {
                        var a = Array.isArray(e) ? e[r].tensor : e[n];
                        if (null != a) {
                            var i = E5.registeredVariables[n];
                            X5((function() {
                                var e = d8(g8(t.c, a), i);
                                i.assign(e)
                            }))
                        }
                    })), this.incrementIterations()
                }
            }, {
                key: "setLearningRate",
                value: function(e) {
                    this.learningRate = e, null != this.c && this.c.dispose(), this.c = J5(i9(-e))
                }
            }, {
                key: "dispose",
                value: function() {
                    this.c.dispose()
                }
            }, {
                key: "getWeights",
                value: (n = c(o().mark((function e() {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.saveIterations();
                            case 2:
                                return e.t0 = e.sent, e.abrupt("return", [e.t0]);
                            case 4:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return n.apply(this, arguments)
                })
            }, {
                key: "setWeights",
                value: (t = c(o().mark((function e(t) {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.extractIterations(t);
                            case 2:
                                if (0 === (t = e.sent).length) {
                                    e.next = 5;
                                    break
                                }
                                throw new Error("SGD optimizer does not have settable weights.");
                            case 5:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e) {
                    return t.apply(this, arguments)
                })
            }, {
                key: "getConfig",
                value: function() {
                    return {
                        learningRate: this.learningRate
                    }
                }
            }], [{
                key: "className",
                get: function() {
                    return "SGD"
                }
            }, {
                key: "fromConfig",
                value: function(e, t) {
                    return new e(t.learningRate)
                }
            }]), a
        }(Yre),
        tae = function(e) {
            d(a, e);
            var t, n, r = w(a);

            function a(e, t) {
                var n, i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                return l(this, a), (n = r.call(this, e)).learningRate = e, n.momentum = t, n.useNesterov = i, n.accumulations = [], n.m = i9(n.momentum), n
            }
            return p(a, [{
                key: "applyGradients",
                value: function(e) {
                    var t = this;
                    (Array.isArray(e) ? e.map((function(e) {
                        return e.name
                    })) : Object.keys(e)).forEach((function(n, r) {
                        var a = E5.registeredVariables[n];
                        if (null == t.accumulations[r]) {
                            t.accumulations[r] = {
                                originalName: "".concat(n, "/momentum"),
                                variable: X5((function() {
                                    return U7(a).variable(false)
                                }))
                            }
                        }
                        var i = t.accumulations[r].variable,
                            o = Array.isArray(e) ? e[r].tensor : e[n];
                        null != o && X5((function() {
                            var e, n = d8(g8(t.m, i), o);
                            e = t.useNesterov ? d8(g8(t.c, d8(o, g8(n, t.m))), a) : d8(g8(t.c, n), a), i.assign(n), a.assign(e)
                        }))
                    })), this.incrementIterations()
                }
            }, {
                key: "dispose",
                value: function() {
                    this.m.dispose(), null != this.accumulations && Y5(this.accumulations.map((function(e) {
                        return e.variable
                    })))
                }
            }, {
                key: "setMomentum",
                value: function(e) {
                    this.momentum = e
                }
            }, {
                key: "getWeights",
                value: (n = c(o().mark((function e() {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.saveIterations();
                            case 2:
                                return e.t0 = e.sent, e.abrupt("return", [e.t0].concat(this.accumulations.map((function(e) {
                                    return {
                                        name: e.originalName,
                                        tensor: e.variable
                                    }
                                }))));
                            case 4:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return n.apply(this, arguments)
                })
            }, {
                key: "setWeights",
                value: (t = c(o().mark((function e(t) {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.extractIterations(t);
                            case 2:
                                t = e.sent, this.accumulations = t.map((function(e) {
                                    return {
                                        originalName: e.name,
                                        variable: e.tensor.variable(!1)
                                    }
                                }));
                            case 5:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e) {
                    return t.apply(this, arguments)
                })
            }, {
                key: "getConfig",
                value: function() {
                    return {
                        learningRate: this.learningRate,
                        momentum: this.momentum,
                        useNesterov: this.useNesterov
                    }
                }
            }], [{
                key: "className",
                get: function() {
                    return "Momentum"
                }
            }, {
                key: "fromConfig",
                value: function(e, t) {
                    return new e(t.learningRate, t.momentum, t.useNesterov)
                }
            }]), a
        }(eae),
        nae = function(e) {
            d(a, e);
            var t, n, r = w(a);

            function a(e) {
                var t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .9,
                    i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                    o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
                    s = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
                if (l(this, a), (t = r.call(this)).learningRate = e, t.decay = n, t.momentum = i, t.epsilon = o, t.accumulatedMeanSquares = [], t.accumulatedMoments = [], t.accumulatedMeanGrads = [], t.centered = s, null == o && (t.epsilon = E5.backend.epsilon()), null == e) throw new Error("learningRate for RMSPropOptimizer must be defined.");
                return t
            }
            return p(a, [{
                key: "applyGradients",
                value: function(e) {
                    var t = this;
                    (Array.isArray(e) ? e.map((function(e) {
                        return e.name
                    })) : Object.keys(e)).forEach((function(n, r) {
                        var a = E5.registeredVariables[n],
                            i = !1;
                        null == t.accumulatedMeanSquares[r] && (t.accumulatedMeanSquares[r] = {
                            originalName: "".concat(n, "/rms"),
                            variable: X5((function() {
                                return U7(a).variable(i)
                            }))
                        }), null == t.accumulatedMoments[r] && (t.accumulatedMoments[r] = {
                            originalName: "".concat(n, "/momentum"),
                            variable: X5((function() {
                                return U7(a).variable(i)
                            }))
                        }), null == t.accumulatedMeanGrads[r] && t.centered && (t.accumulatedMeanGrads[r] = {
                            originalName: "".concat(n, "/mg"),
                            variable: X5((function() {
                                return U7(a).variable(i)
                            }))
                        });
                        var o = Array.isArray(e) ? e[r].tensor : e[n];
                        if (null != o) {
                            var s = t.accumulatedMeanSquares[r].variable,
                                u = t.accumulatedMoments[r].variable;
                            X5((function() {
                                var e = d8(g8(s, t.decay), g8(s9(o), 1 - t.decay));
                                if (t.centered) {
                                    var n = t.accumulatedMeanGrads[r].variable,
                                        i = d8(g8(n, t.decay), g8(o, 1 - t.decay)),
                                        c = m8(g8(o, t.learningRate), o9(P9(e, d8(s9(i), t.epsilon)))),
                                        l = d8(g8(u, t.momentum), c);
                                    s.assign(e), n.assign(i), u.assign(l);
                                    var h = P9(a, l);
                                    a.assign(h)
                                } else {
                                    var p = d8(g8(s, t.decay), g8(s9(o), 1 - t.decay)),
                                        f = d8(g8(u, t.momentum), m8(g8(o, t.learningRate), o9(d8(p, t.epsilon))));
                                    s.assign(p), u.assign(f);
                                    var d = P9(a, f);
                                    a.assign(d)
                                }
                            }))
                        }
                    })), this.incrementIterations()
                }
            }, {
                key: "dispose",
                value: function() {
                    null != this.accumulatedMeanSquares && Y5(this.accumulatedMeanSquares.map((function(e) {
                        return e.variable
                    }))), null != this.accumulatedMeanGrads && this.centered && Y5(this.accumulatedMeanGrads.map((function(e) {
                        return e.variable
                    }))), null != this.accumulatedMoments && Y5(this.accumulatedMoments.map((function(e) {
                        return e.variable
                    })))
                }
            }, {
                key: "getWeights",
                value: (n = c(o().mark((function e() {
                    var t;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return t = [].concat(T(this.accumulatedMeanSquares), T(this.accumulatedMoments)), this.centered && t.push.apply(t, T(this.accumulatedMeanGrads)), e.next = 4, this.saveIterations();
                            case 4:
                                return e.t0 = e.sent, e.abrupt("return", [e.t0].concat(t.map((function(e) {
                                    return {
                                        name: e.originalName,
                                        tensor: e.variable
                                    }
                                }))));
                            case 6:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return n.apply(this, arguments)
                })
            }, {
                key: "setWeights",
                value: (t = c(o().mark((function e(t) {
                    var n, r;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.extractIterations(t);
                            case 2:
                                t = e.sent, n = this.centered ? t.length / 3 : t.length / 2, r = !1, this.accumulatedMeanSquares = t.slice(0, n).map((function(e) {
                                    return {
                                        originalName: e.name,
                                        variable: e.tensor.variable(r)
                                    }
                                })), this.accumulatedMoments = t.slice(n, 2 * n).map((function(e) {
                                    return {
                                        originalName: e.name,
                                        variable: e.tensor.variable(r)
                                    }
                                })), this.centered && (this.accumulatedMeanGrads = t.slice(2 * n, 3 * n).map((function(e) {
                                    return {
                                        originalName: e.name,
                                        variable: e.tensor.variable(r)
                                    }
                                })));
                            case 8:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e) {
                    return t.apply(this, arguments)
                })
            }, {
                key: "getConfig",
                value: function() {
                    return {
                        learningRate: this.learningRate,
                        decay: this.decay,
                        momentum: this.momentum,
                        epsilon: this.epsilon,
                        centered: this.centered
                    }
                }
            }], [{
                key: "className",
                get: function() {
                    return "RMSProp"
                }
            }, {
                key: "fromConfig",
                value: function(e, t) {
                    return new e(t.learningRate, t.decay, t.momentum, t.epsilon, t.centered)
                }
            }]), a
        }(Yre),
        rae = [Jre, Zre, Qre, $re, tae, nae, eae];

    function aae(e) {
        return new Promise((function(e) {
            return setTimeout(e)
        })).then(e)
    }
    var iae = function() {
        function e(t) {
            if (l(this, e), !k0().getBool("IS_BROWSER")) throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
            t.startsWith(e.URL_SCHEME) && (t = t.slice(e.URL_SCHEME.length)), null != t && 0 !== t.length || (t = "model"), this.modelJsonFileName = t + ".json", this.weightDataFileName = t + ".weights.bin"
        }
        var t;
        return p(e, [{
            key: "save",
            value: (t = c(o().mark((function e(t) {
                var n, r, a, i, s, u, c;
                return o().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if ("undefined" != typeof document) {
                                e.next = 2;
                                break
                            }
                            throw new Error("Browser downloads are not supported in this environment since `document` is not present");
                        case 2:
                            if (n = j5.join(t.weightData), r = window.URL.createObjectURL(new Blob([n], {
                                    type: "application/octet-stream"
                                })), !(t.modelTopology instanceof ArrayBuffer)) {
                                e.next = 8;
                                break
                            }
                            throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
                        case 8:
                            return a = [{
                                paths: ["./" + this.weightDataFileName],
                                weights: t.weightSpecs
                            }], i = b6(t, a), s = window.URL.createObjectURL(new Blob([JSON.stringify(i)], {
                                type: "application/json"
                            })), (u = null == this.modelJsonAnchor ? document.createElement("a") : this.modelJsonAnchor).download = this.modelJsonFileName, u.href = s, e.next = 16, aae((function() {
                                return u.dispatchEvent(new MouseEvent("click"))
                            }));
                        case 16:
                            if (null == t.weightData) {
                                e.next = 22;
                                break
                            }
                            return (c = null == this.weightDataAnchor ? document.createElement("a") : this.weightDataAnchor).download = this.weightDataFileName, c.href = r, e.next = 22, aae((function() {
                                return c.dispatchEvent(new MouseEvent("click"))
                            }));
                        case 22:
                            return e.abrupt("return", {
                                modelArtifactsInfo: I6(t)
                            });
                        case 23:
                        case "end":
                            return e.stop()
                    }
                }), e, this)
            }))), function(e) {
                return t.apply(this, arguments)
            })
        }]), e
    }();
    iae.URL_SCHEME = "downloads://";
    var oae = function() {
        function e(t) {
            if (l(this, e), null == t || t.length < 1) throw new Error("When calling browserFiles, at least 1 file is required, " + "but received ".concat(t));
            this.jsonFile = t[0], this.weightsFiles = t.slice(1)
        }
        var t;
        return p(e, [{
            key: "load",
            value: (t = c(o().mark((function e() {
                var t = this;
                return o().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return e.abrupt("return", new Promise((function(e, n) {
                                var r = new FileReader;
                                r.onload = function(r) {
                                    var a = JSON.parse(r.target.result),
                                        i = a.modelTopology;
                                    if (null != i)
                                        if (null != a.weightsManifest)
                                            if (0 !== t.weightsFiles.length) {
                                                var o = k6(a, (function(e) {
                                                    return t.loadWeights(e)
                                                }));
                                                e(o)
                                            } else e({
                                                modelTopology: i
                                            });
                                    else n(new Error("weightManifest field is missing from file ".concat(t.jsonFile.name)));
                                    else n(new Error("modelTopology field is missing from file ".concat(t.jsonFile.name)))
                                }, r.onerror = function(e) {
                                    return n("Failed to read model topology and weights manifest JSON " + "from file '".concat(t.jsonFile.name, "'. BrowserFiles supports loading ") + "Keras-style tf.Model artifacts only.")
                                }, r.readAsText(t.jsonFile)
                            })));
                        case 1:
                        case "end":
                            return e.stop()
                    }
                }), e)
            }))), function() {
                return t.apply(this, arguments)
            })
        }, {
            key: "loadWeights",
            value: function(e) {
                var t, n = this,
                    r = [],
                    a = [],
                    i = O(e);
                try {
                    for (i.s(); !(t = i.n()).done;) {
                        var o = t.value;
                        r.push.apply(r, T(o.weights)), a.push.apply(a, T(o.paths))
                    }
                } catch (e) {
                    i.e(e)
                } finally {
                    i.f()
                }
                var s = this.checkManifestAndWeightFiles(e),
                    u = a.map((function(e) {
                        return n.loadWeightsFile(e, s[e])
                    }));
                return Promise.all(u).then((function(e) {
                    return [r, e]
                }))
            }
        }, {
            key: "loadWeightsFile",
            value: function(e, t) {
                return new Promise((function(n, r) {
                    var a = new FileReader;
                    a.onload = function(e) {
                        var t = e.target.result;
                        n(t)
                    }, a.onerror = function(t) {
                        return r("Failed to weights data from file of path '".concat(e, "'."))
                    }, a.readAsArrayBuffer(t)
                }))
            }
        }, {
            key: "checkManifestAndWeightFiles",
            value: function(e) {
                var t, n = this,
                    r = [],
                    a = this.weightsFiles.map((function(e) {
                        return y6(e.name)
                    })),
                    i = {},
                    o = O(e);
                try {
                    for (o.s(); !(t = o.n()).done;) {
                        t.value.paths.forEach((function(e) {
                            var t = y6(e);
                            if (-1 !== r.indexOf(t)) throw new Error("Duplicate file basename found in weights manifest: " + "'".concat(t, "'"));
                            if (r.push(t), -1 === a.indexOf(t)) throw new Error("Weight file with basename '".concat(t, "' is not provided."));
                            i[e] = n.weightsFiles[a.indexOf(t)]
                        }))
                    }
                } catch (e) {
                    o.e(e)
                } finally {
                    o.f()
                }
                if (r.length !== this.weightsFiles.length) throw new Error("Mismatch in the number of files in weights manifest " + "(".concat(r.length, ") and the number of weight files provided ") + "(".concat(this.weightsFiles.length, ")."));
                return i
            }
        }]), e
    }();

    function sae(e, t, n, r) {
        ! function(e) {
            F$(null != e && Array.isArray(e) && e.length > 0, (function() {
                return "promises must be a none empty array"
            }))
        }(e),
        function(e, t) {
            F$(e >= 0 && e <= 1, (function() {
                return "Progress fraction must be in range [0, 1], but " + "got startFraction ".concat(e)
            })), F$(t >= 0 && t <= 1, (function() {
                return "Progress fraction must be in range [0, 1], but " + "got endFraction ".concat(t)
            })), F$(t >= e, (function() {
                return "startFraction must be no more than endFraction, but " + "got startFraction ".concat(e, " and endFraction ") + "".concat(t)
            }))
        }(n = null == n ? 0 : n, r = null == r ? 1 : r);
        var a = 0;
        return Promise.all(e.map((function(i) {
            return i.then((function(i) {
                var o = n + ++a / e.length * (r - n);
                return t(o), i
            })), i
        })))
    }

    function uae(e, t) {
        return cae.apply(this, arguments)
    }

    function cae() {
        return (cae = c(o().mark((function e(t, n) {
            var r, a, i, s, u, c, l, h, p;
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        if (null == n && (n = {}), r = null == n.fetchFunc ? k0().platform.fetch : n.fetchFunc, a = t.map((function(e) {
                                return r(e, n.requestInit, {
                                    isBinary: !0
                                })
                            })), i = 0, s = .5, null != n.onProgress) {
                            e.next = 11;
                            break
                        }
                        return e.next = 8, Promise.all(a);
                    case 8:
                        e.t0 = e.sent, e.next = 14;
                        break;
                    case 11:
                        return e.next = 13, sae(a, n.onProgress, i, s);
                    case 13:
                        e.t0 = e.sent;
                    case 14:
                        if (u = e.t0, c = u.map((function(e) {
                                return e.arrayBuffer()
                            })), l = .5, h = 1, null != n.onProgress) {
                            e.next = 24;
                            break
                        }
                        return e.next = 21, Promise.all(c);
                    case 21:
                        e.t1 = e.sent, e.next = 27;
                        break;
                    case 24:
                        return e.next = 26, sae(c, n.onProgress, l, h);
                    case 26:
                        e.t1 = e.sent;
                    case 27:
                        return p = e.t1, e.abrupt("return", p);
                    case 29:
                    case "end":
                        return e.stop()
                }
            }), e)
        })))).apply(this, arguments)
    }

    function lae(e, t) {
        var n, r, a, i = null == t.fetchFunc ? k0().platform.fetch : t.fetchFunc,
            s = 0;
        return null === (n = t.onProgress) || void 0 === n || n.call(t, 0), new ReadableStream({
            pull: (a = c(o().mark((function n(a) {
                var u, c, l, h, p;
                return o().wrap((function(n) {
                    for (;;) switch (n.prev = n.next) {
                        case 0:
                            if (!(s < e.length)) {
                                n.next = 20;
                                break
                            }
                            if (r) {
                                n.next = 6;
                                break
                            }
                            return n.next = 4, i(e[s], t.requestInit, {
                                isBinary: !0
                            });
                        case 4:
                            c = n.sent.body, r = c.getReader();
                        case 6:
                            return n.next = 8, r.read();
                        case 8:
                            if (l = n.sent, h = l.done, p = l.value, !h) {
                                n.next = 16;
                                break
                            }
                            return s++, r = void 0, null === (u = t.onProgress) || void 0 === u || u.call(t, s / e.length), n.abrupt("continue", 0);
                        case 16:
                            return a.enqueue(p), n.abrupt("return");
                        case 20:
                            a.close();
                        case 21:
                        case "end":
                            return n.stop()
                    }
                }), n)
            }))), function(e) {
                return a.apply(this, arguments)
            })
        })
    }

    function hae(e) {
        return pae.apply(this, arguments)
    }

    function pae() {
        return pae = c(o().mark((function e(t) {
            var n, r, a, i, s = arguments;
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return n = s.length > 1 && void 0 !== s[1] ? s[1] : "", r = s.length > 2 ? s[2] : void 0, a = s.length > 3 ? s[3] : void 0, i = fae((function(e) {
                            return uae(e, {
                                requestInit: a
                            })
                        })), e.abrupt("return", i(t, n, r));
                    case 6:
                    case "end":
                        return e.stop()
                }
            }), e)
        }))), pae.apply(this, arguments)
    }

    function fae(e) {
        return function() {
            var t = c(o().mark((function t(n) {
                var r, a, i, s, u, c, l, h, p, f, d, v, m = arguments;
                return o().wrap((function(t) {
                    for (;;) switch (t.prev = t.next) {
                        case 0:
                            if (r = m.length > 1 && void 0 !== m[1] ? m[1] : "", a = m.length > 2 ? m[2] : void 0, i = n.map((function() {
                                    return !1
                                })), s = {}, u = null != a ? a.map((function() {
                                    return !1
                                })) : [], c = [], n.forEach((function(e, t) {
                                    var n = 0;
                                    e.weights.forEach((function(e) {
                                        var r = "quantization" in e ? e.quantization.dtype : e.dtype,
                                            o = G5[r] * L$(e.shape),
                                            l = function() {
                                                i[t] = !0, null == s[t] && (s[t] = []), s[t].push({
                                                    manifestEntry: e,
                                                    groupOffset: n,
                                                    sizeBytes: o
                                                })
                                            };
                                        null != a ? a.forEach((function(t, n) {
                                            t === e.name && (l(), u[n] = !0)
                                        })) : l(), c.push(e.name), n += o
                                    }))
                                })), u.every((function(e) {
                                    return e
                                }))) {
                                t.next = 10;
                                break
                            }
                            throw l = a.filter((function(e, t) {
                                return !u[t]
                            })), new Error("Could not find weights in manifest with names: " + "".concat(l.join(", "), ". \n") + "Manifest JSON has weights with names: " + "".concat(c.join(", "), "."));
                        case 10:
                            return h = i.reduce((function(e, t, n) {
                                return t && e.push(n), e
                            }), []), p = [], h.forEach((function(e) {
                                n[e].paths.forEach((function(e) {
                                    var t = r + (r.endsWith("/") ? "" : "/") + e;
                                    p.push(t)
                                }))
                            })), t.next = 15, e(p);
                        case 15:
                            return f = t.sent, d = {}, v = 0, h.forEach((function(e) {
                                var t = n[e].paths.length,
                                    r = new j5(f.slice(v, v + t));
                                s[e].forEach((function(e) {
                                    var t = r6(r.slice(e.groupOffset, e.groupOffset + e.sizeBytes), [e.manifestEntry]);
                                    for (var n in t) d[n] = t[n]
                                })), v += t
                            })), t.abrupt("return", d);
                        case 20:
                        case "end":
                            return t.stop()
                    }
                }), t)
            })));
            return function(e) {
                return t.apply(this, arguments)
            }
        }()
    }
    S6.registerSaveRouter((function(e) {
        return k0().getBool("IS_BROWSER") && !Array.isArray(e) && e.startsWith(iae.URL_SCHEME) ? function() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "model";
            return new iae(e)
        }(e.slice(iae.URL_SCHEME.length)) : null
    }));
    var dae = function() {
        function e(t, n) {
            if (l(this, e), this.DEFAULT_METHOD = "POST", null == n && (n = {}), this.weightPathPrefix = n.weightPathPrefix, this.weightUrlConverter = n.weightUrlConverter, null != n.fetchFunc ? (F$("function" == typeof n.fetchFunc, (function() {
                    return "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"
                })), this.fetch = n.fetchFunc) : this.fetch = k0().platform.fetch, F$(null != t && t.length > 0, (function() {
                    return "URL path for http must not be null, undefined or empty."
                })), Array.isArray(t) && F$(2 === t.length, (function() {
                    return "URL paths for http must have a length of 2, " + "(actual length is ".concat(t.length, ").")
                })), this.path = t, null != n.requestInit && null != n.requestInit.body) throw new Error("requestInit is expected to have no pre-existing body, but has one.");
            this.requestInit = n.requestInit || {}, this.loadOptions = n
        }
        var t, n, r, a, i;
        return p(e, [{
            key: "save",
            value: (i = c(o().mark((function e(t) {
                var n, r, a, i, s;
                return o().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if (!(t.modelTopology instanceof ArrayBuffer)) {
                                e.next = 2;
                                break
                            }
                            throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
                        case 2:
                            return (n = Object.assign({
                                method: this.DEFAULT_METHOD
                            }, this.requestInit)).body = new FormData, r = [{
                                paths: ["./model.weights.bin"],
                                weights: t.weightSpecs
                            }], a = b6(t, r), n.body.append("model.json", new Blob([JSON.stringify(a)], {
                                type: "application/json"
                            }), "model.json"), null != t.weightData && (i = j5.join(t.weightData), n.body.append("model.weights.bin", new Blob([i], {
                                type: "application/octet-stream"
                            }), "model.weights.bin")), e.next = 10, this.fetch(this.path, n);
                        case 10:
                            if (!(s = e.sent).ok) {
                                e.next = 15;
                                break
                            }
                            return e.abrupt("return", {
                                modelArtifactsInfo: I6(t),
                                responses: [s]
                            });
                        case 15:
                            throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status " + "".concat(s.status, "."));
                        case 16:
                        case "end":
                            return e.stop()
                    }
                }), e, this)
            }))), function(e) {
                return i.apply(this, arguments)
            })
        }, {
            key: "loadModelJSON",
            value: (a = c(o().mark((function e() {
                var t, n, r, a, i;
                return o().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return e.next = 2, this.fetch(this.path, this.requestInit);
                        case 2:
                            if ((t = e.sent).ok) {
                                e.next = 5;
                                break
                            }
                            throw new Error("Request to ".concat(this.path, " failed with status code ") + "".concat(t.status, ". Please verify this URL points to ") + "the model JSON of the model to load.");
                        case 5:
                            return e.prev = 5, e.next = 8, t.json();
                        case 8:
                            n = e.sent, e.next = 16;
                            break;
                        case 11:
                            throw e.prev = 11, e.t0 = e.catch(5), r = "Failed to parse model JSON of response from ".concat(this.path, "."), this.path.endsWith(".pb") ? r += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository." : r += " Please make sure the server is serving valid JSON for this request.", new Error(r);
                        case 16:
                            if (a = n.modelTopology, i = n.weightsManifest, null != a || null != i) {
                                e.next = 20;
                                break
                            }
                            throw new Error("The JSON from HTTP path ".concat(this.path, " contains neither model ") + "topology or manifest for weights.");
                        case 20:
                            return e.abrupt("return", n);
                        case 21:
                        case "end":
                            return e.stop()
                    }
                }), e, this, [
                    [5, 11]
                ])
            }))), function() {
                return a.apply(this, arguments)
            })
        }, {
            key: "load",
            value: (r = c(o().mark((function e() {
                var t, n = this;
                return o().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if (!this.loadOptions.streamWeights) {
                                e.next = 2;
                                break
                            }
                            return e.abrupt("return", this.loadStream());
                        case 2:
                            return e.next = 4, this.loadModelJSON();
                        case 4:
                            return t = e.sent, e.abrupt("return", k6(t, (function(e) {
                                return n.loadWeights(e)
                            })));
                        case 6:
                        case "end":
                            return e.stop()
                    }
                }), e, this)
            }))), function() {
                return r.apply(this, arguments)
            })
        }, {
            key: "loadStream",
            value: (n = c(o().mark((function e() {
                var t, n, r, a, i = this;
                return o().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return e.next = 2, this.loadModelJSON();
                        case 2:
                            return t = e.sent, e.next = 5, this.getWeightUrls(t.weightsManifest);
                        case 5:
                            return n = e.sent, r = N6(t.weightsManifest), a = function() {
                                return lae(n, i.loadOptions)
                            }, e.abrupt("return", Object.assign(Object.assign({}, t), {
                                weightSpecs: r,
                                getWeightStream: a
                            }));
                        case 9:
                        case "end":
                            return e.stop()
                    }
                }), e, this)
            }))), function() {
                return n.apply(this, arguments)
            })
        }, {
            key: "getWeightUrls",
            value: (t = c(o().mark((function e(t) {
                var n, r, a, i, s, u, c, l, h, p, f, d, v, m;
                return o().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            n = Array.isArray(this.path) ? this.path[1] : this.path, r = vae(n), a = S(r, 2), i = a[0], s = a[1], u = this.weightPathPrefix || i, c = [], l = [], h = O(t);
                            try {
                                for (h.s(); !(p = h.n()).done;) {
                                    f = p.value, d = O(f.paths);
                                    try {
                                        for (d.s(); !(v = d.n()).done;) m = v.value, null != this.weightUrlConverter ? l.push(this.weightUrlConverter(m)) : c.push(u + m + s)
                                    } catch (e) {
                                        d.e(e)
                                    } finally {
                                        d.f()
                                    }
                                }
                            } catch (e) {
                                h.e(e)
                            } finally {
                                h.f()
                            }
                            if (!this.weightUrlConverter) {
                                e.next = 16;
                                break
                            }
                            return e.t0 = c.push, e.t1 = c, e.t2 = T, e.next = 13, Promise.all(l);
                        case 13:
                            e.t3 = e.sent, e.t4 = (0, e.t2)(e.t3), e.t0.apply.call(e.t0, e.t1, e.t4);
                        case 16:
                            return e.abrupt("return", c);
                        case 17:
                        case "end":
                            return e.stop()
                    }
                }), e, this)
            }))), function(e) {
                return t.apply(this, arguments)
            })
        }, {
            key: "loadWeights",
            value: function() {
                var e = c(o().mark((function e(t) {
                    var n, r, a;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.getWeightUrls(t);
                            case 2:
                                return n = e.sent, r = N6(t), e.next = 6, uae(n, this.loadOptions);
                            case 6:
                                return a = e.sent, e.abrupt("return", [r, a]);
                            case 8:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                })));
                return function(t) {
                    return e.apply(this, arguments)
                }
            }()
        }]), e
    }();

    function vae(e) {
        var t = e.lastIndexOf("/"),
            n = e.lastIndexOf("?");
        return [e.substring(0, t) + "/", n > t ? e.substring(n) : ""]
    }

    function mae(e) {
        return null != e.match(dae.URL_SCHEME_REGEX)
    }
    dae.URL_SCHEME_REGEX = /^https?:\/\//;
    var gae = function(e, t) {
        if ("undefined" == typeof fetch && (null == t || null == t.fetchFunc)) return null;
        return (Array.isArray(e) ? e.every((function(e) {
            return mae(e)
        })) : mae(e)) ? yae(e, t) : null
    };

    function yae(e, t) {
        return new dae(e, t)
    }

    function bae(e, t) {
        return yae(e, t)
    }
    S6.registerSaveRouter(gae), S6.registerLoadRouter(gae);
    var xae = function() {
            function e(t) {
                l(this, e), this.modelArtifacts = t
            }
            return p(e, [{
                key: "load",
                value: function() {
                    return this.modelArtifacts
                }
            }]), e
        }(),
        kae = function() {
            function e(t) {
                l(this, e), this.saveHandler = t
            }
            return p(e, [{
                key: "save",
                value: function(e) {
                    return this.saveHandler(e)
                }
            }]), e
        }(),
        wae = p((function e(t) {
            l(this, e), t.load && (this.load = function() {
                return Promise.resolve(t.load())
            }), t.save && (this.save = function(e) {
                return Promise.resolve(t.save(e))
            })
        }));

    function Iae(e, t, n, r) {
        if (1 === arguments.length) {
            var a = null != e.modelTopology || null != e.weightSpecs;
            return a ? new xae(e) : (console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new xae({
                modelTopology: e
            }))
        }
        return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new xae({
            modelTopology: e,
            weightSpecs: t,
            weightData: n,
            trainingConfig: r
        })
    }
    var Nae = {
        __proto__: null,
        CompositeArrayBuffer: j5,
        browserFiles: function(e) {
            return new oae(e)
        },
        browserHTTPRequest: bae,
        concatenateArrayBuffers: g6,
        copyModel: function(e, t) {
            return a8.apply(this, arguments)
        },
        decodeWeights: r6,
        decodeWeightsStream: l6,
        encodeWeights: t6,
        fromMemory: function(e, t, n, r) {
            var a = arguments;
            return new wae(Iae.apply(void 0, T(a)))
        },
        fromMemorySync: Iae,
        getLoadHandlers: E6,
        getModelArtifactsForJSON: k6,
        getModelArtifactsForJSONSync: x6,
        getModelArtifactsInfoForJSON: I6,
        getSaveHandlers: T6,
        getWeightSpecs: N6,
        http: yae,
        isHTTPScheme: mae,
        listModels: function() {
            return n8.apply(this, arguments)
        },
        loadWeights: hae,
        moveModel: function(e, t) {
            return i8.apply(this, arguments)
        },
        registerLoadRouter: function(e) {
            return S6.registerLoadRouter(e)
        },
        registerSaveRouter: function(e) {
            return S6.registerSaveRouter(e)
        },
        removeModel: function(e) {
            return r8.apply(this, arguments)
        },
        weightsLoaderFactory: fae,
        withSaveHandler: function(e) {
            return new kae(e)
        },
        withSaveHandlerSync: function(e) {
            return new kae(e)
        }
    };
    var Sae, Tae = {
            __proto__: null,
            confusionMatrix: B5({
                confusionMatrix_: function(e, t, n) {
                    var r = L5(e, "labels", "confusionMatrix"),
                        a = L5(t, "predictions", "confusionMatrix");
                    F$(null == n || n > 0 && Number.isInteger(n), (function() {
                        return "If provided, numClasses must be a positive integer, " + "but got ".concat(n)
                    })), F$(1 === r.rank, (function() {
                        return "Expected the rank of labels to be 1, but got ".concat(r.rank)
                    })), F$(1 === a.rank, (function() {
                        return "Expected the rank of predictions to be 1, " + "but got ".concat(a.rank)
                    })), F$(r.shape[0] === a.shape[0], (function() {
                        return "Mismatch in the number of examples: " + "".concat(r.shape[0], " vs. ").concat(a.shape[0], ". ") + "Labels and predictions should have the same number of elements."
                    })), F$(n > 0 && Number.isInteger(n), (function() {
                        return "numClasses is required to be a positive integer, but got " + "".concat(n)
                    }));
                    var i = cee(h8(r, "int32"), n),
                        o = cee(h8(a, "int32"), n),
                        s = hne(i),
                        u = Q8(s, o);
                    return h8(u, "int32")
                }
            })
        },
        Eae = !1;

    function Cae(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 3;
        if (t > 4) throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
        if (null == e) throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
        var n = !1,
            r = !1,
            a = !1,
            i = !1,
            o = !1,
            s = !1;
        if (e.data instanceof Uint8Array) n = !0;
        else if ("undefined" != typeof ImageData && e instanceof ImageData) r = !0;
        else if ("undefined" != typeof HTMLVideoElement && e instanceof HTMLVideoElement) a = !0;
        else if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement) i = !0;
        else if (null != e.getContext) o = !0;
        else {
            if (!("undefined" != typeof ImageBitmap && e instanceof ImageBitmap)) throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, " + "but was ".concat(e.constructor.name));
            s = !0
        }
        var u = W3(O3, E5.backendName);
        if (null != u) {
            var c = {
                    pixels: e
                },
                l = {
                    numChannels: t
                };
            return E5.runKernel(O3, c, l)
        }
        var h, p, f = a ? [e.videoWidth, e.videoHeight] : [e.width, e.height],
            d = S(f, 2),
            v = d[0],
            m = d[1];
        if (o) h = e.getContext("2d").getImageData(0, 0, v, m).data;
        else if (r || n) h = e.data;
        else if (i || a || s) {
            if (null == Sae)
                if ("undefined" == typeof document) {
                    if ("undefined" == typeof OffscreenCanvas || "undefined" == typeof OffscreenCanvasRenderingContext2D) throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");
                    Sae = new OffscreenCanvas(1, 1).getContext("2d")
                } else Sae = document.createElement("canvas").getContext("2d", {
                    willReadFrequently: !0
                });
            Sae.canvas.width = v, Sae.canvas.height = m, Sae.drawImage(e, 0, 0, v, m), h = Sae.getImageData(0, 0, v, m).data
        }
        if (4 === t) p = new Int32Array(h);
        else {
            var g = v * m;
            p = new Int32Array(g * t);
            for (var y = 0; y < g; y++)
                for (var b = 0; b < t; ++b) p[y * t + b] = h[4 * y + b]
        }
        var x = [m, v, t];
        return jte(p, x, "int32")
    }

    function Aae(e) {
        return "undefined" != typeof window && "undefined" != typeof ImageBitmap && window.hasOwnProperty("createImageBitmap") && !(e instanceof ImageBitmap) && function(e) {
            return null != e && 0 !== e.width && 0 !== e.height
        }(e) && ! function(e) {
            return null != e && e.data instanceof Uint8Array
        }(e)
    }

    function Rae() {
        return Rae = c(o().mark((function e(t) {
            var n, r, a, i = arguments;
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        if (n = i.length > 1 && void 0 !== i[1] ? i[1] : 3, r = null, !k0().getBool("WRAP_TO_IMAGEBITMAP") || !Aae(t)) {
                            e.next = 15;
                            break
                        }
                        return e.prev = 3, e.next = 6, createImageBitmap(t, {
                            premultiplyAlpha: "none"
                        });
                    case 6:
                        a = e.sent, e.next = 12;
                        break;
                    case 9:
                        e.prev = 9, e.t0 = e.catch(3), a = null;
                    case 12:
                        r = null != a && a.width === t.width && a.height === t.height ? a : t, e.next = 16;
                        break;
                    case 15:
                        r = t;
                    case 16:
                        return e.abrupt("return", Cae(r, n));
                    case 17:
                    case "end":
                        return e.stop()
                }
            }), e, null, [
                [3, 9]
            ])
        }))), Rae.apply(this, arguments)
    }

    function _ae(e) {
        if (2 !== e.rank && 3 !== e.rank) throw new Error("toPixels only supports rank 2 or 3 tensors, got rank ".concat(e.rank, "."));
        var t = 2 === e.rank ? 1 : e.shape[2];
        if (t > 4 || 2 === t) throw new Error("toPixels only supports depth of size " + "1, 3 or 4 but got ".concat(t));
        if ("float32" !== e.dtype && "int32" !== e.dtype) throw new Error("Unsupported type for toPixels: ".concat(e.dtype, ".") + " Please use float32 or int32 tensors.")
    }

    function Oae() {
        return Oae = c(o().mark((function e(t, n) {
            var r, a, i, s, u, c, l, h, p, f, d, v, m, g, y, b, x;
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return r = L5(t, "img", "toPixels"), t instanceof n5 || (r = h8(a = r, "int32"), a.dispose()), _ae(r), i = r.shape.slice(0, 2), s = S(i, 2), u = s[0], c = s[1], l = 2 === r.rank ? 1 : r.shape[2], e.next = 7, r.data();
                    case 7:
                        h = e.sent, p = "float32" === r.dtype ? 255 : 1, f = new Uint8ClampedArray(c * u * 4), d = 0;
                    case 11:
                        if (!(d < u * c)) {
                            e.next = 36;
                            break
                        }
                        v = [0, 0, 0, 255], m = 0;
                    case 14:
                        if (!(m < l)) {
                            e.next = 28;
                            break
                        }
                        if (g = h[d * l + m], "float32" !== r.dtype) {
                            e.next = 21;
                            break
                        }
                        if (!(g < 0 || g > 1)) {
                            e.next = 19;
                            break
                        }
                        throw new Error("Tensor values for a float32 Tensor must be in the " + "range [0 - 1] but encountered ".concat(g, "."));
                    case 19:
                        e.next = 24;
                        break;
                    case 21:
                        if ("int32" !== r.dtype) {
                            e.next = 24;
                            break
                        }
                        if (!(g < 0 || g > 255)) {
                            e.next = 24;
                            break
                        }
                        throw new Error("Tensor values for a int32 Tensor must be in the " + "range [0 - 255] but encountered ".concat(g, "."));
                    case 24:
                        1 === l ? (v[0] = g * p, v[1] = g * p, v[2] = g * p) : v[m] = g * p;
                    case 25:
                        m++, e.next = 14;
                        break;
                    case 28:
                        f[(y = 4 * d) + 0] = Math.round(v[0]), f[y + 1] = Math.round(v[1]), f[y + 2] = Math.round(v[2]), f[y + 3] = Math.round(v[3]);
                    case 33:
                        ++d, e.next = 11;
                        break;
                    case 36:
                        return null != n && (Eae || null != W3(x1, E5.backendName) && (console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."), Eae = !0), n.width = c, n.height = u, b = n.getContext("2d"), x = new ImageData(f, c, u), b.putImageData(x, 0, 0)), r !== t && r.dispose(), e.abrupt("return", f);
                    case 39:
                    case "end":
                        return e.stop()
                }
            }), e)
        }))), Oae.apply(this, arguments)
    }
    var Fae = B5({
            fromPixels_: Cae
        }),
        Dae = {
            __proto__: null,
            draw: function(e, t, n) {
                var r = L5(e, "img", "draw");
                if (!(e instanceof n5)) {
                    var a = r;
                    r = h8(a, "int32"), a.dispose()
                }
                _ae(r),
                    function(e) {
                        var t = (null == e ? void 0 : e.alpha) || 1;
                        if (t > 1 || t < 0) throw new Error("Alpha value ".concat(t, " is suppoed to be in range [0 - 1]."))
                    }(null == n ? void 0 : n.imageOptions);
                var i = {
                        image: r
                    },
                    o = {
                        canvas: t,
                        options: n
                    };
                E5.runKernel(x1, i, o)
            },
            fromPixels: Fae,
            fromPixelsAsync: function(e) {
                return Rae.apply(this, arguments)
            },
            toPixels: function(e, t) {
                return Oae.apply(this, arguments)
            }
        };

    function Mae(e, t) {
        var n = e.shape.length,
            r = t.shape.length;
        if (n < 1) throw new Error("tf.gatherND() expects the input to be rank 1 or higher," + " but the rank was ".concat(n, "."));
        if (r < 1) throw new Error("tf.gatherND() expects the indices to be rank 1 or higher," + " but the rank was ".concat(r, "."));
        if ("int32" !== t.dtype) throw new Error("tf.gatherND() expects the indices to be int32 type," + " but the dtype was ".concat(t.dtype, "."));
        if (t.shape[r - 1] > n) throw new Error("index innermost dimension length must be <= tensor rank; saw: " + "".concat(t.shape[r - 1], " vs. ").concat(n));
        if (0 === L$(e.shape)) throw new Error("Requested more than 0 entries, but input is empty." + " Input shape: ".concat(e.shape, "."));
        for (var a = t.shape, i = a[a.length - 1], o = 1, s = 0; s < a.length - 1; ++s) o *= a[s];
        var u = e.shape,
            c = a.slice();
        c.pop();
        for (var l = 1, h = i; h < n; ++h) l *= u[h], c.push(u[h]);
        var p = [].concat(T(i0(e.shape).map((function(e) {
            return e / l
        }))), [1]).slice(0, i);
        return [c, o, l, p]
    }
    var Lae = {
        __proto__: null,
        prepareAndValidate: Mae
    };

    function zae(e, t, n) {
        var r = e.shape.length;
        F$(r === t.length, (function() {
            return "Error in slice".concat(r, "D: Length of begin ").concat(t, " must ") + "match the rank of the array (".concat(r, ").")
        })), F$(r === n.length, (function() {
            return "Error in slice".concat(r, "D: Length of size ").concat(n, " must ") + "match the rank of the array (".concat(r, ").")
        }));
        for (var a = function(a) {
                F$(t[a] + n[a] <= e.shape[a], (function() {
                    return "Error in slice".concat(r, "D: begin[").concat(a, "] + size[").concat(a, "] ") + "(".concat(t[a] + n[a], ") would overflow input.shape[").concat(a, "] (").concat(e.shape[a], ")")
                }))
            }, i = 0; i < r; ++i) a(i)
    }

    function Pae(e, t, n) {
        for (var r = [], a = 0; a < e.length; a++) r[a] = Math.ceil((t[a] - e[a]) / n[a]);
        return r
    }

    function Bae(e, t, n, r) {
        for (var a = T(e), i = a.length; i < r.length; i++) a.push(1);
        for (var o = 0; o < n; o++) 0 === o ? a[t] = 1 : (a.splice(t, 0, 1), a.pop());
        return a
    }

    function Wae(e, t, n) {
        return n <= e ? n : n - (t - 1)
    }

    function Uae(e, t) {
        for (var n = [], r = 0; r < e; r++) n.push(t + r);
        return n
    }

    function Vae(e, t, n, r, a) {
        for (var i = T(a), o = Uae(n, t), s = 0; s < i.length; s++)
            if (o.indexOf(s) > -1) i[s] = 0;
            else {
                var u = Wae(t, n, s),
                    c = r[u];
                e & 1 << u && (c = 0), i[s] = c
            }
        return i
    }

    function Gae(e, t, n, r, a) {
        for (var i = T(a), o = Uae(n, t), s = 0; s < i.length; s++)
            if (o.indexOf(s) > -1) i[s] = Number.MAX_SAFE_INTEGER;
            else {
                var u = Wae(t, n, s),
                    c = r[u];
                e & 1 << u && (c = Number.MAX_SAFE_INTEGER), i[s] = c
            }
        for (var l = 0; l < i.length; l++) {
            var h = a[l];
            i[l] < 0 && (i[l] += h), i[l] = A$(0, i[l], a[l])
        }
        return i
    }

    function jae(e, t, n) {
        var r = e[t];
        return (n & 1 << t || null == r) && (r = 1), r
    }

    function Hae(e, t, n, r, a, i) {
        var o = t[a],
            s = n[a] || 1;
        (e & 1 << a || i & 1 << a || null == o) && (o = s > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER);
        var u = r[a];
        return o < 0 && (o += u), o = A$(0, o, u - 1)
    }

    function qae(e, t, n, r, a, i) {
        var o = t[a],
            s = n[a] || 1;
        (e & 1 << a || i & 1 << a || null == o) && (o = s > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER);
        var u = r[a];
        return o < 0 && (o += u), o = s > 0 ? A$(0, o, u) : A$(-1, o, u - 1)
    }

    function Kae(e, t, n) {
        for (var r = n.length, a = 0; a < n.length; a++)
            if (n[a] > 1) {
                r = a;
                break
            }
        for (var i = r + 1; i < n.length; i++)
            if (t[i] > 0 || n[i] !== e[i]) return !1;
        return !0
    }

    function Xae(e, t) {
        for (var n = e.length > 0 ? e[e.length - 1] : 1, r = 0; r < e.length - 1; r++) n += e[r] * t[r];
        return n
    }

    function Yae(e, t, n) {
        var r, a, i = e.shape.length;
        return (r = "number" == typeof t ? [t].concat(T(new Array(i - 1).fill(0))) : t.length < i ? t.concat(new Array(i - t.length).fill(0)) : t.slice()).forEach((function(e) {
            F$(-1 !== e, (function() {
                return "slice() does not support negative begin indexing."
            }))
        })), a = (a = null == n ? new Array(i).fill(-1) : "number" == typeof n ? [n].concat(T(new Array(i - 1).fill(-1))) : n.length < i ? n.concat(new Array(i - n.length).fill(-1)) : n).map((function(t, n) {
            return t >= 0 ? t : (F$(-1 === t, (function() {
                return "Negative size values should be exactly -1 but got " + "".concat(t, " for the slice() size at index ").concat(n, ".")
            })), e.shape[n] - r[n])
        })), [r, a]
    }

    function Jae(e, t, n, r, a, i, o, s, u) {
        var c;
        if (null == r ? (c = new Array(t.length)).fill(1) : c = r, null != o && 0 != (o & o - 1)) throw new Error("Multiple ellipses in slice is not allowed.");
        for (var l = !1, h = {
                dims: c.length,
                numAddAxisAfterEllipsis: 0,
                begin: t.slice(),
                end: n.slice(),
                strides: c.slice(),
                beginMask: a,
                endMask: i,
                ellipsisMask: o,
                newAxisMask: s,
                shrinkAxisMask: u
            }, p = 0; p < h.dims; p++) l && 0 != (1 << p & s) && h.numAddAxisAfterEllipsis++, 1 << p & o && (l = !0);
        l || (h.ellipsisMask |= 1 << h.dims, h.dims++);
        var f = {
            dims: e.length,
            beginMask: 0,
            endMask: 0,
            beginValid: !1,
            endValid: !1
        };
        ! function(e, t) {
            t.beginMask = 0, t.endMask = 0, t.shrinkAxisMask = 0;
            var n = 0;
            t.beginValid = null != e.begin, t.endValid = null != e.end, t.begin = new Array(t.dims), t.end = new Array(t.dims), t.strides = new Array(t.dims), t.finalShapeGatherIndices = [], t.finalShapeGatherIndicesSparse = [], t.inputShapeGatherIndicesSparse = new Array(t.dims);
            for (var r = 0; r < e.dims; r++)
                if (1 << r & e.ellipsisMask)
                    for (var a = Math.min(t.dims - (e.dims - r) + 1 + e.numAddAxisAfterEllipsis, t.dims); n < a; n++) t.begin[n] = 0, t.end[n] = 0, t.strides[n] = 1, t.beginMask |= 1 << n, t.endMask |= 1 << n, t.finalShapeGatherIndices.push(n), t.finalShapeGatherIndicesSparse.push(-1), t.inputShapeGatherIndicesSparse[n] = r;
                else if (1 << r & e.newAxisMask) t.finalShapeGatherIndices.push(-2), t.finalShapeGatherIndicesSparse.push(-1);
            else {
                if (n === t.begin.length) throw Error("Index out of range using input dim ".concat(n, "; input ") + "has only ".concat(t.dims, " dims, ").concat(t.begin.length, "."));
                null != e.begin && (t.begin[n] = e.begin[r]), null != e.end && (t.end[n] = e.end[r]), t.strides[n] = e.strides[r], e.beginMask & 1 << r && (t.beginMask |= 1 << n), e.endMask & 1 << r && (t.endMask |= 1 << n), e.shrinkAxisMask & 1 << r ? (t.finalShapeGatherIndices.push(-1), t.finalShapeGatherIndicesSparse.push(-1), t.shrinkAxisMask |= 1 << n) : (t.finalShapeGatherIndices.push(n), t.finalShapeGatherIndicesSparse.push(r)), t.inputShapeGatherIndicesSparse[n] = r, n++
            }
        }(h, f);
        for (var d = !0, v = !0, m = !0, g = [], y = [], b = 0; b < e.length; ++b) {
            if (0 === f.strides[b]) throw Error("strides[".concat(b, "] must be non-zero"));
            var x = !!(f.shrinkAxisMask & 1 << b),
                k = e[b];
            if (-1 !== k) {
                var w = [f.beginMask & 1 << b, f.endMask & 1 << b],
                    I = [f.strides[b] > 0 ? 0 : -1, f.strides[b] > 0 ? k : k - 1];
                if (x && f.strides[b] <= 0) throw Error("only stride 1 allowed on non-range indexing.");
                m = m && 1 === f.strides[b];
                var N = !!(f.beginMask & 1 << b && f.endMask & 1 << b);
                if (f.beginValid && f.endValid) {
                    if (x) {
                        var S = f.begin[b] < 0 ? k + f.begin[b] : f.begin[b];
                        if (f.begin[b] = S, f.end[b] = f.begin[b] + 1, S < 0 || S >= k) throw Error("slice index ".concat(f.begin[b], " of dimension ").concat(b, " out of bounds."))
                    } else f.begin[b] = Zae(f.begin[b], 0, f.strides[b], k, w, I), f.end[b] = Zae(f.end[b], 1, f.strides[b], k, w, I);
                    var T = 1 === f.strides[b] && 0 === f.begin[b] && f.end[b] === k;
                    d = d && T, v = v && (0 === b && 1 === f.strides[b] || T)
                } else d = d && 1 === f.strides[b] && N, v = v && (0 === b && 1 === f.strides[b] || N);
                var E = void 0,
                    C = !1;
                if (f.beginValid && f.endValid ? (E = f.end[b] - f.begin[b], C = !0) : x ? (E = 1, C = !0) : N && k >= 0 && (E = f.strides[b] < 0 ? -k : k, C = !0), C) {
                    var A = void 0;
                    A = 0 === E || E < 0 != f.strides[b] < 0 ? 0 : Math.trunc(E / f.strides[b]) + (E % f.strides[b] != 0 ? 1 : 0), g.push(A)
                } else g.push(-1)
            } else g.push(x ? 1 : -1)
        }
        for (var R = 0; R < f.finalShapeGatherIndices.length; ++R) {
            var _ = f.finalShapeGatherIndices[R];
            _ >= 0 ? y.push(g[_]) : -2 === _ && y.push(1)
        }
        var O = y.filter((function(e, t) {
            return -2 !== f.finalShapeGatherIndices[t]
        }));
        return {
            finalShapeSparse: O,
            finalShape: y,
            isIdentity: d,
            sliceDim0: v,
            isSimpleSlice: m,
            begin: f.begin,
            end: f.end,
            strides: f.strides
        }
    }

    function Zae(e, t, n, r, a, i) {
        if (a[t]) return n > 0 ? i[t] : i[t + 1 & 1];
        var o = e < 0 ? r + e : e;
        return o < i[0] ? i[0] : o > i[1] ? i[1] : o
    }
    var Qae, $ae = {
            __proto__: null,
            assertParamsValid: zae,
            computeFlatOffset: Xae,
            computeOutShape: Pae,
            getNormalizedAxes: function(e, t, n, r, a, i, o, s, u) {
                var c = e.length,
                    l = new Array(c),
                    h = new Array(c),
                    p = new Array(c);
                if (t.length && n > 0) {
                    var f = t[0],
                        d = n + 1;
                    l = Vae(o, f, d, r, e), h = Gae(s, f, d, a, e), p = Bae(i, f, d, e)
                } else
                    for (var v = 0; v < c; v++) l[v] = Hae(o, r, i, e, v, u), h[v] = qae(s, a, i, e, v, u), p[v] = jae(i, v, u);
                return {
                    begin: l,
                    end: h,
                    strides: p
                }
            },
            isSliceContinous: Kae,
            maskToAxes: function(e) {
                for (var t = [], n = 0; e > 0;) 1 & e && t.push(n), e /= 2, n++;
                return t
            },
            parseSliceParams: Yae,
            sliceInfo: Jae,
            startForAxis: Hae,
            startIndicesWithElidedDims: Vae,
            stopForAxis: qae,
            stopIndicesWithElidedDims: Gae,
            stridesForAxis: jae,
            stridesWithElidedDims: Bae
        },
        eie = "4.22.0",
        tie = function() {
            function e() {
                l(this, e)
            }
            return p(e, null, [{
                key: "sgd",
                value: function(e) {
                    return new eae(e)
                }
            }, {
                key: "momentum",
                value: function(e, t) {
                    var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                    return new tae(e, t, n)
                }
            }, {
                key: "rmsprop",
                value: function(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .9,
                        n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                        r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
                        a = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
                    return new nae(e, t, n, r, a)
                }
            }, {
                key: "adam",
                value: function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .001,
                        t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .9,
                        n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : .999,
                        r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
                    return new Qre(e, t, n, r)
                }
            }, {
                key: "adadelta",
                value: function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .001,
                        t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .95,
                        n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
                    return new Jre(e, t, n)
                }
            }, {
                key: "adamax",
                value: function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .002,
                        t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .9,
                        n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : .999,
                        r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
                        a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
                    return new $re(e, t, n, r, a)
                }
            }, {
                key: "adagrad",
                value: function(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .1;
                    return new Zre(e, t)
                }
            }]), e
        }(),
        nie = tie,
        rie = "undefined" != typeof requestAnimationFrame ? requestAnimationFrame : "undefined" != typeof setImmediate ? setImmediate : function(e) {
            return e()
        };

    function aie() {
        return new Promise((function(e) {
            return rie((function() {
                return e()
            }))
        }))
    }

    function iie(e, t) {
        var n = e[0].length;
        e.forEach((function(e, t) {
            F$(e.length === n, (function() {
                return "Error in concat".concat(n, "D: rank of tensors[").concat(t, "] must be the same ") + "as the rank of the rest (".concat(n, ")")
            }))
        })), F$(t >= 0 && t < n, (function() {
            return "Error in concat".concat(n, "D: axis must be between 0 and ").concat(n - 1, ".")
        }));
        var r = e[0];
        e.forEach((function(e, a) {
            for (var i = 0; i < n; i++) F$(i === t || e[i] === r[i], (function() {
                return "Error in concat".concat(n, "D: Shape of tensors[").concat(a, "] (").concat(e, ") ") + "does not match the shape of the rest (".concat(r, ") ") + "along the non-concatenated axis ".concat(a, ".")
            }))
        }))
    }

    function oie(e, t) {
        for (var n = e[0].slice(), r = 1; r < e.length; r++) n[t] += e[r][t];
        return n
    }

    function sie(e, t, n) {
        var r = new Array;
        if (null == n && null == t) return r;
        if (null == t)
            for (; r.length < e + n.length;) r.push(-1);
        else r = t.slice();
        if (null == n) return r;
        if (e + n.length !== r.length) throw new Error("rt input.shape and shape=".concat(t, " are incompatible: rt input.rank = ").concat(e + n.length, ", but shape.rank = ").concat(r.length));
        for (var a = 1; a < n.length; ++a) {
            var i = n[a],
                o = r[r.length - n.length + a],
                s = r[o];
            if (i >= 0)
                if (s >= 0) {
                    if (s !== i) throw new Error("rt input.shape and shape=".concat(t, " are incompatible: rt input.shape[").concat(a + e, "] = ").concat(i, " but shape[").concat(a + e, "] = ").concat(s))
                } else r[o] = i
        }
        return r
    }

    function uie(e) {
        var t, n = {
                FIRST_DIM_SIZE: Qae.FIRST_DIM_SIZE,
                VALUE_ROWIDS: Qae.VALUE_ROWIDS,
                ROW_LENGTHS: Qae.ROW_LENGTHS,
                ROW_SPLITS: Qae.ROW_SPLITS,
                ROW_LIMITS: Qae.ROW_LIMITS,
                ROW_STARTS: Qae.ROW_STARTS
            },
            r = [],
            a = O(e);
        try {
            for (a.s(); !(t = a.n()).done;) {
                var i = t.value;
                if (!(i in n)) break;
                r.push(n[i])
            }
        } catch (e) {
            a.e(e)
        } finally {
            a.f()
        }
        return r
    }

    function cie(e) {
        return 0 === e.length ? 0 : e[0] === Qae.FIRST_DIM_SIZE ? e.length - 1 : e.length
    }

    function lie(e, t) {
        if (null != e && null != t) {
            var n = e.length,
                r = t.length;
            if (n >= r) throw new Error("defaultValue.shape=".concat(e, " and ragged tensor flatValues.shape=").concat(t, ", are incompatible: defaultValue.rank = ").concat(n, " must be less than ragged tensor input flatValues.rank = ").concat(r, ")"));
            for (var a = 0; a < Math.min(n, r - 1); ++a) {
                var i = e[a],
                    o = t[a + 1];
                if (i >= 0 && o >= 0 && 1 !== i && i !== o) throw new Error("defaultValue.shape=".concat(e, ", and ragged tensor input flatValues.shape=").concat(t, " are incompatible: defaultValue.shape[").concat(a - e.length, "] = ").concat(i, " but ragged tensor input.flatValues.shape[").concat(a - e.length, "] = ").concat(o))
            }
        }
    }! function(e) {
        e[e.FIRST_DIM_SIZE = 0] = "FIRST_DIM_SIZE", e[e.VALUE_ROWIDS = 1] = "VALUE_ROWIDS", e[e.ROW_LENGTHS = 2] = "ROW_LENGTHS", e[e.ROW_SPLITS = 3] = "ROW_SPLITS", e[e.ROW_LIMITS = 4] = "ROW_LIMITS", e[e.ROW_STARTS = 5] = "ROW_STARTS"
    }(Qae || (Qae = {}));

    function hie(e) {
        return e <= 30 ? e : a0(e, Math.floor(Math.sqrt(e)))
    }

    function pie(e, t, n) {
        return [n * ("number" == typeof e ? e : e[0]), t * ("number" == typeof e ? e : e[1])]
    }

    function fie(e, t, n) {
        var r = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
            a = [];
        if (r)(a = a.concat(t.slice(0))).push(e[0] / n), a = a.concat(e.slice(1));
        else {
            a = a.concat(e[0]);
            for (var i = t.length, o = 0; o < i; ++o) a = a.concat([e[o + 1] / t[o], t[o]]);
            a = a.concat(e.slice(i + 1))
        }
        return a
    }

    function die(e, t) {
        var n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
            r = [];
        if (n) {
            r.push(t);
            for (var a = t + 1; a < e; ++a) a <= 2 * t ? (r.push(a), r.push(a - (t + 1))) : r.push(a)
        } else {
            for (var i = [], o = [], s = 1; s < e; ++s) s >= 2 * t + 1 || s % 2 == 1 ? o.push(s) : i.push(s);
            r.push.apply(r, i), r.push(0), r.push.apply(r, o)
        }
        return r
    }

    function vie(e, t, n) {
        var r = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
            a = [];
        r ? a.push(e[0] / n) : a.push(e[0] * n);
        for (var i = 1; i < e.length; ++i) i <= t.length ? r ? a.push(t[i - 1] * e[i]) : a.push(e[i] / t[i - 1]) : a.push(e[i]);
        return a
    }

    function mie(e, t) {
        for (var n = [0], r = 0; r < t; ++r) n.push(e[r][0]);
        return n
    }

    function gie(e, t, n) {
        for (var r = e.slice(0, 1), a = 0; a < n; ++a) r.push(e[a + 1] - t[a][0] - t[a][1]);
        return r
    }
    var yie = 1.7580993408473768,
        bie = 1.0507009873554805,
        xie = .3275911,
        kie = .254829592,
        wie = -.284496736,
        Iie = 1.421413741,
        Nie = -1.453152027,
        Sie = 1.061405429;

    function Tie(e, t) {
        if (e.length !== t.length) throw new Error("Cannot merge real and imag arrays of different lengths. real:" + "".concat(e.length, ", imag: ").concat(t.length, "."));
        for (var n = new Float32Array(2 * e.length), r = 0; r < n.length; r += 2) n[r] = e[r / 2], n[r + 1] = t[r / 2];
        return n
    }

    function Eie(e) {
        for (var t = new Float32Array(e.length / 2), n = new Float32Array(e.length / 2), r = 0; r < e.length; r += 2) t[r / 2] = e[r], n[r / 2] = e[r + 1];
        return {
            real: t,
            imag: n
        }
    }

    function Cie(e) {
        for (var t = Math.ceil(e.length / 4), n = new Float32Array(t), r = new Float32Array(t), a = 0; a < e.length; a += 4) n[Math.floor(a / 4)] = e[a], r[Math.floor(a / 4)] = e[a + 1];
        return {
            real: n,
            imag: r
        }
    }

    function Aie(e) {
        for (var t = Math.floor(e.length / 4), n = new Float32Array(t), r = new Float32Array(t), a = 2; a < e.length; a += 4) n[Math.floor(a / 4)] = e[a], r[Math.floor(a / 4)] = e[a + 1];
        return {
            real: n,
            imag: r
        }
    }

    function Rie(e, t) {
        return {
            real: e[2 * t],
            imag: e[2 * t + 1]
        }
    }

    function _ie(e, t, n, r) {
        e[2 * r] = t, e[2 * r + 1] = n
    }

    function Oie(e, t) {
        for (var n = new Float32Array(e / 2), r = new Float32Array(e / 2), a = 0; a < Math.ceil(e / 2); a++) {
            var i = (t ? 2 : -2) * Math.PI * (a / e);
            n[a] = Math.cos(i), r[a] = Math.sin(i)
        }
        return {
            real: n,
            imag: r
        }
    }

    function Fie(e, t, n) {
        var r = (n ? 2 : -2) * Math.PI * (e / t);
        return {
            real: Math.cos(r),
            imag: Math.sin(r)
        }
    }
    var Die = "->",
        Mie = /->/g;

    function Lie(e, t) {
        var n = ((e = e.replace(/\s/g, "")).length - e.replace(Mie, "").length) / Die.length;
        if (n < 1) throw new Error("Equations without an arrow are not supported.");
        if (n > 1) throw new Error('Equation must contain exactly one arrow ("'.concat(Die, '").'));
        var r = S(e.split(Die), 2),
            a = r[0],
            i = r[1];
        F$(-1 === a.indexOf("..."), (function() {
            return 'The ellipsis notation ("'.concat("...", '") is not supported yet.')
        }));
        var o = a.split(","),
            s = o.length;
        if (t !== s) throw new Error("Expected ".concat(s, " input tensors, received ").concat(t));
        if (s > 2) throw new Error("Support for more than 2 input tensors is not implemented yet.");
        for (var u = [], c = function() {
                var e = i[l];
                if (!o.some((function(t) {
                        return -1 !== t.indexOf(e)
                    }))) throw new Error("Output subscripts contain the label ".concat(e, " ") + "not present in the input subscripts."); - 1 === u.indexOf(e) && u.push(e)
            }, l = 0; l < i.length; ++l) c();
        for (var h = 0; h < a.length; ++h) {
            var p = a[h]; - 1 === u.indexOf(p) && "," !== p && u.push(p)
        }
        for (var f = new Array(o.length), d = 0; d < s; ++d) {
            if (new Set(o[d].split("")).size !== o[d].length) throw new Error("Found duplicate axes in input component ".concat(o[d], ". ") + "Support for duplicate axes in input is not implemented yet.");
            f[d] = [];
            for (var v = 0; v < o[d].length; ++v) f[d].push(u.indexOf(o[d][v]))
        }
        for (var m = u.length, g = [], y = i.length; y < m; ++y) g.push(y);
        return {
            allDims: u,
            summedDims: g,
            idDims: f
        }
    }

    function zie(e, t) {
        var n = new Array(e);
        n.fill(-1);
        for (var r = 0; r < t.length; ++r) n[t[r]] = r;
        for (var a = [], i = 0; i < e; ++i) - 1 === n[i] && a.push(i);
        return {
            permutationIndices: n = n.filter((function(e) {
                return -1 !== e
            })),
            expandDims: a
        }
    }

    function Pie(e, t, n) {
        for (var r = new Array(e), a = function(e) {
                for (var a = n[e].shape, i = function(n) {
                        void 0 === r[t[e][n]] ? r[t[e][n]] = a[n] : F$(r[t[e][n]] === a[n], (function() {
                            return "Expected dimension ".concat(r[t[e][n]], " at axis ").concat(n, " ") + "of input shaped ".concat(JSON.stringify(a), ", ") + "but got dimension ".concat(a[n])
                        }))
                    }, o = 0; o < t[e].length; ++o) i(o)
            }, i = 0; i < n.length; ++i) a(i)
    }

    function Bie(e, t) {
        var n, r = e,
            a = [];
        0 === e.length && r.push(-1), n = e.length + 1;
        for (var i = 0; i < n; ++i) a.push([]);
        for (var o = [], s = 0; s < r.length; ++s) {
            var u, c = O(Uie(t, r[s]));
            try {
                for (c.s(); !(u = c.n()).done;) {
                    var l = u.value; - 1 === o.indexOf(l) && (a[s].push(l), o.push(l))
                }
            } catch (e) {
                c.e(e)
            } finally {
                c.f()
            }
        }
        return {
            path: r,
            steps: a
        }
    }

    function Wie(e) {
        return e.every((function(e, t) {
            return e === t
        }))
    }

    function Uie(e, t) {
        for (var n = [], r = 0; r < e.length; ++r) 0 !== e[r].length && -1 === e[r].indexOf(t) && -1 !== t || n.push(r);
        return n
    }

    function Vie(e, t) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
            r = [];
        if ("number" == typeof t) F$(e.shape[n] % t == 0, (function() {
            return "Number of splits must evenly divide the axis."
        })), r = new Array(t).fill(e.shape[n] / t);
        else {
            var a = t.reduce((function(e, t) {
                return -1 === t && (e += 1), e
            }), 0);
            F$(a <= 1, (function() {
                return "There should be only one negative value in split array."
            }));
            var i = t.indexOf(-1);
            if (-1 !== i) {
                var o = t.reduce((function(e, t) {
                    return t > 0 ? e + t : e
                }));
                t[i] = e.shape[n] - o
            }
            F$(e.shape[n] === t.reduce((function(e, t) {
                return e + t
            })), (function() {
                return "The sum of sizes must match the size of the axis dimension."
            })), r = t
        }
        return r
    }

    function Gie(e) {
        return "Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ".concat(e)
    }

    function jie(e, t) {
        return "indices(".concat(e, ", 0) is invalid: ").concat(t, " < 0")
    }

    function Hie(e, t, n) {
        return "indices(".concat(e, ", 0) is invalid: ").concat(t, " >= ").concat(n)
    }

    function qie(e, t) {
        return "only one output dimension may be -1, not both ".concat(e, " and ").concat(t)
    }

    function Kie(e, t) {
        return "size ".concat(e, " must be non-negative, not ").concat(t)
    }

    function Xie() {
        return "reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"
    }

    function Yie(e, t) {
        var n = L$(e),
            r = L$(t);
        return "Input to reshape is a SparseTensor with ".concat(n, "\n  dense values, but the requested shape requires a multiple of ").concat(r, ". inputShape=").concat(e, " outputShape= ").concat(t)
    }

    function Jie(e, t) {
        var n = L$(e),
            r = L$(t);
        return "Input to reshape is a tensor with ".concat(n, " dense values, but the requested shape has ").concat(r, ". inputShape=").concat(e, " outputShape=").concat(t)
    }

    function Zie() {
        return "segment ids must be >= 0"
    }

    function Qie() {
        return "segment ids are not increasing"
    }

    function $ie(e, t) {
        return "Segment id ".concat(e, " out of range [0, ").concat(t, "), possibly because segmentIds input is not sorted.")
    }

    function eoe(e, t, n) {
        return "Bad: indices[".concat(e, "] == ").concat(t, " out of range [0, ").concat(n, ")")
    }

    function toe(e, t) {
        var n, r = !1;
        for (e <= 30 ? (n = e, r = !0) : n = a0(e, Math.floor(Math.sqrt(e))); !r;) n > t || n === e ? r = !0 : n = a0(e, n + 1);
        return n
    }

    function noe(e, t, n) {
        for (var r = [], a = e.length, i = 0; i < a; i++) i !== t ? r.push(e[i]) : r.push(n);
        return r
    }

    function roe(e, t, n, r) {
        var a = t.shape.length,
            i = e.shape.length;
        if (0 !== r && (r < -a || r > a)) throw new Error("Expect batchDims in the range of [-".concat(a, ", ").concat(a, "], but got ").concat(r));
        if (r < 0 && (r += a), r > i) throw new Error("batchDims (".concat(r, ") must be less than rank(x) (\n    ").concat(i, ")."));
        if (n < r) throw new Error("batchDims (".concat(r, ") must be less than or equal to axis (").concat(n, ")."));
        for (var o = 0; o < r; ++o)
            if (e.shape[o] !== t.shape[o]) throw new Error("x.shape[".concat(o, "]: ").concat(e.shape[o], " should be equal to indices.shape[").concat(o, "]: ").concat(t.shape[o], "."));
        for (var s = e.shape[n], u = [], c = 1, l = 1, h = 1, p = 0; p < r; ++p) u.push(e.shape[p]), c *= e.shape[p];
        for (var f = r; f < n; f++) u.push(e.shape[f]), l *= e.shape[f];
        for (var d = r; d < a; d++) u.push(t.shape[d]);
        for (var v = n + 1; v < i; v++) u.push(e.shape[v]), h *= e.shape[v];
        return {
            batchSize: c,
            sliceSize: h,
            outerSize: l,
            dimSize: s,
            outputShape: u
        }
    }

    function aoe(e) {
        try {
            return e.map((function(e) {
                return W4(e)
            }))
        } catch (e) {
            throw new Error("Failed to decode encoded string bytes into utf-8, error: ".concat(e))
        }
    }

    function ioe(e) {
        return e.map((function(e) {
            return B4(e)
        }))
    }
    var ooe = {
            __proto__: null,
            ERF_A1: kie,
            ERF_A2: wie,
            ERF_A3: Iie,
            ERF_A4: Nie,
            ERF_A5: Sie,
            ERF_P: xie,
            PARALLELIZE_THRESHOLD: 30,
            get RowPartitionType() {
                return Qae
            },
            SELU_SCALE: bie,
            SELU_SCALEALPHA: yie,
            applyActivation: Sne,
            assertAndGetBroadcastShape: z7,
            assertAxesAreInnerMostDims: Q7,
            assertParamsConsistent: iie,
            assignToTypedArray: _ie,
            axesAreInnerMostDims: X7,
            calculateShapes: Jte,
            checkEinsumDimSizes: Pie,
            checkPadOnDimRoundingMode: K8,
            combineLocations: Y7,
            combineRaggedTensorToTensorShapes: sie,
            complexWithEvenIndex: Cie,
            complexWithOddIndex: Aie,
            computeConv2DInfo: D8,
            computeConv3DInfo: M8,
            computeDefaultPad: L8,
            computeDilation2DInfo: _8,
            computeOptimalWindowSize: hie,
            computeOutAndReduceShapes: J7,
            computeOutShape: oie,
            computePool2DInfo: O8,
            computePool3DInfo: F8,
            convertConv2DDataFormat: q8,
            decodeEinsumEquation: Lie,
            eitherStridesOrDilationsAreOne: j8,
            expandShapeToKeepDim: Z7,
            exponent: Fie,
            exponents: Oie,
            fromStringArrayToUint8: ioe,
            fromUint8ToStringArray: aoe,
            getAxesPermutation: $7,
            getBroadcastDims: M7,
            getComplexWithIndex: Rie,
            getEinsumComputePath: Bie,
            getEinsumPermutation: zie,
            getFusedBiasGradient: Nne,
            getFusedDyActivation: Ine,
            getImageCenter: pie,
            getInnerMostAxes: t9,
            getPermuted: die,
            getRaggedRank: cie,
            getReductionAxes: L7,
            getReshaped: fie,
            getReshapedPermuted: vie,
            getRowPartitionTypesHelper: uie,
            getSliceBeginCoords: mie,
            getSliceSize: gie,
            getSparseFillEmptyRowsIndicesDenseShapeMismatch: Gie,
            getSparseFillEmptyRowsNegativeIndexErrorMessage: jie,
            getSparseFillEmptyRowsOutOfRangeIndexErrorMessage: Hie,
            getSparseReshapeEmptyTensorZeroOutputDimErrorMessage: Xie,
            getSparseReshapeInputOutputMismatchErrorMessage: Jie,
            getSparseReshapeInputOutputMultipleErrorMessage: Yie,
            getSparseReshapeMultipleNegativeOneOutputDimErrorMessage: qie,
            getSparseReshapeNegativeOutputDimErrorMessage: Kie,
            getSparseSegmentReductionIndicesOutOfRangeErrorMessage: eoe,
            getSparseSegmentReductionNegativeSegmentIdsErrorMessage: Zie,
            getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage: Qie,
            getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage: $ie,
            getUndoAxesPermutation: e9,
            isIdentityPermutation: Wie,
            log: function() {
                var e;
                k0().getBool("IS_TEST") || k0().getBool("PROD") || (e = console).log.apply(e, arguments)
            },
            mergeRealAndImagArrays: Tie,
            prepareAndValidate: Mae,
            prepareSplitSize: Vie,
            segment_util: {
                __proto__: null,
                collectGatherOpShapeInfo: roe,
                computeOutShape: noe,
                segOpComputeOptimalWindowSize: toe
            },
            shouldFuse: Tne,
            slice_util: $ae,
            splitRealAndImagArrays: Eie,
            stridesOrDilationsArePositive: H8,
            tupleValuesAreOne: G8,
            upcastType: h5,
            validateDefaultValueShape: lie,
            validateInput: Yte,
            validateUpdateShape: Xte,
            warn: z3
        },
        soe = {
            __proto__: null,
            nonMaxSuppressionV3Impl: qne,
            nonMaxSuppressionV4Impl: Kne,
            nonMaxSuppressionV5Impl: Xne,
            whereImpl: one
        };
    ! function() {
        var e, t = O(rae);
        try {
            for (t.s(); !(e = t.n()).done;) {
                Kre(e.value)
            }
        } catch (e) {
            t.e(e)
        } finally {
            t.f()
        }
    }();
    var uoe = {
            kernelName: N0,
            inputsToSave: ["x"],
            gradFunc: function(e, t) {
                var n = S(t, 1)[0];
                return {
                    x: function() {
                        return g8(e, Bte(h8(n, "float32"), -1))
                    }
                }
            }
        },
        coe = {
            kernelName: S0,
            inputsToSave: ["x"],
            gradFunc: function(e, t) {
                var n = S(t, 1)[0];
                return {
                    x: function() {
                        var t = s9(h8(n, "float32")),
                            r = o9(P9(i9(1), t));
                        return M9(m8(e, r))
                    }
                }
            }
        },
        loe = {
            kernelName: T0,
            inputsToSave: ["x"],
            gradFunc: function(e, t) {
                var n = S(t, 1)[0];
                return {
                    x: function() {
                        var t = o9(P9(s9(h8(n, "float32")), 1));
                        return m8(e, t)
                    }
                }
            }
        },
        hoe = {
            kernelName: E0,
            inputsToSave: ["a", "b"],
            gradFunc: function(e, t) {
                var n = S(t, 2),
                    r = n[0],
                    a = n[1],
                    i = z7(r.shape, a.shape);
                return {
                    a: function() {
                        var t = e,
                            n = L7(r.shape, i);
                        return n.length > 0 && (t = u9(t, n)), X8(t, r.shape)
                    },
                    b: function() {
                        var t = e,
                            n = L7(a.shape, i);
                        return n.length > 0 && (t = u9(t, n)), X8(t, a.shape)
                    }
                }
            }
        },
        poe = {
            kernelName: C0,
            saveAllInputs: !0,
            gradFunc: function(e, t) {
                var n = {};
                return t.forEach((function(t, r) {
                    n[r] = function() {
                        return e.clone()
                    }
                })), n
            }
        },
        foe = {
            kernelName: _0,
            inputsToSave: ["x"],
            gradFunc: function(e, t) {
                var n = S(t, 1)[0];
                return {
                    x: function() {
                        return U7(n)
                    }
                }
            }
        },
        doe = {
            kernelName: O0,
            inputsToSave: ["x"],
            gradFunc: function(e, t) {
                var n = S(t, 1)[0];
                return {
                    x: function() {
                        return U7(n)
                    }
                }
            }
        },
        voe = {
            kernelName: F0,
            inputsToSave: ["x"],
            gradFunc: function(e, t) {
                var n = S(t, 1)[0];
                return {
                    x: function() {
                        return m8(e, o9(P9(i9(1), s9(h8(n, "float32")))))
                    }
                }
            }
        },
        moe = {
            kernelName: D0,
            inputsToSave: ["x"],
            gradFunc: function(e, t) {
                var n = S(t, 1)[0];
                return {
                    x: function() {
                        var t = o9(d8(i9(1), s9(h8(n, "float32"))));
                        return m8(e, t)
                    }
                }
            }
        },
        goe = {
            kernelName: z0,
            inputsToSave: ["a", "b"],
            gradFunc: function(e, t) {
                var n = S(t, 2),
                    r = n[0],
                    a = n[1],
                    i = z7(r.shape, a.shape);
                return {
                    a: function() {
                        var t = d8(s9(r), s9(a)),
                            n = g8(e, m8(a, t)),
                            o = L7(r.shape, i);
                        return o.length > 0 && (n = u9(n, o)), X8(n, r.shape)
                    },
                    b: function() {
                        var t = d8(s9(r), s9(a)),
                            n = M9(g8(e, m8(r, t))),
                            o = L7(a.shape, i);
                        return o.length > 0 && (n = u9(n, o)), X8(n, a.shape)
                    }
                }
            }
        },
        yoe = {
            kernelName: M0,
            inputsToSave: ["x"],
            gradFunc: function(e, t) {
                var n = S(t, 1)[0];
                return {
                    x: function() {
                        return m8(e, d8(s9(h8(n, "float32")), 1))
                    }
                }
            }
        },
        boe = {
            kernelName: L0,
            inputsToSave: ["x"],
            gradFunc: function(e, t) {
                var n = S(t, 1)[0];
                return {
                    x: function() {
                        return m8(e, P9(i9(1), s9(h8(n, "float32"))))
                    }
                }
            }
        };
    var xoe = B5({
            avgPool3dGrad_: function(e, t, n, r, a, i) {
                var o = L5(e, "dy", "avgPool3dGrad"),
                    s = L5(t, "input", "avgPool3dGrad"),
                    u = o,
                    c = s,
                    l = !1;
                4 === s.rank && (l = !0, u = X8(o, [1, o.shape[0], o.shape[1], o.shape[2], o.shape[3]]), c = X8(s, [1, s.shape[0], s.shape[1], s.shape[2], s.shape[3]])), F$(5 === u.rank, (function() {
                    return "Error in avgPool3dGrad: dy must be rank 5 but got rank " + "".concat(u.rank, ".")
                })), F$(5 === c.rank, (function() {
                    return "Error in avgPool3dGrad: input must be rank 5 but got rank " + "".concat(c.rank, ".")
                })), K8("avgPool3dGrad", a, i);
                var h = {
                        dy: u,
                        input: c
                    },
                    p = {
                        filterSize: n,
                        strides: r,
                        pad: a,
                        dimRoundingMode: i
                    },
                    f = E5.runKernel(U0, h, p);
                return l ? X8(f, [f.shape[1], f.shape[2], f.shape[3], f.shape[4]]) : f
            }
        }),
        koe = {
            kernelName: W0,
            inputsToSave: ["x"],
            gradFunc: function(e, t, n) {
                var r = S(t, 1)[0],
                    a = n.filterSize,
                    i = n.strides,
                    o = n.pad,
                    s = n.dimRoundingMode;
                return {
                    x: function() {
                        return xoe(e, r, a, i, o, s)
                    }
                }
            }
        };
    var woe = B5({
            avgPoolGrad_: function(e, t, n, r, a) {
                var i = L5(e, "dy", "avgPoolGrad"),
                    o = L5(t, "input", "avgPoolGrad");
                F$(o.rank === i.rank, (function() {
                    return "Rank of input (".concat(o.rank, ") does not match rank of dy (").concat(i.rank, ")")
                }));
                var s = o,
                    u = i,
                    c = !1;
                3 === o.rank && (c = !0, s = X8(o, [1, o.shape[0], o.shape[1], o.shape[2]]), u = X8(i, [1, i.shape[0], i.shape[1], i.shape[2]])), F$(4 === u.rank, (function() {
                    return "Error in avgPoolGrad: dy must be rank 4 but got rank " + "".concat(u.rank, ".")
                })), F$(4 === s.rank, (function() {
                    return "Error in avgPoolGrad: input must be rank 4 but got rank " + "".concat(s.rank, ".")
                }));
                var l = {
                        dy: u,
                        input: s
                    },
                    h = {
                        filterSize: n,
                        strides: r,
                        pad: a
                    },
                    p = E5.runKernel(B0, l, h);
                return c ? X8(p, [p.shape[1], p.shape[2], p.shape[3]]) : p
            }
        }),
        Ioe = {
            kernelName: P0,
            inputsToSave: ["x"],
            gradFunc: function(e, t, n) {
                var r = S(t, 1)[0],
                    a = n.filterSize,
                    i = n.strides,
                    o = n.pad;
                return {
                    x: function() {
                        return woe(e, r, a, i, o)
                    }
                }
            }
        },
        Noe = {
            kernelName: V0,
            inputsToSave: ["a", "b"],
            gradFunc: function(e, t, n) {
                var r = S(t, 2),
                    a = r[0],
                    i = r[1],
                    o = n.transposeA,
                    s = n.transposeB;
                return o || s ? !o && s ? {
                    a: function() {
                        return Q8(e, i, !1, !1)
                    },
                    b: function() {
                        return Q8(e, a, !0, !1)
                    }
                } : o && !s ? {
                    a: function() {
                        return Q8(i, e, !1, !0)
                    },
                    b: function() {
                        return Q8(a, e, !1, !1)
                    }
                } : {
                    a: function() {
                        return Q8(i, e, !0, !0)
                    },
                    b: function() {
                        return Q8(e, a, !0, !0)
                    }
                } : {
                    a: function() {
                        return Q8(e, i, !1, !0)
                    },
                    b: function() {
                        return Q8(a, e, !0, !1)
                    }
                }
            }
        },
        Soe = {
            kernelName: G0,
            gradFunc: function(e, t, n) {
                var r = n.blockShape,
                    a = n.crops;
                return {
                    x: function() {
                        return gee(e, r, a)
                    }
                }
            }
        },
        Toe = {
            kernelName: q0,
            gradFunc: function(e, t, n) {
                for (var r = n, a = r.inputShape, i = r.shape, o = Array.from(i), s = a.length - 1; s >= 0; s--)
                    if (a[s] === i[s]) o[s] = 1;
                    else if (1 !== a[s]) throw new Error("broadcastTo(): [".concat(a, "] cannot be broadcast to [").concat(i, "]."));
                for (var u = [], c = 0; c < o.length; c++) o[c] > 1 && u.push(c);
                return {
                    x: function() {
                        return u9(e, u, !0)
                    }
                }
            }
        },
        Eoe = {
            kernelName: X0,
            gradFunc: function(e) {
                return {
                    x: function() {
                        return e.clone()
                    }
                }
            }
        },
        Coe = {
            kernelName: Y0,
            gradFunc: function(e) {
                return {
                    x: function() {
                        return U7(e)
                    }
                }
            }
        },
        Aoe = {
            kernelName: J0,
            inputsToSave: ["x"],
            gradFunc: function(e, t, n) {
                var r = S(t, 1)[0],
                    a = n.clipValueMin,
                    i = n.clipValueMax;
                return {
                    x: function() {
                        return W7(U9(x9(r, a), E9(r, i)), e, U7(e))
                    }
                }
            }
        },
        Roe = {
            kernelName: Q0,
            inputsToSave: ["x"],
            gradFunc: uoe.gradFunc
        },
        _oe = {
            kernelName: $0,
            saveAllInputs: !0,
            gradFunc: function(e, t, n) {
                var r = t.map((function(e) {
                        return e.shape
                    })),
                    a = j$(n.axis, t[0].shape)[0],
                    i = r.map((function(e) {
                        return e[a]
                    }));
                return Dte(e, i, a).map((function(e) {
                    return function() {
                        return e
                    }
                }))
            }
        },
        Ooe = {
            kernelName: e1,
            inputsToSave: ["x", "filter"],
            gradFunc: function(e, t, n) {
                var r = S(t, 2),
                    a = r[0],
                    i = r[1],
                    o = n.dilations,
                    s = n.strides,
                    u = n.pad,
                    c = n.dataFormat;
                return F$(G8(o), (function() {
                    return "Error in gradient of conv2D: dilation rates greater than 1 " + "are not yet supported in gradients. Got dilations '".concat(o, "'")
                })), {
                    x: function() {
                        return k7(a.shape, e, i, s, u, c)
                    },
                    filter: function() {
                        return wne(a, e, i.shape, s, u, c)
                    }
                }
            }
        },
        Foe = {
            kernelName: n1,
            inputsToSave: ["dy", "filter"],
            gradFunc: function(e, t, n) {
                var r = S(t, 2),
                    a = r[0],
                    i = r[1],
                    o = n.strides,
                    s = n.pad,
                    u = n.dataFormat,
                    c = n.dimRoundingMode;
                return {
                    dy: function() {
                        return b7(e, i, o, s, u, 1, c)
                    },
                    filter: function() {
                        return wne(e, a, i.shape, o, s, u, c)
                    }
                }
            }
        };
    var Doe = B5({
            conv3DBackpropFilter_: function(e, t, n, r, a) {
                var i = e;
                4 === e.rank && (i = X8(e, [1, e.shape[0], e.shape[1], e.shape[2], e.shape[3]]));
                var o = t;
                4 === o.rank && (o = X8(t, [1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]])), F$(5 === i.rank, (function() {
                    return "Error in conv3dDerFilter: input must be rank 5, but got shape " + "".concat(i.shape, ".")
                })), F$(5 === o.rank, (function() {
                    return "Error in conv3dDerFilter: dy must be rank 5, but got shape " + "".concat(o.shape, ".")
                })), F$(5 === n.length, (function() {
                    return "Error in conv3dDerFilter: filterShape must be length 5, but got " + "".concat(n, ".")
                })), F$(i.shape[4] === n[3], (function() {
                    return "Error in conv3dDerFilter: depth of input ".concat(i.shape[4], ") must ") + "match input depth in filter (".concat(n[3], ".")
                })), F$(o.shape[4] === n[4], (function() {
                    return "Error in conv3dDerFilter: depth of dy (".concat(o.shape[4], ") must ") + "match output depth for filter (".concat(n[4], ").")
                }));
                var s = {
                        x: i,
                        dy: o
                    },
                    u = {
                        strides: r,
                        pad: a,
                        filterShape: n
                    };
                return E5.runKernel(a1, s, u)
            }
        }),
        Moe = {
            kernelName: r1,
            inputsToSave: ["x", "filter"],
            gradFunc: function(e, t, n) {
                var r = n.dilations,
                    a = n.strides,
                    i = n.pad;
                F$(G8(r), (function() {
                    return "Error in gradient of conv3D: dilation rates greater than 1 are " + "not yet supported in gradients. Got dilations '".concat(r, "'")
                }));
                var o = S(t, 2),
                    s = o[0],
                    u = o[1];
                return {
                    x: function() {
                        return N7(s.shape, e, u, a, i)
                    },
                    filter: function() {
                        return Doe(s, e, u.shape, a, i)
                    }
                }
            }
        },
        Loe = {
            kernelName: o1,
            inputsToSave: ["x"],
            gradFunc: function(e, t) {
                var n = S(t, 1)[0];
                return {
                    x: function() {
                        return g8(M9(Nte(h8(n, "float32"))), e)
                    }
                }
            }
        },
        zoe = {
            kernelName: s1,
            inputsToSave: ["x"],
            gradFunc: function(e, t) {
                var n = S(t, 1)[0];
                return {
                    x: function() {
                        return g8(Ste(h8(n, "float32")), e)
                    }
                }
            }
        },
        Poe = {
            kernelName: c1,
            inputsToSave: ["x"],
            gradFunc: function(e, t, n) {
                var r = S(t, 1)[0],
                    a = n.axis,
                    i = n.exclusive,
                    o = n.reverse;
                return {
                    x: function() {
                        var t = $7([a], r.rank),
                            n = A7(e, a, i, !o);
                        return null != t && (n = hne(n, t)), n
                    }
                }
            }
        },
        Boe = {
            kernelName: f1,
            inputsToSave: ["x", "filter"],
            gradFunc: function(e, t, n) {
                var r = n.dilations,
                    a = n.strides,
                    i = n.pad,
                    o = n.dimRoundingMode,
                    s = null == r ? [1, 1] : r;
                F$(G8(s), (function() {
                    return "Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations " + "'".concat(s, "'")
                }));
                var u = S(t, 2),
                    c = u[0],
                    l = u[1];
                return F$(4 === c.rank, (function() {
                    return "Error in gradient of depthwiseConv2dNative: input must be " + "rank 4, but got rank ".concat(c.rank, ".")
                })), F$(4 === l.rank, (function() {
                    return "Error in gradient of depthwiseConv2dNative: filter must be " + "rank 4, but got rank ".concat(l.rank, ".")
                })), F$(c.shape[3] === l.shape[2], (function() {
                    return "Error in gradient of depthwiseConv2d: number of input " + "channels (".concat(c.shape[3], ") must match the inChannels dimension ") + "in filter ".concat(l.shape[2], ".")
                })), F$(j8(a, s), (function() {
                    return "Error in gradient of depthwiseConv2d: Either strides or " + "dilations must be  1. Got strides ".concat(a, " and dilations ") + "'".concat(s, "'.")
                })), K8("depthwiseConv2d", i, o), {
                    x: function() {
                        return Ane(c.shape, e, l, a, i, s, o)
                    },
                    filter: function() {
                        return Cne(c, e, l.shape, a, i, s, o)
                    }
                }
            }
        },
        Woe = {
            kernelName: g1,
            inputsToSave: ["x", "filter"],
            gradFunc: function(e, t, n) {
                var r = S(t, 2),
                    a = r[0],
                    i = r[1],
                    o = {
                        x: a,
                        filter: i,
                        dy: e
                    },
                    s = {
                        x: a,
                        filter: i,
                        dy: e
                    };
                return {
                    x: function() {
                        return E5.runKernel(y1, o, n)
                    },
                    filter: function() {
                        return E5.runKernel(b1, s, n)
                    }
                }
            }
        },
        Uoe = {
            kernelName: I1,
            outputsToSave: [!0],
            gradFunc: function(e, t) {
                var n = {
                    dy: e,
                    y: S(t, 1)[0]
                };
                return {
                    x: function() {
                        return E5.runKernel(N1, n)
                    }
                }
            }
        },
        Voe = {
            kernelName: S1,
            inputsToSave: ["x"],
            gradFunc: function(e, t) {
                var n = S(t, 1)[0],
                    r = g8(p9(M9(s9(n))), 2 / Math.sqrt(Math.PI));
                return {
                    x: function() {
                        return g8(e, r)
                    }
                }
            }
        },
        Goe = {
            kernelName: E1,
            outputsToSave: [!0],
            gradFunc: function(e, t) {
                var n = S(t, 1)[0];
                return {
                    x: function() {
                        return g8(e, n)
                    }
                }
            }
        },
        joe = {
            kernelName: C1,
            inputsToSave: ["input"],
            gradFunc: function(e, t) {
                var n = S(t, 1)[0];
                return {
                    input: function() {
                        return X8(e, n.shape)
                    }
                }
            }
        },
        Hoe = {
            kernelName: A1,
            inputsToSave: ["x"],
            gradFunc: function(e, t) {
                var n = S(t, 1)[0];
                return {
                    x: function() {
                        return g8(e, p9(n))
                    }
                }
            }
        },
        qoe = {
            kernelName: F1,
            gradFunc: function(e) {
                return {
                    x: function() {
                        return U7(e)
                    }
                }
            }
        },
        Koe = {
            kernelName: D1,
            inputsToSave: ["a", "b"],
            gradFunc: function(e, t) {
                var n = S(t, 2),
                    r = n[0],
                    a = n[1],
                    i = z7(r.shape, a.shape);
                return {
                    a: function() {
                        var t = m8(e, h8(a, "float32")),
                            n = L7(r.shape, i);
                        return n.length > 0 ? X8(u9(t, n), r.shape) : t
                    },
                    b: function() {
                        var t = g8(e, h8(r, "float32")),
                            n = L7(a.shape, i);
                        n.length > 0 && (t = X8(u9(t, n), a.shape));
                        var o = s9(a);
                        return M9(m8(t, h8(o, "float32")))
                    }
                }
            }
        },
        Xoe = {
            kernelName: M1,
            inputsToSave: ["x", "mean", "variance", "scale"],
            gradFunc: function(e, t, n) {
                var r = n.varianceEpsilon,
                    a = S(t, 4),
                    i = a[0],
                    o = a[1],
                    s = a[2],
                    u = a[3],
                    c = null == u ? i9(1) : u,
                    l = L7(o.shape, i.shape),
                    h = [];
                if (1 === o.rank) {
                    for (var p = 0; p < i.shape.length - 1; ++p) h.push(i.shape[p]);
                    h.push(1)
                }
                var f = P9(i, o),
                    d = g8(e, c),
                    v = yte(d8(s, i9(r))),
                    m = g8(g8(g8(v, v), v), i9(-.5));
                return {
                    x: function() {
                        return 1 === o.rank ? X8(g8(g8(e, v9(X8(v, [1, 1, 1, o.shape[0]]), h)), c), i.shape) : X8(g8(g8(e, v), c), i.shape)
                    },
                    mean: function() {
                        var e = g8(g8(v, i9(-1)), d);
                        return 1 === o.rank && (e = u9(e, l)), X8(e, o.shape)
                    },
                    variance: function() {
                        var e = g8(g8(m, f), d);
                        return 1 === o.rank && (e = u9(e, l)), X8(e, o.shape)
                    },
                    scale: function() {
                        var t = g8(f, v),
                            n = g8(e, t);
                        return 1 === o.rank && (n = u9(n, l)), X8(n, o.shape)
                    },
                    offset: function() {
                        var t = e;
                        return 1 === o.rank && (t = u9(t, l)), X8(t, o.shape)
                    }
                }
            }
        },
        Yoe = {
            kernelName: L1,
            inputsToSave: ["x", "indices"],
            gradFunc: function(e, t, n) {
                var r = S(t, 2),
                    a = r[0],
                    i = r[1],
                    o = n.axis,
                    s = n.batchDims,
                    u = j$(o, a.shape)[0],
                    c = function(e, t, n) {
                        return function() {
                            var r = e.shape,
                                a = t.size,
                                i = r.slice(0, u),
                                s = i.length,
                                c = r.slice(o, r.length).slice(1),
                                l = c.length,
                                h = Joe(0, s),
                                p = Joe(s + 1, s + 1 + l),
                                f = Zoe([i, [a], c]),
                                d = X8(n, f),
                                v = X8(t, [a]),
                                m = Zoe([
                                    [s], h, p
                                ]),
                                g = hne(d, m),
                                y = nne(g, v, e.shape[u]),
                                b = e9(m);
                            return y = hne(y, b)
                        }
                    };
                if (1 === s) {
                    var l = a.shape[0],
                        h = a.split(l, 0);
                    return {
                        x: function() {
                            var t = Pte(h.map((function(t, n) {
                                return c(t, i.slice(n, 1), e.slice(n, 1))()
                            })));
                            return t.reshape(a.shape)
                        },
                        indices: function() {
                            return i
                        }
                    }
                }
                return {
                    x: c(a, i, e),
                    indices: function() {
                        return i
                    }
                }
            }
        };

    function Joe(e, t) {
        for (var n = [], r = e; r < t; ++r) n.push(r);
        return n
    }

    function Zoe(e) {
        for (var t = [], n = 0; n < e.length; ++n)
            for (var r = 0; r < e[n].length; ++r) t.push(e[n][r]);
        return t
    }
    var Qoe = {
            kernelName: B1,
            inputsToSave: ["a", "b"],
            gradFunc: function(e, t) {
                var n = S(t, 2),
                    r = n[0],
                    a = n[1];
                return {
                    a: function() {
                        return U7(r)
                    },
                    b: function() {
                        return U7(a)
                    }
                }
            }
        },
        $oe = {
            kernelName: W1,
            gradFunc: function(e) {
                return {
                    x: function() {
                        return h8(e, "float32")
                    }
                }
            }
        },
        ese = {
            kernelName: G1,
            gradFunc: function(e) {
                return {
                    x: function() {
                        return U7(e)
                    }
                }
            }
        },
        tse = {
            kernelName: j1,
            gradFunc: function(e) {
                return {
                    x: function() {
                        return U7(e)
                    }
                }
            }
        },
        nse = {
            kernelName: H1,
            gradFunc: function(e) {
                return {
                    x: function() {
                        return U7(e)
                    }
                }
            }
        },
        rse = {
            kernelName: q1,
            inputsToSave: ["x"],
            gradFunc: function(e, t, n) {
                var r = S(t, 1)[0],
                    a = n.alpha,
                    i = b9(r, 0);
                return {
                    x: function() {
                        return W7(i, e, g8(e, a))
                    }
                }
            }
        },
        ase = {
            kernelName: Z1,
            inputsToSave: ["x"],
            gradFunc: function(e, t) {
                var n = S(t, 1)[0];
                return {
                    x: function() {
                        return m8(e, d8(n, 1))
                    }
                }
            }
        },
        ise = {
            kernelName: J1,
            inputsToSave: ["x"],
            gradFunc: function(e, t) {
                var n = S(t, 1)[0];
                return {
                    x: function() {
                        return m8(e, h8(n, "float32"))
                    }
                }
            }
        },
        ose = {
            kernelName: t2,
            inputsToSave: [],
            outputsToSave: [!0],
            gradFunc: function(e, t, n) {
                var r = S(t, 1)[0],
                    a = n.axis;
                return {
                    logits: function() {
                        var t = p9(r);
                        return P9(e, g8(u9(e, a, !0), t))
                    }
                }
            }
        };
    var sse = B5({
            localResponseNormalizationBackprop_: function(e, t, n) {
                var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 5,
                    a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1,
                    i = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1,
                    o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : .5,
                    s = {
                        x: e,
                        y: t,
                        dy: n
                    },
                    u = {
                        depthRadius: r,
                        bias: a,
                        alpha: i,
                        beta: o
                    };
                return E5.runKernel(r2, s, u)
            }
        }),
        use = {
            kernelName: n2,
            inputsToSave: ["x"],
            outputsToSave: [!0],
            gradFunc: function(e, t, n) {
                var r = S(t, 2),
                    a = r[0],
                    i = r[1],
                    o = n.depthRadius,
                    s = n.bias,
                    u = n.alpha,
                    c = n.beta;
                return {
                    x: function() {
                        return sse(a, i, e, o, s, u, c)
                    }
                }
            }
        };

    function cse(e, t, n, r) {
        return t.rank < n.rank && (t = X8(t, Z7(t.shape, r))), e.rank < n.rank && (e = X8(e, Z7(e.shape, r))), {
            x: function() {
                return g8(e, h8(B7(n, t), e.dtype))
            }
        }
    }
    var lse = {
            kernelName: a2,
            inputsToSave: ["x"],
            outputsToSave: [!0],
            gradFunc: function(e, t, n) {
                var r = n.reductionIndices,
                    a = t[0],
                    i = cse(e, t[1], a, j$(r, a.shape));
                return {
                    x: function() {
                        return i.x()
                    }
                }
            }
        },
        hse = {
            kernelName: i2,
            inputsToSave: ["a", "b"],
            gradFunc: function(e, t) {
                var n = S(t, 2),
                    r = n[0],
                    a = n[1];
                return {
                    a: function() {
                        return g8(e, h8(x9(r, a), "float32"))
                    },
                    b: function() {
                        return g8(e, h8(T9(r, a), "float32"))
                    }
                }
            }
        };
    var pse = B5({
            maxPool3dGrad_: function(e, t, n, r, a, i, o) {
                var s = L5(e, "dy", "maxPool3dGrad"),
                    u = L5(t, "input", "maxPool3dGrad"),
                    c = L5(n, "output", "maxPool3dGrad"),
                    l = s,
                    h = u,
                    p = c,
                    f = !1;
                4 === u.rank && (f = !0, l = X8(s, [1, s.shape[0], s.shape[1], s.shape[2], s.shape[3]]), h = X8(u, [1, u.shape[0], u.shape[1], u.shape[2], u.shape[3]]), p = X8(c, [1, c.shape[0], c.shape[1], c.shape[2], c.shape[3]])), F$(5 === l.rank, (function() {
                    return "Error in maxPool3dGrad: dy must be rank 5 but got rank " + "".concat(l.rank, ".")
                })), F$(5 === h.rank, (function() {
                    return "Error in maxPool3dGrad: input must be rank 5 but got rank " + "".concat(h.rank, ".")
                })), F$(5 === p.rank, (function() {
                    return "Error in maxPool3dGrad: output must be rank 5 but got rank " + "".concat(p.rank, ".")
                })), K8("maxPool3dGrad", i, o);
                var d = {
                        dy: l,
                        input: h,
                        output: p
                    },
                    v = {
                        filterSize: r,
                        strides: a,
                        pad: i,
                        dimRoundingMode: o
                    },
                    m = E5.runKernel(c2, d, v);
                return f ? X8(m, [m.shape[1], m.shape[2], m.shape[3], m.shape[4]]) : m
            }
        }),
        fse = {
            kernelName: u2,
            inputsToSave: ["x"],
            outputsToSave: [!0],
            gradFunc: function(e, t, n) {
                var r = S(t, 2),
                    a = r[0],
                    i = r[1],
                    o = n.filterSize,
                    s = n.strides,
                    u = n.pad,
                    c = n.dimRoundingMode;
                return {
                    x: function() {
                        return pse(e, a, i, o, s, u, c)
                    }
                }
            }
        };
    var dse = B5({
            maxPoolGrad_: function(e, t, n, r, a, i, o) {
                var s = L5(e, "dy", "maxPoolGrad"),
                    u = L5(t, "input", "maxPoolGrad"),
                    c = L5(n, "output", "maxPoolGrad");
                F$(u.rank === s.rank, (function() {
                    return "Rank of input (".concat(u.rank, ") does not match rank of dy ") + "(".concat(s.rank, ")")
                })), F$(4 === s.rank, (function() {
                    return "Error in maxPoolGrad: dy must be rank 4 but got rank " + "".concat(s.rank, ".")
                })), F$(4 === u.rank, (function() {
                    return "Error in maxPoolGrad: input must be rank 4 but got rank " + "".concat(u.rank, ".")
                })), K8("maxPoolGrad", i, o);
                var l = {
                        dy: s,
                        input: u,
                        output: c
                    },
                    h = {
                        filterSize: r,
                        strides: a,
                        pad: i,
                        dimRoundingMode: o
                    };
                return E5.runKernel(s2, l, h)
            }
        }),
        vse = {
            kernelName: o2,
            inputsToSave: ["x"],
            outputsToSave: [!0],
            gradFunc: function(e, t, n) {
                var r = S(t, 2),
                    a = r[0],
                    i = r[1],
                    o = n.filterSize,
                    s = n.strides,
                    u = n.pad;
                return {
                    x: function() {
                        return dse(e, a, i, o, s, u)
                    }
                }
            }
        },
        mse = {
            kernelName: d2,
            inputsToSave: ["x"],
            gradFunc: function(e, t, n) {
                var r = t[0],
                    a = n.paddings.map((function(e) {
                        return e[0]
                    }));
                return {
                    x: function() {
                        return e7(e, a, r.shape)
                    }
                }
            }
        },
        gse = {
            kernelName: T2,
            inputsToSave: ["x"],
            gradFunc: function(e, t, n) {
                var r = t[0],
                    a = n.paddings.map((function(e) {
                        return e[0]
                    }));
                return {
                    x: function() {
                        return e7(e, a, r.shape)
                    }
                }
            }
        },
        yse = {
            kernelName: E2,
            inputsToSave: ["a", "b"],
            outputsToSave: [!0],
            gradFunc: function(e, t) {
                var n = S(t, 3),
                    r = n[0],
                    a = n[1],
                    i = n[2],
                    o = r,
                    s = a,
                    u = z7(o.shape, s.shape);
                return {
                    a: function() {
                        var t = h8(s, "float32"),
                            n = g8(e, g8(t, a9(o, P9(t, i9(1))))),
                            r = L7(o.shape, u);
                        return r.length > 0 && (n = u9(n, r)), X8(n, o.shape)
                    },
                    b: function() {
                        var t = b9(o, 0),
                            n = W7(t, R9(o), U7(o)),
                            r = g8(e, g8(i, n)),
                            a = L7(s.shape, u);
                        return a.length > 0 && (r = u9(r, a)), X8(r, s.shape)
                    }
                }
            }
        };

    function bse(e, t, n) {
        var r = e.shape.length,
            a = r - n.length,
            i = $7(n, r),
            o = e;
        null != i && (o = hne(e, i));
        var s = o.shape.slice(),
            u = s.splice(r - n.length, n.length).reduce((function(e, t) {
                return e * t
            }), 1);
        s.push(u);
        var c = function(e, t, n) {
            var r = e.shape.slice();
            r[n] = 1;
            var a = X8(t, r),
                i = C7(e, n, !0, !1),
                o = C7(e, n, !0, !0),
                s = g8(i, o);
            return g8(a, s)
        }(o.reshape(s), t, a);
        if (c = c.reshape(o.shape), null != i) {
            var l = e9(i);
            c = hne(c, l)
        }
        return c
    }
    var xse = {
            kernelName: J2,
            inputsToSave: ["x"],
            gradFunc: function(e, t) {
                var n = S(t, 1)[0];
                return {
                    x: function() {
                        var t = b9(n, i9(0)),
                            r = i9(yie),
                            a = i9(bie),
                            i = g8(e, a),
                            o = g8(g8(e, r), p9(h8(n, "float32")));
                        return W7(t, i, o)
                    }
                }
            }
        },
        kse = {
            kernelName: i3,
            gradFunc: function(e, t, n) {
                var r = n.blockShape,
                    a = n.paddings;
                return {
                    x: function() {
                        return r7(e, r, a)
                    }
                }
            }
        },
        wse = {
            kernelName: o3,
            gradFunc: function(e, t, n) {
                var r = n.axis;
                return {
                    x: function() {
                        return Z8(e, r)
                    }
                }
            }
        },
        Ise = {
            kernelName: I3,
            inputsToSave: ["x"],
            gradFunc: function(e, t, n) {
                var r = S(t, 1)[0],
                    a = n.reps;
                return {
                    x: function() {
                        var t = U7(r);
                        if (1 === r.rank)
                            for (var n = 0; n < a[0]; ++n) t = d8(t, e7(e, [n * r.shape[0]], [r.shape[0]]));
                        else if (2 === r.rank)
                            for (var i = 0; i < a[0]; ++i)
                                for (var o = 0; o < a[1]; ++o) t = d8(t, e7(e, [i * r.shape[0], o * r.shape[1]], [r.shape[0], r.shape[1]]));
                        else if (3 === r.rank)
                            for (var s = 0; s < a[0]; ++s)
                                for (var u = 0; u < a[1]; ++u)
                                    for (var c = 0; c < a[2]; ++c) t = d8(t, e7(e, [s * r.shape[0], u * r.shape[1], c * r.shape[2]], [r.shape[0], r.shape[1], r.shape[2]]));
                        else {
                            if (4 !== r.rank) throw new Error("Gradient for tile operation is not implemented for rank-" + "".concat(r.rank, " tensors yet."));
                            for (var l = 0; l < a[0]; ++l)
                                for (var h = 0; h < a[1]; ++h)
                                    for (var p = 0; p < a[2]; ++p)
                                        for (var f = 0; f < a[3]; ++f) t = d8(t, e7(e, [l * r.shape[0], h * r.shape[1], p * r.shape[2], f * r.shape[3]], [r.shape[0], r.shape[1], r.shape[2], r.shape[3]]))
                        }
                        return t
                    }
                }
            }
        };
    for (var Nse = 0, Sse = [uoe, coe, loe, hoe, poe, foe, doe, voe, moe, goe, yoe, boe, koe, Ioe, Noe, Soe, Toe, Eoe, Coe, Aoe, Roe, _oe, Foe, Ooe, Moe, Loe, zoe, Poe, Boe, Woe, {
            kernelName: k1,
            inputsToSave: ["a", "b"],
            gradFunc: function(e, t) {
                var n = S(t, 2),
                    r = n[0],
                    a = n[1],
                    i = z7(r.shape, a.shape);
                return {
                    a: function() {
                        var t = m8(e, h8(a, "float32")),
                            n = L7(r.shape, i);
                        return n.length > 0 ? X8(u9(t, n), r.shape) : t
                    },
                    b: function() {
                        var t = g8(e, h8(r, "float32")),
                            n = L7(a.shape, i);
                        n.length > 0 && (t = X8(u9(t, n), a.shape));
                        var o = s9(a);
                        return M9(m8(t, h8(o, "float32")))
                    }
                }
            }
        }, Uoe, Voe, Goe, joe, Hoe, Koe, qoe, Xoe, Yoe, Qoe, $oe, ese, tse, nse, rse, ase, ise, ose, use, lse, lse, hse, fse, vse, {
            kernelName: h2,
            inputsToSave: ["x"],
            gradFunc: function(e, t, n) {
                var r = S(t, 1)[0],
                    a = j$(n.axis, r.shape),
                    i = L$(J7(r.shape, a)[1]);
                return {
                    x: function() {
                        var t = r.shape.slice();
                        a.forEach((function(e) {
                            t[e] = 1
                        }));
                        var n = X8(e, t);
                        return m8(g8(n, eee(r.shape, "float32")), i)
                    }
                }
            }
        }, {
            kernelName: p2,
            inputsToSave: ["x"],
            outputsToSave: [!0],
            gradFunc: function(e, t, n) {
                var r = n.axis,
                    a = S(t, 2),
                    i = a[0],
                    o = cse(e, a[1], i, j$(r, i.shape));
                return {
                    x: function() {
                        return o.x()
                    }
                }
            }
        }, {
            kernelName: f2,
            inputsToSave: ["a", "b"],
            gradFunc: function(e, t) {
                var n = S(t, 2),
                    r = n[0],
                    a = n[1];
                return {
                    a: function() {
                        return g8(e, h8(E9(r, a), "float32"))
                    },
                    b: function() {
                        return g8(e, h8(b9(r, a), "float32"))
                    }
                }
            }
        }, mse, {
            kernelName: v2,
            inputsToSave: ["a", "b"],
            gradFunc: function(e, t) {
                var n = S(t, 2),
                    r = n[0],
                    a = n[1],
                    i = z7(r.shape, a.shape);
                return {
                    a: function() {
                        var t = L7(r.shape, i);
                        return t.length > 0 ? X8(u9(e, t), r.shape) : e
                    },
                    b: function() {
                        var t = g8(e, M9(g9(m8(r, a)))),
                            n = L7(a.shape, i);
                        return n.length > 0 ? X8(u9(t, n), a.shape) : t
                    }
                }
            }
        }, {
            kernelName: g2,
            inputsToSave: ["a", "b"],
            gradFunc: function(e, t) {
                var n = S(t, 2),
                    r = n[0],
                    a = n[1],
                    i = z7(r.shape, a.shape);
                return {
                    a: function() {
                        var t = g8(e, h8(a, "float32")),
                            n = L7(r.shape, i);
                        return n.length > 0 ? X8(u9(t, n), r.shape) : t
                    },
                    b: function() {
                        var t = g8(e, h8(r, "float32")),
                            n = L7(a.shape, i);
                        return n.length > 0 ? X8(u9(t, n), a.shape) : t
                    }
                }
            }
        }, {
            kernelName: y2,
            gradFunc: function(e) {
                return {
                    x: function() {
                        return M9(e)
                    }
                }
            }
        }, {
            kernelName: N2,
            inputsToSave: ["indices"],
            gradFunc: function(e, t) {
                var n = t[0];
                return {
                    indices: function() {
                        return $9(n.shape, "float32")
                    }
                }
            }
        }, {
            kernelName: I2,
            gradFunc: function(e) {
                return {
                    x: function() {
                        return U7(e)
                    }
                }
            }
        }, {
            kernelName: S2,
            saveAllInputs: !0,
            gradFunc: function(e, t, n) {
                var r = n.axis;
                return rne(e, r).map((function(e) {
                    return function() {
                        return e
                    }
                }))
            }
        }, gse, gse, yse, {
            kernelName: C2,
            inputsToSave: ["x", "alpha"],
            gradFunc: function(e, t) {
                var n = S(t, 2),
                    r = n[0],
                    a = n[1],
                    i = b9(r, 0);
                return {
                    x: function() {
                        return W7(i, e, g8(e, a))
                    },
                    alpha: function() {
                        var t = W7(i, U7(e), g8(e, r)),
                            n = L7(a.shape, e.shape);
                        return n.length > 0 && (t = u9(t, n)), X8(t, a.shape)
                    }
                }
            }
        }, {
            kernelName: A2,
            inputsToSave: ["x"],
            gradFunc: function(e, t, n) {
                var r = S(t, 1)[0],
                    a = n.axis,
                    i = [];
                return i = null == a ? r.shape.map((function(e, t) {
                    return t
                })) : "number" == typeof a ? [a] : a, {
                    x: function() {
                        return bse(r, e, i)
                    }
                }
            }
        }, {
            kernelName: M2,
            inputsToSave: ["x"],
            gradFunc: function(e, t) {
                var n = S(t, 1)[0];
                return {
                    x: function() {
                        return m8(e, M9(s9(n)))
                    }
                }
            }
        }, {
            kernelName: V2,
            inputsToSave: ["x"],
            gradFunc: function(e, t) {
                var n = S(t, 1)[0],
                    r = g8(E9(n, 6), Bte(n));
                return {
                    x: function() {
                        return g8(e, h8(r, "float32"))
                    }
                }
            }
        }, {
            kernelName: L2,
            inputsToSave: ["x"],
            gradFunc: function(e, t) {
                var n = S(t, 1)[0];
                return {
                    x: function() {
                        return g8(e, h8(Bte(n), "float32"))
                    }
                }
            }
        }, {
            kernelName: z2,
            inputsToSave: ["x"],
            gradFunc: function(e, t) {
                var n = S(t, 1)[0];
                return {
                    x: function() {
                        return X8(e, n.shape)
                    }
                }
            }
        }, {
            kernelName: W2,
            inputsToSave: ["images"],
            gradFunc: function(e, t, n) {
                var r = {
                    dy: e,
                    images: S(t, 1)[0]
                };
                return {
                    images: function() {
                        return E5.runKernel(U2, r, n)
                    }
                }
            }
        }, {
            kernelName: P2,
            inputsToSave: ["images"],
            gradFunc: function(e, t, n) {
                var r = {
                    dy: e,
                    images: S(t, 1)[0]
                };
                return {
                    images: function() {
                        return E5.runKernel(B2, r, n)
                    }
                }
            }
        }, {
            kernelName: G2,
            gradFunc: function(e, t, n) {
                var r = j$(n.dims, e.shape);
                return {
                    x: function() {
                        return pte(e, r)
                    }
                }
            }
        }, {
            kernelName: j2,
            gradFunc: function(e) {
                return {
                    x: function() {
                        return U7(e)
                    }
                }
            }
        }, {
            kernelName: H2,
            inputsToSave: ["x"],
            gradFunc: function(e, t) {
                var n = S(t, 1)[0];
                return {
                    x: function() {
                        return M9(m8(e, g8(a9(n, 1.5), 2)))
                    }
                }
            }
        }, {
            kernelName: Y2,
            inputsToSave: ["condition"],
            gradFunc: function(e, t) {
                var n = S(t, 1)[0];
                return {
                    condition: function() {
                        return h8(U7(n), "float32")
                    },
                    t: function() {
                        return g8(e, h8(n, e.dtype))
                    },
                    e: function() {
                        return g8(e, h8(V9(n), e.dtype))
                    }
                }
            }
        }, xse, {
            kernelName: t3,
            outputsToSave: [!0],
            gradFunc: function(e, t) {
                var n = S(t, 1)[0];
                return {
                    x: function() {
                        return g8(e, g8(n, P9(i9(1), n)))
                    }
                }
            }
        }, {
            kernelName: e3,
            gradFunc: function(e) {
                return {
                    x: function() {
                        return U7(e)
                    }
                }
            }
        }, {
            kernelName: Q2,
            inputsToSave: ["x"],
            gradFunc: function(e, t) {
                var n = S(t, 1)[0];
                return {
                    x: function() {
                        return g8(T7(h8(n, "float32")), e)
                    }
                }
            }
        }, {
            kernelName: $2,
            inputsToSave: ["x"],
            gradFunc: function(e, t) {
                var n = S(t, 1)[0];
                return {
                    x: function() {
                        return g8(E7(h8(n, "float32")), e)
                    }
                }
            }
        }, {
            kernelName: Z2,
            inputsToSave: ["x"],
            gradFunc: function(e, t, n) {
                for (var r = S(t, 1)[0], a = n.begin, i = n.size, o = r.shape, s = S(Yae(r, a, i), 2), u = s[0], c = s[1], l = [], h = 0; h < e.rank; h++) l.push([u[h], o[h] - u[h] - c[h]]);
                return {
                    x: function() {
                        return pee(e, l)
                    }
                }
            }
        }, {
            kernelName: s3,
            outputsToSave: [!0],
            gradFunc: function(e, t, n) {
                var r = S(t, 1)[0],
                    a = n.dim,
                    i = g8(e, r);
                return {
                    logits: function() {
                        return P9(i, g8(u9(i, [a], true), r))
                    }
                }
            }
        }, {
            kernelName: n3,
            inputsToSave: ["x"],
            gradFunc: function(e, t) {
                var n = S(t, 1)[0];
                return {
                    x: function() {
                        return g8(e, $8(n))
                    }
                }
            }
        }, kse, kse, wse, wse, {
            kernelName: r3,
            inputsToSave: ["x"],
            gradFunc: function(e, t) {
                var n = S(t, 1)[0];
                return {
                    x: function() {
                        return m8(e, g8(o9(h8(n, "float32")), 2))
                    }
                }
            }
        }, {
            kernelName: f3,
            inputsToSave: ["a", "b"],
            gradFunc: function(e, t) {
                var n = S(t, 2),
                    r = n[0],
                    a = n[1],
                    i = i9(2);
                return {
                    a: function() {
                        return g8(e, g8(i, P9(r, a)))
                    },
                    b: function() {
                        return g8(e, g8(i, P9(a, r)))
                    }
                }
            }
        }, {
            kernelName: d3,
            inputsToSave: ["x"],
            gradFunc: function(e, t) {
                var n = S(t, 1)[0];
                return {
                    x: function() {
                        return g8(e, g8(h8(n, "float32"), 2))
                    }
                }
            }
        }, {
            kernelName: _3,
            gradFunc: function(e) {
                return {
                    x: function() {
                        return U7(e)
                    }
                }
            }
        }, {
            kernelName: x3,
            inputsToSave: ["a", "b"],
            gradFunc: function(e, t) {
                var n = S(t, 2),
                    r = n[0],
                    a = n[1],
                    i = z7(r.shape, a.shape);
                return {
                    a: function() {
                        var t = e,
                            n = L7(r.shape, i);
                        return n.length > 0 && (t = u9(t, n)), X8(t, r.shape)
                    },
                    b: function() {
                        var t = e,
                            n = L7(a.shape, i);
                        return n.length > 0 && (t = u9(t, n)), X8(M9(t), a.shape)
                    }
                }
            }
        }, {
            kernelName: a3,
            inputsToSave: ["x"],
            gradFunc: function(e, t, n) {
                var r = S(t, 1)[0],
                    a = r.shape.slice();
                j$(n.axis, r.shape).forEach((function(e) {
                    a[e] = 1
                }));
                var i = X8(e, a),
                    o = g8(i, eee(r.shape, "float32"));
                return {
                    x: function() {
                        return o
                    }
                }
            }
        }, {
            kernelName: k3,
            inputsToSave: ["x"],
            gradFunc: function(e, t) {
                var n = S(t, 1)[0];
                return {
                    x: function() {
                        return m8(e, s9(T7(n)))
                    }
                }
            }
        }, {
            kernelName: w3,
            outputsToSave: [!0],
            gradFunc: function(e, t) {
                var n = S(t, 1)[0];
                return {
                    x: function() {
                        return g8(P9(i9(1), s9(n)), e)
                    }
                }
            }
        }, Ise, {
            kernelName: T3,
            gradFunc: function(e, t, n) {
                var r = e9(n.perm);
                return {
                    x: function() {
                        return hne(e, r)
                    }
                }
            }
        }, {
            kernelName: C3,
            gradFunc: function(e, t, n) {
                var r = n.axis;
                return {
                    value: function() {
                        return Pte(e, r)
                    }
                }
            }
        }, {
            kernelName: A3,
            inputsToSave: ["segmentIds"],
            gradFunc: function(e, t) {
                var n = S(t, 1)[0];
                return {
                    x: function() {
                        return function(e, t) {
                            for (var n = Z9(t, U7(t)), r = y9(e, n), a = x9(t, i9(0, "int32")), i = r.rank - a.rank, o = 0; o < i; ++o) a = f9(a, o + 1);
                            a = U9(a, eee(r.shape, "bool"));
                            var s = U7(r);
                            return W7(a, r, s)
                        }(e, n)
                    }
                }
            }
        }, {
            kernelName: R3,
            gradFunc: function(e) {
                return {
                    x: function() {
                        return U7(e)
                    }
                }
            }
        }]; Nse < Sse.length; Nse++) {
        j3(Sse[Nse])
    }
    r5().prototype.abs = function() {
        return this.throwIfDisposed(), y8(this)
    }, r5().prototype.acos = function() {
        return this.throwIfDisposed(), b8(this)
    }, r5().prototype.acosh = function() {
        return this.throwIfDisposed(), x8(this)
    }, r5().prototype.add = function(e) {
        return this.throwIfDisposed(), d8(this, e)
    }, r5().prototype.all = function(e, t) {
        return this.throwIfDisposed(), w8(this, e, t)
    }, r5().prototype.any = function(e, t) {
        return this.throwIfDisposed(), I8(this, e, t)
    }, r5().prototype.argMax = function(e) {
        return this.throwIfDisposed(), N8(this, e)
    }, r5().prototype.argMin = function(e) {
        return this.throwIfDisposed(), S8(this, e)
    }, r5().prototype.asScalar = function() {
        return this.throwIfDisposed(), F$(1 === this.size, (function() {
            return "The array must have only 1 element."
        })), X8(this, [])
    }, r5().prototype.asType = function(e) {
        return this.throwIfDisposed(), h8(this, e)
    }, r5().prototype.as1D = function() {
        return this.throwIfDisposed(), X8(this, [this.size])
    }, r5().prototype.as2D = function(e, t) {
        return this.throwIfDisposed(), X8(this, [e, t])
    }, r5().prototype.as3D = function(e, t, n) {
        return this.throwIfDisposed(), X8(this, [e, t, n])
    }, r5().prototype.as4D = function(e, t, n, r) {
        return this.throwIfDisposed(), X8(this, [e, t, n, r])
    }, r5().prototype.as5D = function(e, t, n, r, a) {
        return this.throwIfDisposed(), X8(this, [e, t, n, r, a])
    }, r5().prototype.asin = function() {
        return this.throwIfDisposed(), T8(this)
    }, r5().prototype.asinh = function() {
        return this.throwIfDisposed(), E8(this)
    }, r5().prototype.atan = function() {
        return this.throwIfDisposed(), C8(this)
    }, r5().prototype.atan2 = function(e) {
        return this.throwIfDisposed(), A8(this, e)
    }, r5().prototype.atanh = function() {
        return this.throwIfDisposed(), R8(this)
    }, r5().prototype.avgPool = function(e, t, n, r) {
        return this.throwIfDisposed(), Y8(this, e, t, n, r)
    }, r5().prototype.batchToSpaceND = function(e, t) {
        return this.throwIfDisposed(), r7(this, e, t)
    }, r5().prototype.batchNorm = function(e, t, n, r, a) {
        return this.throwIfDisposed(), a7(this, e, t, n, r, a)
    }, r5().prototype.broadcastTo = function(e) {
        return this.throwIfDisposed(), h7(this, e)
    }, r5().prototype.cast = function(e) {
        return this.throwIfDisposed(), h8(this, e)
    }, r5().prototype.ceil = function() {
        return this.throwIfDisposed(), p7(this)
    }, r5().prototype.clipByValue = function(e, t) {
        return this.throwIfDisposed(), d7(this, e, t)
    }, r5().prototype.concat = function(e, t) {
        return this.throwIfDisposed(), e instanceof n5 && (e = [e]), Z8([this].concat(T(e)), t)
    }, r5().prototype.conv1d = function(e, t, n, r, a, i) {
        return this.throwIfDisposed(), x7(this, e, t, n, r, a, i)
    }, r5().prototype.conv2dTranspose = function(e, t, n, r, a) {
        return this.throwIfDisposed(), w7(this, e, t, n, r, a)
    }, r5().prototype.conv2d = function(e, t, n, r, a, i) {
        return this.throwIfDisposed(), b7(this, e, t, n, r, a, i)
    }, r5().prototype.cos = function() {
        return this.throwIfDisposed(), T7(this)
    }, r5().prototype.cosh = function() {
        return this.throwIfDisposed(), E7(this)
    }, r5().prototype.cumprod = function(e, t, n) {
        return this.throwIfDisposed(), C7(this, e, t, n)
    }, r5().prototype.cumsum = function(e, t, n) {
        return this.throwIfDisposed(), A7(this, e, t, n)
    }, r5().prototype.depthToSpace = function(e, t) {
        return this.throwIfDisposed(), _7(this, e, t)
    }, r5().prototype.depthwiseConv2d = function(e, t, n, r, a, i) {
        return this.throwIfDisposed(), O7(this, e, t, n, r, a, i)
    }, r5().prototype.dilation2d = function(e, t, n, r, a) {
        return this.throwIfDisposed(), D7(this, e, t, n, r, a)
    }, r5().prototype.divNoNan = function(e) {
        return this.throwIfDisposed(), V7(this, e)
    }, r5().prototype.div = function(e) {
        return this.throwIfDisposed(), m8(this, e)
    }, r5().prototype.dot = function(e) {
        return this.throwIfDisposed(), G7(this, e)
    }, r5().prototype.elu = function() {
        return this.throwIfDisposed(), H7(this)
    }, r5().prototype.equal = function(e) {
        return this.throwIfDisposed(), B7(this, e)
    }, r5().prototype.erf = function() {
        return this.throwIfDisposed(), K7(this)
    }, r5().prototype.euclideanNorm = function(e, t) {
        return this.throwIfDisposed(), h9(this, e, t)
    }, r5().prototype.exp = function() {
        return this.throwIfDisposed(), p9(this)
    }, r5().prototype.expandDims = function(e) {
        return this.throwIfDisposed(), f9(this, e)
    }, r5().prototype.expm1 = function() {
        return this.throwIfDisposed(), d9(this)
    }, r5().prototype.fft = function() {
        return this.throwIfDisposed(), _te(this)
    }, r5().prototype.flatten = function() {
        return this.throwIfDisposed(), X8(this, [this.size])
    }, r5().prototype.floor = function() {
        return this.throwIfDisposed(), g9(this)
    }, r5().prototype.floorDiv = function(e) {
        return this.throwIfDisposed(), v8(this, e)
    }, r5().prototype.gather = function(e, t, n) {
        return this.throwIfDisposed(), y9(this, e, t, n)
    }, r5().prototype.greaterEqual = function(e) {
        return this.throwIfDisposed(), x9(this, e)
    }, r5().prototype.greater = function(e) {
        return this.throwIfDisposed(), b9(this, e)
    }, r5().prototype.ifft = function() {
        return this.throwIfDisposed(), Ote(this)
    }, r5().prototype.irfft = function() {
        return this.throwIfDisposed(), Fte(this)
    }, r5().prototype.isFinite = function() {
        return this.throwIfDisposed(), w9(this)
    }, r5().prototype.isInf = function() {
        return this.throwIfDisposed(), I9(this)
    }, r5().prototype.isNaN = function() {
        return this.throwIfDisposed(), N9(this)
    }, r5().prototype.leakyRelu = function(e) {
        return this.throwIfDisposed(), S9(this, e)
    }, r5().prototype.lessEqual = function(e) {
        return this.throwIfDisposed(), E9(this, e)
    }, r5().prototype.less = function(e) {
        return this.throwIfDisposed(), T9(this, e)
    }, r5().prototype.localResponseNormalization = function(e, t, n, r) {
        return this.throwIfDisposed(), A9(this, e, t, n, r)
    }, r5().prototype.logSigmoid = function() {
        return this.throwIfDisposed(), z9(this)
    }, r5().prototype.logSoftmax = function(e) {
        return this.throwIfDisposed(), B9(this, e)
    }, r5().prototype.logSumExp = function(e, t) {
        return this.throwIfDisposed(), W9(this, e, t)
    }, r5().prototype.log = function() {
        return this.throwIfDisposed(), R9(this)
    }, r5().prototype.log1p = function() {
        return this.throwIfDisposed(), _9(this)
    }, r5().prototype.logicalAnd = function(e) {
        return this.throwIfDisposed(), U9(this, e)
    }, r5().prototype.logicalNot = function() {
        return this.throwIfDisposed(), V9(this)
    }, r5().prototype.logicalOr = function(e) {
        return this.throwIfDisposed(), G9(this, e)
    }, r5().prototype.logicalXor = function(e) {
        return this.throwIfDisposed(), j9(this, e)
    }, r5().prototype.matMul = function(e, t, n) {
        return this.throwIfDisposed(), Q8(this, e, t, n)
    }, r5().prototype.maxPool = function(e, t, n, r) {
        return this.throwIfDisposed(), X9(this, e, t, n, r)
    }, r5().prototype.max = function(e, t) {
        return this.throwIfDisposed(), n9(this, e, t)
    }, r5().prototype.maximum = function(e) {
        return this.throwIfDisposed(), Z9(this, e)
    }, r5().prototype.mean = function(e, t) {
        return this.throwIfDisposed(), Q9(this, e, t)
    }, r5().prototype.min = function(e, t) {
        return this.throwIfDisposed(), r9(this, e, t)
    }, r5().prototype.minimum = function(e) {
        return this.throwIfDisposed(), nee(this, e)
    }, r5().prototype.mirrorPad = function(e, t) {
        return this.throwIfDisposed(), ree(this, e, t)
    }, r5().prototype.mod = function(e) {
        return this.throwIfDisposed(), aee(this, e)
    }, r5().prototype.mul = function(e) {
        return this.throwIfDisposed(), g8(this, e)
    }, r5().prototype.neg = function() {
        return this.throwIfDisposed(), M9(this)
    }, r5().prototype.norm = function(e, t, n) {
        return this.throwIfDisposed(), l9(this, e, t, n)
    }, r5().prototype.notEqual = function(e) {
        return this.throwIfDisposed(), uee(this, e)
    }, r5().prototype.oneHot = function(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        return this.throwIfDisposed(), cee(this, e, t, n)
    }, r5().prototype.onesLike = function() {
        return this.throwIfDisposed(), lee(this)
    }, r5().prototype.pad = function(e, t) {
        return this.throwIfDisposed(), pee(this, e, t)
    }, r5().prototype.pool = function(e, t, n, r, a, i) {
        return this.throwIfDisposed(), yee(this, e, t, n, r, a, i)
    }, r5().prototype.pow = function(e) {
        return this.throwIfDisposed(), a9(this, e)
    }, r5().prototype.prelu = function(e) {
        return this.throwIfDisposed(), bee(this, e)
    }, r5().prototype.prod = function(e, t) {
        return this.throwIfDisposed(), xee(this, e, t)
    }, r5().prototype.reciprocal = function() {
        return this.throwIfDisposed(), cte(this)
    }, r5().prototype.relu = function() {
        return this.throwIfDisposed(), lte(this)
    }, r5().prototype.relu6 = function() {
        return this.throwIfDisposed(), hte(this)
    }, r5().prototype.reshapeAs = function(e) {
        return this.throwIfDisposed(), X8(this, e.shape)
    }, r5().prototype.reshape = function(e) {
        return this.throwIfDisposed(), X8(this, e)
    }, r5().prototype.resizeBilinear = function(e, t, n) {
        return this.throwIfDisposed(), sre(this, e, t, n)
    }, r5().prototype.resizeNearestNeighbor = function(e, t, n) {
        return this.throwIfDisposed(), ure(this, e, t, n)
    }, r5().prototype.reverse = function(e) {
        return this.throwIfDisposed(), pte(this, e)
    }, r5().prototype.rfft = function() {
        return this.throwIfDisposed(), Mte(this)
    }, r5().prototype.round = function() {
        return this.throwIfDisposed(), gte(this)
    }, r5().prototype.rsqrt = function() {
        return this.throwIfDisposed(), yte(this)
    }, r5().prototype.selu = function() {
        return this.throwIfDisposed(), bte(this)
    }, r5().prototype.separableConv2d = function(e, t, n, r, a, i) {
        return this.throwIfDisposed(), xte(this, e, t, n, r, a, i)
    }, r5().prototype.sigmoid = function() {
        return this.throwIfDisposed(), $8(this)
    }, r5().prototype.sign = function() {
        return this.throwIfDisposed(), Ite(this)
    }, r5().prototype.sin = function() {
        return this.throwIfDisposed(), Nte(this)
    }, r5().prototype.sinh = function() {
        return this.throwIfDisposed(), Ste(this)
    }, r5().prototype.slice = function(e, t) {
        return this.throwIfDisposed(), e7(this, e, t)
    }, r5().prototype.softmax = function(e) {
        return this.throwIfDisposed(), Rte(this, e)
    }, r5().prototype.softplus = function() {
        return this.throwIfDisposed(), L9(this)
    }, r5().prototype.spaceToBatchND = function(e, t) {
        return this.throwIfDisposed(), gee(this, e, t)
    }, r5().prototype.split = function(e, t) {
        return this.throwIfDisposed(), Dte(this, e, t)
    }, r5().prototype.sqrt = function() {
        return this.throwIfDisposed(), o9(this)
    }, r5().prototype.square = function() {
        return this.throwIfDisposed(), s9(this)
    }, r5().prototype.squaredDifference = function(e) {
        return this.throwIfDisposed(), Lte(this, e)
    }, r5().prototype.squeeze = function(e) {
        return this.throwIfDisposed(), zte(this, e)
    }, r5().prototype.stack = function(e, t) {
        this.throwIfDisposed();
        var n = e instanceof n5 ? [this, e] : [this].concat(T(e));
        return Pte(n, t)
    }, r5().prototype.step = function(e) {
        return this.throwIfDisposed(), Bte(this, e)
    }, r5().prototype.stridedSlice = function(e, t, n, r, a, i, o, s) {
        return this.throwIfDisposed(), Wte(this, e, t, n, r, a, i, o, s)
    }, r5().prototype.sub = function(e) {
        return this.throwIfDisposed(), P9(this, e)
    }, r5().prototype.sum = function(e, t) {
        return this.throwIfDisposed(), u9(this, e, t)
    }, r5().prototype.tan = function() {
        return this.throwIfDisposed(), Ute(this)
    }, r5().prototype.tanh = function() {
        return this.throwIfDisposed(), t7(this)
    }, r5().prototype.tile = function(e) {
        return this.throwIfDisposed(), v9(this, e)
    }, r5().prototype.toBool = function() {
        return this.throwIfDisposed(), h8(this, "bool")
    }, r5().prototype.toFloat = function() {
        return this.throwIfDisposed(), h8(this, "float32")
    }, r5().prototype.toInt = function() {
        return this.throwIfDisposed(), h8(this, "int32")
    }, r5().prototype.topk = function(e, t) {
        return this.throwIfDisposed(), $te(this, e, t)
    }, r5().prototype.transpose = function(e) {
        return this.throwIfDisposed(), hne(this, e)
    }, r5().prototype.unique = function(e) {
        return this.throwIfDisposed(), tne(this, e)
    }, r5().prototype.unsortedSegmentSum = function(e, t) {
        return this.throwIfDisposed(), nne(this, e, t)
    }, r5().prototype.unstack = function(e) {
        return this.throwIfDisposed(), rne(this, e)
    }, r5().prototype.where = function(e, t) {
        return this.throwIfDisposed(), W7(e, this, t)
    }, r5().prototype.zerosLike = function() {
        return this.throwIfDisposed(), U7(this)
    };
    var Tse = function(e) {
            d(n, e);
            var t = w(n);

            function n(e) {
                var r;
                return l(this, n), r = t.call(this, e), Object.setPrototypeOf(x(r), n.prototype), r
            }
            return p(n)
        }(b(Error)),
        Ese = function(e) {
            d(n, e);
            var t = w(n);

            function n(e) {
                var r;
                return l(this, n), r = t.call(this, e), Object.setPrototypeOf(x(r), n.prototype), r
            }
            return p(n)
        }(b(Error)),
        Cse = function(e) {
            d(n, e);
            var t = w(n);

            function n(e) {
                var r;
                return l(this, n), r = t.call(this, e), Object.setPrototypeOf(x(r), n.prototype), r
            }
            return p(n)
        }(b(Error)),
        Ase = function(e) {
            d(n, e);
            var t = w(n);

            function n(e) {
                var r;
                return l(this, n), r = t.call(this, e), Object.setPrototypeOf(x(r), n.prototype), r
            }
            return p(n)
        }(b(Error)),
        Rse = function(e) {
            d(n, e);
            var t = w(n);

            function n(e) {
                var r;
                return l(this, n), r = t.call(this, e), Object.setPrototypeOf(x(r), n.prototype), r
            }
            return p(n)
        }(b(Error)),
        _se = (Error, function() {
            function e(t) {
                l(this, e), this.maxEntries = t || 100, this.cache = new Map
            }
            return p(e, [{
                key: "get",
                value: function(e) {
                    var t;
                    return this.cache.has(e) && (t = this.cache.get(e), this.cache.delete(e), this.cache.set(e, t)), t
                }
            }, {
                key: "put",
                value: function(e, t) {
                    if (this.cache.has(e)) this.cache.delete(e);
                    else if (this.cache.size >= this.maxEntries) {
                        var n = this.cache.keys().next().value;
                        this.cache.delete(n)
                    }
                    this.cache.set(e, t)
                }
            }, {
                key: "getMaxEntries",
                value: function() {
                    return this.maxEntries
                }
            }, {
                key: "setMaxEntries",
                value: function(e) {
                    if (e < 0) throw new Error("The maxEntries of LRU caches must be at least 0, but got ".concat(e, "."));
                    if (this.maxEntries > e)
                        for (var t = 0; t < this.maxEntries - e; t++) {
                            var n = this.cache.keys().next().value;
                            this.cache.delete(n)
                        }
                    this.maxEntries = e
                }
            }]), e
        }());

    function Ose(e, t) {
        if (Array.isArray(e)) {
            for (var n = [], r = 0; r < t; r++) n = n.concat(e);
            return n
        }
        var a = new Array(t);
        return a.fill(e), a
    }

    function Fse(e, t) {
        if (!e) throw new Rse(t)
    }

    function Dse(e, t) {
        var n, r = 0,
            a = O(e);
        try {
            for (a.s(); !(n = a.n()).done;) {
                n.value === t && r++
            }
        } catch (e) {
            a.e(e)
        } finally {
            a.f()
        }
        return r
    }

    function Mse(e) {
        return 1 === e.length ? e[0] : e
    }

    function Lse(e) {
        return Array.isArray(e) ? e : [e]
    }

    function zse(e) {
        var t = e.replace(/(.)([A-Z][a-z0-9]+)/g, "$1_$2").replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
        return "_" !== t[0] ? t : "private" + t
    }

    function Pse(e) {
        return e.length <= 1 || -1 === e.indexOf("_") ? e : e.replace(/[_]+(\w|$)/g, (function(e, t) {
            return t.toUpperCase()
        }))
    }
    var Bse = {};

    function Wse(e) {
        if (null == e) return null;
        var t = {};
        return t.className = e.getClassName(), t.config = e.getConfig(), t
    }

    function Use(e) {
        if (null != e && "object" === s(e))
            if (Array.isArray(e)) e.forEach((function(e) {
                return Use(e)
            }));
            else
                for (var t = 0, n = Object.keys(e); t < n.length; t++) {
                    var r = n[t],
                        a = e[r];
                    null != a && "object" === s(a) && (Array.isArray(a) || "ndarray" !== a.type || "number" != typeof a.value ? Use(a) : e[r] = a.value)
                }
    }

    function Vse(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
            r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "object",
            a = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
        if ("string" == typeof e) {
            var i, o = e;
            if (o in n) i = n[o];
            else if (o in Bse) i = Bse[o];
            else if (null == (i = t[o])) throw new Cse("Unknown ".concat(r, ": ").concat(e, ". ") + "This may be due to one of the following reasons:\n" + "1. The ".concat(r, " is defined in Python, in which ") + "case it needs to be ported to TensorFlow.js or your JavaScript code.\n" + "2. The custom ".concat(r, " is defined in JavaScript, ") + "but is not registered properly with tf.serialization.registerClass().");
            return i
        }
        var s = e;
        if (null == s.className || null == s.config) throw new Cse("".concat(r, ": Improper config format: ") + "".concat(JSON.stringify(s), ".\n") + "'className' and 'config' must set.");
        var u, c, l = s.className;
        if (l in n) {
            var h = S(n[l], 2);
            u = h[0], c = h[1]
        } else if (l in Bse) {
            var p = S(Bse.className, 2);
            u = p[0], c = p[1]
        } else if (l in t) {
            var f = S(t[l], 2);
            u = f[0], c = f[1]
        }
        if (null == u) throw new Cse("Unknown ".concat(r, ": ").concat(l, ". ") + "This may be due to one of the following reasons:\n" + "1. The ".concat(r, " is defined in Python, in which ") + "case it needs to be ported to TensorFlow.js or your JavaScript code.\n" + "2. The custom ".concat(r, " is defined in JavaScript, ") + "but is not registered properly with tf.serialization.registerClass().");
        if (null != c) {
            for (var d = {}, v = 0, m = Object.keys(Bse); v < m.length; v++) {
                var g = m[v];
                d[g] = Bse[g]
            }
            for (var y = 0, b = Object.keys(n); y < b.length; y++) {
                var x = b[y];
                d[x] = n[x]
            }
            var k = s.config;
            k.customObjects = d;
            for (var w = Object.assign({}, Bse), I = 0, N = Object.keys(n); I < N.length; I++) {
                var T = N[I];
                Bse[T] = n[T]
            }
            Use(s.config);
            var E = c(u, s.config, n, a);
            return Bse = Object.assign({}, w), E
        }
        for (var C = Object.assign({}, Bse), A = 0, R = Object.keys(n); A < R.length; A++) {
            var _ = R[A];
            Bse[_] = n[_]
        }
        var O = new u(s.config);
        return Bse = Object.assign({}, C), O
    }

    function Gse(e, t) {
        return -1 * function(e, t) {
            return e < t ? -1 : e > t ? 1 : 0
        }(e, t)
    }

    function jse(e) {
        if (null == e) return e;
        var t, n = [],
            r = O(e);
        try {
            for (r.s(); !(t = r.n()).done;) {
                var a = t.value; - 1 === n.indexOf(a) && n.push(a)
            }
        } catch (e) {
            r.e(e)
        } finally {
            r.f()
        }
        return n
    }

    function Hse(e) {
        if (null == e) throw new Cse("Invalid value in obj: ".concat(JSON.stringify(e)));
        for (var t in e)
            if (e.hasOwnProperty(t)) return !1;
        return !0
    }

    function qse(e, t, n) {
        if (null != n && e.indexOf(n) < 0) throw new Cse("".concat(n, " is not a valid ").concat(t, ".  Valid values are ").concat(e, " or null/undefined."))
    }

    function Kse(e, t) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
            r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1 / 0;
        return Fse(n >= 0), Fse(r >= n), Array.isArray(e) && e.length >= n && e.length <= r && e.every((function(e) {
            return s(e) === t
        }))
    }

    function Xse(e, t) {
        Array.isArray(e) ? (F$(e.length > 0, (function() {
            return "".concat(t, " is unexpectedly an empty array.")
        })), e.forEach((function(e, n) {
            return Xse(e, "element ".concat(n + 1, " of ").concat(t))
        }))) : F$(Number.isInteger(e) && e > 0, (function() {
            return "Expected ".concat(t, " to be a positive integer, but got ") + "".concat(Yse(e), ".")
        }))
    }

    function Yse(e) {
        return null === e ? "null" : Array.isArray(e) ? "[" + e.map((function(e) {
            return Yse(e)
        })).join(",") + "]" : "string" == typeof e ? '"'.concat(e, '"') : "".concat(e)
    }

    function Jse(e) {
        return "relu" === e ? "relu" : "linear" === e ? "linear" : "elu" === e ? "elu" : null
    }
    var Zse = 0;

    function Qse() {
        return Zse++
    }
    var $se = {};

    function eue() {
        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
        return e in $se || ($se[e] = 0), $se[e] += 1, e + $se[e].toString()
    }
    var tue = ["channelsFirst", "channelsLast"],
        nue = ["nearest", "bilinear"],
        rue = ["valid", "same", "causal"],
        aue = ["max", "avg"],
        iue = ["sum", "mul", "concat", "ave"],
        oue = new Map;

    function sue(e) {
        qse(tue, "DataFormat", e)
    }

    function uue(e) {
        qse(rue, "PaddingMode", e)
    }

    function cue(e) {
        qse(aue, "PoolMode", e)
    }
    var lue = [];

    function hue(e, t) {
        lue.push(e);
        try {
            var n = t();
            return lue.pop(), n
        } catch (e) {
            throw lue.pop(), e
        }
    }

    function pue(e) {
        if (!mue(e)) throw new Error("Not a valid tensor name: '" + e + "'");
        return (0 === lue.length ? "" : lue.join("/") + "/") + e
    }

    function fue(e) {
        if (!mue(e)) throw new Error("Not a valid tensor name: '" + e + "'");
        oue.has(e) || oue.set(e, 0);
        var t = oue.get(e);
        if (oue.set(e, oue.get(e) + 1), t > 0) {
            var n = "".concat(e, "_").concat(t);
            return oue.set(n, 1), n
        }
        return e
    }
    var due, vue = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);

    function mue(e) {
        return !!e.match(vue)
    }

    function gue(e, t, n) {
        null == t && (t = 0), null == n && (n = e.length);
        for (var r = 1, a = t; a < n; ++a) r *= e[a];
        return r
    }

    function yue(e) {
        if (0 === e.length) return Number.NaN;
        for (var t = Number.POSITIVE_INFINITY, n = 0; n < e.length; n++) {
            var r = e[n];
            r < t && (t = r)
        }
        return t
    }

    function bue(e) {
        if (0 === e.length) return Number.NaN;
        for (var t = Number.NEGATIVE_INFINITY, n = 0; n < e.length; n++) {
            var r = e[n];
            r > t && (t = r)
        }
        return t
    }

    function xue(e, t) {
        if (t < e) throw new Cse("end (".concat(t, ") < begin (").concat(e, ") is forbidden."));
        for (var n = [], r = e; r < t; ++r) n.push(r);
        return n
    }

    function kue() {
        return null == due && (due = e6().epsilon()), due
    }

    function wue(e, t) {
        return h8(e, t)
    }

    function Iue(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1,
            n = e.shape.slice();
        return t < 0 && (t = n.length + t + 1), n.splice(t, 0, 1), X8(e, n)
    }

    function Nue(e) {
        var t = [gue(e.shape)];
        return X8(e, t)
    }

    function Sue(e, t, n) {
        return X5((function() {
            switch (e.rank) {
                case 1:
                    return Tte(e, t, n);
                case 2:
                    return Ete(e, [t, 0], [n, e.shape[1]]);
                case 3:
                    return Cte(e, [t, 0, 0], [n, e.shape[1], e.shape[2]]);
                case 4:
                    return Ate(e, [t, 0, 0, 0], [n, e.shape[1], e.shape[2], e.shape[3]]);
                case 5:
                    return e7(e, [t, 0, 0, 0, 0], [n, e.shape[1], e.shape[2], e.shape[3], e.shape[4]]);
                case 6:
                    return e7(e, [t, 0, 0, 0, 0, 0], [n, e.shape[1], e.shape[2], e.shape[3], e.shape[4], e.shape[5]]);
                default:
                    throw new Cse("sliceAlongFirstAxis() received an unsupported tensor rank: " + "".concat(e.rank))
            }
        }))
    }

    function Tue(e, t, n) {
        return X5((function() {
            switch (e.rank) {
                case 1:
                    return Tte(e, t, n);
                case 2:
                    return Ete(e, [0, t], [e.shape[0], n]);
                case 3:
                    return Cte(e, [0, 0, t], [e.shape[0], e.shape[1], n]);
                case 4:
                    return Ate(e, [0, 0, 0, t], [e.shape[0], e.shape[1], e.shape[2], n]);
                default:
                    throw new Cse("sliceAlongLastAxis() received an unsupported tensor rank: " + "".concat(e.rank))
            }
        }))
    }

    function Eue(e, t, n, r) {
        return X5((function() {
            switch (e.rank) {
                case 1:
                    return Tte(e, t, n);
                case 2:
                    switch (r) {
                        case 1:
                            return Sue(e, t, n);
                        case 2:
                            return Tue(e, t, n);
                        default:
                            throw new Cse("The axis is not within the rank of the tensor " + "".concat(r))
                    }
                case 3:
                    switch (r) {
                        case 1:
                            return Sue(e, t, n);
                        case 2:
                            return Cte(e, [0, t, 0], [e.shape[0], n, e.shape[2]]);
                        case 3:
                            return Tue(e, t, n);
                        default:
                            throw new Cse("The axis is not within the rank of the tensor " + "".concat(r))
                    }
                case 4:
                    switch (r) {
                        case 1:
                            return Sue(e, t, n);
                        case 2:
                            return Ate(e, [0, t, 0, 0], [e.shape[0], n, e.shape[2], e.shape[3]]);
                        case 3:
                            return Ate(e, [0, 0, t, 0], [e.shape[0], e.shape[1], n, e.shape[3]]);
                        case 4:
                            return Tue(e, t, n);
                        default:
                            throw new Cse("The axis is not within the rank of the tensor " + "".concat(r))
                    }
                default:
                    throw new Cse("sliceAlongLastAxis() received an unsupported tensor rank: " + "".concat(e.rank))
            }
        }))
    }

    function Cue(e) {
        var t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1;
        return n < 0 && (n = 0 !== (t = e[0].rank) ? t : 0), n === e[0].rank && (n = -1), Z8(e, n)
    }

    function Aue(e, t) {
        switch (e.rank) {
            case 1:
                return v7([e, t]);
            case 2:
                return m7([e, t], 0);
            case 3:
                return g7([e, t], 0);
            case 4:
                return y7([e, t], 0);
            default:
                throw new Cse("concatAlongFirstAxis() received an unsupported " + "tensor rank: ".concat(e.rank))
        }
    }

    function Rue(e, t) {
        if (Array.isArray(t) || (t = [t]), e.rank !== t.length) throw new Cse("The length of input n (".concat(t.length, ") does not match ") + "the number of dimensions in input x (".concat(e.rank, ")"));
        return v9(e, t)
    }

    function _ue(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
            r = arguments.length > 3 ? arguments[3] : void 0,
            a = arguments.length > 4 ? arguments[4] : void 0;
        return rte(e, t, n, r, a)
    }

    function Oue(e, t, n, r) {
        if (e.rank < 2 || t.rank < 2) throw new Ase("dot requires both inputs to be rank >= 2" + " but got x shape = ".concat(e.shape, " and y shape = ").concat(t.shape));
        if (t.rank >= 3 && e.shape.slice(-1)[0] !== t.shape.slice(-2)[0]) throw new Ase("If rank y >= 3, then the second last dim" + " of y must equal the last dim of x but got x shape = ".concat(e.shape, " and ") + " y shape = ".concat(t.shape));
        if (2 === e.rank && 2 === t.rank) {
            return _ne({
                a: e,
                b: t,
                transposeA: !1,
                transposeB: !1,
                bias: r ? Mue(e.rank, r, "channelsLast") : null,
                activation: n
            })
        }
        var a = e.shape.slice(),
            i = a.pop();
        e = X8(e, [-1, i]);
        var o = t.shape.slice(),
            s = o.pop(),
            u = o.pop(),
            c = [].concat(T(o), [s]),
            l = Array.from({
                length: t.rank
            }, (function(e, n) {
                return 0 === n ? t.rank - 2 : n <= t.rank - 2 ? n - 1 : n
            }));
        t = X8(hne(t, l), [u, -1]);
        var h = [].concat(T(a), T(c));
        return X8(_ne({
            a: e,
            b: t,
            transposeA: !1,
            transposeB: !1,
            bias: r ? Mue(e.rank, r, "channelsLast") : null,
            activation: n
        }), h)
    }

    function Fue(e, t, n) {
        return X5((function() {
            return t = Array.isArray(t) ? Vte(t, "int32") : h8(t, "int32"), y9(e, t, n)
        }))
    }

    function Due(e) {
        return g8(e, e)
    }

    function Mue(e, t, n) {
        var r = t.shape;
        if (1 !== t.rank && t.rank !== e) throw new Cse("Unexpected bias dimensions: ".concat(t.rank) + "; expected it to be 1 or ".concat(e));
        if (5 === e) {
            if ("channelsFirst" === n) return 1 === r.length ? X8(t, [1, r[0], 1, 1, 1]) : X8(t, [1, r[3], r[0], r[1], r[2]]);
            if ("channelsLast" === n) return 1 === r.length ? X8(t, [1, 1, 1, 1, r[0]]) : X8(t, [1].concat(r))
        } else if (4 === e) {
            if ("channelsFirst" === n) return 1 === r.length ? X8(t, [1, r[0], 1, 1]) : X8(t, [1, r[2], r[0], r[1]]);
            if ("channelsLast" === n) return 1 === r.length ? X8(t, [1, 1, 1, r[0]]) : X8(t, [1].concat(r))
        } else if (3 === e) {
            if ("channelsFirst" === n) return 1 === r.length ? X8(t, [1, r[0], 1]) : X8(t, [1, r[1], r[0]]);
            if ("channelsLast" === n) return 1 === r.length ? X8(t, [1, 1, r[0]]) : X8(t, [1].concat(r))
        } else if (e < 3) return t;
        throw new Cse("Unsupported input rank by biasAdd: ".concat(t.rank))
    }

    function Lue(e, t, n) {
        return X5((function() {
            return null == n && (n = "channelsLast"), sue(n), d8(e, Mue(e.rank, t, n))
        }))
    }

    function zue(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
        if (1 !== t) throw new Ase("Support for alpha values other than 1 (".concat(t, ") is not implemented ") + "yet.");
        return H7(e)
    }

    function Pue(e, t, n, r) {
        return X5((function() {
            return gne(e, t, n, r)
        }))
    }

    function Bue(e, t) {
        var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        return n ? e() : t()
    }
    var Wue = ["fanIn", "fanOut", "fanAvg"],
        Uue = ["normal", "uniform", "truncatedNormal"];
    var Vue = function(e) {
            d(n, e);
            var t = w(n);

            function n() {
                return l(this, n), t.apply(this, arguments)
            }
            return p(n, [{
                key: "fromConfigUsesCustomObjects",
                value: function() {
                    return !1
                }
            }, {
                key: "getConfig",
                value: function() {
                    return {}
                }
            }]), n
        }(Hre),
        Gue = function(e) {
            d(n, e);
            var t = w(n);

            function n() {
                return l(this, n), t.apply(this, arguments)
            }
            return p(n, [{
                key: "apply",
                value: function(e, t) {
                    return $9(e, t)
                }
            }]), n
        }(Vue);
    Gue.className = "Zeros", Kre(Gue);
    var jue = function(e) {
        d(n, e);
        var t = w(n);

        function n() {
            return l(this, n), t.apply(this, arguments)
        }
        return p(n, [{
            key: "apply",
            value: function(e, t) {
                return eee(e, t)
            }
        }]), n
    }(Vue);
    jue.className = "Ones", Kre(jue);
    var Hue = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            if (l(this, n), r = t.call(this), "object" !== s(e)) throw new Cse("Expected argument of type ConstantConfig but got ".concat(e));
            if (void 0 === e.value) throw new Cse("config must have value set but got ".concat(e));
            return r.value = e.value, r
        }
        return p(n, [{
            key: "apply",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    return g8(i9(n.value), eee(e, t))
                }))
            }
        }, {
            key: "getConfig",
            value: function() {
                return {
                    value: this.value
                }
            }
        }]), n
    }(Vue);
    Hue.className = "Constant", Kre(Hue);
    var que = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            return l(this, n), (r = t.call(this)).DEFAULT_MINVAL = -.05, r.DEFAULT_MAXVAL = .05, r.minval = e.minval || r.DEFAULT_MINVAL, r.maxval = e.maxval || r.DEFAULT_MAXVAL, r.seed = e.seed, r
        }
        return p(n, [{
            key: "apply",
            value: function(e, t) {
                return ite(e, this.minval, this.maxval, t, this.seed)
            }
        }, {
            key: "getConfig",
            value: function() {
                return {
                    minval: this.minval,
                    maxval: this.maxval,
                    seed: this.seed
                }
            }
        }]), n
    }(Vue);
    que.className = "RandomUniform", Kre(que);
    var Kue = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            return l(this, n), (r = t.call(this)).DEFAULT_MEAN = 0, r.DEFAULT_STDDEV = .05, r.mean = e.mean || r.DEFAULT_MEAN, r.stddev = e.stddev || r.DEFAULT_STDDEV, r.seed = e.seed, r
        }
        return p(n, [{
            key: "apply",
            value: function(e, t) {
                if ("float32" !== (t = t || "float32") && "int32" !== t) throw new Ase("randomNormal does not support dType ".concat(t, "."));
                return _ue(e, this.mean, this.stddev, t, this.seed)
            }
        }, {
            key: "getConfig",
            value: function() {
                return {
                    mean: this.mean,
                    stddev: this.stddev,
                    seed: this.seed
                }
            }
        }]), n
    }(Vue);
    Kue.className = "RandomNormal", Kre(Kue);
    var Xue = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            return l(this, n), (r = t.call(this)).DEFAULT_MEAN = 0, r.DEFAULT_STDDEV = .05, r.mean = e.mean || r.DEFAULT_MEAN, r.stddev = e.stddev || r.DEFAULT_STDDEV, r.seed = e.seed, r
        }
        return p(n, [{
            key: "apply",
            value: function(e, t) {
                if ("float32" !== (t = t || "float32") && "int32" !== t) throw new Ase("truncatedNormal does not support dType ".concat(t, "."));
                return ene(e, this.mean, this.stddev, t, this.seed)
            }
        }, {
            key: "getConfig",
            value: function() {
                return {
                    mean: this.mean,
                    stddev: this.stddev,
                    seed: this.seed
                }
            }
        }]), n
    }(Vue);
    Xue.className = "TruncatedNormal", Kre(Xue);
    var Yue = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            return l(this, n), (r = t.call(this)).gain = null != e.gain ? e.gain : 1, r
        }
        return p(n, [{
            key: "apply",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    if (2 !== e.length || e[0] !== e[1]) throw new Cse("Identity matrix initializer can only be used for 2D square matrices.");
                    return g8(n.gain, m9(e[0]))
                }))
            }
        }, {
            key: "getConfig",
            value: function() {
                return {
                    gain: this.gain
                }
            }
        }]), n
    }(Vue);
    Yue.className = "Identity", Kre(Yue);
    var Jue = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r, a;
            if (l(this, n), r = t.call(this), e.scale < 0) throw new Cse("scale must be a positive float. Got: ".concat(e.scale));
            return r.scale = null == e.scale ? 1 : e.scale, r.mode = null == e.mode ? "fanIn" : e.mode, a = r.mode, qse(Wue, "FanMode", a), r.distribution = null == e.distribution ? "normal" : e.distribution,
                function(e) {
                    qse(Uue, "Distribution", e)
                }(r.distribution), r.seed = e.seed, r
        }
        return p(n, [{
            key: "apply",
            value: function(e, t) {
                var n = function(e) {
                        var t, n, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "channelsLast";
                        if (sue(r), 2 === e.length) t = e[0], n = e[1];
                        else if (-1 !== [3, 4, 5].indexOf(e.length)) {
                            if ("channelsFirst" === r) {
                                var a = gue(e, 2);
                                t = e[1] * a, n = e[0] * a
                            } else if ("channelsLast" === r) {
                                var i = gue(e, 0, e.length - 2);
                                t = e[e.length - 2] * i, n = e[e.length - 1] * i
                            }
                        } else {
                            var o = gue(e);
                            t = Math.sqrt(o), n = Math.sqrt(o)
                        }
                        return [t, n]
                    }(e),
                    r = n[0],
                    a = n[1],
                    i = this.scale;
                if ("fanIn" === this.mode ? i /= Math.max(1, r) : "fanOut" === this.mode ? i /= Math.max(1, a) : i /= Math.max(1, (r + a) / 2), "normal" === this.distribution) {
                    var o = Math.sqrt(i);
                    if ("float32" !== (t = t || "float32") && "int32" !== t) throw new Ase("".concat(this.getClassName(), " does not support dType ").concat(t, "."));
                    return ene(e, 0, o, t, this.seed)
                }
                var s = Math.sqrt(3 * i);
                return ite(e, -s, s, t, this.seed)
            }
        }, {
            key: "getConfig",
            value: function() {
                return {
                    scale: this.scale,
                    mode: this.mode,
                    distribution: this.distribution,
                    seed: this.seed
                }
            }
        }]), n
    }(Vue);
    Jue.className = "VarianceScaling", Kre(Jue);
    var Zue = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            return l(this, n), t.call(this, {
                scale: 1,
                mode: "fanAvg",
                distribution: "uniform",
                seed: null == e ? null : e.seed
            })
        }
        return p(n, [{
            key: "getClassName",
            value: function() {
                return Jue.className
            }
        }]), n
    }(Jue);
    Zue.className = "GlorotUniform", Kre(Zue);
    var Que = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            return l(this, n), t.call(this, {
                scale: 1,
                mode: "fanAvg",
                distribution: "normal",
                seed: null == e ? null : e.seed
            })
        }
        return p(n, [{
            key: "getClassName",
            value: function() {
                return Jue.className
            }
        }]), n
    }(Jue);
    Que.className = "GlorotNormal", Kre(Que);
    var $ue = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            return l(this, n), t.call(this, {
                scale: 2,
                mode: "fanIn",
                distribution: "normal",
                seed: null == e ? null : e.seed
            })
        }
        return p(n, [{
            key: "getClassName",
            value: function() {
                return Jue.className
            }
        }]), n
    }(Jue);
    $ue.className = "HeNormal", Kre($ue);
    var ece = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            return l(this, n), t.call(this, {
                scale: 2,
                mode: "fanIn",
                distribution: "uniform",
                seed: null == e ? null : e.seed
            })
        }
        return p(n, [{
            key: "getClassName",
            value: function() {
                return Jue.className
            }
        }]), n
    }(Jue);
    ece.className = "HeUniform", Kre(ece);
    var tce = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            return l(this, n), t.call(this, {
                scale: 1,
                mode: "fanIn",
                distribution: "normal",
                seed: null == e ? null : e.seed
            })
        }
        return p(n, [{
            key: "getClassName",
            value: function() {
                return Jue.className
            }
        }]), n
    }(Jue);
    tce.className = "LeCunNormal", Kre(tce);
    var nce = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            return l(this, n), t.call(this, {
                scale: 1,
                mode: "fanIn",
                distribution: "uniform",
                seed: null == e ? null : e.seed
            })
        }
        return p(n, [{
            key: "getClassName",
            value: function() {
                return Jue.className
            }
        }]), n
    }(Jue);
    nce.className = "LeCunUniform", Kre(nce);
    var rce = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            return l(this, n), (r = t.call(this)).DEFAULT_GAIN = 1, r.ELEMENTS_WARN_SLOW = 2e3, r.gain = null == e.gain ? r.DEFAULT_GAIN : e.gain, r.seed = e.seed, r
        }
        return p(n, [{
            key: "apply",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    if (e.length < 2) throw new Ase("Shape must be at least 2D.");
                    if ("int32" !== t && "float32" !== t && void 0 !== t) throw new TypeError("Unsupported data type ".concat(t, "."));
                    var r = L$(e.slice(0, -1)),
                        a = e[e.length - 1],
                        i = r * a;
                    i > n.ELEMENTS_WARN_SLOW && console.warn("Orthogonal initializer is being called on a matrix with more " + "than ".concat(n.ELEMENTS_WARN_SLOW, " (").concat(i, ") elements: ") + "Slowness may result.");
                    var o = _ue([Math.max(a, r), Math.min(a, r)], 0, 1, t, n.seed),
                        s = Bre.qr(o, !1),
                        u = s[0],
                        c = s[1].flatten().stridedSlice([0], [Math.min(a, r) * Math.min(a, r)], [Math.min(a, r) + 1]);
                    return u = g8(u, c.sign()), r < a && (u = u.transpose()), g8(i9(n.gain), u.reshape(e))
                }))
            }
        }, {
            key: "getConfig",
            value: function() {
                return {
                    gain: this.gain,
                    seed: this.seed
                }
            }
        }]), n
    }(Vue);
    rce.className = "Orthogonal", Kre(rce);
    var ace = {
        constant: "Constant",
        glorotNormal: "GlorotNormal",
        glorotUniform: "GlorotUniform",
        heNormal: "HeNormal",
        heUniform: "HeUniform",
        identity: "Identity",
        leCunNormal: "LeCunNormal",
        leCunUniform: "LeCunUniform",
        ones: "Ones",
        orthogonal: "Orthogonal",
        randomNormal: "RandomNormal",
        randomUniform: "RandomUniform",
        truncatedNormal: "TruncatedNormal",
        varianceScaling: "VarianceScaling",
        zeros: "Zeros"
    };

    function ice(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return Vse(e, qre.getMap().classNameMap, t, "initializer")
    }

    function oce(e) {
        return Wse(e)
    }

    function sce(e) {
        if ("string" == typeof e) {
            var t = e in ace ? ace[e] : e;
            if ("GlorotNormal" === t) return new Que;
            if ("GlorotUniform" === t) return new Zue;
            if ("HeNormal" === t) return new $ue;
            if ("HeUniform" === t) return new ece;
            if ("LeCunNormal" === t) return new tce;
            if ("LeCunUniform" === t) return new nce;
            var n = {};
            return n.className = t, n.config = {}, ice(n)
        }
        return e instanceof Vue ? e : ice(e)
    }

    function uce(e) {
        return Array.isArray(e) && Array.isArray(e[0])
    }

    function cce(e) {
        return 0 === e.length ? [] : Array.isArray(e[0]) ? e : [e]
    }

    function lce(e) {
        var t;
        if (Array.isArray(e)) {
            if (1 !== e.length) throw new Cse("Expected Tensor length to be 1; got ".concat(e.length));
            t = e[0]
        } else t = e;
        return t
    }

    function hce(e) {
        if (Array.isArray(e) && Array.isArray(e[0])) {
            if (1 === e.length) return e[0];
            throw new Cse("Expected exactly 1 Shape; got ".concat(e.length))
        }
        return e
    }

    function pce(e) {
        var t, n = 0,
            r = O(e);
        try {
            for (r.s(); !(t = r.n()).done;) {
                var a = t.value;
                0 === a.shape.length ? n += 1 : n += a.shape.reduce((function(e, t) {
                    return e * t
                }))
            }
        } catch (e) {
            r.e(e)
        } finally {
            r.f()
        }
        return n
    }
    var fce = "Variable",
        dce = function() {
            function e(t) {
                var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "float32",
                    r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : fce,
                    a = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
                    i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null;
                l(this, e), this.dtype = null == n ? "float32" : n, this.shape = t.shape, this.id = Qse(), r = null == r ? fce : r, this.originalName = pue(r), this.name = fue(this.originalName), this.trainable_ = a, this.constraint = i, this.val = ine(t, this.trainable_, this.name, this.dtype)
            }
            return p(e, [{
                key: "read",
                value: function() {
                    return this.assertNotDisposed(), this.val
                }
            }, {
                key: "write",
                value: function(e) {
                    return this.assertNotDisposed(),
                        function(e, t) {
                            if (e.shape.toString() !== t.shape.toString()) throw new Error("Shape mismatch: " + JSON.stringify(e.shape) + " vs. " + JSON.stringify(t.shape))
                        }(this.val, e), this.val.id !== e.id && (this.val.assign(e), null != this.constraint && this.val.assign(this.constraint.apply(this.val))), this
                }
            }, {
                key: "dispose",
                value: function() {
                    this.assertNotDisposed(), this.val.dispose()
                }
            }, {
                key: "assertNotDisposed",
                value: function() {
                    if (this.val.isDisposed) throw new Error("LayersVariable ".concat(this.name, " is already disposed."))
                }
            }, {
                key: "trainable",
                get: function() {
                    return this.trainable_
                },
                set: function(e) {
                    this.trainable_ = e, this.val.trainable = e
                }
            }]), e
        }();

    function vce(e) {
        return e.map((function(e) {
            return e.read()
        }))
    }

    function mce(e) {
        e.forEach((function(e) {
            e[0].write(e[1])
        }))
    }
    var gce = p((function e(t) {
            l(this, e), this.dtype = t.dtype, this.shape = t.shape, null != t.shape ? this.ndim = t.shape.length : this.ndim = t.ndim, this.maxNDim = t.maxNDim, this.minNDim = t.minNDim, this.axes = t.axes || {}
        })),
        yce = p((function e(t, n, r, a, i, o, s) {
            l(this, e), this.dtype = t, this.shape = n, this.sourceLayer = r, this.inputs = a, this.callArgs = i, this.outputTensorIndex = s, this.id = Qse(), null != o && (this.originalName = pue(o), this.name = fue(this.originalName)), this.rank = n.length
        })),
        bce = 0,
        xce = function() {
            function e(t, n) {
                l(this, e), this.callArgs = n, this.id = bce++, this.outboundLayer = t.outboundLayer, this.inboundLayers = t.inboundLayers, this.nodeIndices = t.nodeIndices, this.tensorIndices = t.tensorIndices, this.inputTensors = t.inputTensors, this.outputTensors = t.outputTensors, this.inputMasks = t.inputMasks, this.outputMasks = t.outputMasks, this.inputShapes = t.inputShapes, this.outputShapes = t.outputShapes;
                var r, a = O(t.inboundLayers);
                try {
                    for (a.s(); !(r = a.n()).done;) {
                        var i = r.value;
                        null != i && i.outboundNodes.push(this)
                    }
                } catch (e) {
                    a.e(e)
                } finally {
                    a.f()
                }
                t.outboundLayer.inboundNodes.push(this)
            }
            return p(e, [{
                key: "getConfig",
                value: function() {
                    var e, t = [],
                        n = O(this.inboundLayers);
                    try {
                        for (n.s(); !(e = n.n()).done;) {
                            var r = e.value;
                            null != r ? t.push(r.name) : t.push(null)
                        }
                    } catch (e) {
                        n.e(e)
                    } finally {
                        n.f()
                    }
                    return {
                        outboundLayer: this.outboundLayer ? this.outboundLayer.name : null,
                        inboundLayers: t,
                        nodeIndices: this.nodeIndices,
                        tensorIndices: this.tensorIndices
                    }
                }
            }]), e
        }(),
        kce = 0,
        wce = function(e) {
            d(n, e);
            var t = w(n);

            function n() {
                var e, r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                l(this, n), (e = t.call(this))._callHook = null, e._addedWeightNames = [], e._stateful = !1, e.id = kce++, e.activityRegularizer = null, e.inputSpec = null, e.supportsMasking = !1, e._trainableWeights = [], e._nonTrainableWeights = [], e._losses = [], e._updates = [], e._built = !1, e.inboundNodes = [], e.outboundNodes = [];
                var a = r.name;
                if (!a) {
                    var i = e.getClassName();
                    a = zse(i) + "_" + eue(i)
                }
                if (e.name = a, e.trainable_ = null == r.trainable || r.trainable, null != r.inputShape || null != r.batchInputShape) {
                    var o;
                    if (null != r.batchInputShape) o = r.batchInputShape;
                    else if (null != r.inputShape) {
                        var s = null;
                        null != r.batchSize && (s = r.batchSize), o = [s].concat(r.inputShape)
                    }
                    e.batchInputShape = o;
                    var u = r.dtype;
                    null == u && (u = r.inputDType), null == u && (u = "float32"), e.dtype = u
                }
                return null != r.weights ? e.initialWeights = r.weights : e.initialWeights = null, e._refCount = null, e.fastWeightInitDuringBuild = !1, e
            }
            return p(n, [{
                key: "getNodeAtIndex",
                value: function(e, t) {
                    if (0 === this.inboundNodes.length) throw new Ese("The layer has never been called " + "and thus has no defined ".concat(t, "."));
                    if (this.inboundNodes.length <= e) throw new Cse("Asked to get ".concat(t, " at node ").concat(e, ", ") + "but the layer has only ".concat(this.inboundNodes.length, " inbound nodes."));
                    return this.inboundNodes[e]
                }
            }, {
                key: "getInputAt",
                value: function(e) {
                    return Mse(this.getNodeAtIndex(e, "input").inputTensors)
                }
            }, {
                key: "getOutputAt",
                value: function(e) {
                    return Mse(this.getNodeAtIndex(e, "output").outputTensors)
                }
            }, {
                key: "input",
                get: function() {
                    if (this.inboundNodes.length > 1) throw new Tse("Layer ".concat(this.name) + ' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');
                    if (0 === this.inboundNodes.length) throw new Tse("Layer ".concat(this.name) + " is not connected, no input to return.");
                    return Mse(this.getNodeAtIndex(0, "input").inputTensors)
                }
            }, {
                key: "output",
                get: function() {
                    if (0 === this.inboundNodes.length) throw new Tse("Layer ".concat(this.name) + " has no inbound nodes.");
                    if (this.inboundNodes.length > 1) throw new Tse("Layer ".concat(this.name) + ' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');
                    return Mse(this.getNodeAtIndex(0, "output").outputTensors)
                }
            }, {
                key: "losses",
                get: function() {
                    return this._losses
                }
            }, {
                key: "calculateLosses",
                value: function() {
                    return this.losses.map((function(e) {
                        return e()
                    }))
                }
            }, {
                key: "updates",
                get: function() {
                    return this._updates
                }
            }, {
                key: "built",
                get: function() {
                    return this._built
                },
                set: function(e) {
                    this._built = e
                }
            }, {
                key: "trainable",
                get: function() {
                    return this.trainable_
                },
                set: function(e) {
                    this._trainableWeights.forEach((function(t) {
                        return t.trainable = e
                    })), this.trainable_ = e
                }
            }, {
                key: "trainableWeights",
                get: function() {
                    return this.trainable_ ? this._trainableWeights.filter((function(e) {
                        return e.trainable
                    })) : []
                },
                set: function(e) {
                    this._trainableWeights = e
                }
            }, {
                key: "nonTrainableWeights",
                get: function() {
                    return this.trainable ? this._trainableWeights.filter((function(e) {
                        return !e.trainable
                    })).concat(this._nonTrainableWeights) : this._trainableWeights.concat(this._nonTrainableWeights)
                },
                set: function(e) {
                    this._nonTrainableWeights = e
                }
            }, {
                key: "weights",
                get: function() {
                    return this.trainableWeights.concat(this.nonTrainableWeights)
                }
            }, {
                key: "stateful",
                get: function() {
                    return this._stateful
                }
            }, {
                key: "resetStates",
                value: function() {
                    if (!this.stateful) throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")
                }
            }, {
                key: "assertInputCompatibility",
                value: function(e) {
                    var t = Lse(e);
                    if (null != this.inputSpec && 0 !== this.inputSpec.length) {
                        var n = Lse(this.inputSpec);
                        if (t.length !== n.length) throw new Cse("Layer ".concat(this.name, " expects ").concat(n.length, " inputs, ") + "but it received ".concat(t.length, " input tensors. ") + "Input received: ".concat(e));
                        for (var r = 0; r < t.length; r++) {
                            var a = t[r],
                                i = n[r];
                            if (null != i) {
                                var o = a.rank;
                                if (null != i.ndim && o !== i.ndim) throw new Cse("Input ".concat(r, " is incompatible with layer ").concat(this.name, ": ") + "expected ndim=".concat(i.ndim, ", found ndim=").concat(o));
                                if (null != i.maxNDim && o > i.maxNDim) throw new Cse("Input ".concat(r, " is incompatible with layer ").concat(this.name) + ": expected max_ndim=".concat(i.maxNDim, ", found ndim=").concat(o));
                                if (null != i.minNDim && o < i.minNDim) throw new Cse("Input ".concat(r, " is incompatible with layer ").concat(this.name) + ": expected min_ndim=".concat(i.minNDim, ", found ndim=").concat(o, "."));
                                if (null != i.dtype && a.dtype !== i.dtype) throw new Cse("Input ".concat(r, " is incompatible with layer ").concat(this.name, " ") + ": expected dtype=".concat(i.dtype, ", found dtype=").concat(a.dtype, "."));
                                if (i.axes) {
                                    var s = a.shape;
                                    for (var u in i.axes) {
                                        var c = Number(u),
                                            l = i.axes[u],
                                            h = c >= 0 ? s[c] : s[s.length + c];
                                        if (null != l && -1 === [l, null].indexOf(h)) throw new Cse("Input ".concat(r, " is incompatible with layer ") + "".concat(this.name, ": expected axis ").concat(c, " of input shape to ") + "have value ".concat(l, " but got shape ").concat(s, "."))
                                    }
                                }
                                if (null != i.shape)
                                    for (var p = 0; p < i.shape.length; ++p) {
                                        var f = i.shape[p],
                                            d = a.shape[p];
                                        if (null != f && null != d && f !== d) throw new Cse("Input ".concat(r, " is incompatible with layer ") + "".concat(this.name, ": expected shape=").concat(i.shape, ", ") + "found shape=".concat(a.shape, "."))
                                    }
                            }
                        }
                    }
                }
            }, {
                key: "call",
                value: function(e, t) {
                    return e
                }
            }, {
                key: "invokeCallHook",
                value: function(e, t) {
                    null != this._callHook && this._callHook(e, t)
                }
            }, {
                key: "setCallHook",
                value: function(e) {
                    this._callHook = e
                }
            }, {
                key: "clearCallHook",
                value: function() {
                    this._callHook = null
                }
            }, {
                key: "apply",
                value: function(e, t) {
                    var n = this;
                    t = t || {}, this.assertNotDisposed();
                    var r = Lse(e),
                        a = function(e) {
                            var t, n = !0,
                                r = O(Lse(e));
                            try {
                                for (r.s(); !(t = r.n()).done;) {
                                    if (!(t.value instanceof yce)) {
                                        n = !1;
                                        break
                                    }
                                }
                            } catch (e) {
                                r.e(e)
                            } finally {
                                r.f()
                            }
                            return n
                        }(e),
                        i = function(e) {
                            var t, n = !0,
                                r = O(Lse(e));
                            try {
                                for (r.s(); !(t = r.n()).done;) {
                                    if (t.value instanceof yce) {
                                        n = !1;
                                        break
                                    }
                                }
                            } catch (e) {
                                r.e(e)
                            } finally {
                                r.f()
                            }
                            return n
                        }(e);
                    if (a === i) throw new Cse("Arguments to apply() must be all SymbolicTensors or all Tensors");
                    return hue(this.name, (function() {
                        if (!n.built) {
                            n.assertInputCompatibility(e);
                            var a, o = [],
                                s = O(Lse(e));
                            try {
                                for (s.s(); !(a = s.n()).done;) {
                                    var u = a.value;
                                    o.push(u.shape)
                                }
                            } catch (e) {
                                s.e(e)
                            } finally {
                                s.f()
                            }
                            n.build(Mse(o)), n.built = !0, n.initialWeights && n.setWeights(n.initialWeights), null === n._refCount && i && (n._refCount = 1)
                        }
                        if (n.assertInputCompatibility(e), i) {
                            var c = n.call(e, t);
                            n.supportsMasking && n.setMaskMetadata(e, c);
                            var l, h = [],
                                p = O(Lse(c));
                            try {
                                for (p.s(); !(l = p.n()).done;) {
                                    var f = l.value; - 1 !== r.indexOf(f) && (f = f.clone()), h.push(f)
                                }
                            } catch (e) {
                                p.e(e)
                            } finally {
                                p.f()
                            }
                            if (c = Mse(h), null != n.activityRegularizer) throw new Ase("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
                            return c
                        }
                        var d, v = function(e) {
                                e = Lse(e);
                                var t, n = [],
                                    r = O(e);
                                try {
                                    for (r.s(); !(t = r.n()).done;) {
                                        var a = t.value;
                                        n.push(a.shape)
                                    }
                                } catch (e) {
                                    r.e(e)
                                } finally {
                                    r.f()
                                }
                                return Mse(n)
                            }(e),
                            m = n.computeOutputShape(v),
                            g = "float32";
                        if (n.warnOnIncompatibleInputShape(Array.isArray(e) ? v[0] : v), d = null != m && m.length > 0 && Array.isArray(m[0]) ? m.map((function(r, a) {
                                return new yce(g, r, n, Lse(e), t, n.name, a)
                            })) : new yce(g, m, n, Lse(e), t, n.name), n.addInboundNode(e, d, null, null, v, m, t), n._refCount++, null != n.activityRegularizer) throw new Ase("Layer invocation in the presence of activity regularizer(s) is not supported yet.");
                        return d
                    }))
                }
            }, {
                key: "warnOnIncompatibleInputShape",
                value: function(e) {
                    if (null != this.batchInputShape)
                        if (e.length !== this.batchInputShape.length) console.warn("The rank of the input tensor provided (shape: " + "".concat(JSON.stringify(e), ") does not match that of the ") + "batchInputShape (".concat(JSON.stringify(this.batchInputShape), ") ") + "of the layer ".concat(this.name));
                        else {
                            var t = !1;
                            this.batchInputShape.forEach((function(n, r) {
                                null != n && null != e[r] && e[r] !== n && (t = !0)
                            })), t && console.warn("The shape of the input tensor " + "(".concat(JSON.stringify(e), ") does not ") + "match the expectation of layer ".concat(this.name, ": ") + "".concat(JSON.stringify(this.batchInputShape)))
                        }
                }
            }, {
                key: "outputShape",
                get: function() {
                    if (null == this.inboundNodes || 0 === this.inboundNodes.length) throw new Tse("The layer ".concat(this.name, " has never been called and thus has no ") + "defined output shape.");
                    var e, t = [],
                        n = O(this.inboundNodes);
                    try {
                        for (n.s(); !(e = n.n()).done;) {
                            var r = e.value,
                                a = JSON.stringify(r.outputShapes); - 1 === t.indexOf(a) && t.push(a)
                        }
                    } catch (e) {
                        n.e(e)
                    } finally {
                        n.f()
                    }
                    if (1 === t.length) {
                        var i = this.inboundNodes[0].outputShapes;
                        return Array.isArray(i) && Array.isArray(i[0]) && 1 === i.length ? i[0] : i
                    }
                    throw new Tse("The layer ".concat(this.name, " has multiple inbound nodes with different ") + 'output shapes. Hence the notion of "output shape" is ill-defined for the layer.')
                }
            }, {
                key: "countParams",
                value: function() {
                    if (!this.built) throw new Ese("You tried to call countParams() on ".concat(this.name, ", ") + "but the layer is not built yet. Build it first by calling build(batchInputShape).");
                    return pce(this.weights)
                }
            }, {
                key: "build",
                value: function(e) {
                    this.built = !0
                }
            }, {
                key: "getWeights",
                value: function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                    return vce(e ? this.trainableWeights : this.weights)
                }
            }, {
                key: "setWeights",
                value: function(e) {
                    var t = this;
                    X5((function() {
                        var n = t.weights;
                        if (n.length !== e.length) throw new Cse('You called setWeights(weights) on layer "'.concat(t.name, '" ') + "with a weight list of length ".concat(e.length, ", ") + "but the layer was expecting ".concat(n.length, " weights. ") + "Provided weights: ".concat(e, "..."));
                        if (0 !== n.length) {
                            for (var r = [], a = vce(n), i = 0; i < a.length; ++i) {
                                var o = a[i],
                                    s = n[i],
                                    u = e[i];
                                if (!P$(o.shape, u.shape)) throw new Cse("Layer weight shape ".concat(o.shape, " ") + "not compatible with provided weight shape ".concat(u.shape));
                                r.push([s, u])
                            }
                            mce(r)
                        }
                    }))
                }
            }, {
                key: "addWeight",
                value: function(e, t, n, r, a, i, o, s) {
                    if (-1 !== this._addedWeightNames.indexOf(e)) throw new Cse("Duplicate weight name ".concat(e, " for layer ").concat(this.name));
                    this._addedWeightNames.push(e), null == n && (n = "float32"), this.fastWeightInitDuringBuild && (r = null != s ? s() : sce("zeros"));
                    var u = r.apply(t, n),
                        c = new dce(u, n, e, i, o);
                    return u.dispose(), null != a && this.addLoss((function() {
                        return a.apply(c.read())
                    })), null == i && (i = !0), i ? this._trainableWeights.push(c) : this._nonTrainableWeights.push(c), c
                }
            }, {
                key: "setFastWeightInitDuringBuild",
                value: function(e) {
                    this.fastWeightInitDuringBuild = e
                }
            }, {
                key: "addLoss",
                value: function(e) {
                    var t;
                    null == e || Array.isArray(e) && 0 === e.length || (e = Lse(e), void 0 !== this._losses && null !== this._losses && (t = this.losses).push.apply(t, T(e)))
                }
            }, {
                key: "computeOutputShape",
                value: function(e) {
                    return e
                }
            }, {
                key: "computeMask",
                value: function(e, t) {
                    var n = this;
                    if (!this.supportsMasking) {
                        if (null != t) {
                            if (!Array.isArray(t)) throw new TypeError("Layer ".concat(this.name, " does not support masking, ") + "but was passed an inputMask.");
                            t.forEach((function(e) {
                                if (null != e) throw new TypeError("Layer ".concat(n.name, " does not support masking, ") + "but was passed an inputMask.")
                            }))
                        }
                        return null
                    }
                    return t
                }
            }, {
                key: "setMaskMetadata",
                value: function(e, t, n) {
                    if (this.supportsMasking) {
                        var r = this.computeMask(e, n),
                            a = Lse(t),
                            i = Lse(r);
                        if (a.length !== i.length) throw new Error("".concat(this.name, " outputs ").concat(a.length, " tensors ") + "but ".concat(a.length, " masks for those tensors"));
                        for (var o = 0; o < a.length; o++) a[o].kerasMask = i[o]
                    }
                }
            }, {
                key: "addInboundNode",
                value: function(e, t, n, r, a, i) {
                    var o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null,
                        s = Lse(e);
                    t = Lse(t), n = Lse(n), r = Lse(r), a = cce(a), i = cce(i);
                    var u, c = [],
                        l = [],
                        h = [],
                        p = O(s);
                    try {
                        for (p.s(); !(u = p.n()).done;) {
                            var f = u.value;
                            c.push(f.sourceLayer), l.push(f.nodeIndex), h.push(f.tensorIndex)
                        }
                    } catch (e) {
                        p.e(e)
                    } finally {
                        p.f()
                    }
                    new xce({
                        outboundLayer: this,
                        inboundLayers: c,
                        nodeIndices: l,
                        tensorIndices: h,
                        inputTensors: s,
                        outputTensors: t,
                        inputMasks: n,
                        outputMasks: r,
                        inputShapes: a,
                        outputShapes: i
                    }, o);
                    for (var d = 0; d < t.length; d++) t[d].sourceLayer = this, t[d].nodeIndex = this.inboundNodes.length - 1, t[d].tensorIndex = d
                }
            }, {
                key: "getConfig",
                value: function() {
                    var e = {
                        name: this.name,
                        trainable: this.trainable
                    };
                    return null != this.batchInputShape && (e.batchInputShape = this.batchInputShape), null != this.dtype && (e.dtype = this.dtype), e
                }
            }, {
                key: "disposeWeights",
                value: function() {
                    return this.weights.forEach((function(e) {
                        return e.dispose()
                    })), this.weights.length
                }
            }, {
                key: "assertNotDisposed",
                value: function() {
                    if (0 === this._refCount) throw new Error("Layer '".concat(this.name, "' is already disposed."))
                }
            }, {
                key: "dispose",
                value: function() {
                    if (!this.built) throw new Error("Cannot dispose Layer ".concat(this.name, " because it has not been ") + "built yet.");
                    if (null === this._refCount) throw new Error("Cannot dispose Layer ".concat(this.name, " because it has not been used ") + "yet.");
                    this.assertNotDisposed();
                    var e = 0;
                    return 0 == --this._refCount && (e = this.disposeWeights()), {
                        refCountAfterDispose: this._refCount,
                        numDisposedVariables: e
                    }
                }
            }], [{
                key: "nodeKey",
                value: function(e, t) {
                    return e.name + "_ib-" + t.toString()
                }
            }]), n
        }(Hre);

    function Ice(e, t, n) {
        if ((null == t || null != n && n > 0) && (t = e.sourceLayer, n = e.nodeIndex), 0 === t.inboundNodes.length) return [e];
        var r = t.inboundNodes[n];
        if (0 === r.inboundLayers.length) return r.inputTensors;
        for (var a = [], i = 0; i < r.inboundLayers.length; i++) {
            var o, s = O(Ice(r.inputTensors[i], r.inboundLayers[i], r.nodeIndices[i]));
            try {
                for (s.s(); !(o = s.n()).done;) {
                    var u = o.value; - 1 === a.indexOf(u) && a.push(u)
                }
            } catch (e) {
                s.e(e)
            } finally {
                s.f()
            }
        }
        return a
    }
    var Nce = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            if (l(this, n), r = t.call(this, {
                    dtype: e.dtype,
                    name: null != e.name ? e.name : eue("input").toString()
                }), null == e.batchSize && (e.batchSize = null), null == e.sparse && (e.sparse = !1), r.trainable = !1, r.built = !0, r.sparse = e.sparse, null != e.inputShape && null != e.batchInputShape) throw new Cse("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");
            var a = e.batchInputShape;
            if (null == a) {
                if (null == e.inputShape) throw new Cse("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");
                a = [e.batchSize].concat(e.inputShape)
            } else if (null != e.batchSize) throw new Cse("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");
            var i = e.dtype || "float32";
            r.batchInputShape = a, r.dtype = i, r.inputSpec = [{
                shape: a
            }];
            var o = new yce(r.dtype, r.batchInputShape, x(r), [], {}, r.name);
            return o.nodeIndex = 0, o.tensorIndex = 0, new xce({
                outboundLayer: x(r),
                inboundLayers: [],
                nodeIndices: [],
                tensorIndices: [],
                inputTensors: [o],
                outputTensors: [o],
                inputMasks: [null],
                outputMasks: [null],
                inputShapes: [a],
                outputShapes: [a]
            }), r
        }
        return p(n, [{
            key: "apply",
            value: function(e, t) {
                throw new Cse("Cannot pass any input to an " + "InputLayer's apply() method. InputLayer name: ".concat(this.name))
            }
        }, {
            key: "dispose",
            value: function() {
                return {
                    refCountAfterDispose: this._refCount,
                    numDisposedVariables: 0
                }
            }
        }, {
            key: "getConfig",
            value: function() {
                return {
                    batchInputShape: this.batchInputShape,
                    dtype: this.dtype,
                    sparse: this.sparse,
                    name: this.name
                }
            }
        }]), n
    }(wce);

    function Sce(e) {
        if (null == e.batchShape && null == e.shape) throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");
        if (null != e.batchShape && null != e.shape) throw new Cse("Please provide either a `shape` or `batchShape` argument to Input, but not both.");
        var t = e.batchShape;
        null != e.shape && null == t && (t = [null].concat(e.shape));
        var n = e.dtype;
        return null == n && (n = "float32"), new Nce({
            batchInputShape: t,
            name: e.name,
            dtype: n,
            sparse: e.sparse
        }).inboundNodes[0].outputTensors[0]
    }
    Nce.className = "InputLayer", Kre(Nce);
    var Tce = function() {
            function e(t) {
                if (l(this, e), this.id2Value = {}, this.id2Mask = {}, this.name2Id = {}, t instanceof e)
                    for (var n in t.id2Value) this.id2Value[n] = t.id2Value[n], n in t.id2Mask && (this.id2Mask[n] = t.id2Mask[n]);
                else {
                    if (null == t) return;
                    var r, a = O(t);
                    try {
                        for (a.s(); !(r = a.n()).done;) {
                            var i = r.value;
                            this.add(i.key, i.value)
                        }
                    } catch (e) {
                        a.e(e)
                    } finally {
                        a.f()
                    }
                }
            }
            return p(e, [{
                key: "add",
                value: function(e, t, n) {
                    if (null != this.id2Value[e.id]) throw new Cse("Duplicate key: name=".concat(e.name, ", id=").concat(e.id));
                    return this.id2Value[e.id] = function(e, t) {
                        if (null == e.dtype || e.dtype === t.dtype) return t;
                        try {
                            return h8(t, e.dtype)
                        } catch (n) {
                            throw new Cse("The dtype of the feed (".concat(t.dtype, ") can not be cast to the dtype ") + "of the key '".concat(e.name, "' (").concat(e.dtype, ")."))
                        }
                    }(e, t), this.name2Id[e.name] = e.id, null != n && (this.id2Mask[e.id] = n), this
                }
            }, {
                key: "addFeed",
                value: function(e) {
                    this.add(e.key, e.value)
                }
            }, {
                key: "hasKey",
                value: function(e) {
                    return null != this.id2Value[e.id]
                }
            }, {
                key: "names",
                value: function() {
                    return Object.keys(this.name2Id)
                }
            }, {
                key: "getValue",
                value: function(e) {
                    if (e instanceof yce) {
                        if (null == this.id2Value[e.id]) throw new Cse("Nonexistent key: ".concat(e.name));
                        return this.id2Value[e.id]
                    }
                    var t = this.name2Id[e];
                    if (null == t) throw new Cse("Feed dict has no SymbolicTensor name: ".concat(e));
                    return this.id2Value[t]
                }
            }, {
                key: "getMask",
                value: function(e) {
                    if (e instanceof yce) {
                        if (null == this.id2Value[e.id]) throw new Cse("Nonexistent key: ".concat(e.name));
                        return this.id2Mask[e.id]
                    }
                    var t = this.name2Id[e];
                    if (null == t) throw new Cse("Feed dict has no SymbolicTensor name: ".concat(e));
                    return this.id2Mask[t]
                }
            }, {
                key: "disposeMasks",
                value: function() {
                    null != this.id2Mask && Y5(this.id2Mask)
                }
            }]), e
        }(),
        Ece = new _se,
        Cce = new _se;

    function Ace(e, t, n, r) {
        var a, i = null != n && n.training,
            o = Array.isArray(e),
            s = o ? e : [e],
            u = s.map((function(e) {
                return e.name
            })),
            c = [],
            l = t.names(),
            h = O(u);
        try {
            for (h.s(); !(a = h.n()).done;) {
                var p = a.value; - 1 !== l.indexOf(p) ? c.push(t.getValue(p)) : c.push(null)
            }
        } catch (e) {
            h.e(e)
        } finally {
            h.f()
        }
        null != r && (r.maxNumTensors = -1 / 0, r.minNumTensors = 1 / 0);
        var f, d = u.join(",") + "|" + t.names().sort().join(","),
            v = Ece.get(d);
        if (null == v) {
            var m = function(e, t) {
                F$(null != e && e.length > 0, (function() {
                    return "Expected at least one fetch, got none"
                }));
                var n = [],
                    r = {};
                if (1 === e.length) {
                    var a = _ce(e[0], t);
                    n = a.sorted, r = a.recipientMap
                } else {
                    var i, o = new Set,
                        s = O(e);
                    try {
                        for (s.s(); !(i = s.n()).done;) {
                            var u, c = _ce(i.value, t),
                                l = c.sorted,
                                h = c.recipientMap,
                                p = O(l);
                            try {
                                for (p.s(); !(u = p.n()).done;) {
                                    var f = u.value;
                                    o.has(f.name) || (n.push(f), o.add(f.name))
                                }
                            } catch (e) {
                                p.e(e)
                            } finally {
                                p.f()
                            }
                            var d = function(e) {
                                null == r[e] && (r[e] = new Set), h[e].forEach((function(t) {
                                    return r[e].add(t)
                                }))
                            };
                            for (var v in h) d(v)
                        }
                    } catch (e) {
                        s.e(e)
                    } finally {
                        s.f()
                    }
                }
                return {
                    sorted: n,
                    recipientCounts: Rce(r)
                }
            }(s, t);
            v = m.sorted, f = m.recipientCounts, Ece.put(d, v), Cce.put(d, f)
        }
        f = {}, i || Object.assign(f, Cce.get(d));
        for (var g = new Tce(t), y = 0; y < v.length; ++y) {
            if (null != r) {
                var b = K5().numTensors;
                b > r.maxNumTensors && (r.maxNumTensors = b), b < r.minNumTensors && (r.minNumTensors = b)
            }
            var x = v[y],
                k = x.sourceLayer;
            if (!(k instanceof Nce)) {
                var w, I = [],
                    N = [],
                    S = [],
                    T = !1,
                    E = O(x.inputs);
                try {
                    for (E.s(); !(w = E.n()).done;) {
                        var C = w.value,
                            A = g.getValue(C),
                            R = g.getMask(C);
                        I.push(A), N.push(R), null != R && (T = !0), i || (f[C.name]--, 0 !== f[C.name] || t.hasKey(C) || -1 !== u.indexOf(C.name) || A.isDisposed || !0 === C.sourceLayer.stateful || S.push(A))
                    }
                } catch (e) {
                    E.e(e)
                } finally {
                    E.f()
                }
                T && ((n = n || {}).mask = N[0]);
                var _ = Lse(k.apply(I, n)),
                    F = null;
                k.supportsMasking && (F = k.computeMask(I, N));
                for (var D = Oce(x), M = Array.isArray(D) ? D : [D], L = 0; L < M.length; ++L) {
                    g.hasKey(M[L]) || g.add(M[L], _[L], Array.isArray(F) ? F[0] : F);
                    var z = u.indexOf(M[L].name); - 1 !== z && (c[z] = _[L])
                }
                i || Y5(S)
            }
        }
        return g.disposeMasks(), o ? c : c[0]
    }

    function Rce(e) {
        var t = {};
        for (var n in e) t[n] = e[n].size;
        return t
    }

    function _ce(e, t) {
        var n, r = new Set,
            a = [],
            i = {},
            o = O(t.names());
        try {
            for (o.s(); !(n = o.n()).done;) {
                var s = n.value;
                r.add(s)
            }
        } catch (e) {
            o.e(e)
        } finally {
            o.f()
        }
        var u = [],
            c = [];
        for (u.push(e); u.length > 0;) {
            var l = u[u.length - 1];
            if (r.has(l.name)) u.pop();
            else {
                var h = c[c.length - 1] === u.length - 1;
                if (0 === l.inputs.length || h) u.pop(), a.push(l), r.add(l.name), h && c.pop();
                else {
                    c.push(u.length - 1);
                    var p, f = O(l.inputs);
                    try {
                        for (f.s(); !(p = f.n()).done;) {
                            var d = p.value;
                            null == i[d.name] && (i[d.name] = new Set), i[d.name].add(l.name), r.has(d.name) || u.push(d)
                        }
                    } catch (e) {
                        f.e(e)
                    } finally {
                        f.f()
                    }
                }
            }
        }
        return {
            sorted: a,
            recipientMap: i
        }
    }

    function Oce(e) {
        var t;
        if (1 === e.sourceLayer.inboundNodes.length) t = e.sourceLayer.output;
        else {
            for (var n = null, r = 0; r < e.sourceLayer.inboundNodes.length; ++r) {
                var a, i = O(e.sourceLayer.inboundNodes[r].outputTensors);
                try {
                    for (i.s(); !(a = i.n()).done;) {
                        if (a.value.id === e.id) {
                            n = r;
                            break
                        }
                    }
                } catch (e) {
                    i.e(e)
                } finally {
                    i.f()
                }
            }
            t = e.sourceLayer.getOutputAt(n)
        }
        return t
    }

    function Fce(e, t) {
        return X5((function() {
            return o9(u9(g8(e, e), t, !0))
        }))
    }
    k0().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES", (function() {
        return 100
    }), (function(e) {
        null != Ece && Ece.setMaxEntries(e), null != Cce && Cce.setMaxEntries(e)
    }));
    var Dce = function(e) {
            d(n, e);
            var t = w(n);

            function n() {
                return l(this, n), t.apply(this, arguments)
            }
            return p(n, [{
                key: "getConfig",
                value: function() {
                    return {}
                }
            }]), n
        }(Hre),
        Mce = function(e) {
            d(n, e);
            var t = w(n);

            function n(e) {
                var r;
                return l(this, n), (r = t.call(this)).defaultMaxValue = 2, r.defaultAxis = 0, r.maxValue = null != e.maxValue ? e.maxValue : r.defaultMaxValue, r.axis = null != e.axis ? e.axis : r.defaultAxis, r
            }
            return p(n, [{
                key: "apply",
                value: function(e) {
                    var t = this;
                    return X5((function() {
                        var n = Fce(e, t.axis),
                            r = d7(n, 0, t.maxValue);
                        return g8(e, m8(r, d8(kue(), n)))
                    }))
                }
            }, {
                key: "getConfig",
                value: function() {
                    return {
                        maxValue: this.maxValue,
                        axis: this.axis
                    }
                }
            }]), n
        }(Dce);
    Mce.className = "MaxNorm", Kre(Mce);
    var Lce = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            return l(this, n), (r = t.call(this)).defaultAxis = 0, r.axis = null != e.axis ? e.axis : r.defaultAxis, r
        }
        return p(n, [{
            key: "apply",
            value: function(e) {
                var t = this;
                return X5((function() {
                    return m8(e, d8(kue(), Fce(e, t.axis)))
                }))
            }
        }, {
            key: "getConfig",
            value: function() {
                return {
                    axis: this.axis
                }
            }
        }]), n
    }(Dce);
    Lce.className = "UnitNorm", Kre(Lce);
    var zce = function(e) {
        d(n, e);
        var t = w(n);

        function n() {
            return l(this, n), t.apply(this, arguments)
        }
        return p(n, [{
            key: "apply",
            value: function(e) {
                return lte(e)
            }
        }]), n
    }(Dce);
    zce.className = "NonNeg", Kre(zce);
    var Pce = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            return l(this, n), (r = t.call(this)).defaultMinValue = 0, r.defaultMaxValue = 1, r.defaultRate = 1, r.defaultAxis = 0, r.minValue = null != e.minValue ? e.minValue : r.defaultMinValue, r.maxValue = null != e.maxValue ? e.maxValue : r.defaultMaxValue, r.rate = null != e.rate ? e.rate : r.defaultRate, r.axis = null != e.axis ? e.axis : r.defaultAxis, r
        }
        return p(n, [{
            key: "apply",
            value: function(e) {
                var t = this;
                return X5((function() {
                    var n = Fce(e, t.axis),
                        r = d8(g8(t.rate, d7(n, t.minValue, t.maxValue)), g8(1 - t.rate, n));
                    return g8(e, m8(r, d8(kue(), n)))
                }))
            }
        }, {
            key: "getConfig",
            value: function() {
                return {
                    minValue: this.minValue,
                    maxValue: this.maxValue,
                    rate: this.rate,
                    axis: this.axis
                }
            }
        }]), n
    }(Dce);
    Pce.className = "MinMaxNorm", Kre(Pce);
    var Bce = {
        maxNorm: "MaxNorm",
        minMaxNorm: "MinMaxNorm",
        nonNeg: "NonNeg",
        unitNorm: "UnitNorm"
    };

    function Wce(e) {
        return Wse(e)
    }

    function Uce(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return Vse(e, qre.getMap().classNameMap, t, "constraint")
    }

    function Vce(e) {
        return null == e ? null : "string" == typeof e ? Uce({
            className: e in Bce ? Bce[e] : e,
            config: {}
        }) : e instanceof Dce ? e : Uce(e)
    }
    var Gce = {
        __proto__: null,
        maxNorm: function(e) {
            return new Mce(e)
        },
        minMaxNorm: function(e) {
            return new Pce(e)
        },
        nonNeg: function() {
            return new zce
        },
        unitNorm: function(e) {
            return new Lce(e)
        }
    };
    var jce, Hce = {
        __proto__: null,
        constant: function(e) {
            return new Hue(e)
        },
        glorotNormal: function(e) {
            return new Que(e)
        },
        glorotUniform: function(e) {
            return new Zue(e)
        },
        heNormal: function(e) {
            return new $ue(e)
        },
        heUniform: function(e) {
            return new ece(e)
        },
        identity: function(e) {
            return new Yue(e)
        },
        leCunNormal: function(e) {
            return new tce(e)
        },
        leCunUniform: function(e) {
            return new nce(e)
        },
        ones: function() {
            return new jue
        },
        orthogonal: function(e) {
            return new rce(e)
        },
        randomNormal: function(e) {
            return new Kue(e)
        },
        randomUniform: function(e) {
            return new que(e)
        },
        truncatedNormal: function(e) {
            return new Xue(e)
        },
        varianceScaling: function(e) {
            return new Jue(e)
        },
        zeros: function() {
            return new Gue
        }
    };

    function qce(e) {
        return Kce.apply(this, arguments)
    }

    function Kce() {
        return Kce = c(o().mark((function e(t) {
            var n, r, a, i, s, u, c, l;
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        if (null != t) {
                            e.next = 2;
                            break
                        }
                        return e.abrupt("return");
                    case 2:
                        for (i in n = [], r = [], a = [], t) "number" != typeof(s = t[i]) && (u = s, n.push(u.data()), r.push(i), a.push(u));
                        if (!(n.length > 0)) {
                            e.next = 12;
                            break
                        }
                        return e.next = 9, Promise.all(n);
                    case 9:
                        for (c = e.sent, l = 0; l < c.length; ++l) t[r[l]] = c[l][0];
                        Y5(a);
                    case 12:
                    case "end":
                        return e.stop()
                }
            }), e)
        }))), Kce.apply(this, arguments)
    }

    function Xce(e) {
        if (null != e)
            for (var t in e) {
                var n = e[t];
                "number" != typeof n && n.dispose()
            }
    }! function(e) {
        e[e.SILENT = 0] = "SILENT", e[e.VERBOSE = 1] = "VERBOSE"
    }(jce || (jce = {}));
    var Yce = function() {
            function e() {
                l(this, e), this.validationData = null
            }
            var t, n, r, a, i, s;
            return p(e, [{
                key: "setParams",
                value: function(e) {
                    this.params = e
                }
            }, {
                key: "onEpochBegin",
                value: (s = c(o().mark((function e(t, n) {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                            case "end":
                                return e.stop()
                        }
                    }), e)
                }))), function(e, t) {
                    return s.apply(this, arguments)
                })
            }, {
                key: "onEpochEnd",
                value: (i = c(o().mark((function e(t, n) {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                            case "end":
                                return e.stop()
                        }
                    }), e)
                }))), function(e, t) {
                    return i.apply(this, arguments)
                })
            }, {
                key: "onBatchBegin",
                value: (a = c(o().mark((function e(t, n) {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                            case "end":
                                return e.stop()
                        }
                    }), e)
                }))), function(e, t) {
                    return a.apply(this, arguments)
                })
            }, {
                key: "onBatchEnd",
                value: (r = c(o().mark((function e(t, n) {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                            case "end":
                                return e.stop()
                        }
                    }), e)
                }))), function(e, t) {
                    return r.apply(this, arguments)
                })
            }, {
                key: "onTrainBegin",
                value: (n = c(o().mark((function e(t) {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                            case "end":
                                return e.stop()
                        }
                    }), e)
                }))), function(e) {
                    return n.apply(this, arguments)
                })
            }, {
                key: "onTrainEnd",
                value: (t = c(o().mark((function e(t) {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                            case "end":
                                return e.stop()
                        }
                    }), e)
                }))), function(e) {
                    return t.apply(this, arguments)
                })
            }, {
                key: "setModel",
                value: function(e) {}
            }]), e
        }(),
        Jce = function() {
            function e(t) {
                var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 10;
                l(this, e), null == t && (t = []), this.callbacks = t, this.queueLength = n
            }
            var t, n, r, a, i, s;
            return p(e, [{
                key: "append",
                value: function(e) {
                    this.callbacks.push(e)
                }
            }, {
                key: "setParams",
                value: function(e) {
                    var t, n = O(this.callbacks);
                    try {
                        for (n.s(); !(t = n.n()).done;) {
                            t.value.setParams(e)
                        }
                    } catch (e) {
                        n.e(e)
                    } finally {
                        n.f()
                    }
                }
            }, {
                key: "setModel",
                value: function(e) {
                    var t, n = O(this.callbacks);
                    try {
                        for (n.s(); !(t = n.n()).done;) {
                            t.value.setModel(e)
                        }
                    } catch (e) {
                        n.e(e)
                    } finally {
                        n.f()
                    }
                }
            }, {
                key: "onEpochBegin",
                value: (s = c(o().mark((function e(t, n) {
                    var r, a, i;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                null == n && (n = {}), r = O(this.callbacks), e.prev = 2, r.s();
                            case 4:
                                if ((a = r.n()).done) {
                                    e.next = 10;
                                    break
                                }
                                return i = a.value, e.next = 8, i.onEpochBegin(t, n);
                            case 8:
                                e.next = 4;
                                break;
                            case 10:
                                e.next = 15;
                                break;
                            case 12:
                                e.prev = 12, e.t0 = e.catch(2), r.e(e.t0);
                            case 15:
                                return e.prev = 15, r.f(), e.finish(15);
                            case 18:
                            case "end":
                                return e.stop()
                        }
                    }), e, this, [
                        [2, 12, 15, 18]
                    ])
                }))), function(e, t) {
                    return s.apply(this, arguments)
                })
            }, {
                key: "onEpochEnd",
                value: (i = c(o().mark((function e(t, n) {
                    var r, a, i;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                null == n && (n = {}), r = O(this.callbacks), e.prev = 2, r.s();
                            case 4:
                                if ((a = r.n()).done) {
                                    e.next = 10;
                                    break
                                }
                                return i = a.value, e.next = 8, i.onEpochEnd(t, n);
                            case 8:
                                e.next = 4;
                                break;
                            case 10:
                                e.next = 15;
                                break;
                            case 12:
                                e.prev = 12, e.t0 = e.catch(2), r.e(e.t0);
                            case 15:
                                return e.prev = 15, r.f(), e.finish(15);
                            case 18:
                            case "end":
                                return e.stop()
                        }
                    }), e, this, [
                        [2, 12, 15, 18]
                    ])
                }))), function(e, t) {
                    return i.apply(this, arguments)
                })
            }, {
                key: "onBatchBegin",
                value: (a = c(o().mark((function e(t, n) {
                    var r, a, i;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                null == n && (n = {}), r = O(this.callbacks), e.prev = 2, r.s();
                            case 4:
                                if ((a = r.n()).done) {
                                    e.next = 10;
                                    break
                                }
                                return i = a.value, e.next = 8, i.onBatchBegin(t, n);
                            case 8:
                                e.next = 4;
                                break;
                            case 10:
                                e.next = 15;
                                break;
                            case 12:
                                e.prev = 12, e.t0 = e.catch(2), r.e(e.t0);
                            case 15:
                                return e.prev = 15, r.f(), e.finish(15);
                            case 18:
                            case "end":
                                return e.stop()
                        }
                    }), e, this, [
                        [2, 12, 15, 18]
                    ])
                }))), function(e, t) {
                    return a.apply(this, arguments)
                })
            }, {
                key: "onBatchEnd",
                value: (r = c(o().mark((function e(t, n) {
                    var r, a, i;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                null == n && (n = {}), r = O(this.callbacks), e.prev = 2, r.s();
                            case 4:
                                if ((a = r.n()).done) {
                                    e.next = 10;
                                    break
                                }
                                return i = a.value, e.next = 8, i.onBatchEnd(t, n);
                            case 8:
                                e.next = 4;
                                break;
                            case 10:
                                e.next = 15;
                                break;
                            case 12:
                                e.prev = 12, e.t0 = e.catch(2), r.e(e.t0);
                            case 15:
                                return e.prev = 15, r.f(), e.finish(15);
                            case 18:
                            case "end":
                                return e.stop()
                        }
                    }), e, this, [
                        [2, 12, 15, 18]
                    ])
                }))), function(e, t) {
                    return r.apply(this, arguments)
                })
            }, {
                key: "onTrainBegin",
                value: (n = c(o().mark((function e(t) {
                    var n, r, a;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                null == t && (t = {}), n = O(this.callbacks), e.prev = 2, n.s();
                            case 4:
                                if ((r = n.n()).done) {
                                    e.next = 10;
                                    break
                                }
                                return a = r.value, e.next = 8, a.onTrainBegin(t);
                            case 8:
                                e.next = 4;
                                break;
                            case 10:
                                e.next = 15;
                                break;
                            case 12:
                                e.prev = 12, e.t0 = e.catch(2), n.e(e.t0);
                            case 15:
                                return e.prev = 15, n.f(), e.finish(15);
                            case 18:
                            case "end":
                                return e.stop()
                        }
                    }), e, this, [
                        [2, 12, 15, 18]
                    ])
                }))), function(e) {
                    return n.apply(this, arguments)
                })
            }, {
                key: "onTrainEnd",
                value: (t = c(o().mark((function e(t) {
                    var n, r, a;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                null == t && (t = {}), n = O(this.callbacks), e.prev = 2, n.s();
                            case 4:
                                if ((r = n.n()).done) {
                                    e.next = 10;
                                    break
                                }
                                return a = r.value, e.next = 8, a.onTrainEnd(t);
                            case 8:
                                e.next = 4;
                                break;
                            case 10:
                                e.next = 15;
                                break;
                            case 12:
                                e.prev = 12, e.t0 = e.catch(2), n.e(e.t0);
                            case 15:
                                return e.prev = 15, n.f(), e.finish(15);
                            case 18:
                            case "end":
                                return e.stop()
                        }
                    }), e, this, [
                        [2, 12, 15, 18]
                    ])
                }))), function(e) {
                    return t.apply(this, arguments)
                })
            }]), e
        }(),
        Zce = function(e) {
            d(i, e);
            var t, n, r, a = w(i);

            function i() {
                return l(this, i), a.call(this)
            }
            return p(i, [{
                key: "onEpochBegin",
                value: (r = c(o().mark((function e(t) {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                this.seen = 0, this.totals = {};
                            case 2:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e) {
                    return r.apply(this, arguments)
                })
            }, {
                key: "onBatchEnd",
                value: (n = c(o().mark((function e(t, n) {
                    var r, a, i, s = this;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                null == n && (n = {}), r = null == n.size ? 0 : n.size, this.seen += r, a = o().mark((function e(t) {
                                    var a, i, u;
                                    return o().wrap((function(e) {
                                        for (;;) switch (e.prev = e.next) {
                                            case 0:
                                                "number" == typeof(a = n[t]) ? (s.totals.hasOwnProperty(t) || (s.totals[t] = 0), s.totals[t] = s.totals[t] + a * r) : (t in s.totals ? i = s.totals[t] : s.totals[t] = 0, u = X5((function() {
                                                    return d8(s.totals[t], g8(a, r))
                                                })), s.totals[t] = u, null != i && i.dispose());
                                            case 2:
                                            case "end":
                                                return e.stop()
                                        }
                                    }), e)
                                })), e.t0 = o().keys(n);
                            case 5:
                                if ((e.t1 = e.t0()).done) {
                                    e.next = 10;
                                    break
                                }
                                return i = e.t1.value, e.delegateYield(a(i), "t2", 8);
                            case 8:
                                e.next = 5;
                                break;
                            case 10:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e, t) {
                    return n.apply(this, arguments)
                })
            }, {
                key: "onEpochEnd",
                value: (t = c(o().mark((function e(t, n) {
                    var r, a, i, s = this;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (null == n) {
                                    e.next = 20;
                                    break
                                }
                                r = O(this.params.metrics), e.prev = 2, i = o().mark((function e() {
                                    var t;
                                    return o().wrap((function(e) {
                                        for (;;) switch (e.prev = e.next) {
                                            case 0:
                                                if (t = a.value, null != s.totals[t]) {
                                                    e.next = 3;
                                                    break
                                                }
                                                return e.abrupt("return", "continue");
                                            case 3:
                                                "number" == typeof s.totals[t] ? n[t] = s.totals[t] / s.seen : X5((function() {
                                                    var e = g8(m8(1, s.seen), s.totals[t]);
                                                    n[t] = e, s.totals[t].dispose(), J5(n[t])
                                                }));
                                            case 4:
                                            case "end":
                                                return e.stop()
                                        }
                                    }), e)
                                })), r.s();
                            case 5:
                                if ((a = r.n()).done) {
                                    e.next = 12;
                                    break
                                }
                                return e.delegateYield(i(), "t0", 7);
                            case 7:
                                if ("continue" !== e.t0) {
                                    e.next = 10;
                                    break
                                }
                                return e.abrupt("continue", 10);
                            case 10:
                                e.next = 5;
                                break;
                            case 12:
                                e.next = 17;
                                break;
                            case 14:
                                e.prev = 14, e.t1 = e.catch(2), r.e(e.t1);
                            case 17:
                                return e.prev = 17, r.f(), e.finish(17);
                            case 20:
                            case "end":
                                return e.stop()
                        }
                    }), e, this, [
                        [2, 14, 17, 20]
                    ])
                }))), function(e, n) {
                    return t.apply(this, arguments)
                })
            }]), i
        }(Yce),
        Qce = function(e) {
            d(i, e);
            var t, n, r, a = w(i);

            function i() {
                return l(this, i), a.apply(this, arguments)
            }
            return p(i, [{
                key: "onTrainBegin",
                value: (r = c(o().mark((function e(t) {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                this.epoch = [], this.history = {};
                            case 2:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e) {
                    return r.apply(this, arguments)
                })
            }, {
                key: "onEpochEnd",
                value: (n = c(o().mark((function e(t, n) {
                    var r;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                for (r in null == n && (n = {}), this.epoch.push(t), n) null == this.history[r] && (this.history[r] = []), this.history[r].push(n[r]);
                            case 3:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e, t) {
                    return n.apply(this, arguments)
                })
            }, {
                key: "syncData",
                value: (t = c(o().mark((function e() {
                    var t, n, r, a, i, s, u, c, l;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                for (a in t = [], n = [], r = [], this.history)
                                    for (i = this.history[a], s = 0; s < i.length; ++s) "number" != typeof i[s] && (u = i[s], t.push(u.data()), n.push(a), r.push(s));
                                return e.next = 6, Promise.all(t);
                            case 6:
                                for (c = e.sent, l = 0; l < c.length; ++l) this.history[n[l]][r[l]].dispose(), this.history[n[l]][r[l]] = c[l][0];
                            case 8:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return t.apply(this, arguments)
                })
            }]), i
        }(Yce),
        $ce = function(e) {
            d(f, e);
            var t, n, r, a, i, s, u, h = w(f);

            function f(e, t) {
                var n;
                if (l(this, f), (n = h.call(this)).currentEpoch = 0, n.nowFunc = e.nowFunc, n.nextFrameFunc = e.nextFrameFunc || aie, n.yieldEvery = t || "auto", "auto" === n.yieldEvery && (n.yieldEvery = 125), "never" === n.yieldEvery && null != e.onYield) throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");
                return t0(n.yieldEvery) && (n.maybeWait = function(e, t, n) {
                    var r, a = null != n ? n() : z4();
                    return function() {
                        var i = null != n ? n() : z4();
                        return i - a < t ? r : (a = i, r = e.apply(void 0, arguments))
                    }
                }(n.maybeWait.bind(x(n)), n.yieldEvery, n.nowFunc)), n.trainBegin = e.onTrainBegin, n.trainEnd = e.onTrainEnd, n.epochBegin = e.onEpochBegin, n.epochEnd = e.onEpochEnd, n.batchBegin = e.onBatchBegin, n.batchEnd = e.onBatchEnd, n.yield = e.onYield, n
            }
            return p(f, [{
                key: "maybeWait",
                value: (u = c(o().mark((function e(t, n, r) {
                    var a;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (a = [], null == this.yield) {
                                    e.next = 5;
                                    break
                                }
                                return e.next = 4, qce(r);
                            case 4:
                                a.push(this.yield(t, n, r));
                            case 5:
                                return a.push(this.nextFrameFunc()), e.next = 8, Promise.all(a);
                            case 8:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e, t, n) {
                    return u.apply(this, arguments)
                })
            }, {
                key: "onEpochBegin",
                value: (s = c(o().mark((function e(t, n) {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (this.currentEpoch = t, null == this.epochBegin) {
                                    e.next = 6;
                                    break
                                }
                                return e.next = 4, qce(n);
                            case 4:
                                return e.next = 6, this.epochBegin(t, n);
                            case 6:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e, t) {
                    return s.apply(this, arguments)
                })
            }, {
                key: "onEpochEnd",
                value: (i = c(o().mark((function e(t, n) {
                    var r;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (r = [], null == this.epochEnd) {
                                    e.next = 5;
                                    break
                                }
                                return e.next = 4, qce(n);
                            case 4:
                                r.push(this.epochEnd(t, n));
                            case 5:
                                return "epoch" === this.yieldEvery && r.push(this.nextFrameFunc()), e.next = 8, Promise.all(r);
                            case 8:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e, t) {
                    return i.apply(this, arguments)
                })
            }, {
                key: "onBatchBegin",
                value: (a = c(o().mark((function e(t, n) {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (null == this.batchBegin) {
                                    e.next = 5;
                                    break
                                }
                                return e.next = 3, qce(n);
                            case 3:
                                return e.next = 5, this.batchBegin(t, n);
                            case 5:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e, t) {
                    return a.apply(this, arguments)
                })
            }, {
                key: "onBatchEnd",
                value: (r = c(o().mark((function e(t, n) {
                    var r;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (r = [], null == this.batchEnd) {
                                    e.next = 5;
                                    break
                                }
                                return e.next = 4, qce(n);
                            case 4:
                                r.push(this.batchEnd(t, n));
                            case 5:
                                return "batch" === this.yieldEvery ? r.push(this.nextFrameFunc()) : t0(this.yieldEvery) && r.push(this.maybeWait(this.currentEpoch, t, n)), e.next = 8, Promise.all(r);
                            case 8:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e, t) {
                    return r.apply(this, arguments)
                })
            }, {
                key: "onTrainBegin",
                value: (n = c(o().mark((function e(t) {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (null == this.trainBegin) {
                                    e.next = 5;
                                    break
                                }
                                return e.next = 3, qce(t);
                            case 3:
                                return e.next = 5, this.trainBegin(t);
                            case 5:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e) {
                    return n.apply(this, arguments)
                })
            }, {
                key: "onTrainEnd",
                value: (t = c(o().mark((function e(t) {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (null == this.trainEnd) {
                                    e.next = 5;
                                    break
                                }
                                return e.next = 3, qce(t);
                            case 3:
                                return e.next = 5, this.trainEnd(t);
                            case 5:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e) {
                    return t.apply(this, arguments)
                })
            }]), f
        }(Yce);

    function ele(e, t) {
        return null == e && (e = {}), e instanceof Yce ? [e] : Array.isArray(e) && e[0] instanceof Yce ? e : Lse(e).map((function(e) {
            return new $ce(e, t)
        }))
    }
    var tle = function() {
        function e() {
            l(this, e)
        }
        return p(e, null, [{
            key: "registerCallbackConstructor",
            value: function(t, n) {
                F$(t >= 0 && Number.isInteger(t), (function() {
                    return "Verbosity level is expected to be an integer >= 0, " + "but got ".concat(t)
                })), e.checkForDuplicate(n), null == e.constructors[t] && (e.constructors[t] = []), e.constructors[t].push(n)
            }
        }, {
            key: "checkForDuplicate",
            value: function(t) {
                for (var n in e.constructors) {
                    e.constructors[+n].forEach((function(e) {
                        if (e === t) throw new Cse("Duplicate callback constructor.")
                    }))
                }
            }
        }, {
            key: "clear",
            value: function() {
                e.constructors = {}
            }
        }, {
            key: "createCallbacks",
            value: function(t) {
                var n = [];
                for (var r in e.constructors) {
                    var a = +r;
                    t >= a && n.push.apply(n, T(e.constructors[a]))
                }
                return n.map((function(e) {
                    return new e
                }))
            }
        }]), e
    }();

    function nle(e, t, n, r, a, i, o, s, u) {
        var c = new Qce,
            l = [new Zce].concat(T(tle.createCallbacks(t)));
        null != e && l.push.apply(l, T(e)), l.push(c);
        var h = new Jce(l);
        return h.setParams({
            epochs: n,
            initialEpoch: r,
            samples: a,
            steps: i,
            batchSize: o,
            verbose: t,
            doValidation: s,
            metrics: u
        }), {
            callbackList: h,
            history: c
        }
    }

    function rle(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
            n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        return Vse(e, qre.getMap().classNameMap, t, "layer", n)
    }

    function ale(e, t) {
        return X5((function() {
            "float32" !== e.dtype && (e = h8(e, "float32"));
            var n = u9(Due(e), t, !0),
                r = f7(n.shape, kue()),
                a = o9(Z9(n, r));
            return m8(e, a)
        }))
    }

    function ile(e, t) {
        return X5((function() {
            return Q9(Due(P9(t, e)), -1)
        }))
    }

    function ole(e, t) {
        return X5((function() {
            return Q9(y8(P9(t, e)), -1)
        }))
    }

    function sle(e, t) {
        return X5((function() {
            var n = P9(e, t),
                r = d7(y8(e), kue(), Number.MAX_VALUE),
                a = y8(m8(n, r));
            return g8(100, Q9(a, -1))
        }))
    }

    function ule(e, t) {
        return X5((function() {
            var n = d7(t, kue(), Number.MAX_VALUE),
                r = R9(d8(1, n)),
                a = d7(e, kue(), Number.MAX_VALUE),
                i = R9(d8(1, a));
            return Q9(Due(P9(r, i)), -1)
        }))
    }

    function cle(e, t) {
        var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        return X5((function() {
            if (n) t = Rte(t);
            else {
                var r = u9(t, t.shape.length - 1, !0);
                t = m8(t, r)
            }
            return t = d7(t, kue(), 1 - kue()), M9(u9(g8(h8(e, "float32"), R9(t)), t.shape.length - 1))
        }))
    }

    function lle(e, t) {
        var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        return X5((function() {
            var r = h8(g9(Nue(e)), "int32"),
                a = (t = d7(t, kue(), 1 - kue())).shape;
            return cle(X8(cee(r, a[a.length - 1]), a), t, n)
        }))
    }

    function hle(e, t) {
        return X5((function() {
            var n;
            return n = d7(t, kue(), 1 - kue()), n = R9(m8(n, P9(1, n))), Q9(function(e, t) {
                if (!P$(e.shape, t.shape)) throw new Cse("logits and labels must have the same shape, but got shapes " + "".concat(JSON.stringify(e.shape), " and ").concat(JSON.stringify(t.shape)));
                return X5((function() {
                    var n = lte(t),
                        r = M9(y8(t));
                    return d8(P9(n, g8(t, e)), _9(p9(r)))
                }))
            }(e, n), -1)
        }))
    }

    function ple(e, t) {
        return X5((function() {
            var n = d7(e, kue(), 1),
                r = d7(t, kue(), 1);
            return u9(g8(e, R9(m8(n, r))), -1)
        }))
    }

    function fle(e, t) {
        return X5((function() {
            var n = ale(e, -1),
                r = ale(t, -1),
                a = g8(n, r);
            return M9(u9(a, -1))
        }))
    }
    tle.constructors = {};
    var dle = {
        meanSquaredError: ile,
        meanAbsoluteError: ole,
        meanAbsolutePercentageError: sle,
        meanSquaredLogarithmicError: ule,
        squaredHinge: function(e, t) {
            return X5((function() {
                var n = Z9(0, P9(1, g8(e, t)));
                return Q9(Due(n), -1)
            }))
        },
        hinge: function(e, t) {
            return X5((function() {
                var n = Z9(0, P9(1, g8(e, t)));
                return Q9(n, -1)
            }))
        },
        categoricalHinge: function(e, t) {
            return X5((function() {
                var n = u9(g8(e, t), -1),
                    r = n9(g8(P9(1, e), t), -1);
                return Z9(0, d8(1, P9(r, n)))
            }))
        },
        logcosh: function(e, t) {
            return X5((function() {
                var n = Math.log(2),
                    r = P9(t, e),
                    a = P9(d8(r, L9(g8(-2, r))), n);
                return Q9(a, -1)
            }))
        },
        categoricalCrossentropy: cle,
        sparseCategoricalCrossentropy: lle,
        binaryCrossentropy: hle,
        kullbackLeiblerDivergence: ple,
        poisson: function(e, t) {
            return X5((function() {
                var n = R9(d8(kue(), t));
                return Q9(P9(t, g8(e, n)), -1)
            }))
        },
        cosineProximity: fle
    };

    function vle(e) {
        if ("string" == typeof e) {
            if (e in dle) return dle[e];
            var t = "Unknown loss ".concat(e);
            throw e.toLowerCase().includes("softmaxcrossentropy") && (t = "Unknown loss ".concat(e, ". ") + 'Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'), new Cse(t)
        }
        return e
    }

    function mle(e, t) {
        return X5((function() {
            var n = g8(.5, lee(t)),
                r = wue(b9(t, n), e.dtype);
            return Q9(B7(e, r), -1)
        }))
    }

    function gle(e, t) {
        return X5((function() {
            return wue(B7(N8(e, -1), N8(t, -1)), "float32")
        }))
    }

    function yle(e, t) {
        return X5((function() {
            return h8(u9(U9(B7(e, 1), B7(t, 1))), "float32")
        }))
    }

    function ble(e, t) {
        return X5((function() {
            var n = yle(e, t),
                r = function(e, t) {
                    return X5((function() {
                        return h8(u9(U9(B7(e, 0), B7(t, 1))), "float32")
                    }))
                }(e, t),
                a = d8(n, r);
            return h8(W7(b9(a, 0), m8(n, a), 0), "float32")
        }))
    }

    function xle(e, t) {
        return X5((function() {
            var n = yle(e, t),
                r = function(e, t) {
                    return X5((function() {
                        return h8(u9(U9(B7(e, 1), B7(t, 0))), "float32")
                    }))
                }(e, t),
                a = d8(n, r);
            return h8(W7(b9(a, 0), m8(n, a), 0), "float32")
        }))
    }

    function kle(e, t) {
        return hle(e, t)
    }

    function wle(e, t) {
        return e.rank === t.rank && (e = zte(e, [e.rank - 1])), (t = N8(t, -1)).dtype !== e.dtype && (t = h8(t, e.dtype)), h8(B7(e, t), "float32")
    }
    var Ile = cle,
        Nle = lle,
        Sle = {
            binaryAccuracy: mle,
            categoricalAccuracy: gle,
            precision: ble,
            categoricalCrossentropy: Ile,
            sparseCategoricalCrossentropy: Nle,
            mse: ile,
            MSE: ile,
            mae: ole,
            MAE: ole,
            mape: sle,
            MAPE: sle,
            cosine: fle
        };

    function Tle(e) {
        if (Fse(null !== e, "Unknown LossOrMetricFn ".concat(e)), "string" == typeof e) return e;
        for (var t, n = 0, r = Object.keys(dle); n < r.length; n++) {
            var a = r[n];
            if (dle[a] === e) {
                t = a;
                break
            }
        }
        if (void 0 !== t) return t;
        for (var i = 0, o = Object.keys(Sle); i < o.length; i++) {
            var s = o[i];
            if (Sle[s] === e) {
                t = s;
                break
            }
        }
        return void 0 !== t ? t : e.name
    }
    var Ele = 1048576;

    function Cle(e, t) {
        var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        if (null == e || "object" !== s(e) || Object.getPrototypeOf(e) !== Object.prototype || !Ale(e)) throw new Error("User-defined metadata is expected to be a JSON object, but is not.");
        if (n) {
            var r = JSON.stringify(e);
            r.length > Ele && console.warn('User-defined metadata of model "'.concat(t, '" is too large in ') + "size (length=".concat(r.length, " when serialized). It is not ") + "recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= " + "".concat(Ele, "."))
        }
    }

    function Ale(e) {
        if (null === e) return !0;
        if ("object" === s(e)) {
            if (Object.getPrototypeOf(e) === Object.prototype) {
                for (var t = 0, n = Object.keys(e); t < n.length; t++) {
                    var r = n[t];
                    if ("string" != typeof r) return !1;
                    if (!Ale(e[r])) return !1
                }
                return !0
            }
            if (Array.isArray(e)) {
                var a, i = O(e);
                try {
                    for (i.s(); !(a = i.n()).done;) {
                        if (!Ale(a.value)) return !1
                    }
                } catch (e) {
                    i.e(e)
                } finally {
                    i.f()
                }
                return !0
            }
            return !1
        }
        var o = s(e);
        return "string" === o || "number" === o || "boolean" === o
    }

    function Rle(e, t, n) {
        var r, a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : console.log,
            i = Ole(e),
            o = ["Layer (type)", "Input Shape", "Output shape", "Param #"];
        if (i ? (t = t || 90, n = n || [.32, .61, .89, 1]) : (t = t || 115, n = n || [.24, .48, .7, .8, 1]), n[n.length - 1] <= 1 && (n = n.map((function(e) {
                return Math.floor(t * e)
            }))), !i)
            for (var s in o.push("Receives inputs"), r = [], e.nodesByDepth) {
                var u;
                (u = r).push.apply(u, T(e.nodesByDepth[s]))
            }
        a("_".repeat(t)), Fle(o, n, a), a("=".repeat(t));
        for (var c = e.layers, l = 0; l < c.length; ++l) i ? Dle(c[l], n, a) : Mle(c[l], n, r, a), a((l === c.length - 1 ? "=" : "_").repeat(t));
        e.checkTrainableWeightsConsistency();
        var h = _le(e),
            p = pce(e.nonTrainableWeights);
        a("Total params: ".concat(h + p)), a("Trainable params: ".concat(h)), a("Non-trainable params: ".concat(p)), a("_".repeat(t))
    }

    function _le(e) {
        return null != e.collectedTrainableWeights ? pce(e.collectedTrainableWeights) : pce(e.trainableWeights)
    }

    function Ole(e) {
        var t = !0,
            n = [],
            r = [];
        for (var a in e.nodesByDepth) n.push(e.nodesByDepth[a]);
        for (var i = 0, o = n; i < o.length; i++) {
            var s = o[i];
            if (s.length > 1 || 1 === s.length && s[0].inboundLayers.length > 1) {
                t = !1;
                break
            }
            r.push.apply(r, T(s))
        }
        if (t) {
            var u, c = O(e.layers);
            try {
                for (c.s(); !(u = c.n()).done;) {
                    var l, h = u.value,
                        p = !1,
                        f = O(h.inboundNodes);
                    try {
                        for (f.s(); !(l = f.n()).done;) {
                            var d = l.value;
                            if (-1 !== r.indexOf(d)) {
                                if (p) {
                                    t = !1;
                                    break
                                }
                                p = !0
                            }
                        }
                    } catch (e) {
                        f.e(e)
                    } finally {
                        f.f()
                    }
                    if (!t) break
                }
            } catch (e) {
                c.e(e)
            } finally {
                c.f()
            }
        }
        return t
    }

    function Fle(e, t) {
        for (var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : console.log, r = "", a = 0; a < e.length; ++a) a > 0 && (r = r.slice(0, r.length - 1) + " "), r = (r += e[a]).slice(0, t[a]), r += " ".repeat(t[a] - r.length);
        n(r)
    }

    function Dle(e, t, n) {
        var r, a;
        try {
            a = e.inboundNodes.map((function(e) {
                return JSON.stringify(e.inputShapes)
            })).join(",")
        } catch (e) {
            a = "multiple"
        }
        try {
            r = JSON.stringify(e.outputShape)
        } catch (e) {
            r = "multiple"
        }
        var i = e.name,
            o = e.getClassName();
        Fle(["".concat(i, " (").concat(o, ")"), a, r, e.countParams().toString()], t, n)
    }

    function Mle(e, t, n, r) {
        var a, i;
        try {
            i = e.inboundNodes.map((function(e) {
                return JSON.stringify(e.inputShapes)
            })).join(",")
        } catch (e) {
            i = "multiple"
        }
        try {
            a = JSON.stringify(e.outputShape)
        } catch (e) {
            a = "multiple"
        }
        var o, s = [],
            u = O(e.inboundNodes);
        try {
            for (u.s(); !(o = u.n()).done;) {
                var c = o.value;
                if (!(null != n && n.length > 0 && -1 === n.indexOf(c)))
                    for (var l = 0; l < c.inboundLayers.length; ++l) {
                        var h = c.inboundLayers[l].name,
                            p = c.nodeIndices[l],
                            f = c.tensorIndices[l];
                        s.push("".concat(h, "[").concat(p, "][").concat(f, "]"))
                    }
            }
        } catch (e) {
            u.e(e)
        } finally {
            u.f()
        }
        var d = e.name,
            v = e.getClassName(),
            m = 0 === s.length ? "" : s[0];
        Fle(["".concat(d, " (").concat(v, ")"), i, a, e.countParams().toString(), m], t, r);
        for (var g = 1; g < s.length; ++g) Fle(["", "", "", "", s[g]], t, r)
    }

    function Lle(e, t, n) {
        return ("inboundNodes" === e || "outputLayers" === e || "inputLayers" === e) && 0 === t && "string" == typeof n
    }

    function zle(e, t) {
        if (null === e) return null;
        if ("string" == typeof e) return Pse(e);
        if ("number" == typeof e || "boolean" == typeof e) return e;
        if (e instanceof Array) {
            for (var n = [], r = e.length, a = 0; a < r; ++a) {
                var i = e[a];
                Lle(t, a, i) ? n.push(i) : n.push(zle(i, t))
            }
            return n
        }
        for (var o = {}, s = 0, u = Object.keys(e); s < u.length; s++) {
            var c = u[s],
                l = e[c];
            if ("name" === c && "string" == typeof l) o[c] = l;
            else {
                var h = Pse(c);
                o[h] = zle(l, h)
            }
        }
        return o
    }

    function Ple(e, t) {
        if (null == e) return null;
        if ("string" == typeof e) return zse(e);
        if ("number" == typeof e || "boolean" == typeof e) return e;
        if (e instanceof Array) {
            for (var n = [], r = e.length, a = 0; a < r; ++a) {
                var i = e[a];
                Lle(t, a, i) ? n.push(i) : n.push(Ple(i, t))
            }
            return n
        }
        for (var o = {}, s = 0, u = Object.keys(e); s < u.length; s++) {
            var c = u[s],
                l = e[c],
                h = zse(c);
            o[h] = "name" !== c && "className" !== c || "string" != typeof l ? Ple(l, c) : l
        }
        return o
    }
    var Ble = "4.22.0",
        Wle = function(e) {
            var t = Object.keys(e);
            if (0 === t.length) return !1;
            var n = t[0].split("/");
            return !isNaN(parseInt(n[n.length - 1], 10))
        },
        Ule = function(e) {
            d(n, e);
            var t = w(n);

            function n(e) {
                var r;
                if (l(this, n), (r = t.call(this, {})).containerNodes = new Set, r.name = e.name, null == r.name) {
                    var a = r.getClassName().toLowerCase();
                    r.name = eue(a)
                }
                if (r.supportsMasking = !1, r.trainable_ = !0, Array.isArray(e.inputs) ? r.inputs = e.inputs.slice() : r.inputs = [e.inputs], Array.isArray(e.outputs) ? r.outputs = e.outputs.slice() : r.outputs = [e.outputs], jse(r.inputs).length !== r.inputs.length) throw new Cse("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: " + "".concat(r.inputs.map((function(e) {
                    return e.name
                }))));
                jse(r.outputs).length !== r.outputs.length && console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: " + "".concat(r.outputs.map((function(e) {
                    return e.name
                })))), r.inputLayers = [], r.inputLayersNodeIndices = [], r.inputLayersTensorIndices = [], r.outputLayers = [], r.outputLayersNodeIndices = [], r.outputLayersTensorIndices = [], r.layers = [], r.internalContainerRefs = [];
                var i, o = O(r.outputs);
                try {
                    for (o.s(); !(i = o.n()).done;) {
                        var s = i.value,
                            u = s.sourceLayer,
                            c = s.nodeIndex,
                            h = s.tensorIndex;
                        r.outputLayers.push(u), r.outputLayersNodeIndices.push(c), r.outputLayersTensorIndices.push(h)
                    }
                } catch (e) {
                    o.e(e)
                } finally {
                    o.f()
                }
                var p, f = O(r.inputs);
                try {
                    for (f.s(); !(p = f.n()).done;) {
                        var d = p.value,
                            v = d.sourceLayer,
                            m = d.nodeIndex,
                            g = d.tensorIndex;
                        Fse(0 === m, "input layer has >1 nodes"), Fse(0 === g, "input layer has >1 tensors"), r.inputLayers.push(v), r.inputLayersNodeIndices.push(m), r.inputLayersTensorIndices.push(g)
                    }
                } catch (e) {
                    f.e(e)
                } finally {
                    f.f()
                }
                r.inputNames = [], r.outputNames = [], r.feedInputShapes = [], r.feedInputNames = [], r.feedOutputNames = [];
                for (var y = 0; y < r.inputLayers.length; y++) {
                    var b = r.inputLayers[y];
                    if (!(b instanceof Nce)) throw new TypeError("Input layers to a LayersModel must be InputLayer objects. " + "Received inputs: ".concat(e.inputs, ". ") + "Input ".concat(y, " (0-based) originates ") + "from layer type ".concat(b.getClassName(), "."));
                    r.inputNames.push(b.name), r.feedInputShapes.push(b.batchInputShape), r.feedInputNames.push(b.name)
                }
                var k, w = O(r.outputLayers);
                try {
                    for (w.s(); !(k = w.n()).done;) {
                        var I = k.value;
                        r.outputNames.push(I.name)
                    }
                } catch (e) {
                    w.e(e)
                } finally {
                    w.f()
                }
                r.internalInputShapes = r.inputs.map((function(e) {
                    return e.shape
                })), r.internalOutputShapes = r.outputs.map((function(e) {
                    return e.shape
                }));
                var N, S = {},
                    T = {},
                    E = {},
                    C = {},
                    A = {},
                    R = [],
                    _ = function e(t, a, i, o, s, u) {
                        null != o && null != s && null != u || (o = t.sourceLayer, s = t.nodeIndex, u = t.tensorIndex);
                        var c = o.inboundNodes[s];
                        if (-1 !== i.indexOf(c)) throw new Ese("The tensor ".concat(t.name, ' at layer "').concat(o.name, '" ') + "is part of a cycle.");
                        if (-1 === a.indexOf(c)) {
                            r.containerNodes.add(n.nodeKey(o, s)), o.id in A || (A[o.id] = Object.keys(A).length), -1 === i.indexOf(c) && i.push(c);
                            for (var l = c.inboundLayers.length, h = 0; h < l; h++) {
                                e(c.inputTensors[h], a, i, c.inboundLayers[h], c.nodeIndices[h], c.tensorIndices[h])
                            }
                            for (a.push(c); i.indexOf(c) >= 0;) i.splice(i.indexOf(c), 1);
                            R.push(c)
                        }
                    },
                    F = [],
                    D = [],
                    M = O(r.outputs);
                try {
                    for (M.s(); !(N = M.n()).done;) {
                        _(N.value, F, D)
                    }
                } catch (e) {
                    M.e(e)
                } finally {
                    M.f()
                }
                var L, z = O(R.slice().reverse());
                try {
                    for (z.s(); !(L = z.n()).done;) {
                        var P = L.value;
                        T[P.id] = P, P.id in S || (S[P.id] = 0);
                        var B = S[P.id],
                            W = null == E[P.outboundLayer.id] ? 0 : E[P.outboundLayer.id];
                        B = Math.max(B, W), E[P.outboundLayer.id] = B, C[P.outboundLayer.id] = P.outboundLayer, S[P.id] = B;
                        for (var U = 0; U < P.inboundLayers.length; U++) {
                            var V = P.inboundLayers[U],
                                G = P.nodeIndices[U],
                                j = V.inboundNodes[G],
                                H = null == S[j.id] ? 0 : S[j.id];
                            S[j.id] = Math.max(B + 1, H), T[j.id] = j
                        }
                    }
                } catch (e) {
                    z.e(e)
                } finally {
                    z.f()
                }
                var q = {};
                for (var K in S) {
                    var X = S[K];
                    X in q || (q[X] = []), q[X].push(T[K])
                }
                var Y = {};
                for (var J in E) {
                    var Z = E[J];
                    Z in Y || (Y[Z] = []), Y[Z].push(C[J])
                }
                var Q = Object.keys(Y).map((function(e) {
                    return parseInt(e, 10)
                })).sort(Gse);
                r.layers = [];
                var $, ee = O(Q);
                try {
                    for (ee.s(); !($ = ee.n()).done;) {
                        var te = Y[$.value];
                        te.sort((function(e, t) {
                            var n = A[e.id],
                                r = A[t.id];
                            return n < r ? -1 : n > r ? 1 : 0
                        }));
                        var ne, re = O(te);
                        try {
                            for (re.s(); !(ne = re.n()).done;) {
                                var ae = ne.value;
                                ae instanceof n && r.internalContainerRefs.push(ae), r.layers.push(ae)
                            }
                        } catch (e) {
                            re.e(e)
                        } finally {
                            re.f()
                        }
                    }
                } catch (e) {
                    ee.e(e)
                } finally {
                    ee.f()
                }
                r.layersByDepth = Y, Q = Object.keys(q).map((function(e) {
                    return parseInt(e, 10)
                })).sort(Gse);
                var ie, oe = r.inputs.slice(),
                    se = [],
                    ue = O(Q);
                try {
                    for (ue.s(); !(ie = ue.n()).done;) {
                        var ce, le = O(q[ie.value]);
                        try {
                            for (le.s(); !(ce = le.n()).done;) {
                                var he = ce.value,
                                    pe = he.outboundLayer;
                                if (null != pe) {
                                    var fe, de = O(he.inputTensors);
                                    try {
                                        for (de.s(); !(fe = de.n()).done;) {
                                            var ve = fe.value;
                                            if (-1 === oe.indexOf(ve)) throw new Ese("Graph disconnected: cannot obtain value for tensor ".concat(ve) + ' at layer "'.concat(pe.name, '". ') + "The following previous layers were accessed without " + "issue: ".concat(se))
                                        }
                                    } catch (e) {
                                        de.e(e)
                                    } finally {
                                        de.f()
                                    }
                                    var me, ge = O(he.outputTensors);
                                    try {
                                        for (ge.s(); !(me = ge.n()).done;) {
                                            var ye = me.value;
                                            oe.push(ye)
                                        }
                                    } catch (e) {
                                        ge.e(e)
                                    } finally {
                                        ge.f()
                                    }
                                    se.push(pe.name)
                                }
                            }
                        } catch (e) {
                            le.e(e)
                        } finally {
                            le.f()
                        }
                    }
                } catch (e) {
                    ue.e(e)
                } finally {
                    ue.f()
                }
                r.nodesByDepth = q;
                var be, xe = r.layers.map((function(e) {
                        return e.name
                    })),
                    ke = O(xe);
                try {
                    var we = function() {
                        var e = be.value,
                            t = xe.filter((function(t) {
                                return t === e
                            })).length;
                        if (1 !== t) throw new Ese('The name "'.concat(e, '" is used ').concat(t, " times ") + "in the model. All layer names should be unique. Layer names: " + JSON.stringify(xe))
                    };
                    for (ke.s(); !(be = ke.n()).done;) we()
                } catch (e) {
                    ke.e(e)
                } finally {
                    ke.f()
                }
                return r.outboundNodes = [], r.inboundNodes = [], new xce({
                    outboundLayer: x(r),
                    inboundLayers: [],
                    nodeIndices: [],
                    tensorIndices: [],
                    inputTensors: r.inputs,
                    outputTensors: r.outputs,
                    inputMasks: r.inputs.map((function(e) {
                        return null
                    })),
                    outputMasks: r.outputs.map((function(e) {
                        return null
                    })),
                    inputShapes: r.inputs.map((function(e) {
                        return e.shape
                    })),
                    outputShapes: r.outputs.map((function(e) {
                        return e.shape
                    }))
                }), r.built = !0, r._refCount = 1, r
            }
            return p(n, [{
                key: "assertNotDisposed",
                value: function() {
                    if (0 === this._refCount) throw new Error("Container '".concat(this.name, "' is already disposed."))
                }
            }, {
                key: "dispose",
                value: function() {
                    this.assertNotDisposed();
                    var e = {
                        refCountAfterDispose: null,
                        numDisposedVariables: 0
                    };
                    if (0 == --this._refCount) {
                        var t, n = O(this.layers);
                        try {
                            for (n.s(); !(t = n.n()).done;) {
                                var r = t.value;
                                e.numDisposedVariables += r.dispose().numDisposedVariables
                            }
                        } catch (e) {
                            n.e(e)
                        } finally {
                            n.f()
                        }
                        var a, i = O(this.internalContainerRefs);
                        try {
                            for (i.s(); !(a = i.n()).done;) {
                                var o = a.value;
                                e.numDisposedVariables += o.dispose().numDisposedVariables
                            }
                        } catch (e) {
                            i.e(e)
                        } finally {
                            i.f()
                        }
                    }
                    return e.refCountAfterDispose = this._refCount, e
                }
            }, {
                key: "trainable",
                get: function() {
                    return this.trainable_
                },
                set: function(e) {
                    this.layers.forEach((function(t) {
                        t._trainableWeights.forEach((function(t) {
                            return t.trainable = e
                        }))
                    })), this.trainable_ = e
                }
            }, {
                key: "trainableWeights",
                get: function() {
                    if (this._trainableWeights.length > 0) throw new Cse("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");
                    if (!this.trainable) return [];
                    var e, t = [],
                        n = O(this.layers);
                    try {
                        for (n.s(); !(e = n.n()).done;) {
                            var r = e.value;
                            t = t.concat(r.trainableWeights)
                        }
                    } catch (e) {
                        n.e(e)
                    } finally {
                        n.f()
                    }
                    return t
                }
            }, {
                key: "nonTrainableWeights",
                get: function() {
                    var e, t = [],
                        n = O(this.layers);
                    try {
                        for (n.s(); !(e = n.n()).done;) {
                            var r = e.value;
                            t.push.apply(t, T(r.nonTrainableWeights))
                        }
                    } catch (e) {
                        n.e(e)
                    } finally {
                        n.f()
                    }
                    if (!this.trainable) {
                        var a, i = [],
                            o = O(this.layers);
                        try {
                            for (o.s(); !(a = o.n()).done;) {
                                var s = a.value;
                                i.push.apply(i, T(s.trainableWeights))
                            }
                        } catch (e) {
                            o.e(e)
                        } finally {
                            o.f()
                        }
                        return i.concat(t)
                    }
                    return t
                }
            }, {
                key: "weights",
                get: function() {
                    return this.trainableWeights.concat(this.nonTrainableWeights)
                }
            }, {
                key: "loadWeights",
                value: function(e) {
                    var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                        n = {},
                        r = 0,
                        a = Wle(e);
                    a && this.parseWeights(e);
                    var i, o = O(this.layers);
                    try {
                        for (o.s(); !(i = o.n()).done;) {
                            var s, u = i.value,
                                c = O(u.weights.entries());
                            try {
                                for (c.s(); !(s = c.n()).done;) {
                                    var l = S(s.value, 2),
                                        h = l[0],
                                        p = l[1],
                                        f = a ? "".concat(p.name.split("/").slice(0, -1).join("/") + "/").concat(h) : p.originalName;
                                    if (null != n[f]) throw new Cse("Duplicate weight name: ".concat(f));
                                    n[f] = p, r++
                                }
                            } catch (e) {
                                c.e(e)
                            } finally {
                                c.f()
                            }
                        }
                    } catch (e) {
                        o.e(e)
                    } finally {
                        o.f()
                    }
                    var d = [];
                    for (var v in e) {
                        var m = v;
                        if (null == n[v]) {
                            var g = v.split("/"),
                                y = g.slice(0, -2).concat([g[g.length - 1]]);
                            m = y.join("/")
                        }
                        if (null != n[m]) d.push([n[m], e[v]]);
                        else if (t) throw new Cse("Provided weight data has no target variable: ".concat(v));
                        delete n[m]
                    }
                    if (t) {
                        var b = [];
                        for (var x in n) b.push(x);
                        if (b.length > 0) throw new Cse("".concat(b.length, " of ").concat(r, " weights are not set: ") + "".concat(b))
                    }
                    mce(d)
                }
            }, {
                key: "parseWeights",
                value: function(e) {
                    var t = function() {
                        var t = n.split("/"),
                            r = ["vars", "layer_checkpoint_dependencies"],
                            a = t.map((function(e) {
                                return e.startsWith("_") ? e.slice(1) : e
                            })).filter((function(e) {
                                return !r.includes(e)
                            })).join("/");
                        a !== n && (e[a] = e[n], delete e[n])
                    };
                    for (var n in Object.keys(e)) t()
                }
            }, {
                key: "updatedConfig",
                value: function() {
                    var e = this.getConfig(),
                        t = {};
                    return t.className = this.getClassName(), t.config = e, t.kerasVersion = "tfjs-layers ".concat(Ble), t.backend = "TensorFlow.js", t
                }
            }, {
                key: "toJSON",
                value: function(e) {
                    var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                        n = Ple(this.updatedConfig());
                    return t ? JSON.stringify(n) : n
                }
            }, {
                key: "call",
                value: function(e, t) {
                    var n = this;
                    return X5((function() {
                        e = Lse(e);
                        for (var r = new Tce, a = 0; a < n.inputs.length; ++a) r.add(n.inputs[a], e[a]);
                        return Ace(n.outputs, r, t)
                    }))
                }
            }, {
                key: "computeMask",
                value: function(e, t) {
                    var n = this;
                    return X5((function() {
                        var r;
                        return e = Lse(e), r = null == t ? Ose(null, e.length) : Lse(t), n.runInternalGraph(e, r)[1]
                    }))
                }
            }, {
                key: "computeOutputShape",
                value: function(e) {
                    var t = cce(e);
                    if (t.length !== this.inputLayers.length) throw new Cse("Invalid inputShape argument ".concat(e, ": ") + "model has ".concat(this.inputLayers.length, " tensor inputs."));
                    for (var n = {}, r = 0; r < t.length; r++) {
                        var a = this.inputLayers[r],
                            i = t[r];
                        n[a.name + "_0_0"] = i
                    }
                    var o = Object.keys(this.nodesByDepth).map((function(e) {
                        return parseInt(e, 10)
                    })).sort(Gse);
                    if (o.length > 1) {
                        var s, u = O(o);
                        try {
                            for (u.s(); !(s = u.n()).done;) {
                                var c, l = s.value,
                                    h = O(this.nodesByDepth[l]);
                                try {
                                    for (h.s(); !(c = h.n()).done;) {
                                        var p = c.value,
                                            f = p.outboundLayer;
                                        if (-1 === this.inputLayers.map((function(e) {
                                                return e.id
                                            })).indexOf(f.id)) {
                                            for (var d = [], v = 0; v < p.inboundLayers.length; v++) {
                                                var m = p.inboundLayers[v],
                                                    g = p.nodeIndices[v],
                                                    y = p.tensorIndices[v],
                                                    b = n["".concat(m.name, "_").concat(g, "_").concat(y)];
                                                d.push(b)
                                            }
                                            for (var x = cce(f.computeOutputShape(Mse(d))), k = f.inboundNodes.indexOf(p), w = 0; w < x.length; w++) {
                                                n["".concat(f.name, "_").concat(k, "_").concat(w)] = x[w]
                                            }
                                        }
                                    }
                                } catch (e) {
                                    h.e(e)
                                } finally {
                                    h.f()
                                }
                            }
                        } catch (e) {
                            u.e(e)
                        } finally {
                            u.f()
                        }
                    }
                    for (var I = [], N = [], S = 0; S < this.outputLayers.length; S++) {
                        var T = this.outputLayers[S],
                            E = this.outputLayersNodeIndices[S],
                            C = this.outputLayersTensorIndices[S],
                            A = "".concat(T.name, "_").concat(E, "_").concat(C);
                        N.push(A)
                    }
                    for (var R = 0; R < N.length; R++) {
                        var _ = N[R];
                        Fse(_ in n), I.push(n[_])
                    }
                    return Mse(I)
                }
            }, {
                key: "runInternalGraph",
                value: function(e, t) {
                    null == t && (t = Ose(null, e.length));
                    for (var n = {}, r = 0; r < this.inputs.length; ++r) {
                        var a = this.inputs[r],
                            i = e[r],
                            o = t[r];
                        n[a.id] = [i, o]
                    }
                    var s, u = Object.keys(this.nodesByDepth).map((function(e) {
                            return parseInt(e, 10)
                        })).sort(Gse),
                        c = O(u);
                    try {
                        for (c.s(); !(s = c.n()).done;) {
                            var l, h = s.value,
                                p = O(this.nodesByDepth[h]);
                            try {
                                for (p.s(); !(l = p.n()).done;) {
                                    var f, d = l.value,
                                        v = d.outboundLayer,
                                        m = d.inputTensors,
                                        g = d.outputTensors,
                                        y = new Array,
                                        b = O(m);
                                    try {
                                        for (b.s(); !(f = b.n()).done;) {
                                            var x = f.value;
                                            x.id in n && y.push(n[x.id])
                                        }
                                    } catch (e) {
                                        b.e(e)
                                    } finally {
                                        b.f()
                                    }
                                    if (y.length === m.length) {
                                        var k = {},
                                            w = void 0,
                                            I = void 0,
                                            N = void 0,
                                            T = void 0;
                                        if (null != d.callArgs && (k = d.callArgs), 1 === y.length) {
                                            var E = S(y[0], 2),
                                                C = E[0],
                                                A = E[1];
                                            null == k.mask && (k.mask = A), N = Lse(v.call(C, k)), T = Lse(v.computeMask(C, A)), w = [C], I = [A]
                                        } else w = y.map((function(e) {
                                            return e[0]
                                        })), I = y.map((function(e) {
                                            return e[1]
                                        })), null == k.mask && (k.mask = I), N = Lse(v.call(w, k)), T = Lse(v.computeMask(w, I));
                                        if (v.activityRegularizer) throw new Ase("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");
                                        for (var R = 0; R < g.length; ++R) {
                                            var _ = g[R],
                                                F = N[R],
                                                D = T[R];
                                            n[_.id] = [F, D]
                                        }
                                    }
                                }
                            } catch (e) {
                                p.e(e)
                            } finally {
                                p.f()
                            }
                        }
                    } catch (e) {
                        c.e(e)
                    } finally {
                        c.f()
                    }
                    var M, L = [],
                        z = [],
                        P = [],
                        B = O(this.outputs);
                    try {
                        for (B.s(); !(M = B.n()).done;) {
                            var W = M.value;
                            Fse(W.id in n, "Could not compute output ".concat(W.name, " : ").concat(W.id));
                            var U = S(n[W.id], 2),
                                V = U[0],
                                G = U[1];
                            P.push(V.shape), L.push(V), z.push(G)
                        }
                    } catch (e) {
                        B.e(e)
                    } finally {
                        B.f()
                    }
                    return [L, z, P]
                }
            }, {
                key: "buildNodeConversionMap",
                value: function(e) {
                    var t, r, a = {},
                        i = O(this.layers);
                    try {
                        for (i.s(); !(r = i.n()).done;) {
                            var o = r.value;
                            t = o instanceof n ? 1 : 0;
                            for (var s = 0; s < o.inboundNodes.length; s++) {
                                var u = n.nodeKey(o, s);
                                this.containerNodes.has(u) && (a[u] = t, t += 1)
                            }
                        }
                    } catch (e) {
                        i.e(e)
                    } finally {
                        i.f()
                    }
                    return a
                }
            }, {
                key: "getLayer",
                value: function(e, t) {
                    if (null != t) return this.findLayer(t);
                    if (null == e) throw new Cse("Provide either a layer name or layer index");
                    if ("number" == typeof e) return this.findLayer(e);
                    var n, r = O(this.layers);
                    try {
                        for (r.s(); !(n = r.n()).done;) {
                            var a = n.value;
                            if (a.name === e) return a
                        }
                    } catch (e) {
                        r.e(e)
                    } finally {
                        r.f()
                    }
                    throw new Cse("No such layer: ".concat(e))
                }
            }, {
                key: "findLayer",
                value: function(e) {
                    if (this.layers.length <= e) throw new Cse("Was asked to retrieve layer at index ".concat(e, ", but model only ") + "has ".concat(this.layers.length, " layer(s)."));
                    return this.layers[e]
                }
            }, {
                key: "calculateLosses",
                value: function() {
                    var e = this;
                    return X5((function() {
                        var t, r = [],
                            a = O(e.layers);
                        try {
                            for (a.s(); !(t = a.n()).done;)
                                for (var i = t.value, o = 0; o < i.inboundNodes.length; ++o) {
                                    var s = n.nodeKey(i, o);
                                    e.containerNodes.has(s) && r.push.apply(r, T(i.calculateLosses()))
                                }
                        } catch (e) {
                            a.e(e)
                        } finally {
                            a.f()
                        }
                        return r
                    }))
                }
            }, {
                key: "getConfig",
                value: function() {
                    var e, t = {
                            name: this.name
                        },
                        r = this.buildNodeConversionMap(this.layers),
                        a = [],
                        i = O(this.layers);
                    try {
                        for (i.s(); !(e = i.n()).done;) {
                            for (var o = e.value, s = o.getClassName(), u = o.getConfig(), c = [], l = 0; l < o.inboundNodes.length; l++) {
                                var h = o.inboundNodes[l],
                                    p = n.nodeKey(o, l),
                                    f = {};
                                if (this.containerNodes.has(p)) {
                                    if (h.callArgs) try {
                                        JSON.stringify(h.callArgs), f = h.callArgs
                                    } catch (e) {
                                        console.warn("Layer ".concat(o.name, " was passed ") + "non-serializable keyword arguments: " + "".concat(h.callArgs, ". They will not be included ") + "in the serialized model (and thus will be missing at deserialization time)."), f = {}
                                    }
                                    if (h.inboundLayers.length > 0) {
                                        for (var d = [], v = 0; v < h.inboundLayers.length; v++) {
                                            var m = h.inboundLayers[v],
                                                g = h.nodeIndices[v],
                                                y = h.tensorIndices[v],
                                                b = r[n.nodeKey(m, g)];
                                            null == b && (b = 0), d.push([m.name, b, y, f])
                                        }
                                        c.push(d)
                                    }
                                }
                            }
                            var x = {};
                            x.name = o.name, x.className = s, x.config = u, x.inboundNodes = c, a.push(x)
                        }
                    } catch (e) {
                        i.e(e)
                    } finally {
                        i.f()
                    }
                    t.layers = a;
                    for (var k = [], w = 0; w < this.inputLayers.length; w++) {
                        var I = this.inputLayers[w],
                            N = this.inputLayersNodeIndices[w],
                            S = n.nodeKey(I, N);
                        if (this.containerNodes.has(S)) {
                            var T = r[S];
                            null == T && (T = 0);
                            var E = this.inputLayersTensorIndices[w];
                            k.push([I.name, T, E])
                        }
                    }
                    t.inputLayers = k;
                    for (var C = [], A = 0; A < this.outputLayers.length; A++) {
                        var R = this.outputLayers[A],
                            _ = this.outputLayersNodeIndices[A],
                            F = n.nodeKey(R, _);
                        if (this.containerNodes.has(F)) {
                            var D = r[F];
                            null == D && (D = 0);
                            var M = this.outputLayersTensorIndices[A];
                            C.push([R.name, D, M])
                        }
                    }
                    return t.outputLayers = C, t
                }
            }, {
                key: "stateful",
                get: function() {
                    if (this._stateful) throw new Cse("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");
                    var e, t = O(this.layers);
                    try {
                        for (t.s(); !(e = t.n()).done;) {
                            if (e.value.stateful) return !0
                        }
                    } catch (e) {
                        t.e(e)
                    } finally {
                        t.f()
                    }
                    return !1
                }
            }, {
                key: "resetStates",
                value: function() {
                    var e = this;
                    X5((function() {
                        e.layers.forEach((function(e) {
                            e.stateful && e.resetStates()
                        }))
                    }))
                }
            }], [{
                key: "fromConfig",
                value: function(e, t) {
                    var n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
                        r = {},
                        a = {};

                    function i(e, t) {
                        e.name in a ? a[e.name].push(t) : a[e.name] = [t]
                    }

                    function o(e, t) {
                        var n, a, o = [],
                            s = O(t);
                        try {
                            for (s.s(); !(a = s.n()).done;) {
                                var u = a.value,
                                    c = u[0],
                                    l = u[1],
                                    h = u[2];
                                if (n = null == u[3] ? {} : u[3], !(c in r)) return void i(e, t);
                                var p = r[c];
                                if (p.inboundNodes.length <= l) return void i(e, t);
                                var f = p.inboundNodes[l];
                                o.push(f.outputTensors[h])
                            }
                        } catch (e) {
                            s.e(e)
                        } finally {
                            s.f()
                        }
                        o.length > 0 && e.apply(Mse(o), n)
                    }

                    function s(e) {
                        var a = e.name,
                            o = rle(e, null != t.customObjects ? t.customObjects : {});
                        o.setFastWeightInitDuringBuild(n), r[a] = o, e.inboundNodes.forEach((function(e) {
                            if (!(e instanceof Array)) throw new Cse("Corrupted configuration, expected array for nodeData: ".concat(e));
                            i(o, e)
                        }))
                    }
                    var u, c = t.name,
                        l = t.layers,
                        h = O(l);
                    try {
                        for (h.s(); !(u = h.n()).done;) {
                            var p = u.value;
                            s(p)
                        }
                    } catch (e) {
                        h.e(e)
                    } finally {
                        h.f()
                    }
                    for (; !Hse(a);) {
                        var f, d = O(l);
                        try {
                            for (d.s(); !(f = d.n()).done;) {
                                var v = f.value,
                                    m = r[v.name];
                                if (m.name in a) {
                                    var g = a[m.name];
                                    delete a[m.name];
                                    var y, b = O(g);
                                    try {
                                        for (b.s(); !(y = b.n()).done;) {
                                            var x = y.value;
                                            o(m, x)
                                        }
                                    } catch (e) {
                                        b.e(e)
                                    } finally {
                                        b.f()
                                    }
                                }
                            }
                        } catch (e) {
                            d.e(e)
                        } finally {
                            d.f()
                        }
                    }
                    var k, w = [],
                        I = [],
                        N = t.inputLayers,
                        S = O(N);
                    try {
                        for (S.s(); !(k = S.n()).done;) {
                            var T = k.value,
                                E = T[0],
                                C = T[1],
                                A = T[2];
                            Fse(E in r);
                            var R = r[E],
                                _ = R.inboundNodes[C].outputTensors;
                            w.push(_[A])
                        }
                    } catch (e) {
                        S.e(e)
                    } finally {
                        S.f()
                    }
                    var F, D = t.outputLayers,
                        M = O(D);
                    try {
                        for (M.s(); !(F = M.n()).done;) {
                            var L = F.value,
                                z = L[0],
                                P = L[1],
                                B = L[2];
                            Fse(z in r);
                            var W = r[z],
                                U = W.inboundNodes[P].outputTensors;
                            I.push(U[B])
                        }
                    } catch (e) {
                        M.e(e)
                    } finally {
                        M.f()
                    }
                    return new e({
                        inputs: w,
                        outputs: I,
                        name: c
                    })
                }
            }]), n
        }(wce);

    function Vle(e, t, n) {
        var r = t.length;
        if (null == e || Array.isArray(e) && 0 === e.length) return t.map((function(e) {
            return null
        }));
        if (1 === r) return Array.isArray(e) && 1 === e.length ? e : "object" === s(e) && t[0] in e ? [e[t[0]]] : [e];
        if (Array.isArray(e)) {
            if (e.length !== r) throw new Error("Provided ".concat(n, " is an array of ").concat(e.length, " ") + "element(s), but the model has ".concat(r, " outputs. ") + "Make sure a set of weights is provided for each model output.");
            return e
        }
        if ("object" === s(e) && Object.keys(e).length > 0 && "object" === s(e[Object.keys(e)[0]])) {
            var a = [];
            return t.forEach((function(t) {
                t in e ? a.push(e[t]) : a.push(null)
            })), a
        }
        throw new Error("The model has multiple (".concat(r, ") outputs, ") + "so ".concat(n, " must be either an array with ") + "".concat(r, " elements or an object with ").concat(t, " keys. ") + "Provided ".concat(n, " not understood: ").concat(JSON.stringify(e)))
    }

    function Gle(e, t) {
        return Vle(e, t, "classWeight")
    }

    function jle(e, t, n, r) {
        return Hle.apply(this, arguments)
    }

    function Hle() {
        return (Hle = c(o().mark((function e(t, n, r, a) {
            var i, s, u;
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        if (null == n && null == a) {
                            e.next = 2;
                            break
                        }
                        throw new Error("Support sampleWeight is not implemented yet");
                    case 2:
                        if (null == r) {
                            e.next = 15;
                            break
                        }
                        return i = X5((function() {
                            if (1 === t.shape.length) return p8(t);
                            if (2 === t.shape.length) {
                                if (t.shape[1] > 1) {
                                    return N8(t, 1)
                                }
                                if (1 === t.shape[1]) return X8(t, [t.shape[0]]);
                                throw new Error("Encountered unexpected last-dimension size (".concat(t.shape[1], ") ") + "during handling of class weights. The size is expected to be >= 1.")
                            }
                            throw new Error("Unexpected rank of target (y) tensor (".concat(t.rank, ") during ") + "handling of class weights. The rank is expected to be 1 or 2.")
                        })), e.t0 = Array, e.next = 7, i.data();
                    case 7:
                        return e.t1 = e.sent, s = e.t0.from.call(e.t0, e.t1), Y5(i), u = [], s.forEach((function(e) {
                            if (null == r[e]) throw new Error("classWeight must contain all classes in the training data. " + "The class ".concat(e, " exists in the data but not in ") + "classWeight");
                            u.push(r[e])
                        })), e.abrupt("return", Vte(u, "float32"));
                    case 15:
                        return e.abrupt("return", null);
                    case 16:
                    case "end":
                        return e.stop()
                }
            }), e)
        })))).apply(this, arguments)
    }

    function qle(e, t) {
        return g8(e, t)
    }

    function Kle(e, t) {
        var n, r, a = t;
        n = a.xs, r = a.ys, F$(null != n && null != r, (function() {
            return "A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates " + "".concat(t)
        }));
        var i = Xle("input", e.inputNames, n),
            o = Xle("output", e.outputNames, r),
            s = i[0].shape[0];
        F$(i.length === e.inputs.length, (function() {
            return "LayersModel has ".concat(e.inputs.length, " inputs, but the dataset ") + "provides ".concat(i.length, " inputs.  (Expected input keys: ") + "".concat(JSON.stringify(e.inputNames), ")")
        })), F$(o.length === e.outputs.length, (function() {
            return "LayersModel has ".concat(e.outputs.length, " outputs, but the dataset ") + "provides ".concat(o.length, " outputs.  (Expected output keys: ") + "".concat(JSON.stringify(e.outputNames), ")")
        }));
        for (var u = function(t) {
                F$(i[t].shape[0] === s, (function() {
                    return "Batch size mismatch: input " + "".concat(e.inputNames[t], " has ").concat(i[t].shape[0], "; ") + "expected  ".concat(s, " based on input ").concat(e.inputNames[0], ".")
                }))
            }, c = 0; c < i.length; c++) u(c);
        for (var l = function(t) {
                F$(o[t].shape[0] === s, (function() {
                    return "Batch size mismatch: output " + "".concat(e.outputNames[t], " has ").concat(o[t].shape[0], "; ") + "expected  ".concat(s, " based on input ").concat(e.inputNames[0], ".")
                }))
            }, h = 0; h < o.length; h++) l(h);
        return {
            xs: i,
            ys: o
        }
    }

    function Xle(e, t, n) {
        if (n instanceof n5) return [n];
        if (Array.isArray(n)) return F$(n.length === t.length, (function() {
            return "Received an array of ".concat(n.length, " Tensors, but expected ").concat(t.length, " to match the ").concat(e, " keys ").concat(t, ".")
        })), n;
        var r, a = [],
            i = O(t);
        try {
            for (i.s(); !(r = i.n()).done;) {
                var o = r.value;
                if (null == n[o]) throw new Cse("The feature data generated by the dataset lacks the required " + "".concat(e, " key '").concat(o, "'."));
                a.push(n[o])
            }
        } catch (e) {
            i.e(e)
        } finally {
            i.f()
        }
        return a
    }

    function Yle(e) {
        if (3 === e.length) throw new Ase("Validation with sample weights is not implemented yet.");
        return {
            xs: e[0],
            ys: e[1]
        }
    }

    function Jle(e, t, n) {
        return Zle.apply(this, arguments)
    }

    function Zle() {
        return Zle = c(o().mark((function e(t, n, r) {
            var a, i, s, u, c, l, h, p, f, d, v, m, g, y, b, x, k, w, I, N, S, T, E, C, A, R, _, O, F, D, M, L, z;
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        if (a = null != r.batchesPerEpoch, F$(null != t.optimizer, (function() {
                                return "You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."
                            })), F$(null != r, (function() {
                                return "For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."
                            })), F$(null != r.epochs && r.epochs > 0 && Number.isInteger(r.epochs), (function() {
                                return "For fitDataset(), config.epochs is expected to be a positive " + "integer, but got ".concat(r.epochs)
                            })), F$(!a || r.batchesPerEpoch > 0 && Number.isInteger(r.batchesPerEpoch), (function() {
                                return "For fitDataset(), config.batchesPerEpoch is expected to be a " + "positive integer if specified, but got ".concat(r.batchesPerEpoch)
                            })), F$(null == r.validationSplit, (function() {
                                return "`validationSplit` is not supported by `fitDataset()`. Use validationData instead."
                            })), !t.isTraining) {
                            e.next = 8;
                            break
                        }
                        throw new Error("Cannot start training because another fit() call is ongoing.");
                    case 8:
                        return t.isTraining = !0, e.prev = 9, (i = null != r.validationData) && ($le(r.validationData) ? F$(null == r.validationBatches || r.validationBatches > 0 && Number.isInteger(r.validationBatches), (function() {
                            return "For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, " + "but got ".concat(r.validationBatches)
                        })) : (c = Yle(r.validationData), s = c.xs, u = c.ys)), l = t.makeTrainFunction(), h = t.getDedupedMetricsNames(), p = i ? h.slice().concat(h.map((function(e) {
                            return "val_" + e
                        }))) : h.slice(), f = ele(r.callbacks, r.yieldEvery), d = null == r.verbose ? 1 : r.verbose, v = nle(f, d, r.epochs, null, null, Qle(n, r), null, i, p), m = v.callbackList, g = v.history, m.setModel(t), t.history = g, e.next = 22, m.onTrainBegin();
                    case 22:
                        return t.stopTraining_ = !1, y = null == r.initialEpoch ? 0 : r.initialEpoch, e.next = 26, n.iterator();
                    case 26:
                        b = e.sent;
                    case 27:
                        if (!(y < r.epochs)) {
                            e.next = 98;
                            break
                        }
                        return x = {}, e.next = 31, m.onEpochBegin(y);
                    case 31:
                        if (k = 0, w = 0, a) {
                            e.next = 37;
                            break
                        }
                        return e.next = 36, n.iterator();
                    case 36:
                        b = e.sent;
                    case 37:
                        if (a && !(k < r.batchesPerEpoch)) {
                            e.next = 91;
                            break
                        }
                        return e.next = 40, b.next();
                    case 40:
                        if (I = e.sent, !a || !I.done) {
                            e.next = 44;
                            break
                        }
                        return console.warn("You provided `batchesPerEpoch` as " + "".concat(r.batchesPerEpoch, ", ") + "but your dataset iterator ran out of data after " + "".concat(k, " batches; ") + "interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, " + "".concat(r.batchesPerEpoch * r.epochs, " batches). ") + "You may need to use the repeat() function when building your dataset."), e.abrupt("break", 91);
                    case 44:
                        if (null == I.value) {
                            e.next = 73;
                            break
                        }
                        return N = Kle(t, I.value), S = N.xs, T = N.ys, (E = {}).batch = w, E.size = S[0].shape[0], e.next = 51, m.onBatchBegin(w, E);
                    case 51:
                        if (C = [], null == r.classWeight) {
                            e.next = 64;
                            break
                        }
                        A = Gle(r.classWeight, t.outputNames), R = 0;
                    case 55:
                        if (!(R < A.length)) {
                            e.next = 64;
                            break
                        }
                        return e.t0 = C, e.next = 59, jle(T[R], null, A[R]);
                    case 59:
                        e.t1 = e.sent, e.t0.push.call(e.t0, e.t1);
                    case 61:
                        ++R, e.next = 55;
                        break;
                    case 64:
                        for (_ = S.concat(T).concat(C), O = l(_), Y5(_), F = 0; F < h.length; ++F) D = h[F], M = O[F], E[D] = M, J5(M);
                        return e.next = 70, m.onBatchEnd(w, E);
                    case 70:
                        Xce(E), w++, k++;
                    case 73:
                        if (!(a ? k >= r.batchesPerEpoch : I.done)) {
                            e.next = 87;
                            break
                        }
                        if (!i) {
                            e.next = 86;
                            break
                        }
                        if (L = void 0, !$le(r.validationData)) {
                            e.next = 84;
                            break
                        }
                        return e.t2 = Lse, e.next = 80, t.evaluateDataset(r.validationData, {
                            batches: r.validationBatches
                        });
                    case 80:
                        e.t3 = e.sent, L = (0, e.t2)(e.t3), e.next = 85;
                        break;
                    case 84:
                        L = Lse(t.evaluate(s, u, {
                            batchSize: null == r.validationBatchSize ? 32 : r.validationBatchSize,
                            verbose: 0
                        }));
                    case 85:
                        for (z = 0; z < t.metricsNames.length; ++z) x["val_".concat(t.metricsNames[z])] = L[z];
                    case 86:
                        return e.abrupt("break", 91);
                    case 87:
                        if (!t.stopTraining_) {
                            e.next = 89;
                            break
                        }
                        return e.abrupt("break", 91);
                    case 89:
                        e.next = 37;
                        break;
                    case 91:
                        return e.next = 93, m.onEpochEnd(y, x);
                    case 93:
                        if (y++, !t.stopTraining_) {
                            e.next = 96;
                            break
                        }
                        return e.abrupt("break", 98);
                    case 96:
                        e.next = 27;
                        break;
                    case 98:
                        return e.next = 100, m.onTrainEnd();
                    case 100:
                        return e.next = 102, t.history.syncData();
                    case 102:
                        return e.abrupt("return", t.history);
                    case 103:
                        return e.prev = 103, t.isTraining = !1, e.finish(103);
                    case 106:
                    case "end":
                        return e.stop()
                }
            }), e, null, [
                [9, , 103, 106]
            ])
        }))), Zle.apply(this, arguments)
    }

    function Qle(e, t) {
        var n = null;
        return null != t.batchesPerEpoch ? n = t.batchesPerEpoch : Number.isFinite(e.size) && (n = e.size), n
    }

    function $le(e) {
        return "function" == typeof e.iterator
    }

    function ehe(e) {
        return "function" == typeof e.next
    }

    function the(e, t, n) {
        return nhe.apply(this, arguments)
    }

    function nhe() {
        return nhe = c(o().mark((function e(t, n, r) {
            var a, i, s, u, c, l, h, p, f;
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        if (a = null != (r = r || {}).batches, i = t.testFunction, s = [], !(r.verbose > 0)) {
                            e.next = 6;
                            break
                        }
                        throw new Ase("Verbose mode is not implemented yet.");
                    case 6:
                        if (F$(!a || r.batches > 0 && Number.isInteger(r.batches), (function() {
                                return "Test loop expects `batches` to be a positive integer, but " + "received ".concat(JSON.stringify(r.batches))
                            })), !ehe(n)) {
                            e.next = 11;
                            break
                        }
                        e.t0 = n, e.next = 14;
                        break;
                    case 11:
                        return e.next = 13, n.iterator();
                    case 13:
                        e.t0 = e.sent;
                    case 14:
                        u = e.t0, c = 0, l = 0, h = o().mark((function e() {
                            var n;
                            return o().wrap((function(e) {
                                for (;;) switch (e.prev = e.next) {
                                    case 0:
                                        return e.next = 2, u.next();
                                    case 2:
                                        if (n = e.sent, s = X5((function() {
                                                if (n.value) {
                                                    var e = Kle(t, n.value),
                                                        r = e.xs,
                                                        a = e.ys,
                                                        o = r.concat(a),
                                                        u = X5((function() {
                                                            return i(o)
                                                        }));
                                                    if (Y5(o), 0 === l)
                                                        for (var h = 0; h < u.length; ++h) s.push(i9(0));
                                                    for (var p = o[0].shape[0], f = function(e) {
                                                            var t = u[e],
                                                                n = s[e];
                                                            s[e] = X5((function() {
                                                                return d8(s[e], g8(p, t))
                                                            })), l > 0 && Y5(n)
                                                        }, d = 0; d < u.length; ++d) f(d);
                                                    Y5(u), c += p, ++l
                                                }
                                                return s
                                            })), !n.done) {
                                            e.next = 7;
                                            break
                                        }
                                        return a && console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` " + "batches (in this case, ".concat(r.batches, " batches). ") + "You may need to use the repeat() function when building your dataset."), e.abrupt("return", "break");
                                    case 7:
                                    case "end":
                                        return e.stop()
                                }
                            }), e)
                        }));
                    case 18:
                        if (a && !(l < r.batches)) {
                            e.next = 25;
                            break
                        }
                        return e.delegateYield(h(), "t1", 20);
                    case 20:
                        if ("break" !== e.t1) {
                            e.next = 23;
                            break
                        }
                        return e.abrupt("break", 25);
                    case 23:
                        e.next = 18;
                        break;
                    case 25:
                        for (p = 0; p < s.length; ++p) f = s[p], s[p] = m8(s[p], c), Y5(f);
                        return e.abrupt("return", Mse(s));
                    case 27:
                    case "end":
                        return e.stop()
                }
            }), e)
        }))), nhe.apply(this, arguments)
    }

    function rhe(e) {
        F$(e > 0 && Number.isInteger(e), (function() {
            return "batchSize is required to be a positive integer, but got ".concat(e)
        }))
    }

    function ahe(e, t, n) {
        return null == e ? [null] : Array.isArray(e) ? e.map((function(e) {
            return Sue(e, t, n - t)
        })) : Sue(e, t, n - t)
    }

    function ihe(e, t) {
        return X5((function() {
            return null == e ? null : Array.isArray(e) ? e.map((function(e) {
                return ihe(e, t)
            })) : Fue(e, "int32" === t.dtype ? t : h8(t, "int32"))
        }))
    }

    function ohe(e, t) {
        for (var n = [], r = 0, a = null; r < e;)(a = r + t) >= e && (a = e), n.push([r, a]), r = a;
        return n
    }

    function she(e) {
        var t = [];
        e instanceof n5 && (e = [e]);
        for (var n = 0; n < e.length; ++n) {
            var r = e[n];
            if (1 === r.rank) t.push(Iue(r, 1));
            else {
                if (0 === r.rank) throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");
                t.push(r)
            }
        }
        return t
    }

    function uhe(e, t) {
        if (null != e) {
            var n = [];
            if (t instanceof n5) n.push(t.id);
            else if (Array.isArray(t)) t.forEach((function(e) {
                return n.push(e.id)
            }));
            else if (null != t)
                for (var r in t) {
                    var a = t[r];
                    n.push(a.id)
                }
            var i = [];
            if (e instanceof n5) - 1 === n.indexOf(e.id) && i.push(e);
            else if (Array.isArray(e)) e.forEach((function(e) {
                -1 === n.indexOf(e.id) && i.push(e)
            }));
            else if (null != e)
                for (var o in e) {
                    var s = e[o]; - 1 === n.indexOf(s.id) && i.push(s)
                }
            i.forEach((function(e) {
                e.isDisposed || e.dispose()
            }))
        }
    }

    function che(e) {
        return Array.isArray(e)
    }

    function lhe(e) {
        return ! function(e) {
            return e instanceof n5
        }(e) && !che(e)
    }

    function hhe(e, t, n) {
        var r, a = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
            i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "";
        if (null == t || 0 === t.length) {
            if (null != e) {
                var o = !1;
                if (che(e) && e.length > 0) o = !0;
                else if (lhe(e)) {
                    for (var s in e)
                        if (e.hasOwnProperty(s)) {
                            o = !0;
                            break
                        }
                } else o = !0;
                if (o) throw new Cse("Error when checking model ".concat(i, " expected no data, ") + "but got ".concat(e))
            }
            return []
        }
        if (null == e) return t.map((function(e) {
            return null
        }));
        if (lhe(e)) {
            r = [];
            var u, c = O(t);
            try {
                for (c.s(); !(u = c.n()).done;) {
                    var l = u.value;
                    if (null == e[l]) throw new Cse('No data provided for "'.concat(l, '". Need data for each key in: ') + "".concat(t));
                    r.push(e[l])
                }
            } catch (e) {
                c.e(e)
            } finally {
                c.f()
            }
        } else if (che(e)) {
            if (e.length !== t.length) throw new Cse("Error when checking model ".concat(i, ": the Array of ") + "Tensors that you are passing to your model is not the size the " + "model expected. Expected to see ".concat(t.length, " Tensor(s), but ") + "instead got the following list of Tensor(s): ".concat(e));
            r = e
        } else {
            if (t.length > 1) throw new Cse("The model ".concat(i, " expects ").concat(t.length, " Tensor(s), ") + "but only received one Tensor. Found: Tensor with shape ".concat(e.shape));
            r = [e]
        }
        if (r = she(r), null != n)
            for (var h = 0; h < t.length; ++h)
                if (null != n[h]) {
                    var p = r[h];
                    if (p.shape.length !== n[h].length) throw new Cse("Error when checking ".concat(i, ": expected ").concat(t[h], " ") + "to have ".concat(n[h].length, " dimension(s). but got array with ") + "shape ".concat(p.shape));
                    for (var f = 0; f < n[h].length; ++f)
                        if (0 !== f || a) {
                            var d = p.shape[f],
                                v = n[h][f];
                            if (null != v && v >= 0 && d !== v) throw new Cse("".concat(i, " expected a batch of elements where each ") + "example has shape [".concat(n[h].slice(1, n[h].length), "] ") + "(i.e.,tensor shape [*,".concat(n[h].slice(1, n[h].length), "])") + " but the ".concat(i, " received an input with ").concat(p.shape[0]) + " examples, each with shape [".concat(p.shape.slice(1, p.shape.length), "]") + " (tensor shape [".concat(p.shape, "])"))
                        }
                }
        return r
    }

    function phe(e, t, n) {
        var r = jse(e.map((function(e) {
            return e.shape[0]
        })));
        r.sort();
        var a = jse(t.map((function(e) {
            return e.shape[0]
        })));
        if (a.sort(), r.length > 1) throw new Cse("All input Tensors (x) should have the same number of samples. Got array shapes: " + "".concat(JSON.stringify(e.map((function(e) {
            return e.shape
        })))));
        if (a.length > 1) throw new Cse("All target Tensors (y) should have the same number of samples. Got array shapes: " + "".concat(JSON.stringify(t.map((function(e) {
            return e.shape
        })))));
        if (r.length > 0 && a.length > 0 && !P$(r, a)) throw new Cse("Input Tensors should have the same number of samples as target " + "Tensors. Found ".concat(r[0], " input sample(s) and ").concat(a[0], " target ") + "sample(s).")
    }

    function fhe(e, t, n) {
        for (var r = [ile, hle, cle], a = 0; a < e.length; ++a) {
            var i = e[a],
                o = t[a],
                s = n[a];
            if (null != o) {
                if (o === cle && 1 === i.shape[i.shape.length - 1]) throw new Cse("You are passing a target array of shape ".concat(i.shape, " while using ") + "a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");
                if (-1 !== r.indexOf(o))
                    for (var u = i.shape.slice(1), c = s.slice(1), l = 0; l < u.length; ++l) {
                        var h = u[l],
                            p = c[l];
                        if (null != p && h !== p) throw new Cse("A target Tensor with shape ".concat(i.shape, " was passed for an ") + "output of shape ".concat(s, ", while using a loss function that ") + "expects targets to have the same shape as the output.")
                    }
            }
        }
    }

    function dhe(e, t, n) {
        var r, a = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
            i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "";
        if (Array.isArray(e)) {
            if (e.length !== t.length) throw new Cse("Error when checking model ".concat(i, ": the Array of ") + "Tensors that you are passing to your model is not the size the " + "the model expected. Expected to see ".concat(t.length, " Tensor(s),") + " but instead got ".concat(e.length, " Tensors(s)."));
            r = e
        } else {
            if (t.length > 1) throw new Cse("The model expects ".concat(t.length, " ").concat(i, " Tensors, ") + "but only received one Tensor. Found: array with shape " + "".concat(JSON.stringify(e.shape), "."));
            r = [e]
        }
        if (null != n)
            for (var o = 0; o < t.length; ++o)
                if (null != n[o]) {
                    var s = r[o];
                    if (s.shape.length !== n[o].length) throw new Cse("Error when checking ".concat(i, ": expected ").concat(t[o], " ") + "to have ".concat(n[o].length, " dimension(s), but got array with ") + "shape ".concat(JSON.stringify(s.shape)));
                    for (var u = 0; u < n[o].length; ++u)
                        if (0 !== u || a) {
                            var c = s.shape[u],
                                l = n[o][u];
                            if (null != l && l !== c) throw new Cse("Error when checking ".concat(i, ": expected ") + "".concat(t[o], " to have shape ").concat(JSON.stringify(n[o]), " but ") + "got array with shape ".concat(JSON.stringify(s.shape), "."))
                        }
                }
    }
    var vhe = function(e) {
        d(m, e);
        var t, n, r, a, i, u, h, f = w(m);

        function m(e) {
            var t;
            return l(this, m), (t = f.call(this, e)).isTraining = !1, t
        }
        return p(m, [{
            key: "summary",
            value: function(e, t) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : console.log;
                if (!this.built) throw new Cse("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");
                Rle(this, e, t, n)
            }
        }, {
            key: "compile",
            value: function(e) {
                var t = this;
                if (null == e.loss && (e.loss = []), this.loss = e.loss, "string" == typeof e.optimizer) this.optimizer_ = function(e) {
                    var t = {
                        Adagrad: function() {
                            return nie.adagrad(.01)
                        },
                        Adadelta: function() {
                            return nie.adadelta(1, .95, kue())
                        },
                        Adam: function() {
                            return nie.adam(.001, .9, .999, kue())
                        },
                        Adamax: function() {
                            return nie.adamax(.002, .9, .999, kue(), 0)
                        },
                        RMSProp: function() {
                            return nie.rmsprop(.001, .9, 0, kue())
                        },
                        SGD: function() {
                            return nie.sgd(.01)
                        }
                    };
                    if (t.adagrad = t.Adagrad, t.adadelta = t.Adadelta, t.adam = t.Adam, t.adamax = t.Adamax, t.rmsprop = t.RMSProp, t.sgd = t.SGD, e in t) return t[e]();
                    throw new Cse("Unknown Optimizer ".concat(e))
                }(e.optimizer), this.isOptimizerOwned = !0;
                else {
                    if (!(e.optimizer instanceof Yre)) throw new Cse("User-defined optimizer must be an instance of tf.Optimizer.");
                    this.optimizer_ = e.optimizer, this.isOptimizerOwned = !1
                }
                var n = [];
                if (Array.isArray(e.loss) || "string" == typeof e.loss || "function" == typeof e.loss)
                    if (Array.isArray(e.loss)) {
                        if (e.loss.length !== this.outputs.length) throw new Cse("When passing an Array as loss, it should have one entry per " + "model output. The model has ".concat(this.outputs.length, " output(s), ") + "but you passed loss=".concat(e.loss, "."));
                        var r = e.loss;
                        n = r.map((function(e) {
                            return vle(e)
                        }))
                    } else {
                        var a = vle(e.loss);
                        this.outputs.forEach((function(e) {
                            n.push(a)
                        }))
                    } else {
                    for (var i in e.loss = e.loss, e.loss)
                        if (-1 === this.outputNames.indexOf(i)) throw new Cse('Unknown entry in loss dictionary: "'.concat(i, '". ') + "Only expected the following keys: ".concat(this.outputNames));
                    var o, u = O(this.outputNames);
                    try {
                        for (u.s(); !(o = u.n()).done;) {
                            var c = o.value;
                            null == e.loss[c] && console.warn('Output "'.concat(c, '" is missing from loss dictionary. We assume ') + "this was done on purpose, and we will not be expecting data " + "to be passed to ".concat(c, " during training")), n.push(vle(e.loss[c]))
                        }
                    } catch (e) {
                        u.e(e)
                    } finally {
                        u.f()
                    }
                }
                this.lossFunctions = n, this.feedOutputNames = [], this.feedOutputShapes = [], this.feedLossFns = [];
                for (var l = 0; l < this.outputs.length; ++l) {
                    var h = this.internalOutputShapes[l],
                        p = this.outputNames[l];
                    this.feedOutputNames.push(p), this.feedOutputShapes.push(h), this.feedLossFns.push(this.lossFunctions[l])
                }
                var f = [];
                this.metrics = e.metrics, this.metricsNames = ["loss"], this.metricsTensors = [], hue("loss", (function() {
                    for (var e = 0; e < t.outputs.length; ++e)
                        if (-1 === f.indexOf(e)) {
                            var n = t.lossFunctions[e];
                            t.outputs.length > 1 && (t.metricsTensors.push([n, e]), t.metricsNames.push(t.outputNames[e] + "_loss"))
                        }
                }));
                var d = function(e, t) {
                    if (null == e || Array.isArray(e) && 0 === e.length) return t.map((function(e) {
                        return []
                    }));
                    var n;
                    if ("string" == typeof e || "function" == typeof e) n = [e];
                    else {
                        if (!Array.isArray(e) && "object" !== s(e)) throw new TypeError("Type of metrics argument not understood. Expected an string," + "function, Array, or Object, found: ".concat(e));
                        n = e
                    }
                    if (Array.isArray(n)) return t.map((function(e) {
                        return n
                    }));
                    var r, a = [],
                        i = O(t);
                    try {
                        for (i.s(); !(r = i.n()).done;) {
                            var o = r.value,
                                u = n.hasOwnProperty(o) ? n[o] : [];
                            Array.isArray(u) || (u = [u]), a.push(u)
                        }
                    } catch (e) {
                        i.e(e)
                    } finally {
                        i.f()
                    }
                    return a
                }(e.metrics, this.outputNames);
                hue("metric", (function() {
                    for (var e = function(e) {
                            if (-1 !== f.indexOf(e)) return "continue";
                            ! function(n) {
                                var r, a, i, o, s = O(n);
                                try {
                                    var u = function() {
                                        var n, s = o.value;
                                        if ("string" == typeof s && -1 !== ["accuracy", "acc", "crossentropy", "ce"].indexOf(s)) {
                                            var u, c = t.internalOutputShapes[e];
                                            1 === c[c.length - 1] || t.lossFunctions[e] === hle ? -1 !== ["accuracy", "acc"].indexOf(s) ? a = mle : -1 !== ["crossentropy", "ce"].indexOf(s) && (a = kle) : t.lossFunctions[e] === lle ? -1 !== ["accuracy", "acc"].indexOf(s) ? a = wle : -1 !== ["crossentropy", "ce"].indexOf(s) && (a = Nle) : -1 !== ["accuracy", "acc"].indexOf(s) ? a = gle : -1 !== ["crossentropy", "ce"].indexOf(s) && (a = Ile), -1 !== ["accuracy", "acc"].indexOf(s) ? u = "acc" : -1 !== ["crossentropy", "ce"].indexOf(s) && (u = "ce"), i = a, r = "" + u
                                        } else {
                                            var l = function(e) {
                                                if ("string" == typeof e && e in Sle) return Sle[e];
                                                if ("string" != typeof e && null != e) return e;
                                                throw new Cse("Unknown metric ".concat(e))
                                            }(s);
                                            i = l, r = "" + Tle(s)
                                        }
                                        hue(r, (function() {
                                                n = i
                                            })),
                                            function(e, n, r) {
                                                t.outputNames.length > 1 && (n = t.outputNames[e] + "_" + n), t.metricsNames.push(n), t.metricsTensors.push([r, e])
                                            }(e, r, n)
                                    };
                                    for (s.s(); !(o = s.n()).done;) u()
                                } catch (e) {
                                    s.e(e)
                                } finally {
                                    s.f()
                                }
                            }(d[e])
                        }, n = 0; n < t.outputs.length; ++n) e(n)
                })), this.collectedTrainableWeights = this.trainableWeights
            }
        }, {
            key: "checkTrainableWeightsConsistency",
            value: function() {
                null != this.collectedTrainableWeights && this.trainableWeights.length !== this.collectedTrainableWeights.length && console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")
            }
        }, {
            key: "evaluate",
            value: function(e, t) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                    r = null == n.batchSize ? 32 : n.batchSize;
                rhe(r);
                var a = !0,
                    i = this.standardizeUserDataXY(e, t, a, r);
                try {
                    var o = i[0].concat(i[1]);
                    this.makeTestFunction();
                    var s = this.testFunction,
                        u = this.testLoop(s, o, r, n.verbose, n.steps);
                    return Mse(u)
                } finally {
                    uhe(i[0], e), uhe(i[1], t)
                }
            }
        }, {
            key: "evaluateDataset",
            value: (h = c(o().mark((function e(t, n) {
                return o().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return this.makeTestFunction(), e.abrupt("return", the(this, t, n));
                        case 2:
                        case "end":
                            return e.stop()
                    }
                }), e, this)
            }))), function(e, t) {
                return h.apply(this, arguments)
            })
        }, {
            key: "checkNumSamples",
            value: function(e, t, n) {
                var r, a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "steps";
                if (null != n) {
                    if (r = null, null != t) throw new Cse("If ".concat(a, " is set, batchSize must be null or undefined.") + "Got batchSize = ".concat(t))
                } else {
                    if (null == e) throw new Cse("Either the input data should have a defined shape, or " + "".concat(a, " shoud be specified."));
                    r = Array.isArray(e) ? e[0].shape[0] : e.shape[0]
                }
                return r
            }
        }, {
            key: "execute",
            value: function(e, t) {
                if (Array.isArray(t) && 0 === t.length) throw new Cse("`outputs` is an empty Array, which is not allowed.");
                var n = Array.isArray(t),
                    r = n ? t : [t],
                    a = this.retrieveSymbolicTensors(r),
                    i = new Tce;
                if (e instanceof n5 && (e = [e]), Array.isArray(e)) {
                    if (e.length !== this.inputs.length) throw new Cse("The number of inputs provided (".concat(e.length, ") ") + "does not match the number of inputs of this model " + "(".concat(this.inputs.length, ")."));
                    for (var o = 0; o < this.inputs.length; ++o) i.add(this.inputs[o], e[o])
                } else {
                    var s, u = O(this.inputs);
                    try {
                        for (u.s(); !(s = u.n()).done;) {
                            var c = s.value,
                                l = e[c.name];
                            if (null == l) throw new Cse("No value is provided for the model's input ".concat(c.name));
                            i.add(c, l)
                        }
                    } catch (e) {
                        u.e(e)
                    } finally {
                        u.f()
                    }
                }
                var h = Ace(a, i);
                return n ? h : h[0]
            }
        }, {
            key: "retrieveSymbolicTensors",
            value: function(e) {
                var t, n = Ose(null, e.length),
                    r = e.length,
                    a = O(this.layers);
                try {
                    for (a.s(); !(t = a.n()).done;) {
                        for (var i = t.value, o = Array.isArray(i.output) ? i.output : [i.output], s = o.map((function(e) {
                                return e.name
                            })), u = 0; u < e.length; ++u) {
                            var c = s.indexOf(e[u]);
                            if (-1 !== c && (n[u] = o[c], r--), 0 === r) break
                        }
                        if (0 === r) break
                    }
                } catch (e) {
                    a.e(e)
                } finally {
                    a.f()
                }
                if (r > 0) {
                    var l = [];
                    throw n.forEach((function(t, n) {
                        null == t && l.push(e[n])
                    })), new Cse("Cannot find SymbolicTensors for output name(s): " + "".concat(JSON.stringify(l)))
                }
                return n
            }
        }, {
            key: "predictLoop",
            value: function(e) {
                var t = this,
                    n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 32,
                    r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                return X5((function() {
                    var a = t.checkNumSamples(e);
                    if (r) throw new Ase("Verbose predictLoop() is not implemented yet.");
                    for (var i = ohe(a, n), o = t.outputs.map((function(e) {
                            return []
                        })), s = function(n) {
                            X5((function() {
                                var r = i[n][0],
                                    a = i[n][1],
                                    o = ahe(e, r, a),
                                    s = [];
                                if (Array.isArray(o))
                                    for (var u = 0; u < o.length; ++u) s.push({
                                        key: t.inputs[u],
                                        value: o[u]
                                    });
                                else s.push({
                                    key: t.inputs[0],
                                    value: o
                                });
                                var c = new Tce(s);
                                return Ace(t.outputs, c)
                            })).forEach((function(e, t) {
                                return o[t].push(e)
                            }))
                        }, u = 0; u < i.length; ++u) s(u);
                    return Mse(o.map((function(e) {
                        return Z8(e, 0)
                    })))
                }))
            }
        }, {
            key: "predict",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    n = she(e);
                dhe(n, this.inputNames, this.feedInputShapes, !1);
                try {
                    var r = null == t.batchSize ? 32 : t.batchSize;
                    return rhe(r), this.predictLoop(n, r)
                } finally {
                    uhe(n, e)
                }
            }
        }, {
            key: "predictOnBatch",
            value: function(e) {
                dhe(e, this.inputNames, this.feedInputShapes, !0);
                var t = (Array.isArray(e) ? e[0] : e).shape[0];
                return this.predictLoop(e, t)
            }
        }, {
            key: "standardizeUserDataXY",
            value: function(e, t) {
                var n = arguments.length > 3 ? arguments[3] : void 0;
                if (null == this.optimizer_) throw new Ese("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");
                for (var r = [], a = 0; a < this.feedOutputShapes.length; ++a) {
                    var i = this.feedOutputShapes[a],
                        o = this.feedLossFns[a];
                    o === lle ? r.push(i.slice(0, i.length - 1).concat([1])) : r.push(i)
                }
                if (phe(e = hhe(e, this.feedInputNames, this.feedInputShapes, !1, "input"), t = hhe(t, this.feedOutputNames, r, !1, "target")), fhe(t, this.feedLossFns, this.feedOutputShapes), this.stateful && null != n && n > 0 && e[0].shape[0] % n != 0) throw new Cse("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size " + "".concat(n, ". Found: ").concat(e[0].shape[0], " sample(s)."));
                return [e, t]
            }
        }, {
            key: "standardizeUserData",
            value: (u = c(o().mark((function e(t, n, r, a) {
                var i, s, u, c, l, h, p, f, d, v = arguments;
                return o().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if (i = !(v.length > 4 && void 0 !== v[4]) || v[4], s = v.length > 5 ? v[5] : void 0, u = this.standardizeUserDataXY(t, n, i, s), c = S(u, 2), l = c[0], h = c[1], null == r) {
                                e.next = 5;
                                break
                            }
                            throw new Error("sample weight is not supported yet.");
                        case 5:
                            if (p = null, null == a) {
                                e.next = 19;
                                break
                            }
                            f = Gle(a, this.outputNames), p = [], d = 0;
                        case 10:
                            if (!(d < f.length)) {
                                e.next = 19;
                                break
                            }
                            return e.t0 = p, e.next = 14, jle(h[d], null, f[d]);
                        case 14:
                            e.t1 = e.sent, e.t0.push.call(e.t0, e.t1);
                        case 16:
                            ++d, e.next = 10;
                            break;
                        case 19:
                            return e.abrupt("return", [l, h, p]);
                        case 20:
                        case "end":
                            return e.stop()
                    }
                }), e, this)
            }))), function(e, t, n, r) {
                return u.apply(this, arguments)
            })
        }, {
            key: "testLoop",
            value: function(e, t, n) {
                var r = this,
                    a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                    i = arguments.length > 4 ? arguments[4] : void 0;
                return X5((function() {
                    var o = r.checkNumSamples(t, n, i, "steps"),
                        s = [];
                    if (a > 0) throw new Ase("Verbose mode is not implemented yet.");
                    if (null != i) throw new Ase("steps mode in testLoop() is not implemented yet");
                    for (var u = ohe(o, n), c = Vte(xue(0, o)), l = 0; l < u.length; ++l) {
                        var h = u[l][0],
                            p = u[l][1],
                            f = Sue(c, h, p - h),
                            d = ihe(t, f),
                            v = e(d);
                        if (0 === l)
                            for (var m = 0; m < v.length; ++m) s.push(i9(0));
                        for (var g = 0; g < v.length; ++g) {
                            var y = v[g];
                            s[g] = d8(s[g], g8(p - h, y))
                        }
                    }
                    for (var b = 0; b < s.length; ++b) s[b] = m8(s[b], o);
                    return s
                }))
            }
        }, {
            key: "getDedupedMetricsNames",
            value: function() {
                for (var e = this.metricsNames, t = [], n = 0; n < e.length; ++n) {
                    var r = e[n],
                        a = r;
                    if (Dse(e, r) > 1) {
                        var i = Dse(e.slice(0, n), r);
                        a += "_".concat(i)
                    }
                    t.push(a)
                }
                return t
            }
        }, {
            key: "makeTrainFunction",
            value: function() {
                var e = this;
                return function(t) {
                    var n = [],
                        r = t.slice(0, e.inputs.length),
                        a = t.slice(e.inputs.length, e.inputs.length + e.outputs.length),
                        i = t.slice(e.inputs.length + e.outputs.length, e.inputs.length + 2 * e.outputs.length),
                        o = [],
                        s = e.collectedTrainableWeights.map((function(e) {
                            return e.read()
                        }));
                    return [e.optimizer_.minimize((function() {
                        for (var t = [], s = 0; s < e.inputs.length; ++s) t.push({
                            key: e.inputs[s],
                            value: r[s]
                        });
                        for (var u, c = new Tce(t), l = Ace(e.outputs, c, {
                                training: !0
                            }), h = 0; h < e.lossFunctions.length; ++h) {
                            var p = (0, e.lossFunctions[h])(a[h], l[h]);
                            null != i[h] && (p = qle(p, i[h]));
                            var f = Q9(p);
                            n.push(f), u = 0 === h ? p : d8(u, p)
                        }
                        for (var d = 0; d < e.metricsTensors.length; ++d) {
                            var v = void 0;
                            if (e.outputs.length > 1 && d < e.outputs.length) v = n[d];
                            else {
                                var m = e.metricsTensors[d][0],
                                    g = e.metricsTensors[d][1];
                                v = Q9(m(a[g], l[g]))
                            }
                            J5(v), o.push(v)
                        }
                        return u = Q9(u), e.calculateLosses().forEach((function(e) {
                            u = d8(u, e)
                        })), u
                    }), !0, s)].concat(o)
                }
            }
        }, {
            key: "makeTestFunction",
            value: function() {
                var e = this;
                this.testFunction = function(t) {
                    return X5((function() {
                        for (var n, r = [], a = t.slice(0, e.inputs.length), i = t.slice(e.inputs.length, e.inputs.length + e.outputs.length), o = [], s = 0; s < e.inputs.length; ++s) o.push({
                            key: e.inputs[s],
                            value: a[s]
                        });
                        for (var u = new Tce(o), c = Ace(e.outputs, u), l = 0; l < e.lossFunctions.length; ++l) {
                            var h = e.lossFunctions[l],
                                p = Q9(h(i[l], c[l]));
                            n = 0 === l ? p : d8(n, p), r.push(n)
                        }
                        for (var f = 0; f < e.metricsTensors.length; ++f) {
                            var d = e.metricsTensors[f][0],
                                v = e.metricsTensors[f][1],
                                m = Q9(d(i[v], c[v]));
                            r.push(m)
                        }
                        return r
                    }))
                }
            }
        }, {
            key: "fit",
            value: (i = c(o().mark((function e(t, n) {
                var r, a, i, s, u, c, l, h, p, f, d, v, m, g, y, b, x, k, w, I, N, S, T, E, C, A, R = arguments;
                return o().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if (r = R.length > 2 && void 0 !== R[2] ? R[2] : {}, !this.isTraining) {
                                e.next = 3;
                                break
                            }
                            throw new Error("Cannot start training because another fit() call is ongoing.");
                        case 3:
                            return this.isTraining = !0, e.prev = 4, rhe(d = null == r.batchSize ? 32 : r.batchSize), v = !1, e.next = 10, this.standardizeUserData(t, n, r.sampleWeight, r.classWeight, v, d);
                        case 10:
                            if (m = e.sent, a = m[0], i = m[1], f = m[2], g = !1, !(null != r.validationData && r.validationData.length > 0)) {
                                e.next = 36;
                                break
                            }
                            if (g = !0, 2 !== r.validationData.length) {
                                e.next = 22;
                                break
                            }
                            c = r.validationData[0], l = r.validationData[1], e.next = 27;
                            break;
                        case 22:
                            if (3 !== r.validationData.length) {
                                e.next = 26;
                                break
                            }
                            throw new Ase("validationData including sample weights is not supported yet.");
                        case 26:
                            throw new Cse("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; " + "".concat(r.validationData, " is invalid."));
                        case 27:
                            return b = !0, e.next = 30, this.standardizeUserData(c, l, null, null, b, d);
                        case 30:
                            x = e.sent, h = x[0], p = x[1], y = h.concat(p), e.next = 37;
                            break;
                        case 36:
                            null != r.validationSplit && r.validationSplit > 0 && r.validationSplit < 1 ? (g = !0, k = Math.floor(a[0].shape[0] * (1 - r.validationSplit)), w = a[0].shape[0], h = ahe(a, k, w), s = a, a = ahe(a, 0, k), p = ahe(i, k, w), u = i, i = ahe(i, 0, k), y = h.concat(p)) : null != r.validationSteps && (g = !0);
                        case 37:
                            return I = a.concat(i).concat(f), this.checkTrainableWeightsConsistency(), N = this.makeTrainFunction(), S = this.getDedupedMetricsNames(), g ? (this.makeTestFunction(), T = this.testFunction, E = S.slice().concat(S.map((function(e) {
                                return "val_" + e
                            })))) : (T = null, y = [], E = S.slice()), C = ele(r.callbacks, r.yieldEvery), e.next = 45, this.fitLoop(N, I, S, d, r.epochs, r.verbose, C, T, y, r.shuffle, E, r.initialEpoch, null, null);
                        case 45:
                            return A = e.sent, e.abrupt("return", A);
                        case 47:
                            return e.prev = 47, this.isTraining = !1, uhe(a, t), uhe(i, n), uhe(s, t), uhe(u, n), uhe(h, c), uhe(p, l), null != f && Y5(f), e.finish(47);
                        case 57:
                        case "end":
                            return e.stop()
                    }
                }), e, this, [
                    [4, , 47, 57]
                ])
            }))), function(e, t) {
                return i.apply(this, arguments)
            })
        }, {
            key: "fitLoop",
            value: (a = c(o().mark((function e(t, n, r, a, i, s, u, c, l, h, p, f, d, v) {
                var m, g, y, b, x, k, w, I, N = this;
                return o().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if (null == a && (a = 32), null == i && (i = 1), null == h && (h = !0), null == f && (f = 0), m = !1, null != c && null != l && (m = !0), null == v) {
                                e.next = 10;
                                break
                            }
                            if (m = !0, null != d) {
                                e.next = 10;
                                break
                            }
                            throw new Cse("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");
                        case 10:
                            return null != (g = this.checkNumSamples(n, a, d, "steps_per_epoch")) && (y = xue(0, g)), null == s && (s = 1), b = nle(u, s, i, f, g, d, a, m, p), x = b.callbackList, k = b.history, x.setModel(this), this.history = k, e.next = 18, x.onTrainBegin();
                        case 18:
                            this.stopTraining_ = !1, w = o().mark((function e() {
                                var i, s, u, p, f;
                                return o().wrap((function(e) {
                                    for (;;) switch (e.prev = e.next) {
                                        case 0:
                                            return e.next = 2, x.onEpochBegin(I);
                                        case 2:
                                            if (i = {}, null == d) {
                                                e.next = 7;
                                                break
                                            }
                                            throw new Ase("stepsPerEpoch mode is not implemented yet.");
                                        case 7:
                                            if ("batch" !== h) {
                                                e.next = 11;
                                                break
                                            }
                                            throw new Ase("batch shuffling is not implemneted yet");
                                        case 11:
                                            h && C$(y);
                                        case 12:
                                            s = Vte(y), u = ohe(g, a), p = o().mark((function e(h) {
                                                var p;
                                                return o().wrap((function(e) {
                                                    for (;;) switch (e.prev = e.next) {
                                                        case 0:
                                                            return p = {}, e.next = 3, x.onBatchBegin(h, p);
                                                        case 3:
                                                            return X5((function() {
                                                                var e = u[h][0],
                                                                    o = u[h][1],
                                                                    f = Sue(s, e, o - e);
                                                                p.batch = h, p.size = o - e;
                                                                for (var d = ihe(n, f), v = t(d), g = 0; g < r.length; ++g) {
                                                                    var y = r[g],
                                                                        b = v[g];
                                                                    p[y] = b, J5(b)
                                                                }
                                                                if (h === u.length - 1 && m)
                                                                    for (var x = N.testLoop(c, l, a), k = 0; k < r.length; ++k) {
                                                                        var w = r[k],
                                                                            I = x[k];
                                                                        J5(I), i["val_" + w] = I
                                                                    }
                                                            })), e.next = 6, x.onBatchEnd(h, p);
                                                        case 6:
                                                            if (Xce(p), !N.stopTraining_) {
                                                                e.next = 9;
                                                                break
                                                            }
                                                            return e.abrupt("return", "break");
                                                        case 9:
                                                        case "end":
                                                            return e.stop()
                                                    }
                                                }), e)
                                            })), f = 0;
                                        case 16:
                                            if (!(f < u.length)) {
                                                e.next = 24;
                                                break
                                            }
                                            return e.delegateYield(p(f), "t0", 18);
                                        case 18:
                                            if ("break" !== e.t0) {
                                                e.next = 21;
                                                break
                                            }
                                            return e.abrupt("break", 24);
                                        case 21:
                                            ++f, e.next = 16;
                                            break;
                                        case 24:
                                            s.dispose();
                                        case 25:
                                            return e.next = 27, x.onEpochEnd(I, i);
                                        case 27:
                                            if (!N.stopTraining_) {
                                                e.next = 29;
                                                break
                                            }
                                            return e.abrupt("return", "break");
                                        case 29:
                                        case "end":
                                            return e.stop()
                                    }
                                }), e)
                            })), I = f;
                        case 21:
                            if (!(I < i)) {
                                e.next = 29;
                                break
                            }
                            return e.delegateYield(w(), "t0", 23);
                        case 23:
                            if ("break" !== e.t0) {
                                e.next = 26;
                                break
                            }
                            return e.abrupt("break", 29);
                        case 26:
                            ++I, e.next = 21;
                            break;
                        case 29:
                            return e.next = 31, x.onTrainEnd();
                        case 31:
                            return e.next = 33, this.history.syncData();
                        case 33:
                            return e.abrupt("return", this.history);
                        case 34:
                        case "end":
                            return e.stop()
                    }
                }), e, this)
            }))), function(e, t, n, r, i, o, s, u, c, l, h, p, f, d) {
                return a.apply(this, arguments)
            })
        }, {
            key: "fitDataset",
            value: (r = c(o().mark((function e(t, n) {
                return o().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return e.abrupt("return", Jle(this, t, n));
                        case 1:
                        case "end":
                            return e.stop()
                    }
                }), e, this)
            }))), function(e, t) {
                return r.apply(this, arguments)
            })
        }, {
            key: "trainOnBatch",
            value: (n = c(o().mark((function e(t, n) {
                var r, a, i, s, u, c, l, h, p, f;
                return o().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return e.next = 2, this.standardizeUserData(t, n);
                        case 2:
                            r = e.sent, a = r[0], i = r[1], s = this.makeTrainFunction(), u = s(a.concat(i)), c = [], l = O(u), e.prev = 9, l.s();
                        case 11:
                            if ((h = l.n()).done) {
                                e.next = 19;
                                break
                            }
                            return p = h.value, e.next = 15, p.data();
                        case 15:
                            f = e.sent, c.push(f[0]);
                        case 17:
                            e.next = 11;
                            break;
                        case 19:
                            e.next = 24;
                            break;
                        case 21:
                            e.prev = 21, e.t0 = e.catch(9), l.e(e.t0);
                        case 24:
                            return e.prev = 24, l.f(), e.finish(24);
                        case 27:
                            return Y5(u), uhe(r[0], t), uhe(r[1], n), e.abrupt("return", Mse(c));
                        case 31:
                        case "end":
                            return e.stop()
                    }
                }), e, this, [
                    [9, 21, 24, 27]
                ])
            }))), function(e, t) {
                return n.apply(this, arguments)
            })
        }, {
            key: "getNamedWeights",
            value: function(e) {
                for (var t = [], n = null != e && e.trainableOnly, r = n ? this.trainableWeights : this.weights, a = this.getWeights(n), i = 0; i < r.length; ++i) n && !r[i].trainable || t.push({
                    name: r[i].originalName,
                    tensor: a[i]
                });
                return t
            }
        }, {
            key: "stopTraining",
            get: function() {
                return this.stopTraining_
            },
            set: function(e) {
                this.stopTraining_ = e
            }
        }, {
            key: "optimizer",
            get: function() {
                return this.optimizer_
            },
            set: function(e) {
                this.optimizer_ !== e && (this.optimizer_ = e, this.isOptimizerOwned = !1)
            }
        }, {
            key: "dispose",
            value: function() {
                var e = N(v(m.prototype), "dispose", this).call(this);
                if (0 === e.refCountAfterDispose && null != this.optimizer && this.isOptimizerOwned) {
                    var t = K5().numTensors;
                    this.optimizer_.dispose(), e.numDisposedVariables += t - K5().numTensors
                }
                return e
            }
        }, {
            key: "getLossIdentifiers",
            value: function() {
                var e;
                if ("string" == typeof this.loss) e = zse(this.loss);
                else if (Array.isArray(this.loss)) {
                    var t, n = O(this.loss);
                    try {
                        for (n.s(); !(t = n.n()).done;) {
                            if ("string" != typeof t.value) throw new Error("Serialization of non-string loss is not supported.")
                        }
                    } catch (e) {
                        n.e(e)
                    } finally {
                        n.f()
                    }
                    e = this.loss.map((function(e) {
                        return zse(e)
                    }))
                } else {
                    var r = Object.keys(this.loss);
                    e = {};
                    for (var a = this.loss, i = 0, o = r; i < o.length; i++) {
                        var s = o[i];
                        if ("string" != typeof a[s]) throw new Error("Serialization of non-string loss is not supported.");
                        e[s] = zse(a[s])
                    }
                }
                return e
            }
        }, {
            key: "getMetricIdentifiers",
            value: function() {
                if ("string" == typeof this.metrics || "function" == typeof this.metrics) return [zse(Tle(this.metrics))];
                if (Array.isArray(this.metrics)) return this.metrics.map((function(e) {
                    return zse(Tle(e))
                }));
                var e = {};
                for (var t in this.metrics) e[t] = zse(Tle(this.metrics[t]));
                return e
            }
        }, {
            key: "getTrainingConfig",
            value: function() {
                return {
                    loss: this.getLossIdentifiers(),
                    metrics: this.getMetricIdentifiers(),
                    optimizer_config: {
                        class_name: this.optimizer.getClassName(),
                        config: this.optimizer.getConfig()
                    }
                }
            }
        }, {
            key: "loadTrainingConfig",
            value: function(e) {
                if (null != e.weighted_metrics) throw new Error("Loading weight_metrics is not supported yet.");
                if (null != e.loss_weights) throw new Error("Loading loss_weights is not supported yet.");
                if (null != e.sample_weight_mode) throw new Error("Loading sample_weight_mode is not supported yet.");
                var t, n, r = rle(zle(e.optimizer_config));
                if ("string" == typeof e.loss) t = Pse(e.loss);
                else if (Array.isArray(e.loss)) t = e.loss.map((function(e) {
                    return Pse(e)
                }));
                else if (null != e.loss)
                    for (var a in t = {}, e.loss) t[a] = Pse(e.loss[a]);
                if (Array.isArray(e.metrics)) n = e.metrics.map((function(e) {
                    return Pse(e)
                }));
                else if (null != e.metrics)
                    for (var i in n = {}, e.metrics) n[i] = Pse(e.metrics[i]);
                this.compile({
                    loss: t,
                    metrics: n,
                    optimizer: r
                })
            }
        }, {
            key: "save",
            value: (t = c(o().mark((function e(t, n) {
                var r, a, i, s, u, c, l, h, p;
                return o().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if ("string" != typeof t) {
                                e.next = 9;
                                break
                            }
                            if (0 !== (r = T6(t)).length) {
                                e.next = 6;
                                break
                            }
                            throw new Cse("Cannot find any save handlers for URL '".concat(t, "'"));
                        case 6:
                            if (!(r.length > 1)) {
                                e.next = 8;
                                break
                            }
                            throw new Cse("Found more than one (".concat(r.length, ") save handlers for ") + "URL '".concat(t, "'"));
                        case 8:
                            t = r[0];
                        case 9:
                            if (null != t.save) {
                                e.next = 11;
                                break
                            }
                            throw new Cse("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
                        case 11:
                            return e.next = 13, t6(this.getNamedWeights(n));
                        case 13:
                            if (a = e.sent, i = this.toJSON(null, !1), s = {
                                    modelTopology: i,
                                    format: "layers-model",
                                    generatedBy: "TensorFlow.js tfjs-layers v".concat(Ble),
                                    convertedBy: null
                                }, null == n || !n.includeOptimizer || null == this.optimizer) {
                                e.next = 34;
                                break
                            }
                            return s.trainingConfig = this.getTrainingConfig(), c = "optimizer", e.t0 = Nae, e.next = 25, this.optimizer.getWeights();
                        case 25:
                            return e.t1 = e.sent, e.t2 = c, e.next = 29, e.t0.encodeWeights.call(e.t0, e.t1, e.t2);
                        case 29:
                            l = e.sent, h = l.data, p = l.specs, (u = a.specs).push.apply(u, T(p)), a.data = g6([a.data, h]);
                        case 34:
                            return null != this.userDefinedMetadata && (Cle(this.userDefinedMetadata, this.name, !0), s.userDefinedMetadata = this.userDefinedMetadata), s.weightData = a.data, s.weightSpecs = a.specs, e.abrupt("return", t.save(s));
                        case 38:
                        case "end":
                            return e.stop()
                    }
                }), e, this)
            }))), function(e, n) {
                return t.apply(this, arguments)
            })
        }, {
            key: "setUserDefinedMetadata",
            value: function(e) {
                Cle(e, this.name), this.userDefinedMetadata = e
            }
        }, {
            key: "getUserDefinedMetadata",
            value: function() {
                return this.userDefinedMetadata
            }
        }]), m
    }(Ule);
    vhe.className = "Model", Kre(vhe);
    var mhe = function(e) {
        d(n, e);
        var t = w(n);

        function n() {
            return l(this, n), t.apply(this, arguments)
        }
        return p(n)
    }(vhe);

    function ghe() {
        return ghe = c(o().mark((function e(t, n) {
            var r, a, i, s, u, c, l, h;
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        if ("modelTopology" in t || (t = {
                                modelTopology: t
                            }), null != (r = t.modelTopology).model_config && (r = r.model_config), a = zle(r), i = rle(a, n), null == t.weightsManifest) {
                            e.next = 15;
                            break
                        }
                        return e.next = 9, hae(t.weightsManifest, t.pathPrefix, i.weights.map((function(e) {
                            return e.originalName
                        })));
                    case 9:
                        s = e.sent, u = {}, c = O(i.weights);
                        try {
                            for (c.s(); !(l = c.n()).done;) h = l.value, u[h.originalName] = s[h.originalName]
                        } catch (e) {
                            c.e(e)
                        } finally {
                            c.f()
                        }
                        i.loadWeights(u), Y5(s);
                    case 15:
                        return e.abrupt("return", i);
                    case 16:
                    case "end":
                        return e.stop()
                }
            }), e)
        }))), ghe.apply(this, arguments)
    }

    function yhe() {
        return (yhe = c(o().mark((function e(t, n) {
            var r;
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        if (null == n && (n = {}), "string" != typeof t) {
                            e.next = 10;
                            break
                        }
                        if (0 !== (r = E6(t, n)).length) {
                            e.next = 7;
                            break
                        }
                        r.push(bae(t, n)), e.next = 9;
                        break;
                    case 7:
                        if (!(r.length > 1)) {
                            e.next = 9;
                            break
                        }
                        throw new Cse("Found more than one (".concat(r.length, ") load handlers for ") + "URL '".concat(t, "'"));
                    case 9:
                        t = r[0];
                    case 10:
                        return e.abrupt("return", bhe(t, void 0, n));
                    case 11:
                    case "end":
                        return e.stop()
                }
            }), e)
        })))).apply(this, arguments)
    }

    function bhe(e, t, n) {
        return xhe.apply(this, arguments)
    }

    function xhe() {
        return xhe = c(o().mark((function e(t, n, r) {
            var a, i, s, u, c, l, h, p, f;
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        if (null == r && (r = {}), null != t.load) {
                            e.next = 3;
                            break
                        }
                        throw new Cse("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
                    case 3:
                        return e.next = 5, t.load();
                    case 5:
                        if (a = e.sent, null != (i = a.modelTopology).model_config && (i = i.model_config), s = null == r.strict || r.strict, u = null != a.weightData && null != a.weightSpecs && s, c = rle(zle(i), n, u), null != (l = a.trainingConfig) && c.loadTrainingConfig(l), null != a.userDefinedMetadata && c.setUserDefinedMetadata(a.userDefinedMetadata), null == a.weightData) {
                            e.next = 24;
                            break
                        }
                        if (null != a.weightSpecs) {
                            e.next = 17;
                            break
                        }
                        throw new Cse("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");
                    case 17:
                        if (h = khe(a.weightData, a.weightSpecs), p = h.modelWeights, f = h.optimizerWeights, c.loadWeights(p, s), !(null != c.optimizer && f.length > 0)) {
                            e.next = 22;
                            break
                        }
                        return e.next = 22, c.optimizer.setWeights(f);
                    case 22:
                        Y5(p), Y5(f.map((function(e) {
                            return e.tensor
                        })));
                    case 24:
                        return e.abrupt("return", c);
                    case 25:
                    case "end":
                        return e.stop()
                }
            }), e)
        }))), xhe.apply(this, arguments)
    }

    function khe(e, t) {
        var n = r6(e, t),
            r = {},
            a = [];
        return t.forEach((function(e) {
            "optimizer" === e.group ? a.push({
                name: e.name,
                tensor: n[e.name]
            }) : r[e.name] = n[e.name]
        })), {
            modelWeights: r,
            optimizerWeights: a
        }
    }
    mhe.className = "Functional", Kre(mhe);
    var whe = function(e) {
        d(a, e);
        var t, n, r = w(a);

        function a(e) {
            var t;
            if (l(this, a), e = e || {}, (t = r.call(this, {
                    inputs: [],
                    outputs: []
                })).trainable = !0, t.built = !1, t.name = null != e.name ? e.name : eue("sequential_"), null != e.layers) {
                var n, i = O(e.layers);
                try {
                    for (i.s(); !(n = i.n()).done;) {
                        var o = n.value;
                        t.add(o)
                    }
                } catch (e) {
                    i.e(e)
                } finally {
                    i.f()
                }
            }
            return t
        }
        return p(a, [{
            key: "checkShape",
            value: function(e) {
                if (e.inboundNodes[0].outputTensors[0].shape.some((function(e) {
                        return e < 0
                    }))) throw new Cse("Negative dimension size caused by adding layer " + "".concat(e.name, " with input shape [") + "".concat(e.inboundNodes[0].inputTensors[0].shape, "]"))
            }
        }, {
            key: "add",
            value: function(e) {
                var t, n = e instanceof a || e instanceof vhe;
                if (n) {
                    if (1 !== (t = e).outputs.length) throw new Cse("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
                    if (1 !== t.inputs.length) throw new Cse("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")
                }
                if (0 === this.outputs.length) {
                    if (0 === e.inboundNodes.length) {
                        if (null == e.batchInputShape) throw new Cse("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");
                        var r = Sce({
                            batchShape: e.batchInputShape,
                            dtype: e.dtype,
                            name: e.name + "_input"
                        });
                        e.apply(r)
                    }
                    if (n) this.outputs = t.outputs, this.inputs = t.inputs;
                    else {
                        if (1 !== e.inboundNodes.length) throw new Cse("A layer added to a Sequential model must not already be " + "connected somewhere else. LayersModel received layer ".concat(e.name, " ") + "which has ".concat(e.inboundNodes.length, " pre-existing inbound ") + "connections.");
                        if (1 !== e.inboundNodes[0].outputTensors.length) throw new Cse("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
                        this.checkShape(e), this.outputs = [e.inboundNodes[0].outputTensors[0]], this.inputs = Ice(this.outputs[0])
                    }
                    this.inboundNodes = [], new xce({
                        outboundLayer: this,
                        inboundLayers: [],
                        nodeIndices: [],
                        tensorIndices: [],
                        inputTensors: this.inputs,
                        outputTensors: this.outputs,
                        inputMasks: Ose(null, this.inputs.length),
                        outputMasks: [null],
                        inputShapes: this.inputs.map((function(e) {
                            return e.shape
                        })),
                        outputShapes: this.outputs[0].shape
                    })
                } else {
                    var i = e.apply(this.outputs[0]);
                    if (Array.isArray(i)) throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");
                    this.checkShape(e), this.outputs = [i], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [this.outputs[0].shape]
                }
                this.layers.push(e), this.built = !1
            }
        }, {
            key: "pop",
            value: function() {
                if (0 === this.layers.length) throw new TypeError("There are no layers in the model.");
                if (this.layers.pop(), 0 === this.layers.length) this.outputs = [], this.inboundNodes = [], this.outboundNodes = [];
                else {
                    var e = this.layers.length - 1;
                    this.layers[e].outboundNodes = [], this.outputs = [this.layers[e].output], this.inboundNodes[0].outputTensors = this.outputs, this.inboundNodes[0].outputShapes = [this.outputs[0].shape]
                }
            }
        }, {
            key: "call",
            value: function(e, t) {
                return null == this.model && this.build(), this.model.call(e, t)
            }
        }, {
            key: "build",
            value: function(e) {
                if (hce(e), 0 === this.inputs.length || 0 === this.outputs.length) throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");
                this.model = new vhe({
                    inputs: this.inputs,
                    outputs: this.outputs[0],
                    name: this.name + "_model"
                }), this.model.trainable = this.trainable, this.supportsMasking = this.model.supportsMasking, this.inputLayers = this.model.inputLayers, this.inputLayersNodeIndices = this.model.inputLayersNodeIndices, this.inputLayersTensorIndices = this.model.inputLayersTensorIndices, this.outputLayers = this.model.outputLayers, this.outputLayersNodeIndices = this.model.outputLayersNodeIndices, this.outputLayersTensorIndices = this.model.outputLayersTensorIndices, this.nodesByDepth = this.model.nodesByDepth, this.containerNodes = this.model.containerNodes, this.outputNames = this.model.outputNames, this.inputNames = this.model.inputNames, this.built = !0
            }
        }, {
            key: "countParams",
            value: function() {
                return this.built || this.build(), N(v(a.prototype), "countParams", this).call(this)
            }
        }, {
            key: "summary",
            value: function(e, t) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : console.log;
                this.built || this.build(), N(v(a.prototype), "summary", this).call(this, e, t, n)
            }
        }, {
            key: "setWeights",
            value: function(e) {
                null == this.model && this.build(), this.model.setWeights(e)
            }
        }, {
            key: "evaluate",
            value: function(e, t) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                if (!this.built) throw new Ese("The model needs to be compiled before being used.");
                return this.model.evaluate(e, t, n)
            }
        }, {
            key: "evaluateDataset",
            value: function() {
                var e = c(o().mark((function e(t, n) {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (this.built) {
                                    e.next = 2;
                                    break
                                }
                                throw new Ese("The model needs to be compiled before being used.");
                            case 2:
                                return e.abrupt("return", this.model.evaluateDataset(t, n));
                            case 3:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                })));
                return function(t, n) {
                    return e.apply(this, arguments)
                }
            }()
        }, {
            key: "predict",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                return null == this.model && this.build(), this.model.predict(e, t)
            }
        }, {
            key: "predictOnBatch",
            value: function(e) {
                return null == this.model && this.build(), this.model.predictOnBatch(e)
            }
        }, {
            key: "compile",
            value: function(e) {
                this.build(), this.model.compile(e), this.optimizer_ = this.model.optimizer, this.isOptimizerOwned = this.model.isOptimizerOwned, this.loss = this.model.loss, this.metrics = this.model.metrics, this.metricsTensors = this.model.metricsTensors, this.metricsNames = this.model.metricsNames
            }
        }, {
            key: "optimizer",
            get: function() {
                return null == this.model ? void 0 : this.model.optimizer
            },
            set: function(e) {
                this.model.optimizer = e
            }
        }, {
            key: "fit",
            value: (n = c(o().mark((function e(t, n) {
                var r, a = arguments;
                return o().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if (r = a.length > 2 && void 0 !== a[2] ? a[2] : {}, this.built) {
                                e.next = 3;
                                break
                            }
                            throw new Ese("The model needs to be compiled before being used.");
                        case 3:
                            return e.abrupt("return", this.model.fit(t, n, r));
                        case 4:
                        case "end":
                            return e.stop()
                    }
                }), e, this)
            }))), function(e, t) {
                return n.apply(this, arguments)
            })
        }, {
            key: "fitDataset",
            value: function() {
                var e = c(o().mark((function e(t, n) {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (this.built) {
                                    e.next = 2;
                                    break
                                }
                                throw new Ese("The model needs to be compiled before being used.");
                            case 2:
                                return e.abrupt("return", this.model.fitDataset(t, n));
                            case 3:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                })));
                return function(t, n) {
                    return e.apply(this, arguments)
                }
            }()
        }, {
            key: "trainOnBatch",
            value: (t = c(o().mark((function e(t, n) {
                return o().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return e.abrupt("return", this.model.trainOnBatch(t, n));
                        case 1:
                        case "end":
                            return e.stop()
                    }
                }), e, this)
            }))), function(e, n) {
                return t.apply(this, arguments)
            })
        }, {
            key: "stopTraining",
            get: function() {
                if (null == this.model) throw new Cse("Cannot get the stopTraining property of a sequential model before it is compiled.");
                return this.model.stopTraining
            },
            set: function(e) {
                if (null == this.model) throw new Cse("Cannot set the stopTraining property of a sequential model before it is compiled.");
                this.model.stopTraining = e
            }
        }, {
            key: "getConfig",
            value: function() {
                var e, t = [],
                    n = O(this.layers);
                try {
                    for (n.s(); !(e = n.n()).done;) {
                        var r = e.value,
                            a = {};
                        a.className = r.getClassName(), a.config = r.getConfig(), t.push(a)
                    }
                } catch (e) {
                    n.e(e)
                } finally {
                    n.f()
                }
                return {
                    name: this.name,
                    layers: t
                }
            }
        }], [{
            key: "fromConfig",
            value: function(e, t) {
                var n, r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
                    i = {};
                if (t instanceof Array) {
                    if (null == t[0].className || "Merge" === t[0].className) throw new Cse("Legacy serialization format not supported yet.");
                    n = t
                } else F$(null != t.layers, (function() {
                    return "When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."
                })), n = t.layers, delete t.layers, i = t;
                var o = new e(i);
                if (!(o instanceof a)) throw new Ase("Sequential.fromConfig called on non-Sequential input: ".concat(o));
                var s, u = O(n);
                try {
                    for (u.s(); !(s = u.n()).done;) {
                        var c = s.value,
                            l = void 0,
                            h = rle(c, l, r);
                        r && h.setFastWeightInitDuringBuild(!0), o.add(h)
                    }
                } catch (e) {
                    u.e(e)
                } finally {
                    u.f()
                }
                return o
            }
        }]), a
    }(vhe);

    function Ihe(e) {
        return Sce(e)
    }
    whe.className = "Sequential", Kre(whe);
    var Nhe = function(e) {
            d(n, e);
            var t = w(n);

            function n() {
                return l(this, n), t.apply(this, arguments)
            }
            return p(n, [{
                key: "getConfig",
                value: function() {
                    return {}
                }
            }]), n
        }(Hre),
        She = function(e) {
            d(n, e);
            var t = w(n);

            function n() {
                return l(this, n), t.apply(this, arguments)
            }
            return p(n, [{
                key: "apply",
                value: function(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                    return zue(e, t)
                }
            }]), n
        }(Nhe);
    She.className = "elu", Kre(She);
    var The = function(e) {
        d(n, e);
        var t = w(n);

        function n() {
            return l(this, n), t.apply(this, arguments)
        }
        return p(n, [{
            key: "apply",
            value: function(e) {
                return bte(e)
            }
        }]), n
    }(Nhe);
    The.className = "selu", Kre(The);
    var Ehe = function(e) {
        d(n, e);
        var t = w(n);

        function n() {
            return l(this, n), t.apply(this, arguments)
        }
        return p(n, [{
            key: "apply",
            value: function(e) {
                return lte(e)
            }
        }]), n
    }(Nhe);
    Ehe.className = "relu", Kre(Ehe);
    var Che = function(e) {
        d(n, e);
        var t = w(n);

        function n() {
            return l(this, n), t.apply(this, arguments)
        }
        return p(n, [{
            key: "apply",
            value: function(e) {
                return X5((function() {
                    return nee(6, lte(e))
                }))
            }
        }]), n
    }(Nhe);
    Che.className = "relu6", Kre(Che);
    var Ahe = function(e) {
        d(n, e);
        var t = w(n);

        function n() {
            return l(this, n), t.apply(this, arguments)
        }
        return p(n, [{
            key: "apply",
            value: function(e) {
                return e
            }
        }]), n
    }(Nhe);
    Ahe.className = "linear", Kre(Ahe);
    var Rhe = function(e) {
        d(n, e);
        var t = w(n);

        function n() {
            return l(this, n), t.apply(this, arguments)
        }
        return p(n, [{
            key: "apply",
            value: function(e) {
                return $8(e)
            }
        }]), n
    }(Nhe);
    Rhe.className = "sigmoid", Kre(Rhe);
    var _he = function(e) {
        d(n, e);
        var t = w(n);

        function n() {
            return l(this, n), t.apply(this, arguments)
        }
        return p(n, [{
            key: "apply",
            value: function(e) {
                return function(e) {
                    return X5((function() {
                        var t = d8(.5, g8(.2, e));
                        return d7(t, 0, 1)
                    }))
                }(e)
            }
        }]), n
    }(Nhe);
    _he.className = "hardSigmoid", Kre(_he);
    var Ohe = function(e) {
        d(n, e);
        var t = w(n);

        function n() {
            return l(this, n), t.apply(this, arguments)
        }
        return p(n, [{
            key: "apply",
            value: function(e) {
                return L9(e)
            }
        }]), n
    }(Nhe);
    Ohe.className = "softplus", Kre(Ohe);
    var Fhe = function(e) {
        d(n, e);
        var t = w(n);

        function n() {
            return l(this, n), t.apply(this, arguments)
        }
        return p(n, [{
            key: "apply",
            value: function(e) {
                return function(e) {
                    return X5((function() {
                        return m8(e, d8(y8(e), 1))
                    }))
                }(e)
            }
        }]), n
    }(Nhe);
    Fhe.className = "softsign", Kre(Fhe);
    var Dhe = function(e) {
        d(n, e);
        var t = w(n);

        function n() {
            return l(this, n), t.apply(this, arguments)
        }
        return p(n, [{
            key: "apply",
            value: function(e) {
                return t7(e)
            }
        }]), n
    }(Nhe);
    Dhe.className = "tanh", Kre(Dhe);
    var Mhe = function(e) {
        d(n, e);
        var t = w(n);

        function n() {
            return l(this, n), t.apply(this, arguments)
        }
        return p(n, [{
            key: "apply",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1;
                return Rte(e, t)
            }
        }]), n
    }(Nhe);
    Mhe.className = "softmax", Kre(Mhe);
    var Lhe = function(e) {
        d(n, e);
        var t = w(n);

        function n() {
            return l(this, n), t.apply(this, arguments)
        }
        return p(n, [{
            key: "apply",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1;
                return B9(e, t)
            }
        }]), n
    }(Nhe);
    Lhe.className = "logSoftmax", Kre(Lhe);
    var zhe = function(e) {
        d(n, e);
        var t = w(n);

        function n() {
            return l(this, n), t.apply(this, arguments)
        }
        return p(n, [{
            key: "apply",
            value: function(e) {
                return X5((function() {
                    return X5((function() {
                        var t = Math.sqrt(2),
                            n = g8(.5, d8(1, K7(m8(e, t))));
                        return g8(e, n)
                    }))
                }))
            }
        }]), n
    }(Nhe);
    zhe.className = "gelu", Kre(zhe);
    var Phe = function(e) {
        d(n, e);
        var t = w(n);

        function n() {
            return l(this, n), t.apply(this, arguments)
        }
        return p(n, [{
            key: "apply",
            value: function(e) {
                return X5((function() {
                    return g8(.5, g8(e, d8(1, t7(g8(o9(m8(2, Math.PI)), d8(e, g8(.044715, a9(e, 3))))))))
                }))
            }
        }]), n
    }(Nhe);
    Phe.className = "gelu_new", Kre(Phe);
    var Bhe = function(e) {
        d(n, e);
        var t = w(n);

        function n() {
            return l(this, n), t.apply(this, arguments)
        }
        return p(n, [{
            key: "apply",
            value: function(e) {
                return X5((function() {
                    return g8(e, t7(L9(e)))
                }))
            }
        }]), n
    }(Nhe);
    Bhe.className = "mish", Kre(Bhe);
    var Whe = function(e) {
        d(n, e);
        var t = w(n);

        function n() {
            return l(this, n), t.apply(this, arguments)
        }
        return p(n, [{
            key: "apply",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                return X5((function() {
                    return g8($8(g8(e, t)), e)
                }))
            }
        }]), n
    }(Nhe);

    function Uhe(e) {
        return e.getClassName()
    }

    function Vhe(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return Vse(e, qre.getMap().classNameMap, t, "activation")
    }

    function Ghe(e) {
        if (null == e) {
            var t = {
                className: "linear",
                config: {}
            };
            return Vhe(t)
        }
        if ("string" == typeof e) {
            var n = {};
            return n.className = e, n.config = {}, Vhe(n)
        }
        return e instanceof Nhe ? e : Vhe(e)
    }

    function jhe(e) {
        if (null != e && "object" !== s(e)) throw new Error("Argument to L1L2 regularizer's constructor is expected to be an " + "object, but received: ".concat(e))
    }
    Whe.className = "swish", Kre(Whe);
    var Hhe = function(e) {
            d(n, e);
            var t = w(n);

            function n() {
                return l(this, n), t.apply(this, arguments)
            }
            return p(n)
        }(Hre),
        qhe = function(e) {
            d(n, e);
            var t = w(n);

            function n(e) {
                var r;
                return l(this, n), r = t.call(this), jhe(e), r.l1 = null == e || null == e.l1 ? .01 : e.l1, r.l2 = null == e || null == e.l2 ? .01 : e.l2, r.hasL1 = 0 !== r.l1, r.hasL2 = 0 !== r.l2, r
            }
            return p(n, [{
                key: "apply",
                value: function(e) {
                    var t = this;
                    return X5((function() {
                        var n = $9([1]);
                        return t.hasL1 && (n = d8(n, u9(g8(t.l1, y8(e))))), t.hasL2 && (n = d8(n, u9(g8(t.l2, Due(e))))), X8(n, [])
                    }))
                }
            }, {
                key: "getConfig",
                value: function() {
                    return {
                        l1: this.l1,
                        l2: this.l2
                    }
                }
            }], [{
                key: "fromConfig",
                value: function(e, t) {
                    return new e({
                        l1: t.l1,
                        l2: t.l2
                    })
                }
            }]), n
        }(Hhe);
    qhe.className = "L1L2", Kre(qhe);
    var Khe = {
        l1l2: "L1L2"
    };

    function Xhe(e) {
        return Wse(e)
    }

    function Yhe(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        return Vse(e, qre.getMap().classNameMap, t, "regularizer")
    }

    function Jhe(e) {
        return null == e ? null : "string" == typeof e ? Yhe({
            className: e in Khe ? Khe[e] : e,
            config: {}
        }) : e instanceof Hhe ? e : Yhe(e)
    }
    var Zhe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            return l(this, n), (r = t.call(this, null == e ? {} : e)).supportsMasking = !0, null != e && (r.maxValue = e.maxValue), r
        }
        return p(n, [{
            key: "call",
            value: function(e, t) {
                e = lce(e);
                var n = lte(e);
                return null != this.maxValue && (n = d7(n, 0, this.maxValue)), n
            }
        }, {
            key: "computeOutputShape",
            value: function(e) {
                return e
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = {
                        maxValue: this.maxValue
                    },
                    t = N(v(n.prototype), "getConfig", this).call(this);
                return Object.assign(e, t), e
            }
        }]), n
    }(wce);
    Zhe.className = "ReLU", Kre(Zhe);
    var Qhe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            return l(this, n), (r = t.call(this, null == e ? {} : e)).DEFAULT_ALPHA = .3, null == e && (e = {}), r.alpha = null == e.alpha ? r.DEFAULT_ALPHA : e.alpha, r
        }
        return p(n, [{
            key: "call",
            value: function(e, t) {
                var n = lce(e);
                return S9(n, this.alpha)
            }
        }, {
            key: "computeOutputShape",
            value: function(e) {
                return e
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = {
                        alpha: this.alpha
                    },
                    t = N(v(n.prototype), "getConfig", this).call(this);
                return Object.assign(e, t), e
            }
        }]), n
    }(wce);
    Qhe.className = "LeakyReLU", Kre(Qhe);
    var $he = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            if (l(this, n), (r = t.call(this, null == e ? {} : e)).DEFAULT_ALPHA_INITIALIZER = "zeros", null == e && (e = {}), r.supportsMasking = !0, r.alphaInitializer = sce(e.alphaInitializer || r.DEFAULT_ALPHA_INITIALIZER), r.alphaRegularizer = Jhe(e.alphaRegularizer), r.alphaConstraint = Vce(e.alphaConstraint), null == e.sharedAxes) r.sharedAxes = null;
            else if (Array.isArray(e.sharedAxes)) r.sharedAxes = e.sharedAxes;
            else {
                if ("number" != typeof e.sharedAxes) throw new Cse("Expected sharedAxes to be a number or an array of numbers, " + "but got ".concat(e.sharedAxes));
                r.sharedAxes = [e.sharedAxes]
            }
            return r
        }
        return p(n, [{
            key: "build",
            value: function(e) {
                var t = (e = hce(e)).slice(1);
                if (null != this.sharedAxes) {
                    var n, r = O(this.sharedAxes);
                    try {
                        for (r.s(); !(n = r.n()).done;) {
                            t[n.value - 1] = 1
                        }
                    } catch (e) {
                        r.e(e)
                    } finally {
                        r.f()
                    }
                }
                this.alpha = this.addWeight("alpha", t, "float32", this.alphaInitializer, this.alphaRegularizer, !0, this.alphaConstraint);
                var a = {};
                if (null != this.sharedAxes)
                    for (var i = 1; i < e.length; ++i) a[i] = e[i];
                this.inputSpec = [new gce({
                    ndim: e.length,
                    axes: a
                })], this.built = !0
            }
        }, {
            key: "call",
            value: function(e, t) {
                return e = lce(e), bee(e, this.alpha.read())
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = {
                        alphaInitializer: oce(this.alphaInitializer),
                        alphaRegularizer: Xhe(this.alphaRegularizer),
                        alphaConstraint: Wce(this.alphaConstraint),
                        sharedAxes: this.sharedAxes
                    },
                    t = N(v(n.prototype), "getConfig", this).call(this);
                return Object.assign(e, t), e
            }
        }]), n
    }(wce);
    $he.className = "PReLU", Kre($he);
    var epe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            if (l(this, n), (r = t.call(this, null == e ? {} : e)).DEFAULT_ALPHA = 1, null == e && (e = {}), null != e.alpha && e.alpha !== r.DEFAULT_ALPHA) throw new Ase("Non-default alpha value (".concat(e.alpha, ") is not supported by the ") + "ELU layer yet.");
            return r.alpha = null == e.alpha ? r.DEFAULT_ALPHA : e.alpha, r
        }
        return p(n, [{
            key: "call",
            value: function(e, t) {
                var n = lce(e);
                return H7(n)
            }
        }, {
            key: "computeOutputShape",
            value: function(e) {
                return e
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = {
                        alpha: this.alpha
                    },
                    t = N(v(n.prototype), "getConfig", this).call(this);
                return Object.assign(e, t), e
            }
        }]), n
    }(wce);
    epe.className = "ELU", Kre(epe);
    var tpe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            return l(this, n), (r = t.call(this, null == e ? {} : e)).DEFAULT_THETA = 1, null == e && (e = {}), r.theta = null == e.theta ? r.DEFAULT_THETA : e.theta, r
        }
        return p(n, [{
            key: "call",
            value: function(e, t) {
                var n = lce(e);
                return g8(n, h8(b9(n, this.theta), "float32"))
            }
        }, {
            key: "computeOutputShape",
            value: function(e) {
                return e
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = {
                        theta: this.theta
                    },
                    t = N(v(n.prototype), "getConfig", this).call(this);
                return Object.assign(e, t), e
            }
        }]), n
    }(wce);
    tpe.className = "ThresholdedReLU", Kre(tpe);
    var npe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            return l(this, n), (r = t.call(this, null == e ? {} : e)).DEFAULT_AXIS = 1, null == e && (e = {}), r.softmax = (new Mhe).apply, r.axis = null == e.axis ? r.DEFAULT_AXIS : e.axis, r
        }
        return p(n, [{
            key: "call",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    var r = lce(e),
                        a = t.mask;
                    if (null != a) {
                        var i = g8(P9(eee(r.shape), h8(a, r.dtype)), i9(-1e9));
                        r = d8(r, i)
                    }
                    return n.axis instanceof Array ? n.axis.length > 1 ? p9(P9(r, W9(r, n.axis, !0))) : n.softmax(r, n.axis[0]) : n.softmax(r, n.axis)
                }))
            }
        }, {
            key: "computeOutputShape",
            value: function(e) {
                return e
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = {
                        axis: this.axis
                    },
                    t = N(v(n.prototype), "getConfig", this).call(this);
                return Object.assign(e, t), e
            }
        }]), n
    }(wce);

    function rpe(e, t, n) {
        if ("number" == typeof e) return Ose(e, t);
        if (e.length !== t) throw new Cse("The ".concat(n, " argument must be an integer or tuple of ").concat(t, " integers.") + " Received: ".concat(e.length, " elements."));
        for (var r = 0; r < t; ++r) {
            var a = e[r];
            if ((i = a) !== parseInt(i.toString(), 10)) throw new Cse("The ".concat(n, " argument must be an integer or tuple of ").concat(t) + " integers. Received: ".concat(JSON.stringify(e), " including a") + " non-integer number ".concat(a))
        }
        return e;
        var i
    }

    function ape(e, t, n, r) {
        var a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1;
        if (null == e) return e;
        var i, o = t + (t - 1) * (a - 1);
        return i = "same" === n ? e : e - o + 1, Math.floor((i + r - 1) / r)
    }

    function ipe(e, t, n, r) {
        if (null == e) return null;
        if ("valid" === r) e = e * t + bue([n - t, 0]);
        else {
            if ("same" !== r) throw new Cse("Unsupport padding mode: ".concat(r, "."));
            e *= t
        }
        return e
    }

    function ope(e, t) {
        return X5((function() {
            return sue(t), "channelsFirst" === t ? hne(e, [0, 2, 3, 1]) : e
        }))
    }

    function spe(e, t) {
        return X5((function() {
            return sue(t), "channelsFirst" === t ? hne(e, [0, 2, 3, 4, 1]) : e
        }))
    }

    function upe(e, t, n) {
        var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1,
            a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "valid",
            i = arguments.length > 5 ? arguments[5] : void 0,
            o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 1;
        return X5((function() {
            if (null == i && (i = "channelsLast"), sue(i), 3 !== e.shape.length) throw new Cse("The input of a conv1dWithBias operation should be 3, but is " + "".concat(e.shape.length, " instead."));
            if (3 !== t.shape.length) throw new Cse("The kernel for a conv1dWithBias operation should be 3, but is " + "".concat(t.shape.length, " instead"));
            if (null != n && 1 !== n.shape.length) throw new Cse("The bias for a conv1dWithBias operation should be 1, but is " + "".concat(n.shape.length, " instead"));
            if ("channelsFirst" === i && (e = hne(e, [0, 2, 1])), "causal" === a) throw new Ase("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
            var s = x7(e, t, r, "same" === a ? "same" : "valid", "NWC", o);
            return null != n && (s = Lue(s, n)), s
        }))
    }

    function cpe(e, t, n) {
        var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [1, 1],
            a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "valid",
            i = arguments.length > 5 ? arguments[5] : void 0,
            o = arguments.length > 6 ? arguments[6] : void 0,
            s = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null;
        return X5((function() {
            if (null == i && (i = "channelsLast"), sue(i), 3 !== e.rank && 4 !== e.rank) throw new Cse("conv2dWithBiasActivation expects input to be of rank 3 or 4, " + "but received ".concat(e.rank, "."));
            if (3 !== t.rank && 4 !== t.rank) throw new Cse("conv2dWithBiasActivation expects kernel to be of rank 3 or 4, " + "but received ".concat(e.rank, "."));
            var u = ope(e, i);
            if ("causal" === a) throw new Ase("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");
            return u = Ene({
                x: u,
                filter: t,
                strides: r,
                pad: "same" === a ? "same" : "valid",
                dilations: o,
                dataFormat: "NHWC",
                bias: n,
                activation: s
            }), "channelsFirst" === i && (u = hne(u, [0, 3, 1, 2])), u
        }))
    }

    function lpe(e, t, n) {
        var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [1, 1, 1],
            a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "valid",
            i = arguments.length > 5 ? arguments[5] : void 0,
            o = arguments.length > 6 ? arguments[6] : void 0;
        return X5((function() {
            if (null == i && (i = "channelsLast"), sue(i), 4 !== e.rank && 5 !== e.rank) throw new Cse("conv3dWithBias expects input to be of rank 4 or 5, but received " + "".concat(e.rank, "."));
            if (4 !== t.rank && 5 !== t.rank) throw new Cse("conv3dWithBias expects kernel to be of rank 4 or 5, but received " + "".concat(e.rank, "."));
            var s = spe(e, i);
            if ("causal" === a) throw new Ase("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");
            return s = I7(s, t, r, "same" === a ? "same" : "valid", "NDHWC", o), null != n && (s = Lue(s, n)), "channelsFirst" === i && (s = hne(s, [0, 4, 1, 2, 3])), s
        }))
    }
    npe.className = "Softmax", Kre(npe);
    var hpe = function(e) {
            d(n, e);
            var t = w(n);

            function n(e, r) {
                var a;
                if (l(this, n), (a = t.call(this, r)).bias = null, a.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", a.DEFAULT_BIAS_INITIALIZER = "zeros", n.verifyArgs(r), a.rank = e, Xse(a.rank, "rank"), 1 !== a.rank && 2 !== a.rank && 3 !== a.rank) throw new Ase("Convolution layer for rank other than 1, 2, or 3 (".concat(a.rank, ") is ") + "not implemented yet.");
                if (a.kernelSize = rpe(r.kernelSize, e, "kernelSize"), a.strides = rpe(null == r.strides ? 1 : r.strides, e, "strides"), a.padding = null == r.padding ? "valid" : r.padding, uue(a.padding), a.dataFormat = null == r.dataFormat ? "channelsLast" : r.dataFormat, sue(a.dataFormat), a.activation = Ghe(r.activation), a.useBias = null == r.useBias || r.useBias, a.biasInitializer = sce(r.biasInitializer || a.DEFAULT_BIAS_INITIALIZER), a.biasConstraint = Vce(r.biasConstraint), a.biasRegularizer = Jhe(r.biasRegularizer), a.activityRegularizer = Jhe(r.activityRegularizer), a.dilationRate = rpe(null == r.dilationRate ? 1 : r.dilationRate, e, "dilationRate"), 1 === a.rank && Array.isArray(a.dilationRate) && 1 !== a.dilationRate.length) throw new Cse("dilationRate must be a number or an array of a single number for 1D convolution, but received " + "".concat(JSON.stringify(a.dilationRate)));
                if (2 === a.rank) {
                    if ("number" == typeof a.dilationRate) a.dilationRate = [a.dilationRate, a.dilationRate];
                    else if (2 !== a.dilationRate.length) throw new Cse("dilationRate must be a number or array of two numbers for 2D " + "convolution, but received ".concat(JSON.stringify(a.dilationRate)))
                } else if (3 === a.rank)
                    if ("number" == typeof a.dilationRate) a.dilationRate = [a.dilationRate, a.dilationRate, a.dilationRate];
                    else if (3 !== a.dilationRate.length) throw new Cse("dilationRate must be a number or array of three numbers for 3D " + "convolution, but received ".concat(JSON.stringify(a.dilationRate)));
                return a
            }
            return p(n, [{
                key: "getConfig",
                value: function() {
                    var e = {
                            kernelSize: this.kernelSize,
                            strides: this.strides,
                            padding: this.padding,
                            dataFormat: this.dataFormat,
                            dilationRate: this.dilationRate,
                            activation: Uhe(this.activation),
                            useBias: this.useBias,
                            biasInitializer: oce(this.biasInitializer),
                            biasRegularizer: Xhe(this.biasRegularizer),
                            activityRegularizer: Xhe(this.activityRegularizer),
                            biasConstraint: Wce(this.biasConstraint)
                        },
                        t = N(v(n.prototype), "getConfig", this).call(this);
                    return Object.assign(e, t), e
                }
            }], [{
                key: "verifyArgs",
                value: function(e) {
                    if (Fse("kernelSize" in e, "required key 'kernelSize' not in config"), "number" != typeof e.kernelSize && !Kse(e.kernelSize, "number", 1, 3)) throw new Cse("BaseConv expects config.kernelSize to be number or number[] with " + "length 1, 2, or 3, but received ".concat(JSON.stringify(e.kernelSize), "."))
                }
            }]), n
        }(wce),
        ppe = function(e) {
            d(n, e);
            var t = w(n);

            function n(e, r) {
                var a;
                return l(this, n), (a = t.call(this, e, r)).kernel = null, n.verifyArgs(r), a.filters = r.filters, Xse(a.filters, "filters"), a.kernelInitializer = sce(r.kernelInitializer || a.DEFAULT_KERNEL_INITIALIZER), a.kernelConstraint = Vce(r.kernelConstraint), a.kernelRegularizer = Jhe(r.kernelRegularizer), a
            }
            return p(n, [{
                key: "build",
                value: function(e) {
                    e = hce(e);
                    var t = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
                    if (null == e[t]) throw new Cse("The channel dimension of the input should be defined. " + "Found ".concat(e[t]));
                    var n = e[t],
                        r = this.kernelSize.concat([n, this.filters]);
                    this.kernel = this.addWeight("kernel", r, null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint)), this.inputSpec = [{
                        ndim: this.rank + 2,
                        axes: f({}, t, n)
                    }], this.built = !0
                }
            }, {
                key: "call",
                value: function(e, t) {
                    var n = this;
                    return X5((function() {
                        var t;
                        e = lce(e);
                        var r = null == n.bias ? null : n.bias.read(),
                            a = Jse(n.activation.getClassName());
                        if (null != a && 2 === n.rank) t = cpe(e, n.kernel.read(), r, n.strides, n.padding, n.dataFormat, n.dilationRate, a);
                        else {
                            if (1 === n.rank) t = upe(e, n.kernel.read(), r, n.strides[0], n.padding, n.dataFormat, n.dilationRate[0]);
                            else if (2 === n.rank) t = cpe(e, n.kernel.read(), r, n.strides, n.padding, n.dataFormat, n.dilationRate);
                            else {
                                if (3 !== n.rank) throw new Ase("convolutions greater than 3D are not implemented yet.");
                                t = lpe(e, n.kernel.read(), r, n.strides, n.padding, n.dataFormat, n.dilationRate)
                            }
                            null != n.activation && (t = n.activation.apply(t))
                        }
                        return t
                    }))
                }
            }, {
                key: "computeOutputShape",
                value: function(e) {
                    e = hce(e);
                    for (var t = [], n = "channelsLast" === this.dataFormat ? e.slice(1, e.length - 1) : e.slice(2), r = 0; r < n.length; ++r) {
                        var a = ape(n[r], this.kernelSize[r], this.padding, this.strides[r], "number" == typeof this.dilationRate ? this.dilationRate : this.dilationRate[r]);
                        t.push(a)
                    }
                    var i = [e[0]];
                    return "channelsLast" === this.dataFormat ? (i = i.concat(t)).push(this.filters) : (i.push(this.filters), i = i.concat(t)), i
                }
            }, {
                key: "getConfig",
                value: function() {
                    var e = {
                            filters: this.filters,
                            kernelInitializer: oce(this.kernelInitializer),
                            kernelRegularizer: Xhe(this.kernelRegularizer),
                            kernelConstraint: Wce(this.kernelConstraint)
                        },
                        t = N(v(n.prototype), "getConfig", this).call(this);
                    return Object.assign(e, t), e
                }
            }], [{
                key: "verifyArgs",
                value: function(e) {
                    if (!("filters" in e) || "number" != typeof e.filters || e.filters < 1) throw new Cse("Convolution layer expected config.filters to be a 'number' > 0 " + "but got ".concat(JSON.stringify(e.filters)))
                }
            }]), n
        }(hpe),
        fpe = function(e) {
            d(n, e);
            var t = w(n);

            function n(e) {
                var r;
                return l(this, n), r = t.call(this, 2, e), n.verifyArgs(e), r
            }
            return p(n, [{
                key: "getConfig",
                value: function() {
                    var e = N(v(n.prototype), "getConfig", this).call(this);
                    return delete e.rank, e
                }
            }], [{
                key: "verifyArgs",
                value: function(e) {
                    if ("number" != typeof e.kernelSize && !Kse(e.kernelSize, "number", 1, 2)) throw new Cse("Conv2D expects config.kernelSize to be number or number[] with " + "length 1 or 2, but received ".concat(JSON.stringify(e.kernelSize), "."))
                }
            }]), n
        }(ppe);
    fpe.className = "Conv2D", Kre(fpe);
    var dpe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            return l(this, n), r = t.call(this, 3, e), n.verifyArgs(e), r
        }
        return p(n, [{
            key: "getConfig",
            value: function() {
                var e = N(v(n.prototype), "getConfig", this).call(this);
                return delete e.rank, e
            }
        }], [{
            key: "verifyArgs",
            value: function(e) {
                if ("number" != typeof e.kernelSize && (!Array.isArray(e.kernelSize) || 1 !== e.kernelSize.length && 3 !== e.kernelSize.length)) throw new Cse("Conv3D expects config.kernelSize to be number or" + " [number, number, number], but received ".concat(JSON.stringify(e.kernelSize), "."))
            }
        }]), n
    }(ppe);
    dpe.className = "Conv3D", Kre(dpe);
    var vpe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            if (l(this, n), (r = t.call(this, e)).inputSpec = [new gce({
                    ndim: 4
                })], "same" !== r.padding && "valid" !== r.padding) throw new Cse("Conv2DTranspose currently supports only padding modes 'same' " + "and 'valid', but received padding mode ".concat(r.padding));
            return r
        }
        return p(n, [{
            key: "build",
            value: function(e) {
                if (4 !== (e = hce(e)).length) throw new Cse("Input should have rank 4; Received input shape: " + JSON.stringify(e));
                var t = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
                if (null == e[t]) throw new Cse("The channel dimension of the inputs should be defined. Found `None`.");
                var n = e[t],
                    r = this.kernelSize.concat([this.filters, n]);
                this.kernel = this.addWeight("kernel", r, "float32", this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint)), this.inputSpec = [new gce({
                    ndim: 4,
                    axes: f({}, t, n)
                })], this.built = !0
            }
        }, {
            key: "call",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    var t = lce(e);
                    if (4 !== t.shape.length) throw new Cse("Conv2DTranspose.call() expects input tensor to be rank-4, but " + "received a tensor of rank-".concat(t.shape.length));
                    var r, a, i = t.shape,
                        o = i[0];
                    "channelsFirst" === n.dataFormat ? (r = 2, a = 3) : (r = 1, a = 2);
                    var s = i[r],
                        u = i[a],
                        c = n.kernelSize[0],
                        l = n.kernelSize[1],
                        h = n.strides[0],
                        p = n.strides[1],
                        f = [o, ipe(s, h, c, n.padding), ipe(u, p, l, n.padding), n.filters];
                    "channelsLast" !== n.dataFormat && (t = hne(t, [0, 2, 3, 1]));
                    var d = w7(t, n.kernel.read(), f, n.strides, n.padding);
                    return "channelsLast" !== n.dataFormat && (d = hne(d, [0, 3, 1, 2])), null != n.bias && (d = Lue(d, n.bias.read(), n.dataFormat)), null != n.activation && (d = n.activation.apply(d)), d
                }))
            }
        }, {
            key: "computeOutputShape",
            value: function(e) {
                var t, n, r, a = (e = hce(e)).slice();
                "channelsFirst" === this.dataFormat ? (t = 1, n = 2, r = 3) : (t = 3, n = 1, r = 2);
                var i = this.kernelSize[0],
                    o = this.kernelSize[1],
                    s = this.strides[0],
                    u = this.strides[1];
                return a[t] = this.filters, a[n] = ipe(a[n], s, i, this.padding), a[r] = ipe(a[r], u, o, this.padding), a
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = N(v(n.prototype), "getConfig", this).call(this);
                return delete e.dilationRate, e
            }
        }]), n
    }(fpe);
    vpe.className = "Conv2DTranspose", Kre(vpe);
    var mpe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            if (l(this, n), (r = t.call(this, e)).inputSpec = [new gce({
                    ndim: 5
                })], "same" !== r.padding && "valid" !== r.padding) throw new Cse("Conv3DTranspose currently supports only padding modes 'same' " + "and 'valid', but received padding mode ".concat(r.padding));
            return r
        }
        return p(n, [{
            key: "build",
            value: function(e) {
                if (5 !== (e = hce(e)).length) throw new Cse("Input should have rank 5; Received input shape: " + JSON.stringify(e));
                var t = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
                if (null == e[t]) throw new Cse("The channel dimension of the inputs should be defined. Found `None`.");
                var n = e[t],
                    r = this.kernelSize.concat([this.filters, n]);
                this.kernel = this.addWeight("kernel", r, "float32", this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint)), this.inputSpec = [new gce({
                    ndim: 5,
                    axes: f({}, t, n)
                })], this.built = !0
            }
        }, {
            key: "call",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    var t = lce(e);
                    if (5 !== t.shape.length) throw new Cse("Conv3DTranspose.call() expects input tensor to be rank-4, but " + "received a tensor of rank-".concat(t.shape.length));
                    var r, a, i, o = t.shape,
                        s = o[0];
                    "channelsFirst" === n.dataFormat ? (i = 2, r = 3, a = 4) : (i = 1, r = 2, a = 3);
                    var u = o[i],
                        c = o[r],
                        l = o[a],
                        h = n.kernelSize[0],
                        p = n.kernelSize[1],
                        f = n.kernelSize[2],
                        d = n.strides[0],
                        v = n.strides[1],
                        m = n.strides[2],
                        g = [s, ipe(u, d, h, n.padding), ipe(c, v, p, n.padding), ipe(l, m, f, n.padding), n.filters];
                    "channelsLast" !== n.dataFormat && (t = hne(t, [0, 2, 3, 4, 1]));
                    var y = S7(t, n.kernel.read(), g, n.strides, n.padding);
                    return "channelsLast" !== n.dataFormat && (y = hne(y, [0, 4, 1, 2, 3])), null !== n.bias && (y = Lue(y, n.bias.read(), n.dataFormat)), null !== n.activation && (y = n.activation.apply(y)), y
                }))
            }
        }, {
            key: "computeOutputShape",
            value: function(e) {
                var t, n, r, a, i = (e = hce(e)).slice();
                "channelsFirst" === this.dataFormat ? (t = 1, n = 2, r = 3, a = 4) : (t = 4, n = 1, r = 2, a = 3);
                var o = this.kernelSize[0],
                    s = this.kernelSize[1],
                    u = this.kernelSize[2],
                    c = this.strides[0],
                    l = this.strides[1],
                    h = this.strides[2];
                return i[t] = this.filters, i[n] = ipe(i[n], c, o, this.padding), i[r] = ipe(i[r], l, s, this.padding), i[a] = ipe(i[a], h, u, this.padding), i
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = N(v(n.prototype), "getConfig", this).call(this);
                return delete e.dilationRate, e
            }
        }]), n
    }(dpe);
    mpe.className = "Conv3DTranspose", Kre(mpe);
    var gpe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e, r) {
            var a;
            if (l(this, n), (a = t.call(this, e, r)).DEFAULT_DEPTHWISE_INITIALIZER = "glorotUniform", a.DEFAULT_POINTWISE_INITIALIZER = "glorotUniform", a.depthwiseKernel = null, a.pointwiseKernel = null, null == r.filters) throw new Cse("The `filters` configuration field is required by SeparableConv, but is unspecified.");
            if (null != r.kernelInitializer || null != r.kernelRegularizer || null != r.kernelConstraint) throw new Cse("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");
            if (null != r.padding && "same" !== r.padding && "valid" !== r.padding) throw new Cse("SeparableConv".concat(a.rank, "D supports only padding modes: ") + "'same' and 'valid', but received ".concat(JSON.stringify(r.padding)));
            return a.depthMultiplier = null == r.depthMultiplier ? 1 : r.depthMultiplier, a.depthwiseInitializer = sce(r.depthwiseInitializer || a.DEFAULT_DEPTHWISE_INITIALIZER), a.depthwiseRegularizer = Jhe(r.depthwiseRegularizer), a.depthwiseConstraint = Vce(r.depthwiseConstraint), a.pointwiseInitializer = sce(r.depthwiseInitializer || a.DEFAULT_POINTWISE_INITIALIZER), a.pointwiseRegularizer = Jhe(r.pointwiseRegularizer), a.pointwiseConstraint = Vce(r.pointwiseConstraint), a
        }
        return p(n, [{
            key: "build",
            value: function(e) {
                if ((e = hce(e)).length < this.rank + 2) throw new Cse("Inputs to SeparableConv".concat(this.rank, "D should have rank ") + "".concat(this.rank + 2, ", but received input shape: ") + "".concat(JSON.stringify(e)));
                var t = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
                if (null == e[t] || e[t] < 0) throw new Cse("The channel dimension of the inputs should be defined, " + "but found ".concat(JSON.stringify(e[t])));
                for (var n = e[t], r = this.kernelSize.concat([n, this.depthMultiplier]), a = [], i = 0; i < this.rank; ++i) a.push(1);
                a.push(n * this.depthMultiplier, this.filters);
                var o = !0;
                this.depthwiseKernel = this.addWeight("depthwise_kernel", r, "float32", this.depthwiseInitializer, this.depthwiseRegularizer, o, this.depthwiseConstraint), this.pointwiseKernel = this.addWeight("pointwise_kernel", a, "float32", this.pointwiseInitializer, this.pointwiseRegularizer, o, this.pointwiseConstraint), this.useBias ? this.bias = this.addWeight("bias", [this.filters], "float32", this.biasInitializer, this.biasRegularizer, o, this.biasConstraint) : this.bias = null, this.inputSpec = [new gce({
                    ndim: this.rank + 2,
                    axes: f({}, t, n)
                })], this.built = !0
            }
        }, {
            key: "call",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    var t;
                    if (e = lce(e), 1 === n.rank) throw new Ase("1D separable convolution is not implemented yet.");
                    return 2 === n.rank && ("channelsFirst" === n.dataFormat && (e = hne(e, [0, 2, 3, 1])), t = xte(e, n.depthwiseKernel.read(), n.pointwiseKernel.read(), n.strides, n.padding, n.dilationRate, "NHWC")), n.useBias && (t = Lue(t, n.bias.read(), n.dataFormat)), null != n.activation && (t = n.activation.apply(t)), "channelsFirst" === n.dataFormat && (t = hne(t, [0, 3, 1, 2])), t
                }))
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = N(v(n.prototype), "getConfig", this).call(this);
                return delete e.rank, delete e.kernelInitializer, delete e.kernelRegularizer, delete e.kernelConstraint, e.depthwiseInitializer = oce(this.depthwiseInitializer), e.pointwiseInitializer = oce(this.pointwiseInitializer), e.depthwiseRegularizer = Xhe(this.depthwiseRegularizer), e.pointwiseRegularizer = Xhe(this.pointwiseRegularizer), e.depthwiseConstraint = Wce(this.depthwiseConstraint), e.pointwiseConstraint = Wce(this.pointwiseConstraint), e
            }
        }]), n
    }(ppe);
    gpe.className = "SeparableConv";
    var ype = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            return l(this, n), t.call(this, 2, e)
        }
        return p(n)
    }(gpe);
    ype.className = "SeparableConv2D", Kre(ype);
    var bpe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            return l(this, n), r = t.call(this, 1, e), n.verifyArgs(e), r.inputSpec = [{
                ndim: 3
            }], r
        }
        return p(n, [{
            key: "getConfig",
            value: function() {
                var e = N(v(n.prototype), "getConfig", this).call(this);
                return delete e.rank, delete e.dataFormat, e
            }
        }], [{
            key: "verifyArgs",
            value: function(e) {
                if ("number" != typeof e.kernelSize && !Kse(e.kernelSize, "number", 1, 1)) throw new Cse("Conv1D expects config.kernelSize to be number or number[] with " + "length 1, but received ".concat(JSON.stringify(e.kernelSize), "."))
            }
        }]), n
    }(ppe);
    bpe.className = "Conv1D", Kre(bpe);
    var xpe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            return l(this, n), r = t.call(this, e), "number" == typeof e.cropping ? r.cropping = [
                [e.cropping, e.cropping],
                [e.cropping, e.cropping]
            ] : "number" == typeof e.cropping[0] ? r.cropping = [
                [e.cropping[0], e.cropping[0]],
                [e.cropping[1], e.cropping[1]]
            ] : r.cropping = e.cropping, r.dataFormat = void 0 === e.dataFormat ? "channelsLast" : e.dataFormat, r.inputSpec = [{
                ndim: 4
            }], r
        }
        return p(n, [{
            key: "computeOutputShape",
            value: function(e) {
                return "channelsFirst" === this.dataFormat ? [e[0], e[1], e[2] - this.cropping[0][0] - this.cropping[0][1], e[3] - this.cropping[1][0] - this.cropping[1][1]] : [e[0], e[1] - this.cropping[0][0] - this.cropping[0][1], e[2] - this.cropping[1][0] - this.cropping[1][1], e[3]]
            }
        }, {
            key: "call",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    if (e = lce(e), "channelsLast" === n.dataFormat) {
                        var t = Eue(e, n.cropping[0][0], e.shape[1] - n.cropping[0][0] - n.cropping[0][1], 2);
                        return Eue(t, n.cropping[1][0], e.shape[2] - n.cropping[1][1] - n.cropping[1][0], 3)
                    }
                    var r = Eue(e, n.cropping[0][0], e.shape[2] - n.cropping[0][0] - n.cropping[0][1], 3);
                    return Eue(r, n.cropping[1][0], e.shape[3] - n.cropping[1][1] - n.cropping[1][0], 4)
                }))
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = {
                        cropping: this.cropping,
                        dataFormat: this.dataFormat
                    },
                    t = N(v(n.prototype), "getConfig", this).call(this);
                return Object.assign(e, t), e
            }
        }]), n
    }(wce);
    xpe.className = "Cropping2D", Kre(xpe);
    var kpe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r, a;
            return l(this, n), (r = t.call(this, e)).DEFAULT_SIZE = [2, 2], r.inputSpec = [{
                ndim: 4
            }], r.size = null == e.size ? r.DEFAULT_SIZE : e.size, r.dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, sue(r.dataFormat), r.interpolation = null == e.interpolation ? "nearest" : e.interpolation, a = r.interpolation, qse(nue, "InterpolationFormat", a), r
        }
        return p(n, [{
            key: "computeOutputShape",
            value: function(e) {
                if ("channelsFirst" === this.dataFormat) {
                    var t = null == e[2] ? null : this.size[0] * e[2],
                        n = null == e[3] ? null : this.size[1] * e[3];
                    return [e[0], e[1], t, n]
                }
                var r = null == e[1] ? null : this.size[0] * e[1],
                    a = null == e[2] ? null : this.size[1] * e[2];
                return [e[0], r, a, e[3]]
            }
        }, {
            key: "call",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    var t = lce(e),
                        r = t.shape;
                    if ("channelsFirst" === n.dataFormat) {
                        t = hne(t, [0, 2, 3, 1]);
                        var a = n.size[0] * r[2],
                            i = n.size[1] * r[3],
                            o = "nearest" === n.interpolation ? Pre.resizeNearestNeighbor(t, [a, i]) : Pre.resizeBilinear(t, [a, i]);
                        return hne(o, [0, 3, 1, 2])
                    }
                    var s = n.size[0] * r[1],
                        u = n.size[1] * r[2];
                    return "nearest" === n.interpolation ? Pre.resizeNearestNeighbor(t, [s, u]) : Pre.resizeBilinear(t, [s, u])
                }))
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = {
                        size: this.size,
                        dataFormat: this.dataFormat,
                        interpolation: this.interpolation
                    },
                    t = N(v(n.prototype), "getConfig", this).call(this);
                return Object.assign(e, t), e
            }
        }]), n
    }(wce);
    kpe.className = "UpSampling2D", Kre(kpe);
    var wpe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            return l(this, n), (r = t.call(this, 2, e)).depthwiseKernel = null, r.depthMultiplier = null == e.depthMultiplier ? 1 : e.depthMultiplier, r.depthwiseInitializer = sce(e.depthwiseInitializer || r.DEFAULT_KERNEL_INITIALIZER), r.depthwiseConstraint = Vce(e.depthwiseConstraint), r.depthwiseRegularizer = Jhe(e.depthwiseRegularizer), r
        }
        return p(n, [{
            key: "build",
            value: function(e) {
                if ((e = hce(e)).length < 4) throw new Cse("Inputs to DepthwiseConv2D should have rank 4. " + "Received input shape: ".concat(JSON.stringify(e), "."));
                var t = "channelsFirst" === this.dataFormat ? 1 : 3;
                if (null == e[t] || e[t] < 0) throw new Cse("The channel dimension of the inputs to DepthwiseConv2D should " + "be defined, but is not (".concat(e[t], ")."));
                var n = e[t],
                    r = [this.kernelSize[0], this.kernelSize[1], n, this.depthMultiplier];
                this.depthwiseKernel = this.addWeight("depthwise_kernel", r, null, this.depthwiseInitializer, this.depthwiseRegularizer, !0, this.depthwiseConstraint), this.useBias ? this.bias = this.addWeight("bias", [n * this.depthMultiplier], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null, this.built = !0
            }
        }, {
            key: "call",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    var t = function(e, t) {
                        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [1, 1],
                            r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "valid",
                            a = arguments.length > 4 ? arguments[4] : void 0,
                            i = arguments.length > 5 ? arguments[5] : void 0;
                        return X5((function() {
                            null == a && (a = "channelsLast"), sue(a);
                            var o = ope(e, a);
                            if (4 !== e.rank) throw new Cse("Input for depthwiseConv2d is required to be 4-D, but is instead " + "".concat(e.rank, "-D"));
                            if (4 !== t.rank) throw new Cse("depthwiseKernel is required to be 4-D, but is instead " + "".concat(t.rank, "-D"));
                            return o = O7(o, t, n, "same" === r ? "same" : "valid", "NHWC", i), "channelsFirst" === a && (o = hne(o, [0, 3, 1, 2])), o
                        }))
                    }(e = lce(e), n.depthwiseKernel.read(), n.strides, n.padding, n.dataFormat, null);
                    return n.useBias && (t = Lue(t, n.bias.read(), n.dataFormat)), null != n.activation && (t = n.activation.apply(t)), t
                }))
            }
        }, {
            key: "computeOutputShape",
            value: function(e) {
                e = hce(e);
                var t = "channelsFirst" === this.dataFormat ? e[2] : e[1],
                    n = "channelsFirst" === this.dataFormat ? e[3] : e[2],
                    r = "channelsFirst" === this.dataFormat ? e[1] * this.depthMultiplier : e[3] * this.depthMultiplier,
                    a = ape(t, this.kernelSize[0], this.padding, this.strides[0]),
                    i = ape(n, this.kernelSize[1], this.padding, this.strides[1]);
                return "channelsFirst" === this.dataFormat ? [e[0], r, a, i] : [e[0], a, i, r]
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = N(v(n.prototype), "getConfig", this).call(this);
                return e.depthMultiplier = this.depthMultiplier, e.depthwiseInitializer = oce(this.depthwiseInitializer), e.depthwiseRegularizer = Xhe(this.depthwiseRegularizer), e.depthwiseConstraint = Wce(this.depthwiseRegularizer), e
            }
        }]), n
    }(hpe);

    function Ipe(e, t, n, r) {
        if (Array.isArray(e)) {
            if (null != t || null != n) throw new Cse("When inputs is an array, neither initialState or constants should be provided");
            null != r && (n = e.slice(e.length - r, e.length), e = e.slice(0, e.length - r)), e.length > 1 && (t = e.slice(1, e.length)), e = e[0]
        }

        function a(e) {
            return null == e || Array.isArray(e) ? e : [e]
        }
        return {
            inputs: e,
            initialState: t = a(t),
            constants: n = a(n)
        }
    }

    function Npe(e, t, n) {
        var r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
            a = arguments.length > 4 ? arguments[4] : void 0,
            i = arguments.length > 5 ? arguments[5] : void 0,
            o = arguments.length > 6 && void 0 !== arguments[6] && arguments[6],
            s = arguments.length > 7 && void 0 !== arguments[7] && arguments[7];
        return X5((function() {
            var u = t.shape.length;
            if (u < 3) throw new Cse("Input should be at least 3D, but is ".concat(u, "D."));
            var c = [1, 0].concat(xue(2, u));
            if (t = hne(t, c), null != i) throw new Ase("The rnn() functoin of the deeplearn.js backend does not support constants yet.");
            o && console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."), null != a && ((a = h8(h8(a, "bool"), "float32")).rank === u - 1 && (a = f9(a, -1)), a = hne(a, c)), r && (t = pte(t, 0), null != a && (a = pte(a, 0)));
            var l, h, p = [],
                f = n,
                d = t.shape[0],
                v = rne(t);
            null != a && (h = rne(a));
            for (var m, g = function(t) {
                    var n = v[t],
                        r = X5((function() {
                            return e(n, f)
                        }));
                    if (null == a) l = r[0], f = r[1];
                    else {
                        var i = X5((function() {
                            var e = h[t],
                                n = P9(lee(e), e);
                            return {
                                output: d8(g8(r[0], e), g8(f[0], n)),
                                newStates: f.map((function(t, a) {
                                    return d8(g8(r[1][a], e), g8(t, n))
                                }))
                            }
                        }));
                        l = i.output, f = i.newStates
                    }
                    s && p.push(l)
                }, y = 0; y < d; ++y) g(y);
            if (s) {
                m = Pte(p, 1)
            }
            return [l, m, f]
        }))
    }
    wpe.className = "DepthwiseConv2D", Kre(wpe);
    var Spe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r, a;
            if (l(this, n), r = t.call(this, e), null == e.cell) throw new Cse("cell property is missing for the constructor of RNN.");
            if (null == (a = Array.isArray(e.cell) ? new Fpe({
                    cells: e.cell
                }) : e.cell).stateSize) throw new Cse("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");
            return r.cell = a, r.returnSequences = null != e.returnSequences && e.returnSequences, r.returnState = null != e.returnState && e.returnState, r.goBackwards = null != e.goBackwards && e.goBackwards, r._stateful = null != e.stateful && e.stateful, r.unroll = null != e.unroll && e.unroll, r.supportsMasking = !0, r.inputSpec = [new gce({
                ndim: 3
            })], r.stateSpec = null, r.states_ = null, r.numConstants = null, r.keptStates = [], r
        }
        return p(n, [{
            key: "getStates",
            value: function() {
                return null == this.states_ ? xue(0, Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1).map((function(e) {
                    return null
                })) : this.states_
            }
        }, {
            key: "setStates",
            value: function(e) {
                this.states_ = e
            }
        }, {
            key: "computeOutputShape",
            value: function(e) {
                uce(e) && (e = e[0]);
                var t = this.cell.stateSize;
                Array.isArray(t) || (t = [t]);
                var n, r = t[0];
                if (n = this.returnSequences ? [e[0], e[1], r] : [e[0], r], this.returnState) {
                    var a, i = [],
                        o = O(t);
                    try {
                        for (o.s(); !(a = o.n()).done;) {
                            var s = a.value;
                            i.push([e[0], s])
                        }
                    } catch (e) {
                        o.e(e)
                    } finally {
                        o.f()
                    }
                    return [n].concat(i)
                }
                return n
            }
        }, {
            key: "computeMask",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    Array.isArray(t) && (t = t[0]);
                    var e = n.returnSequences ? t : null;
                    if (n.returnState) {
                        var r = n.states.map((function(e) {
                            return null
                        }));
                        return [e].concat(r)
                    }
                    return e
                }))
            }
        }, {
            key: "states",
            get: function() {
                if (null == this.states_) {
                    for (var e = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1, t = [], n = 0; n < e; ++n) t.push(null);
                    return t
                }
                return this.states_
            },
            set: function(e) {
                this.states_ = e
            }
        }, {
            key: "build",
            value: function(e) {
                if (null != this.numConstants) throw new Ase("Constants support is not implemented in RNN yet.");
                uce(e) && (e = e[0]);
                var t = this.stateful ? e[0] : null,
                    n = e.slice(2);
                this.inputSpec[0] = new gce({
                    shape: [t, null].concat(T(n))
                });
                var r, a = [e[0]].concat(e.slice(2));
                if (this.cell.build(a), r = Array.isArray(this.cell.stateSize) ? this.cell.stateSize : [this.cell.stateSize], null != this.stateSpec) {
                    if (!P$(this.stateSpec.map((function(e) {
                            return e.shape[e.shape.length - 1]
                        })), r)) throw new Cse("An initialState was passed that is not compatible with " + "cell.stateSize. Received stateSpec=".concat(this.stateSpec, "; ") + "However cell.stateSize is ".concat(this.cell.stateSize))
                } else this.stateSpec = r.map((function(e) {
                    return new gce({
                        shape: [null, e]
                    })
                }));
                this.stateful && this.resetStates()
            }
        }, {
            key: "resetStates",
            value: function(e) {
                var t = this,
                    n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                X5((function() {
                    if (!t.stateful) throw new Tse("Cannot call resetStates() on an RNN Layer that is not stateful.");
                    var r = t.inputSpec[0].shape[0];
                    if (null == r) throw new Cse("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
                    if (null == t.states_) Array.isArray(t.cell.stateSize) ? t.states_ = t.cell.stateSize.map((function(e) {
                        return $9([r, e])
                    })) : t.states_ = [$9([r, t.cell.stateSize])];
                    else if (null == e) Y5(t.states_), null != t.keptStates && (Y5(t.keptStates), t.keptStates = []), Array.isArray(t.cell.stateSize) ? t.states_ = t.cell.stateSize.map((function(e) {
                        return $9([r, e])
                    })) : t.states_[0] = $9([r, t.cell.stateSize]);
                    else {
                        if (Array.isArray(e) || (e = [e]), e.length !== t.states_.length) throw new Cse("Layer ".concat(t.name, " expects ").concat(t.states_.length, " state(s), ") + "but it received ".concat(e.length, " state value(s). Input ") + "received: ".concat(e));
                        !0 === n ? t.keptStates.push(t.states_.slice()) : Y5(t.states_);
                        for (var a = 0; a < t.states_.length; ++a) {
                            var i = e[a],
                                o = Array.isArray(t.cell.stateSize) ? t.cell.stateSize[a] : t.cell.stateSize,
                                s = [r, o];
                            if (!P$(i.shape, s)) throw new Cse("State ".concat(a, " is incompatible with layer ").concat(t.name, ": ") + "expected shape=".concat(s, ", received shape=").concat(i.shape));
                            t.states_[a] = i
                        }
                    }
                    t.states_ = t.states_.map((function(e) {
                        return J5(e.clone())
                    }))
                }))
            }
        }, {
            key: "apply",
            value: function(e, t) {
                var r = null == t ? null : t.initialState,
                    a = null == t ? null : t.constants;
                null == t && (t = {});
                var i = Ipe(e, r, a, this.numConstants);
                e = i.inputs, r = i.initialState, a = i.constants;
                var o = [],
                    s = [];
                if (null != r) {
                    t.initialState = r, o = o.concat(r), this.stateSpec = [];
                    var u, c = O(r);
                    try {
                        for (c.s(); !(u = c.n()).done;) {
                            var l = u.value;
                            this.stateSpec.push(new gce({
                                shape: l.shape
                            }))
                        }
                    } catch (e) {
                        c.e(e)
                    } finally {
                        c.f()
                    }
                    s = s.concat(this.stateSpec)
                }
                if (null != a && (t.constants = a, o = o.concat(a), this.numConstants = a.length), o[0] instanceof yce) {
                    var h = [e].concat(o),
                        p = this.inputSpec.concat(s),
                        f = this.inputSpec;
                    this.inputSpec = p;
                    var d = N(v(n.prototype), "apply", this).call(this, h, t);
                    return this.inputSpec = f, d
                }
                return N(v(n.prototype), "apply", this).call(this, e, t)
            }
        }, {
            key: "call",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    var r = null == t ? null : t.mask,
                        a = null == t ? null : t.training,
                        i = null == t ? null : t.initialState;
                    e = lce(e), null == i && (i = n.stateful ? n.states_ : n.getInitialState(e));
                    var o = Array.isArray(n.cell.stateSize) ? n.cell.stateSize.length : 1;
                    if (i.length !== o) throw new Cse("RNN Layer has ".concat(o, " state(s) but was passed ") + "".concat(i.length, " initial state(s)."));
                    n.unroll && console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");
                    var s = {
                            training: a
                        },
                        u = Npe((function(e, t) {
                            var r = n.cell.call([e].concat(t), s);
                            return [r[0], r.slice(1)]
                        }), e, i, n.goBackwards, r, null, n.unroll, n.returnSequences),
                        c = u[0],
                        l = u[1],
                        h = u[2];
                    n.stateful && n.resetStates(h, a);
                    var p = n.returnSequences ? l : c;
                    return n.returnState ? [p].concat(h) : p
                }))
            }
        }, {
            key: "getInitialState",
            value: function(e) {
                var t = this;
                return X5((function() {
                    var n = $9(e.shape);
                    return n = Iue(n = u9(n, [1, 2])), Array.isArray(t.cell.stateSize) ? t.cell.stateSize.map((function(e) {
                        return e > 1 ? Rue(n, [1, e]) : n
                    })) : t.cell.stateSize > 1 ? [Rue(n, [1, t.cell.stateSize])] : [n]
                }))
            }
        }, {
            key: "trainableWeights",
            get: function() {
                return this.trainable ? this.cell.trainableWeights : []
            }
        }, {
            key: "nonTrainableWeights",
            get: function() {
                return this.trainable ? this.cell.nonTrainableWeights : this.cell.weights
            }
        }, {
            key: "setFastWeightInitDuringBuild",
            value: function(e) {
                N(v(n.prototype), "setFastWeightInitDuringBuild", this).call(this, e), null != this.cell && this.cell.setFastWeightInitDuringBuild(e)
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = N(v(n.prototype), "getConfig", this).call(this),
                    t = {
                        returnSequences: this.returnSequences,
                        returnState: this.returnState,
                        goBackwards: this.goBackwards,
                        stateful: this.stateful,
                        unroll: this.unroll
                    };
                null != this.numConstants && (t.numConstants = this.numConstants);
                var r = this.cell.getConfig();
                return this.getClassName() === n.className && (t.cell = {
                    className: this.cell.getClassName(),
                    config: r
                }), Object.assign(Object.assign(Object.assign({}, r), e), t)
            }
        }], [{
            key: "fromConfig",
            value: function(e, t) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                    r = t.cell,
                    a = rle(r, n);
                return new e(Object.assign(t, {
                    cell: a
                }))
            }
        }]), n
    }(wce);
    Spe.className = "RNN", Kre(Spe);
    var Tpe = function(e) {
            d(n, e);
            var t = w(n);

            function n() {
                return l(this, n), t.apply(this, arguments)
            }
            return p(n)
        }(wce),
        Epe = function(e) {
            d(n, e);
            var t = w(n);

            function n(e) {
                var r;
                return l(this, n), (r = t.call(this, e)).DEFAULT_ACTIVATION = "tanh", r.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", r.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", r.DEFAULT_BIAS_INITIALIZER = "zeros", r.units = e.units, Xse(r.units, "units"), r.activation = Ghe(null == e.activation ? r.DEFAULT_ACTIVATION : e.activation), r.useBias = null == e.useBias || e.useBias, r.kernelInitializer = sce(e.kernelInitializer || r.DEFAULT_KERNEL_INITIALIZER), r.recurrentInitializer = sce(e.recurrentInitializer || r.DEFAULT_RECURRENT_INITIALIZER), r.biasInitializer = sce(e.biasInitializer || r.DEFAULT_BIAS_INITIALIZER), r.kernelRegularizer = Jhe(e.kernelRegularizer), r.recurrentRegularizer = Jhe(e.recurrentRegularizer), r.biasRegularizer = Jhe(e.biasRegularizer), r.kernelConstraint = Vce(e.kernelConstraint), r.recurrentConstraint = Vce(e.recurrentConstraint), r.biasConstraint = Vce(e.biasConstraint), r.dropout = yue([1, bue([0, null == e.dropout ? 0 : e.dropout])]), r.recurrentDropout = yue([1, bue([0, null == e.recurrentDropout ? 0 : e.recurrentDropout])]), r.dropoutFunc = e.dropoutFunc, r.stateSize = r.units, r.dropoutMask = null, r.recurrentDropoutMask = null, r
            }
            return p(n, [{
                key: "build",
                value: function(e) {
                    e = hce(e), this.kernel = this.addWeight("kernel", [e[e.length - 1], this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias ? this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null, this.built = !0
                }
            }, {
                key: "call",
                value: function(e, t) {
                    var n = this;
                    return X5((function() {
                        if (2 !== e.length) throw new Cse("SimpleRNNCell expects 2 input Tensors, got ".concat(e.length, "."));
                        var r = e[1];
                        e = e[0];
                        var a, i = null != t.training && t.training;
                        0 < n.dropout && n.dropout < 1 && null == n.dropoutMask && (n.dropoutMask = Dpe({
                            ones: function() {
                                return lee(e)
                            },
                            rate: n.dropout,
                            training: i,
                            dropoutFunc: n.dropoutFunc
                        })), 0 < n.recurrentDropout && n.recurrentDropout < 1 && null == n.recurrentDropoutMask && (n.recurrentDropoutMask = Dpe({
                            ones: function() {
                                return lee(r)
                            },
                            rate: n.recurrentDropout,
                            training: i,
                            dropoutFunc: n.dropoutFunc
                        }));
                        var o = n.dropoutMask,
                            s = n.recurrentDropoutMask;
                        a = Oue(null != o ? g8(e, o) : e, n.kernel.read()), null != n.bias && (a = Lue(a, n.bias.read())), null != s && (r = g8(r, s));
                        var u = d8(a, Oue(r, n.recurrentKernel.read()));
                        return null != n.activation && (u = n.activation.apply(u)), [u, u]
                    }))
                }
            }, {
                key: "getConfig",
                value: function() {
                    var e = N(v(n.prototype), "getConfig", this).call(this),
                        t = {
                            units: this.units,
                            activation: Uhe(this.activation),
                            useBias: this.useBias,
                            kernelInitializer: oce(this.kernelInitializer),
                            recurrentInitializer: oce(this.recurrentInitializer),
                            biasInitializer: oce(this.biasInitializer),
                            kernelRegularizer: Xhe(this.kernelRegularizer),
                            recurrentRegularizer: Xhe(this.recurrentRegularizer),
                            biasRegularizer: Xhe(this.biasRegularizer),
                            activityRegularizer: Xhe(this.activityRegularizer),
                            kernelConstraint: Wce(this.kernelConstraint),
                            recurrentConstraint: Wce(this.recurrentConstraint),
                            biasConstraint: Wce(this.biasConstraint),
                            dropout: this.dropout,
                            recurrentDropout: this.recurrentDropout
                        };
                    return Object.assign(Object.assign({}, e), t)
                }
            }]), n
        }(Tpe);
    Epe.className = "SimpleRNNCell", Kre(Epe);
    var Cpe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            return l(this, n), e.cell = new Epe(e), t.call(this, e)
        }
        return p(n, [{
            key: "call",
            value: function(e, t) {
                var r = this;
                return X5((function() {
                    null != r.cell.dropoutMask && (Y5(r.cell.dropoutMask), r.cell.dropoutMask = null), null != r.cell.recurrentDropoutMask && (Y5(r.cell.recurrentDropoutMask), r.cell.recurrentDropoutMask = null);
                    var a = null == t ? null : t.mask,
                        i = null == t ? null : t.training,
                        o = null == t ? null : t.initialState;
                    return N(v(n.prototype), "call", r).call(r, e, {
                        mask: a,
                        training: i,
                        initialState: o
                    })
                }))
            }
        }], [{
            key: "fromConfig",
            value: function(e, t) {
                return new e(t)
            }
        }]), n
    }(Spe);
    Cpe.className = "SimpleRNN", Kre(Cpe);
    var Ape = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            if (l(this, n), (r = t.call(this, e)).DEFAULT_ACTIVATION = "tanh", r.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", r.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", r.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", r.DEFAULT_BIAS_INITIALIZER = "zeros", e.resetAfter) throw new Cse("GRUCell does not support reset_after parameter set to true.");
            return r.units = e.units, Xse(r.units, "units"), r.activation = Ghe(void 0 === e.activation ? r.DEFAULT_ACTIVATION : e.activation), r.recurrentActivation = Ghe(void 0 === e.recurrentActivation ? r.DEFAULT_RECURRENT_ACTIVATION : e.recurrentActivation), r.useBias = null == e.useBias || e.useBias, r.kernelInitializer = sce(e.kernelInitializer || r.DEFAULT_KERNEL_INITIALIZER), r.recurrentInitializer = sce(e.recurrentInitializer || r.DEFAULT_RECURRENT_INITIALIZER), r.biasInitializer = sce(e.biasInitializer || r.DEFAULT_BIAS_INITIALIZER), r.kernelRegularizer = Jhe(e.kernelRegularizer), r.recurrentRegularizer = Jhe(e.recurrentRegularizer), r.biasRegularizer = Jhe(e.biasRegularizer), r.kernelConstraint = Vce(e.kernelConstraint), r.recurrentConstraint = Vce(e.recurrentConstraint), r.biasConstraint = Vce(e.biasConstraint), r.dropout = yue([1, bue([0, null == e.dropout ? 0 : e.dropout])]), r.recurrentDropout = yue([1, bue([0, null == e.recurrentDropout ? 0 : e.recurrentDropout])]), r.dropoutFunc = e.dropoutFunc, r.implementation = e.implementation, r.stateSize = r.units, r.dropoutMask = null, r.recurrentDropoutMask = null, r
        }
        return p(n, [{
            key: "build",
            value: function(e) {
                var t = (e = hce(e))[e.length - 1];
                this.kernel = this.addWeight("kernel", [t, 3 * this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, 3 * this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias ? this.bias = this.addWeight("bias", [3 * this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint) : this.bias = null, this.built = !0
            }
        }, {
            key: "call",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    if (2 !== e.length) throw new Cse("GRUCell expects 2 input Tensors (inputs, h, c), got " + "".concat(e.length, "."));
                    var r = null != t.training && t.training,
                        a = e[1];
                    e = e[0], 0 < n.dropout && n.dropout < 1 && null == n.dropoutMask && (n.dropoutMask = Dpe({
                        ones: function() {
                            return lee(e)
                        },
                        rate: n.dropout,
                        training: r,
                        count: 3,
                        dropoutFunc: n.dropoutFunc
                    })), 0 < n.recurrentDropout && n.recurrentDropout < 1 && null == n.recurrentDropoutMask && (n.recurrentDropoutMask = Dpe({
                        ones: function() {
                            return lee(a)
                        },
                        rate: n.recurrentDropout,
                        training: r,
                        count: 3,
                        dropoutFunc: n.dropoutFunc
                    }));
                    var i, o, s, u = n.dropoutMask,
                        c = n.recurrentDropoutMask;
                    0 < n.dropout && n.dropout < 1 && (e = g8(e, u[0]));
                    var l = Oue(e, n.kernel.read());
                    n.useBias && (l = Lue(l, n.bias.read())), 0 < n.recurrentDropout && n.recurrentDropout < 1 && (a = g8(a, c[0]));
                    var h = n.recurrentKernel.read(),
                        p = S(Dte(h, [2 * n.units, n.units], h.rank - 1), 2),
                        f = p[0],
                        d = p[1],
                        v = Oue(a, f),
                        m = S(Dte(l, 3, l.rank - 1), 3),
                        g = m[0],
                        y = m[1],
                        b = m[2],
                        x = S(Dte(v, 2, v.rank - 1), 2),
                        k = x[0],
                        w = x[1];
                    i = n.recurrentActivation.apply(d8(g, k)), o = n.recurrentActivation.apply(d8(y, w));
                    var I = Oue(g8(o, a), d);
                    s = n.activation.apply(d8(b, I));
                    var N = d8(g8(i, a), g8(d8(1, M9(i)), s));
                    return [N, N]
                }))
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = N(v(n.prototype), "getConfig", this).call(this),
                    t = {
                        units: this.units,
                        activation: Uhe(this.activation),
                        recurrentActivation: Uhe(this.recurrentActivation),
                        useBias: this.useBias,
                        kernelInitializer: oce(this.kernelInitializer),
                        recurrentInitializer: oce(this.recurrentInitializer),
                        biasInitializer: oce(this.biasInitializer),
                        kernelRegularizer: Xhe(this.kernelRegularizer),
                        recurrentRegularizer: Xhe(this.recurrentRegularizer),
                        biasRegularizer: Xhe(this.biasRegularizer),
                        activityRegularizer: Xhe(this.activityRegularizer),
                        kernelConstraint: Wce(this.kernelConstraint),
                        recurrentConstraint: Wce(this.recurrentConstraint),
                        biasConstraint: Wce(this.biasConstraint),
                        dropout: this.dropout,
                        recurrentDropout: this.recurrentDropout,
                        implementation: this.implementation,
                        resetAfter: !1
                    };
                return Object.assign(Object.assign({}, e), t)
            }
        }]), n
    }(Tpe);
    Ape.className = "GRUCell", Kre(Ape);
    var Rpe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            return l(this, n), 0 === e.implementation && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), e.cell = new Ape(e), t.call(this, e)
        }
        return p(n, [{
            key: "call",
            value: function(e, t) {
                var r = this;
                return X5((function() {
                    null != r.cell.dropoutMask && (Y5(r.cell.dropoutMask), r.cell.dropoutMask = null), null != r.cell.recurrentDropoutMask && (Y5(r.cell.recurrentDropoutMask), r.cell.recurrentDropoutMask = null);
                    var a = null == t ? null : t.mask,
                        i = null == t ? null : t.training,
                        o = null == t ? null : t.initialState;
                    return N(v(n.prototype), "call", r).call(r, e, {
                        mask: a,
                        training: i,
                        initialState: o
                    })
                }))
            }
        }], [{
            key: "fromConfig",
            value: function(e, t) {
                return 0 === t.implmentation && (t.implementation = 1), new e(t)
            }
        }]), n
    }(Spe);
    Rpe.className = "GRU", Kre(Rpe);
    var _pe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            return l(this, n), (r = t.call(this, e)).DEFAULT_ACTIVATION = "tanh", r.DEFAULT_RECURRENT_ACTIVATION = "hardSigmoid", r.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", r.DEFAULT_RECURRENT_INITIALIZER = "orthogonal", r.DEFAULT_BIAS_INITIALIZER = "zeros", r.units = e.units, Xse(r.units, "units"), r.activation = Ghe(void 0 === e.activation ? r.DEFAULT_ACTIVATION : e.activation), r.recurrentActivation = Ghe(void 0 === e.recurrentActivation ? r.DEFAULT_RECURRENT_ACTIVATION : e.recurrentActivation), r.useBias = null == e.useBias || e.useBias, r.kernelInitializer = sce(e.kernelInitializer || r.DEFAULT_KERNEL_INITIALIZER), r.recurrentInitializer = sce(e.recurrentInitializer || r.DEFAULT_RECURRENT_INITIALIZER), r.biasInitializer = sce(e.biasInitializer || r.DEFAULT_BIAS_INITIALIZER), r.unitForgetBias = e.unitForgetBias, r.kernelRegularizer = Jhe(e.kernelRegularizer), r.recurrentRegularizer = Jhe(e.recurrentRegularizer), r.biasRegularizer = Jhe(e.biasRegularizer), r.kernelConstraint = Vce(e.kernelConstraint), r.recurrentConstraint = Vce(e.recurrentConstraint), r.biasConstraint = Vce(e.biasConstraint), r.dropout = yue([1, bue([0, null == e.dropout ? 0 : e.dropout])]), r.recurrentDropout = yue([1, bue([0, null == e.recurrentDropout ? 0 : e.recurrentDropout])]), r.dropoutFunc = e.dropoutFunc, r.implementation = e.implementation, r.stateSize = [r.units, r.units], r.dropoutMask = null, r.recurrentDropoutMask = null, r
        }
        return p(n, [{
            key: "build",
            value: function(e) {
                var t, n, r = (e = hce(e))[e.length - 1];
                if (this.kernel = this.addWeight("kernel", [r, 4 * this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.recurrentKernel = this.addWeight("recurrent_kernel", [this.units, 4 * this.units], null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias) {
                    if (this.unitForgetBias) {
                        var a = this.biasInitializer,
                            i = this.units;
                        n = new(t = function(e) {
                            d(n, e);
                            var t = w(n);

                            function n() {
                                return l(this, n), t.apply(this, arguments)
                            }
                            return p(n, [{
                                key: "apply",
                                value: function(e, t) {
                                    var n = a.apply([i]),
                                        r = (new jue).apply([i]),
                                        o = a.apply([2 * i]);
                                    return Aue(Aue(n, r), o)
                                }
                            }]), n
                        }(Vue), t.className = "CustomInit", t)
                    } else n = this.biasInitializer;
                    this.bias = this.addWeight("bias", [4 * this.units], null, n, this.biasRegularizer, !0, this.biasConstraint)
                } else this.bias = null;
                this.built = !0
            }
        }, {
            key: "call",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    var r = null != t.training && t.training;
                    if (3 !== e.length) throw new Cse("LSTMCell expects 3 input Tensors (inputs, h, c), got " + "".concat(e.length, "."));
                    var a = e[1],
                        i = e[2];
                    e = e[0], 0 < n.dropout && n.dropout < 1 && null == n.dropoutMask && (n.dropoutMask = Dpe({
                        ones: function() {
                            return lee(e)
                        },
                        rate: n.dropout,
                        training: r,
                        count: 4,
                        dropoutFunc: n.dropoutFunc
                    })), 0 < n.recurrentDropout && n.recurrentDropout < 1 && null == n.recurrentDropoutMask && (n.recurrentDropoutMask = Dpe({
                        ones: function() {
                            return lee(a)
                        },
                        rate: n.recurrentDropout,
                        training: r,
                        count: 4,
                        dropoutFunc: n.dropoutFunc
                    }));
                    var o, s, u, c, l = n.dropoutMask,
                        h = n.recurrentDropoutMask;
                    0 < n.dropout && n.dropout < 1 && (e = g8(e, l[0]));
                    var p = Oue(e, n.kernel.read());
                    0 < n.recurrentDropout && n.recurrentDropout < 1 && (a = g8(a, h[0])), p = d8(p, Oue(a, n.recurrentKernel.read())), n.useBias && (p = Lue(p, n.bias.read()));
                    var f = S(Dte(p, 4, p.rank - 1), 4),
                        d = f[0],
                        v = f[1],
                        m = f[2],
                        g = f[3];
                    o = n.recurrentActivation.apply(d), s = n.recurrentActivation.apply(v), u = d8(g8(s, i), g8(o, n.activation.apply(m))), c = n.recurrentActivation.apply(g);
                    var y = g8(c, n.activation.apply(u));
                    return [y, y, u]
                }))
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = N(v(n.prototype), "getConfig", this).call(this),
                    t = {
                        units: this.units,
                        activation: Uhe(this.activation),
                        recurrentActivation: Uhe(this.recurrentActivation),
                        useBias: this.useBias,
                        kernelInitializer: oce(this.kernelInitializer),
                        recurrentInitializer: oce(this.recurrentInitializer),
                        biasInitializer: oce(this.biasInitializer),
                        unitForgetBias: this.unitForgetBias,
                        kernelRegularizer: Xhe(this.kernelRegularizer),
                        recurrentRegularizer: Xhe(this.recurrentRegularizer),
                        biasRegularizer: Xhe(this.biasRegularizer),
                        activityRegularizer: Xhe(this.activityRegularizer),
                        kernelConstraint: Wce(this.kernelConstraint),
                        recurrentConstraint: Wce(this.recurrentConstraint),
                        biasConstraint: Wce(this.biasConstraint),
                        dropout: this.dropout,
                        recurrentDropout: this.recurrentDropout,
                        implementation: this.implementation
                    };
                return Object.assign(Object.assign({}, e), t)
            }
        }]), n
    }(Tpe);
    _pe.className = "LSTMCell", Kre(_pe);
    var Ope = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            return l(this, n), 0 === e.implementation && console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."), e.cell = new _pe(e), t.call(this, e)
        }
        return p(n, [{
            key: "call",
            value: function(e, t) {
                var r = this;
                return X5((function() {
                    null != r.cell.dropoutMask && (Y5(r.cell.dropoutMask), r.cell.dropoutMask = null), null != r.cell.recurrentDropoutMask && (Y5(r.cell.recurrentDropoutMask), r.cell.recurrentDropoutMask = null);
                    var a = null == t ? null : t.mask,
                        i = null == t ? null : t.training,
                        o = null == t ? null : t.initialState;
                    return N(v(n.prototype), "call", r).call(r, e, {
                        mask: a,
                        training: i,
                        initialState: o
                    })
                }))
            }
        }], [{
            key: "fromConfig",
            value: function(e, t) {
                return 0 === t.implmentation && (t.implementation = 1), new e(t)
            }
        }]), n
    }(Spe);
    Ope.className = "LSTM", Kre(Ope);
    var Fpe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            return l(this, n), (r = t.call(this, e)).cells = e.cells, r
        }
        return p(n, [{
            key: "stateSize",
            get: function() {
                var e, t = [],
                    n = O(this.cells.slice().reverse());
                try {
                    for (n.s(); !(e = n.n()).done;) {
                        var r = e.value;
                        Array.isArray(r.stateSize) ? t.push.apply(t, T(r.stateSize)) : t.push(r.stateSize)
                    }
                } catch (e) {
                    n.e(e)
                } finally {
                    n.f()
                }
                return t
            }
        }, {
            key: "call",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    var r, a = e.slice(1),
                        i = [],
                        o = O(n.cells.slice().reverse());
                    try {
                        for (o.s(); !(r = o.n()).done;) {
                            var s = r.value;
                            Array.isArray(s.stateSize) ? i.push(a.splice(0, s.stateSize.length)) : i.push(a.splice(0, 1))
                        }
                    } catch (e) {
                        o.e(e)
                    } finally {
                        o.f()
                    }
                    i.reverse();
                    for (var u, c = [], l = 0; l < n.cells.length; ++l) {
                        var h = n.cells[l];
                        a = i[l], u = 0 === l ? [e[0]].concat(a) : [u[0]].concat(a), u = h.call(u, t), c.push(u.slice(1))
                    }
                    a = [];
                    var p, f = O(c.slice().reverse());
                    try {
                        for (f.s(); !(p = f.n()).done;) {
                            var d, v = p.value;
                            (d = a).push.apply(d, T(v))
                        }
                    } catch (e) {
                        f.e(e)
                    } finally {
                        f.f()
                    }
                    return [u[0]].concat(a)
                }))
            }
        }, {
            key: "build",
            value: function(e) {
                var t;
                uce(e) && (e = e[0]), this.cells.forEach((function(n, r) {
                    hue("RNNCell_".concat(r), (function() {
                        n.build(e), t = Array.isArray(n.stateSize) ? n.stateSize[0] : n.stateSize, e = [e[0], t]
                    }))
                })), this.built = !0
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = N(v(n.prototype), "getConfig", this).call(this),
                    t = {
                        cells: this.cells.map((function(e) {
                            return {
                                className: e.getClassName(),
                                config: e.getConfig()
                            }
                        }))
                    };
                return Object.assign(Object.assign({}, e), t)
            }
        }, {
            key: "trainableWeights",
            get: function() {
                if (!this.trainable) return [];
                var e, t = [],
                    n = O(this.cells);
                try {
                    for (n.s(); !(e = n.n()).done;) {
                        var r = e.value;
                        t.push.apply(t, T(r.trainableWeights))
                    }
                } catch (e) {
                    n.e(e)
                } finally {
                    n.f()
                }
                return t
            }
        }, {
            key: "nonTrainableWeights",
            get: function() {
                var e, t = [],
                    n = O(this.cells);
                try {
                    for (n.s(); !(e = n.n()).done;) {
                        var r = e.value;
                        t.push.apply(t, T(r.nonTrainableWeights))
                    }
                } catch (e) {
                    n.e(e)
                } finally {
                    n.f()
                }
                if (!this.trainable) {
                    var a, i = [],
                        o = O(this.cells);
                    try {
                        for (o.s(); !(a = o.n()).done;) {
                            var s = a.value;
                            i.push.apply(i, T(s.trainableWeights))
                        }
                    } catch (e) {
                        o.e(e)
                    } finally {
                        o.f()
                    }
                    return i.concat(t)
                }
                return t
            }
        }, {
            key: "getWeights",
            value: function() {
                var e, t = [],
                    n = O(this.cells);
                try {
                    for (n.s(); !(e = n.n()).done;) {
                        var r = e.value;
                        t.push.apply(t, T(r.weights))
                    }
                } catch (e) {
                    n.e(e)
                } finally {
                    n.f()
                }
                return vce(t)
            }
        }, {
            key: "setWeights",
            value: function(e) {
                var t, n = [],
                    r = O(this.cells);
                try {
                    for (r.s(); !(t = r.n()).done;)
                        for (var a = t.value, i = a.weights.length, o = e.splice(i), s = 0; s < a.weights.length; ++s) n.push([a.weights[s], o[s]])
                } catch (e) {
                    r.e(e)
                } finally {
                    r.f()
                }
                mce(n)
            }
        }], [{
            key: "fromConfig",
            value: function(e, t) {
                var n, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                    a = [],
                    i = O(t.cells);
                try {
                    for (i.s(); !(n = i.n()).done;) {
                        var o = n.value;
                        a.push(rle(o, r))
                    }
                } catch (e) {
                    i.e(e)
                } finally {
                    i.f()
                }
                return new e({
                    cells: a
                })
            }
        }]), n
    }(Tpe);

    function Dpe(e) {
        var t = e.ones,
            n = e.rate,
            r = e.training,
            a = void 0 !== r && r,
            i = e.count,
            o = void 0 === i ? 1 : i,
            s = e.dropoutFunc,
            u = function() {
                return null != s ? s(t(), n) : Pue(t(), n)
            },
            c = function() {
                return Bue(u, t, a)
            };
        return !o || o <= 1 ? J5(c().clone()) : Array(o).fill(void 0).map(c).map((function(e) {
            return J5(e.clone())
        }))
    }
    Fpe.className = "StackedRNNCells", Kre(Fpe);
    var Mpe = function(e, t) {
            var n = {};
            for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
            if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
                var a = 0;
                for (r = Object.getOwnPropertySymbols(e); a < r.length; a++) t.indexOf(r[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[a]) && (n[r[a]] = e[r[a]])
            }
            return n
        },
        Lpe = function(e) {
            d(n, e);
            var t = w(n);

            function n(e) {
                var r;
                if (l(this, n), e.unroll) throw new Ase("Unrolling is not possible with convolutional RNNs.");
                if (Array.isArray(e.cell)) throw new Ase("It is not possible at the moment to stack convolutional cells.");
                return (r = t.call(this, e)).inputSpec = [new gce({
                    ndim: 5
                })], r
            }
            return p(n, [{
                key: "call",
                value: function(e, t) {
                    var r = this;
                    return X5((function() {
                        if (null != r.cell.dropoutMask && (Y5(r.cell.dropoutMask), r.cell.dropoutMask = null), null != r.cell.recurrentDropoutMask && (Y5(r.cell.recurrentDropoutMask), r.cell.recurrentDropoutMask = null), t && t.constants) throw new Cse("ConvRNN2D cell does not support constants");
                        var a = null == t ? null : t.mask,
                            i = null == t ? null : t.training,
                            o = null == t ? null : t.initialState;
                        return N(v(n.prototype), "call", r).call(r, e, {
                            mask: a,
                            training: i,
                            initialState: o
                        })
                    }))
                }
            }, {
                key: "computeOutputShape",
                value: function(e) {
                    var t = this.computeSingleOutputShape(e);
                    return this.returnSequences || (t = [t[0]].concat(T(t.slice(2)))), this.returnState && (t = [t].concat(T(Array(2).fill([e[0]].concat(T(t.slice(-3))))))), t
                }
            }, {
                key: "getInitialState",
                value: function(e) {
                    var t = this;
                    return X5((function() {
                        var n = t.cell.stateSize,
                            r = e.shape,
                            a = t.computeSingleOutputShape(r),
                            i = $9([a[0]].concat(T(a.slice(2))));
                        return Array.isArray(n) ? Array(n.length).fill(i) : [i]
                    }))
                }
            }, {
                key: "resetStates",
                value: function(e) {
                    var t = this,
                        n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    X5((function() {
                        if (!t.stateful) throw new Tse("Cannot call resetStates() on an RNN Layer that is not stateful.");
                        var r = t.inputSpec[0].shape,
                            a = t.computeSingleOutputShape(r),
                            i = [a[0]].concat(T(a.slice(2)));
                        if (null == r[0]) throw new Cse("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");
                        if (null == t.getStates()) Array.isArray(t.cell.stateSize) ? t.states_ = t.cell.stateSize.map((function() {
                            return $9(i)
                        })) : t.states_ = [$9(i)];
                        else if (null == e) Y5(t.states_), null != t.keptStates && (Y5(t.keptStates), t.keptStates = []), Array.isArray(t.cell.stateSize) ? t.states_ = t.cell.stateSize.map((function() {
                            return $9(i)
                        })) : t.states_[0] = $9(i);
                        else {
                            if (Array.isArray(e) || (e = [e]), e.length !== t.states_.length) throw new Cse("Layer ".concat(t.name, " expects ").concat(t.states_.length, " state(s), ") + "but it received ".concat(e.length, " state value(s). Input ") + "received: ".concat(e));
                            n ? t.keptStates.push(t.states_.slice()) : Y5(t.states_);
                            for (var o = 0; o < t.states_.length; ++o) {
                                var s = e[o],
                                    u = i;
                                if (!P$(s.shape, u)) throw new Cse("State ".concat(o, " is incompatible with layer ").concat(t.name, ": ") + "expected shape=".concat(u, ", received shape=").concat(s.shape));
                                t.states_[o] = s
                            }
                        }
                        t.states_ = t.states_.map((function(e) {
                            return J5(e.clone())
                        }))
                    }))
                }
            }, {
                key: "computeSingleOutputShape",
                value: function(e) {
                    var t = this.cell,
                        n = t.dataFormat,
                        r = t.filters,
                        a = t.kernelSize,
                        i = t.padding,
                        o = t.strides,
                        s = t.dilationRate,
                        u = "channelsFirst" === n,
                        c = e[u ? 3 : 2],
                        l = e[u ? 4 : 3],
                        h = ape(c, a[0], i, o[0], s[0]),
                        p = ape(l, a[1], i, o[1], s[1]);
                    return [].concat(T(e.slice(0, 2)), T(u ? [r, h, p] : [h, p, r]))
                }
            }]), n
        }(Spe);
    Lpe.className = "ConvRNN2D";
    var zpe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            l(this, n);
            var a = e.filters,
                i = e.kernelSize,
                o = e.strides,
                s = e.padding,
                u = e.dataFormat,
                c = e.dilationRate;
            return (r = t.call(this, Object.assign(Object.assign({}, e), {
                units: a
            }))).filters = a, Xse(r.filters, "filters"), r.kernelSize = rpe(i, 2, "kernelSize"), r.kernelSize.forEach((function(e) {
                return Xse(e, "kernelSize")
            })), r.strides = rpe(o || 1, 2, "strides"), r.strides.forEach((function(e) {
                return Xse(e, "strides")
            })), r.padding = s || "valid", uue(r.padding), r.dataFormat = u || "channelsLast", sue(r.dataFormat), r.dilationRate = rpe(c || 1, 2, "dilationRate"), r.dilationRate.forEach((function(e) {
                return Xse(e, "dilationRate")
            })), r
        }
        return p(n, [{
            key: "build",
            value: function(e) {
                var t;
                e = hce(e);
                var n = "channelsFirst" === this.dataFormat ? 1 : e.length - 1;
                if (null == e[n]) throw new Cse("The channel dimension of the input should be defined. " + "Found ".concat(e[n]));
                var r = e[n],
                    a = this.kernelSize.concat([r, 4 * this.filters]);
                this.kernel = this.addWeight("kernel", a, null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint);
                var i = this.kernelSize.concat([this.filters, 4 * this.filters]);
                if (this.recurrentKernel = this.addWeight("recurrent_kernel", i, null, this.recurrentInitializer, this.recurrentRegularizer, !0, this.recurrentConstraint), this.useBias) {
                    var o;
                    if (this.unitForgetBias) {
                        var s = this.biasInitializer,
                            u = this.filters;
                        o = new(t = function(e) {
                            d(n, e);
                            var t = w(n);

                            function n() {
                                return l(this, n), t.apply(this, arguments)
                            }
                            return p(n, [{
                                key: "apply",
                                value: function(e, t) {
                                    return Cue([s.apply([u]), eee([u]), s.apply([2 * u])])
                                }
                            }]), n
                        }(Vue), t.className = "CustomInit", t)
                    } else o = this.biasInitializer;
                    this.bias = this.addWeight("bias", [4 * this.filters], null, o, this.biasRegularizer, !0, this.biasConstraint)
                }
                this.built = !0
            }
        }, {
            key: "call",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    if (3 !== e.length) throw new Cse("ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got " + "".concat(e.length, "."));
                    var r = t.training || !1,
                        a = e[0],
                        i = e[1],
                        o = e[2];
                    0 < n.dropout && n.dropout < 1 && null == n.dropoutMask && (n.dropoutMask = Dpe({
                        ones: function() {
                            return lee(a)
                        },
                        rate: n.dropout,
                        training: r,
                        count: 4,
                        dropoutFunc: n.dropoutFunc
                    }));
                    var s = n.dropoutMask,
                        u = function(e, t, n) {
                            return t && t[n] ? g8(t[n], e) : e
                        },
                        c = u(a, s, 0),
                        l = u(a, s, 1),
                        h = u(a, s, 2),
                        p = u(a, s, 3);
                    0 < n.recurrentDropout && n.recurrentDropout < 1 && null == n.recurrentDropoutMask && (n.recurrentDropoutMask = Dpe({
                        ones: function() {
                            return lee(i)
                        },
                        rate: n.recurrentDropout,
                        training: r,
                        count: 4,
                        dropoutFunc: n.dropoutFunc
                    }));
                    var f = n.recurrentDropoutMask,
                        d = u(i, f, 0),
                        v = u(i, f, 1),
                        m = u(i, f, 2),
                        g = u(i, f, 3),
                        y = S(Dte(n.kernel.read(), 4, 3), 4),
                        b = y[0],
                        x = y[1],
                        k = y[2],
                        w = y[3],
                        I = S(n.useBias ? Dte(n.bias.read(), 4) : [null, null, null, null], 4),
                        N = I[0],
                        T = I[1],
                        E = I[2],
                        C = I[3];
                    c = n.inputConv(c, b, N, n.padding), l = n.inputConv(l, x, T, n.padding), h = n.inputConv(h, k, E, n.padding), p = n.inputConv(p, w, C, n.padding);
                    var A = S(Dte(n.recurrentKernel.read(), 4, 3), 4),
                        R = A[0],
                        _ = A[1],
                        O = A[2],
                        F = A[3];
                    d = n.recurrentConv(d, R), v = n.recurrentConv(v, _), m = n.recurrentConv(m, O), g = n.recurrentConv(g, F);
                    var D = n.recurrentActivation.apply(d8(c, d)),
                        M = n.recurrentActivation.apply(d8(l, v)),
                        L = d8(g8(M, o), g8(D, n.activation.apply(d8(h, m)))),
                        z = g8(n.recurrentActivation.apply(d8(p, g)), n.activation.apply(L));
                    return [z, z, L]
                }))
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = N(v(n.prototype), "getConfig", this).call(this),
                    t = (e.units, Mpe(e, ["units"])),
                    r = {
                        filters: this.filters,
                        kernelSize: this.kernelSize,
                        padding: this.padding,
                        dataFormat: this.dataFormat,
                        dilationRate: this.dilationRate,
                        strides: this.strides
                    };
                return Object.assign(Object.assign({}, t), r)
            }
        }, {
            key: "inputConv",
            value: function(e, t, n, r) {
                var a = b7(e, t, this.strides, r || "valid", "channelsFirst" === this.dataFormat ? "NCHW" : "NHWC", this.dilationRate);
                return n ? Lue(a, n, this.dataFormat) : a
            }
        }, {
            key: "recurrentConv",
            value: function(e, t) {
                return b7(e, t, 1, "same", "channelsFirst" === this.dataFormat ? "NCHW" : "NHWC")
            }
        }]), n
    }(_pe);
    zpe.className = "ConvLSTM2DCell", Kre(zpe);
    var Ppe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            l(this, n);
            var r = new zpe(e);
            return t.call(this, Object.assign(Object.assign({}, e), {
                cell: r
            }))
        }
        return p(n, null, [{
            key: "fromConfig",
            value: function(e, t) {
                return new e(t)
            }
        }]), n
    }(Lpe);
    Ppe.className = "ConvLSTM2D", Kre(Ppe);
    var Bpe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            return l(this, n), (r = t.call(this, e)).rate = Math.max(Math.min(e.rate, 1), 0), r.noiseShape = e.noiseShape, r.seed = e.seed, r.supportsMasking = !0, r
        }
        return p(n, [{
            key: "getNoiseShape",
            value: function(e) {
                if (null == this.noiseShape) return this.noiseShape;
                for (var t = e.shape, n = [], r = 0; r < this.noiseShape.length; ++r) n.push(null == this.noiseShape[r] ? t[r] : this.noiseShape[r]);
                return n
            }
        }, {
            key: "call",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    n.invokeCallHook(e, t);
                    var r = lce(e);
                    if (0 < n.rate && n.rate < 1) {
                        var a = null != t.training && t.training,
                            i = n.getNoiseShape(r);
                        return Bue((function() {
                            return Pue(r, n.rate, i, n.seed)
                        }), (function() {
                            return r
                        }), a)
                    }
                    return e
                }))
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = {
                        rate: this.rate,
                        noiseShape: this.noiseShape,
                        seed: this.seed
                    },
                    t = N(v(n.prototype), "getConfig", this).call(this);
                return Object.assign(e, t), e
            }
        }, {
            key: "dispose",
            value: function() {
                return N(v(n.prototype), "dispose", this).call(this)
            }
        }]), n
    }(wce);
    Bpe.className = "Dropout", Kre(Bpe);
    var Wpe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            return l(this, n), (r = t.call(this, e)).inputSpec = [{
                ndim: 3
            }], r
        }
        return p(n, [{
            key: "getNoiseShape",
            value: function(e) {
                var t = e.shape;
                return [t[0], 1, t[2]]
            }
        }]), n
    }(Bpe);
    Wpe.className = "SpatialDropout1D", Kre(Wpe);
    var Upe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            if (l(this, n), (r = t.call(this, e)).activation = null, r.useBias = !0, r.kernel = null, r.bias = null, r.DEFAULT_KERNEL_INITIALIZER = "glorotNormal", r.DEFAULT_BIAS_INITIALIZER = "zeros", null == e.batchInputShape && null == e.inputShape && null != e.inputDim) {
                var a = null;
                null != e.batchSize && (a = e.batchSize), r.batchInputShape = [a, e.inputDim]
            }
            return r.units = e.units, Xse(r.units, "units"), r.activation = Ghe(e.activation), null != e.useBias && (r.useBias = e.useBias), r.kernelInitializer = sce(e.kernelInitializer || r.DEFAULT_KERNEL_INITIALIZER), r.biasInitializer = sce(e.biasInitializer || r.DEFAULT_BIAS_INITIALIZER), r.kernelConstraint = Vce(e.kernelConstraint), r.biasConstraint = Vce(e.biasConstraint), r.kernelRegularizer = Jhe(e.kernelRegularizer), r.biasRegularizer = Jhe(e.biasRegularizer), r.activityRegularizer = Jhe(e.activityRegularizer), r.supportsMasking = !0, r.inputSpec = [{
                minNDim: 2
            }], r
        }
        return p(n, [{
            key: "build",
            value: function(e) {
                var t = (e = hce(e))[e.length - 1];
                null == this.kernel && (this.kernel = this.addWeight("kernel", [t, this.units], null, this.kernelInitializer, this.kernelRegularizer, !0, this.kernelConstraint), this.useBias && (this.bias = this.addWeight("bias", [this.units], null, this.biasInitializer, this.biasRegularizer, !0, this.biasConstraint))), this.inputSpec = [{
                    minNDim: 2,
                    axes: f({}, -1, t)
                }], this.built = !0
            }
        }, {
            key: "computeOutputShape",
            value: function(e) {
                var t = (e = hce(e)).slice();
                return t[t.length - 1] = this.units, t
            }
        }, {
            key: "call",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    n.invokeCallHook(e, t);
                    var r, a = lce(e),
                        i = Jse(n.activation.getClassName());
                    return null != i ? r = Oue(a, n.kernel.read(), i, n.bias ? n.bias.read() : null) : (r = Oue(a, n.kernel.read()), null != n.bias && (r = Lue(r, n.bias.read())), null != n.activation && (r = n.activation.apply(r))), r
                }))
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = {
                        units: this.units,
                        activation: Uhe(this.activation),
                        useBias: this.useBias,
                        kernelInitializer: oce(this.kernelInitializer),
                        biasInitializer: oce(this.biasInitializer),
                        kernelRegularizer: Xhe(this.kernelRegularizer),
                        biasRegularizer: Xhe(this.biasRegularizer),
                        activityRegularizer: Xhe(this.activityRegularizer),
                        kernelConstraint: Wce(this.kernelConstraint),
                        biasConstraint: Wce(this.biasConstraint)
                    },
                    t = N(v(n.prototype), "getConfig", this).call(this);
                return Object.assign(e, t), e
            }
        }]), n
    }(wce);
    Upe.className = "Dense", Kre(Upe);
    var Vpe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            return l(this, n), e = e || {}, (r = t.call(this, e)).inputSpec = [{
                minNDim: 3
            }], r.dataFormat = e.dataFormat, r
        }
        return p(n, [{
            key: "computeOutputShape",
            value: function(e) {
                var t, n = O((e = hce(e)).slice(1));
                try {
                    for (n.s(); !(t = n.n()).done;) {
                        if (null == t.value) throw new Cse('The shape of the input to "Flatten" is not fully defined ' + "(got ".concat(e.slice(1), "). Make sure to pass a complete ") + '"input_shape" or "batch_input_shape" argument to the first layer in your model.')
                    }
                } catch (e) {
                    n.e(e)
                } finally {
                    n.f()
                }
                return [e[0], gue(e, 1)]
            }
        }, {
            key: "call",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    n.invokeCallHook(e, t);
                    var r = lce(e);
                    if ("channelsFirst" === n.dataFormat && r.rank > 1) {
                        for (var a = [0], i = 2; i < r.rank; ++i) a.push(i);
                        a.push(1), r = hne(r, a)
                    }
                    return function(e) {
                        if (e.rank <= 1) throw new Cse("batchFlatten requires a minimum rank of 2. Got rank: ".concat(e.rank, "."));
                        var t = [e.shape[0], gue(e.shape, 1)];
                        return X8(e, t)
                    }(r)
                }))
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = {};
                null != this.dataFormat && (e.dataFormat = this.dataFormat);
                var t = N(v(n.prototype), "getConfig", this).call(this);
                return Object.assign(e, t), e
            }
        }]), n
    }(wce);
    Vpe.className = "Flatten", Kre(Vpe);
    var Gpe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            return l(this, n), (r = t.call(this, e)).supportsMasking = !0, r.activation = Ghe(e.activation), r
        }
        return p(n, [{
            key: "call",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    n.invokeCallHook(e, t);
                    var r = lce(e);
                    return n.activation.apply(r)
                }))
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = {
                        activation: Uhe(this.activation)
                    },
                    t = N(v(n.prototype), "getConfig", this).call(this);
                return Object.assign(e, t), e
            }
        }]), n
    }(wce);
    Gpe.className = "Activation", Kre(Gpe);
    var jpe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            return l(this, n), (r = t.call(this, e)).n = e.n, r.inputSpec = [{
                ndim: 2
            }], r
        }
        return p(n, [{
            key: "computeOutputShape",
            value: function(e) {
                return [e[0], this.n, e[1]]
            }
        }, {
            key: "call",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    return e = lce(e), t = e, r = n.n, X5((function() {
                        if (2 !== t.shape.length) throw new Cse("repeat() expects a rank-2 tensor, but received a " + "rank-".concat(t.shape.length, " tensor."));
                        return Rue(Iue(t, 1), [1, r, 1])
                    }));
                    var t, r
                }))
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = {
                        n: this.n
                    },
                    t = N(v(n.prototype), "getConfig", this).call(this);
                return Object.assign(e, t), e
            }
        }]), n
    }(wce);
    jpe.className = "RepeatVector", Kre(jpe);
    var Hpe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            l(this, n), (r = t.call(this, e)).targetShape = e.targetShape;
            for (var a = 0; a < r.targetShape.length; ++a) r.isUnknown(r.targetShape[a]) && (r.targetShape[a] = null);
            return r
        }
        return p(n, [{
            key: "isUnknown",
            value: function(e) {
                return e < 0 || null == e
            }
        }, {
            key: "fixUnknownDimension",
            value: function(e, t) {
                for (var n = "Total size of new array must be unchanged.", r = t.slice(), a = 1, i = null, o = 0; o < r.length; ++o) {
                    var s = r[o];
                    if (this.isUnknown(s)) {
                        if (null !== i) throw new Cse("Can only specifiy one unknown dimension.");
                        i = o
                    } else a *= s
                }
                var u = gue(e);
                if (null !== i) {
                    if (0 === a || u % a != 0) throw new Cse(n);
                    r[i] = u / a
                } else if (u !== a) throw new Cse(n);
                return r
            }
        }, {
            key: "computeOutputShape",
            value: function(e) {
                for (var t = !1, n = 0; n < e.length; ++n)
                    if (this.isUnknown(e[n])) {
                        t = !0;
                        break
                    }
                return t ? e.slice(0, 1).concat(this.targetShape) : e.slice(0, 1).concat(this.fixUnknownDimension(e.slice(1), this.targetShape))
            }
        }, {
            key: "call",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    n.invokeCallHook(e, t);
                    var r = lce(e),
                        a = r.shape,
                        i = a.slice(0, 1).concat(n.fixUnknownDimension(a.slice(1), n.targetShape));
                    return X8(r, i)
                }))
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = {
                        targetShape: this.targetShape
                    },
                    t = N(v(n.prototype), "getConfig", this).call(this);
                return Object.assign(e, t), e
            }
        }]), n
    }(wce);
    Hpe.className = "Reshape", Kre(Hpe);
    var qpe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            if (l(this, n), r = t.call(this, e), null == e.dims) throw new Error("Required configuration field `dims` is missing during Permute constructor call.");
            if (!Array.isArray(e.dims)) throw new Error("Permute constructor requires `dims` to be an Array, but received " + "".concat(e.dims, " instead."));
            var a = xue(1, e.dims.length + 1);
            if (!P$(e.dims.slice().sort(), a)) throw new Error("Invalid permutation `dims`: " + JSON.stringify(e.dims) + " `dims` must contain consecutive integers starting from 1.");
            return r.dims = e.dims, r.dimsIncludingBatch = [0].concat(r.dims), r.inputSpec = [new gce({
                ndim: r.dims.length + 1
            })], r
        }
        return p(n, [{
            key: "computeOutputShape",
            value: function(e) {
                var t = (e = hce(e)).slice();
                return this.dims.forEach((function(n, r) {
                    t[r + 1] = e[n]
                })), t
            }
        }, {
            key: "call",
            value: function(e, t) {
                return hne(lce(e), this.dimsIncludingBatch)
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = {
                        dims: this.dims
                    },
                    t = N(v(n.prototype), "getConfig", this).call(this);
                return Object.assign(e, t), e
            }
        }]), n
    }(wce);
    qpe.className = "Permute", Kre(qpe);
    var Kpe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            return l(this, n), (r = t.call(this, null == e ? {} : e)).supportsMasking = !0, r.maskValue = null != e ? null == e.maskValue ? 0 : e.maskValue : 0, r
        }
        return p(n, [{
            key: "computeOutputShape",
            value: function(e) {
                return e
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = N(v(n.prototype), "getConfig", this).call(this),
                    t = {
                        maskValue: this.maskValue
                    };
                return Object.assign(t, e), t
            }
        }, {
            key: "computeMask",
            value: function(e, t) {
                var n = lce(e);
                return I8(uee(n, this.maskValue), -1)
            }
        }, {
            key: "call",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    n.invokeCallHook(e, t);
                    var r = lce(e),
                        a = I8(uee(r, n.maskValue), -1, !0);
                    return g8(r, h8(a, r.dtype))
                }))
            }
        }]), n
    }(wce);
    Kpe.className = "Masking", Kre(Kpe);
    var Xpe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            if (l(this, n), (r = t.call(this, e)).embeddings = null, r.DEFAULT_EMBEDDINGS_INITIALIZER = "randomUniform", null == e.batchInputShape && null == e.inputShape) {
                var a = null;
                null != e.batchSize && (a = e.batchSize), null == e.inputLength ? r.batchInputShape = [a, null] : r.batchInputShape = [a].concat(Lse(e.inputLength))
            }
            return r.inputDim = e.inputDim, Xse(r.inputDim, "inputDim"), r.outputDim = e.outputDim, Xse(r.outputDim, "outputDim"), r.embeddingsInitializer = sce(e.embeddingsInitializer || r.DEFAULT_EMBEDDINGS_INITIALIZER), r.embeddingsRegularizer = Jhe(e.embeddingsRegularizer), r.activityRegularizer = Jhe(e.activityRegularizer), r.embeddingsConstraint = Vce(e.embeddingsConstraint), r.maskZero = e.maskZero, r.supportsMasking = e.maskZero, r.inputLength = e.inputLength, r
        }
        return p(n, [{
            key: "build",
            value: function(e) {
                this.embeddings = this.addWeight("embeddings", [this.inputDim, this.outputDim], this.dtype, this.embeddingsInitializer, this.embeddingsRegularizer, !0, this.embeddingsConstraint), this.built = !0
            }
        }, {
            key: "warnOnIncompatibleInputShape",
            value: function(e) {}
        }, {
            key: "computeMask",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    return n.maskZero ? (e = lce(e), uee(e, U7(e))) : null
                }))
            }
        }, {
            key: "computeOutputShape",
            value: function(e) {
                if (e = hce(e), null == this.inputLength) return [].concat(T(e), [this.outputDim]);
                var t = Lse(this.inputLength);
                if (t.length !== e.length - 1) throw new Cse('"inputLength" is '.concat(this.inputLength, ", but received ") + "input shape has shape ".concat(e));
                for (var n = 0, r = 0; r < t.length; ++r) {
                    var a = t[r],
                        i = e[r + 1];
                    if (null != a && null != i && a !== i) throw new Cse('"inputLength" is '.concat(this.inputLength, ", but received ") + "input shape has shape ".concat(e));
                    null == a && (t[n] = i), n++
                }
                return [e[0]].concat(T(t), [this.outputDim])
            }
        }, {
            key: "call",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    n.invokeCallHook(e, t);
                    var r = lce(e);
                    "int32" !== r.dtype && (r = wue(r, "int32"));
                    var a = Fue(n.embeddings.read(), X8(r, [r.size]));
                    return X8(a, hce(n.computeOutputShape(r.shape)))
                }))
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = {
                        inputDim: this.inputDim,
                        outputDim: this.outputDim,
                        embeddingsInitializer: oce(this.embeddingsInitializer),
                        embeddingsRegularizer: Xhe(this.embeddingsRegularizer),
                        activityRegularizer: Xhe(this.activityRegularizer),
                        embeddingsConstraint: Wce(this.embeddingsConstraint),
                        maskZero: this.maskZero,
                        inputLength: this.inputLength
                    },
                    t = N(v(n.prototype), "getConfig", this).call(this);
                return Object.assign(e, t), e
            }
        }]), n
    }(wce);
    Xpe.className = "Embedding", Kre(Xpe);
    var Ype = function(e) {
            d(n, e);
            var t = w(n);

            function n(e) {
                var r;
                return l(this, n), (r = t.call(this, e || {})).supportsMasking = !0, r
            }
            return p(n, [{
                key: "mergeFunction",
                value: function(e) {
                    throw new Ase
                }
            }, {
                key: "computeElementwiseOpOutputShape",
                value: function(e, t) {
                    if (null == e || null == t) return null;
                    if (e.length < t.length) return this.computeElementwiseOpOutputShape(t, e);
                    if (0 === t.length) return e;
                    for (var n = e.slice(0, e.length - t.length), r = 0; r < t.length; ++r) {
                        var a = e[e.length - t.length + r],
                            i = t[r];
                        if (null == a || null == i || a < 0 || i < 0) n.push(null);
                        else if (1 === a) n.push(i);
                        else if (1 === i) n.push(a);
                        else {
                            if (a !== i) throw new Cse("Operands could not be broadcast together with shapes " + JSON.stringify(e) + " " + JSON.stringify(t));
                            n.push(a)
                        }
                    }
                    return n
                }
            }, {
                key: "build",
                value: function(e) {
                    if (Array.isArray(e) && !Array.isArray(e[0]) && (e = [hce(e)]), e.length < 2) throw new Cse("A merge layer should be called on an Array of at least 2 inputs." + " Got ".concat(e.length, " input(s)."));
                    var t, n = [],
                        r = O(e);
                    try {
                        for (r.s(); !(t = r.n()).done;) {
                            var a = t.value;
                            null != a && null !== a[0] && n.push(a[0])
                        }
                    } catch (e) {
                        r.e(e)
                    } finally {
                        r.f()
                    }
                    if ((n = jse(n)).length > 1) throw new Cse("Can not merge tensors with different batch sizes. " + "Got tensors with shapes: ".concat(JSON.stringify(e), "."));
                    for (var i = null == e[0] ? null : e[0].slice(1), o = 1; o < e.length; ++o) {
                        var s = null == e[o] ? null : e[o].slice(1);
                        i = this.computeElementwiseOpOutputShape(i, s)
                    }
                    var u = e.map((function(e) {
                        return e.length
                    })); - 1 === e.indexOf(null) && 1 === jse(u).length ? this.reshapeRequired = !1 : this.reshapeRequired = !0
                }
            }, {
                key: "call",
                value: function(e, t) {
                    var n = this;
                    return X5((function() {
                        if (n.reshapeRequired) {
                            var t = [],
                                r = e.map((function(e) {
                                    return e.rank
                                }));
                            if (-1 === r.indexOf(null)) {
                                var a, i = bue(r),
                                    o = O(e);
                                try {
                                    for (o.s(); !(a = o.n()).done;) {
                                        for (var s = a.value, u = s.rank, c = 0; c < i - u; ++c) s = Iue(s, 1);
                                        t.push(s)
                                    }
                                } catch (e) {
                                    o.e(e)
                                } finally {
                                    o.f()
                                }
                                return n.mergeFunction(t)
                            }
                            var l, h = !1,
                                p = O(e);
                            try {
                                for (p.s(); !(l = p.n()).done;) {
                                    var f = l.value,
                                        d = f.rank;
                                    if (null == d) {
                                        var v = f.shape,
                                            m = v[0],
                                            g = v.slice(1).concat([m]),
                                            y = X8(f, [m].concat(gue(v.slice(1))));
                                        y = hne(y, [1, 0]), y = X8(y, g), t.push(y), h = !0
                                    } else if (d > 1) {
                                        var b = xue(1, d).concat([0]);
                                        t.push(hne(f, b)), h = !0
                                    } else t.push(f)
                                }
                            } catch (e) {
                                p.e(e)
                            } finally {
                                p.f()
                            }
                            var x = n.mergeFunction(t),
                                k = x.rank;
                            if (h)
                                if (null == k) {
                                    var w = x.shape,
                                        I = w[w.length - 1],
                                        N = [I].concat(w.slice(0, w.length - 1));
                                    x = X8(hne(X8(x, [-1, I]), [1, 0]), N)
                                } else if (k > 1) {
                                var S = [k - 1].concat(xue(0, k - 1));
                                x = hne(x, S)
                            }
                            return x
                        }
                        return n.mergeFunction(e)
                    }))
                }
            }, {
                key: "computeOutputShape",
                value: function(e) {
                    var t;
                    t = null == e[0] ? null : e[0].slice(1);
                    for (var n = 1; n < e.length; ++n) {
                        var r = null == e[n] ? null : e[n].slice(1);
                        t = this.computeElementwiseOpOutputShape(t, r)
                    }
                    var a, i = [],
                        o = O(e);
                    try {
                        for (o.s(); !(a = o.n()).done;) {
                            var s = a.value;
                            null != s && null !== s[0] && i.push(s[0])
                        }
                    } catch (e) {
                        o.e(e)
                    } finally {
                        o.f()
                    }
                    return t = 1 === (i = jse(i)).length ? i.concat(t) : [null].concat(t)
                }
            }, {
                key: "computeMask",
                value: function(e, t) {
                    return X5((function() {
                        if (null == t) return null;
                        if (!Array.isArray(t)) throw new Cse("`mask` should be an Array");
                        if (!Array.isArray(e)) throw new Cse("`inputs` should be an Array");
                        if (t.length !== e.length) throw new Cse("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths " + "(".concat(e.length, " vs ").concat(t.length, ")"));
                        if (t.every((function(e) {
                                return null == e
                            }))) return null;
                        for (var n = (t = t.map((function(e) {
                                return null == e ? e : f9(e, 0)
                            })))[0], r = 1; r < t.length - 1; ++r) n = U9(n, t[r]);
                        return n
                    }))
                }
            }]), n
        }(wce),
        Jpe = function(e) {
            d(n, e);
            var t = w(n);

            function n(e) {
                return l(this, n), t.call(this, e)
            }
            return p(n, [{
                key: "mergeFunction",
                value: function(e) {
                    return X5((function() {
                        for (var t = e[0].clone(), n = 1; n < e.length; ++n) t = d8(t, e[n]);
                        return t
                    }))
                }
            }]), n
        }(Ype);
    Jpe.className = "Add", Kre(Jpe);
    var Zpe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            return l(this, n), t.call(this, e)
        }
        return p(n, [{
            key: "mergeFunction",
            value: function(e) {
                return X5((function() {
                    for (var t = e[0].clone(), n = 1; n < e.length; ++n) t = g8(t, e[n]);
                    return t
                }))
            }
        }]), n
    }(Ype);
    Zpe.className = "Multiply", Kre(Zpe);
    var Qpe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            return l(this, n), t.call(this, e)
        }
        return p(n, [{
            key: "mergeFunction",
            value: function(e) {
                return X5((function() {
                    for (var t = e[0].clone(), n = 1; n < e.length; ++n) t = d8(t, e[n]);
                    return g8(1 / e.length, t)
                }))
            }
        }]), n
    }(Ype);
    Qpe.className = "Average", Kre(Qpe);
    var $pe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            return l(this, n), t.call(this, e)
        }
        return p(n, [{
            key: "mergeFunction",
            value: function(e) {
                return X5((function() {
                    for (var t = e[0], n = 1; n < e.length; ++n) t = Z9(t, e[n]);
                    return t
                }))
            }
        }]), n
    }(Ype);
    $pe.className = "Maximum", Kre($pe);
    var efe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            return l(this, n), t.call(this, e)
        }
        return p(n, [{
            key: "mergeFunction",
            value: function(e) {
                return X5((function() {
                    for (var t = e[0], n = 1; n < e.length; ++n) t = nee(t, e[n]);
                    return t
                }))
            }
        }]), n
    }(Ype);
    efe.className = "Minimum", Kre(efe);
    var tfe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            return l(this, n), (r = t.call(this, e)).DEFAULT_AXIS = -1, null == e && (e = {}), r.axis = null == e.axis ? r.DEFAULT_AXIS : e.axis, r.supportsMasking = !0, r.reshapeRequired = !1, r
        }
        return p(n, [{
            key: "build",
            value: function(e) {
                if (!Array.isArray(e) || !Array.isArray(e[0]) || 1 === e.length) throw new Cse("A `Concatenate` layer should be called on a list of at least 2 inputs");
                var t, n = !0,
                    r = O(e);
                try {
                    for (r.s(); !(t = r.n()).done;) {
                        if (null != t.value) {
                            n = !1;
                            break
                        }
                    }
                } catch (e) {
                    r.e(e)
                } finally {
                    r.f()
                }
                if (!n) {
                    for (var a = [], i = 0; i < e.length; ++i) {
                        var o = e[i].slice();
                        o.splice(this.axis, 1);
                        var s, u = !1,
                            c = O(a);
                        try {
                            for (c.s(); !(s = c.n()).done;) {
                                if (P$(s.value, o)) {
                                    u = !0;
                                    break
                                }
                            }
                        } catch (e) {
                            c.e(e)
                        } finally {
                            c.f()
                        }
                        u || a.push(o)
                    }
                    if (a.length > 1) throw new Cse("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: " + JSON.stringify(e))
                }
            }
        }, {
            key: "mergeFunction",
            value: function(e) {
                var t = this;
                return X5((function() {
                    return Cue(e, t.axis)
                }))
            }
        }, {
            key: "computeOutputShape",
            value: function(e) {
                if (!Array.isArray(e) || !Array.isArray(e[0])) throw new Cse("A `Concatenate` layer should be called on a list of inputs.");
                var t, n = e,
                    r = n[0].slice(),
                    a = this.axis < 0 ? r.length + this.axis : this.axis,
                    i = O(n.slice(1));
                try {
                    for (i.s(); !(t = i.n()).done;) {
                        var o = t.value;
                        if (null == r[a] || null == o[a]) {
                            r[a] = null;
                            break
                        }
                        r[a] += o[a]
                    }
                } catch (e) {
                    i.e(e)
                } finally {
                    i.f()
                }
                return r
            }
        }, {
            key: "computeMask",
            value: function(e, t) {
                var n = this;
                if (null == t) return null;
                if (!Array.isArray(t)) throw new Cse("`mask` should be an array for Concatenate");
                if (!Array.isArray(e)) throw new Cse("`inputs` should be an array for Concatenate");
                if (t.length !== e.length) throw new Cse("Mismatch in the length of mask (".concat(t.length, ") ") + "and the legnth of inputs (".concat(e.length, ")"));
                return X5((function() {
                    var r = !0;
                    if (t.forEach((function(e) {
                            null == e || (r = !1)
                        })), r) return null;
                    for (var a = [], i = 0; i < e.length; ++i) null == t[i] ? a.push(h8(lee(e[i]), "bool")) : t[i].rank < e[i].rank ? a.push(f9(t[i], -1)) : a.push(t[i]);
                    var o = Z8(a, n.axis);
                    return w8(o, -1, !1)
                }))
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = {
                        axis: this.axis
                    },
                    t = N(v(n.prototype), "getConfig", this).call(this);
                return Object.assign(e, t), e
            }
        }]), n
    }(Ype);

    function nfe(e, t) {
        for (; e < 0;) e += t;
        return e
    }
    tfe.className = "Concatenate", Kre(tfe);
    var rfe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            return l(this, n), (r = t.call(this, e)).axes = e.axes, r.normalize = null != e.normalize && e.normalize, r.supportsMasking = !0, r.reshapeRequired = !1, r
        }
        return p(n, [{
            key: "build",
            value: function(e) {
                F$(Array.isArray(e) && 2 === e.length && Array.isArray(e[0]) && Array.isArray(e[1]), (function() {
                    return "A `Dot` layer should be called on a list of exactly 2 inputs."
                }));
                var t = e[0],
                    n = e[1];
                if (t.length > 3 || n.length > 3) throw new Ase("Dot layer does not support tensors of 4D or higher rank yet.");
                var r = this.interpretAxes(t, n);
                if (t[r[0]] !== n[r[1]]) throw new Cse("Dimension incompatibility: " + "".concat(t[r[0]], " !== ").concat(n[r[1]]))
            }
        }, {
            key: "mergeFunction",
            value: function(e) {
                if (2 !== e.length) throw new Cse("A `Dot` layer must be called on exactly 2 inputs, " + "but received ".concat(e.length, " input(s)."));
                var t, n = e[0],
                    r = e[1];
                return t = Array.isArray(this.axes) ? this.axes.map((function(t, n) {
                        return nfe(t, e[n].shape.length)
                    })) : [nfe(this.axes, n.shape.length), nfe(this.axes, r.shape.length)], this.normalize && (n = ale(n, t[0]), r = ale(r, t[1])),
                    function(e, t, n) {
                        if (e.shape.length > 3 || t.shape.length > 3) throw new Ase("batchDot is not implemented for tensors of 4D or higher rank yet");
                        if (F$(e.shape.length >= 2, (function() {
                                return "batchDot requires the rank of x to be >= 2, " + "but got ".concat(e.shape.length)
                            })), F$(e.shape.length >= 2, (function() {
                                return "batchDot requires the rank of y to be >= 2, " + "but got ".concat(t.shape.length)
                            })), "number" == typeof n && (n = [n, n]), "complex64" === e.dtype || "complex64" === t.dtype) throw new Ase("batchDot is not implemented for complex64-type Tensors yet.");
                        var r = e.shape.length,
                            a = t.shape.length;
                        null == n && (n = [r - 1, a - 2]);
                        var i = n;
                        return X5((function() {
                            var n, o;
                            if (r > a) {
                                n = r - a;
                                for (var s = [], u = 0; u < n; ++u) s.push(1);
                                t = X8(t, t.shape.concat(s))
                            } else if (a > r) {
                                n = a - r;
                                for (var c = [], l = 0; l < n; ++l) c.push(1);
                                e = X8(e, e.shape.concat(c))
                            } else n = 0;
                            if (2 === e.shape.length && 2 === t.shape.length) o = i[0] === i[1] ? u9(g8(e, t), i[0]) : u9(g8(hne(e, [1, 0]), t), i[1]);
                            else {
                                var h = i[0] !== e.shape.length - 1,
                                    p = i[1] === t.shape.length - 1;
                                o = Q8(e, t, h, p)
                            }
                            if (n > 0) {
                                for (var f, d = [], v = f = r > a ? r + a - 3 : r - 1; v < f + n; ++v) d.push(v);
                                o = zte(o, d)
                            }
                            return 1 === o.shape.length && (o = f9(o, 1)), o
                        }))
                    }(n, r, t)
            }
        }, {
            key: "interpretAxes",
            value: function(e, t) {
                return Array.isArray(this.axes) ? this.axes : [nfe(this.axes, e.length), nfe(this.axes, t.length)]
            }
        }, {
            key: "computeOutputShape",
            value: function(e) {
                F$(Array.isArray(e) && 2 === e.length && Array.isArray(e[0]) && Array.isArray(e[1]), (function() {
                    return "A `Dot` layer should be called on a list of exactly 2 inputs."
                }));
                var t = e[0].slice(),
                    n = e[1].slice();
                if (t.length > 3 || n.length > 3) throw new Ase("Dot layer does not support tensors of 4D or higher rank yet.");
                var r = this.interpretAxes(t, n);
                t.splice(r[0], 1), n.splice(r[1], 1), n.splice(0, 1);
                var a = t.concat(n);
                return 1 === a.length && a.push(1), a
            }
        }, {
            key: "computeMask",
            value: function(e, t) {
                return null
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = {
                        axes: this.axes,
                        normalize: this.normalize
                    },
                    t = N(v(n.prototype), "getConfig", this).call(this);
                return Object.assign(e, t), e
            }
        }]), n
    }(Ype);
    rfe.className = "Dot", Kre(rfe);
    var afe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            return l(this, n), (r = t.call(this, e)).supportsMasking = !0, r.stddev = e.stddev, r
        }
        return p(n, [{
            key: "computeOutputShape",
            value: function(e) {
                return e
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = N(v(n.prototype), "getConfig", this).call(this),
                    t = {
                        stddev: this.stddev
                    };
                return Object.assign(t, e), t
            }
        }, {
            key: "call",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    n.invokeCallHook(e, t);
                    var r = lce(e);
                    return Bue((function() {
                        return d8(_ue(r.shape, 0, n.stddev), r)
                    }), (function() {
                        return r
                    }), t.training || !1)
                }))
            }
        }]), n
    }(wce);
    afe.className = "GaussianNoise", Kre(afe);
    var ife = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            return l(this, n), (r = t.call(this, e)).supportsMasking = !0, r.rate = e.rate, r
        }
        return p(n, [{
            key: "computeOutputShape",
            value: function(e) {
                return e
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = N(v(n.prototype), "getConfig", this).call(this),
                    t = {
                        rate: this.rate
                    };
                return Object.assign(t, e), t
            }
        }, {
            key: "call",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    n.invokeCallHook(e, t);
                    var r = lce(e);
                    if (n.rate > 0 && n.rate < 1) {
                        return Bue((function() {
                            var e = Math.sqrt(n.rate / (1 - n.rate));
                            return g8(r, _ue(r.shape, 1, e))
                        }), (function() {
                            return r
                        }), t.training || !1)
                    }
                    return r
                }))
            }
        }]), n
    }(wce);
    ife.className = "GaussianDropout", Kre(ife);
    var ofe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            return l(this, n), (r = t.call(this, e)).supportsMasking = !0, r.rate = e.rate, r.noiseShape = e.noiseShape, r
        }
        return p(n, [{
            key: "_getNoiseShape",
            value: function(e) {
                return this.noiseShape || lce(e).shape
            }
        }, {
            key: "computeOutputShape",
            value: function(e) {
                return e
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = N(v(n.prototype), "getConfig", this).call(this),
                    t = {
                        rate: this.rate
                    };
                return Object.assign(t, e), t
            }
        }, {
            key: "call",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    if (n.rate < 1 && n.rate > 0) {
                        var r = n._getNoiseShape(e);
                        return Bue((function() {
                            var t = lce(e),
                                a = -1.7580993408473766,
                                i = x9(ite(r), n.rate);
                            i = wue(i, "float32");
                            var o = Math.pow((1 - n.rate) * (1 + n.rate * Math.pow(a, 2)), -.5),
                                s = -o * a * n.rate,
                                u = d8(g8(t, i), g8(d8(i, -1), a));
                            return d8(g8(u, o), s)
                        }), (function() {
                            return lce(e)
                        }), t.training || !1)
                    }
                    return e
                }))
            }
        }]), n
    }(wce);

    function sfe(e, t, n, r, a) {
        var i, o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : .001;
        if (2 === e.rank) i = i7(e, t, n, r, a, o);
        else if (3 === e.rank) i = o7(e, t, n, r, a, o);
        else {
            if (4 !== e.rank) throw new Ase("batchNormalization is not implemented for array of rank ".concat(e.rank, " ") + "yet");
            i = s7(e, t, n, r, a, o)
        }
        return i
    }

    function ufe(e, t, n, r) {
        var a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : .001;
        return X5((function() {
            var i = iee(e, r),
                o = i.mean,
                s = i.variance;
            return [sfe(e, o, s, n, t, a), o, s]
        }))
    }

    function cfe(e, t, n, r) {
        var a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : .001;
        return X5((function() {
            var i, o = iee(e, r),
                s = o.mean,
                u = o.variance,
                c = [],
                l = O(xue(0, e.rank));
            try {
                for (l.s(); !(i = l.n()).done;) {
                    var h = i.value; - 1 !== r.indexOf(h) ? c.push(1) : c.push(e.shape[h])
                }
            } catch (e) {
                l.e(e)
            } finally {
                l.f()
            }
            var p = X8(s, c),
                f = X8(u, c),
                d = null == t ? null : X8(t, c),
                v = null == n ? null : X8(n, c);
            return [sfe(e, p, f, v, d, a), s, u]
        }))
    }
    ofe.className = "AlphaDropout", Kre(ofe);
    var lfe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            return l(this, n), null == e && (e = {}), (r = t.call(this, e)).supportsMasking = !0, r.axis = null == e.axis ? -1 : e.axis, r.momentum = null == e.momentum ? .99 : e.momentum, r.epsilon = null == e.epsilon ? .001 : e.epsilon, r.center = null == e.center || e.center, r.scale = null == e.scale || e.scale, r.betaInitializer = sce(e.betaInitializer || "zeros"), r.gammaInitializer = sce(e.gammaInitializer || "ones"), r.movingMeanInitializer = sce(e.movingMeanInitializer || "zeros"), r.movingVarianceInitializer = sce(e.movingVarianceInitializer || "ones"), r.betaConstraint = Vce(e.betaConstraint), r.gammaConstraint = Vce(e.gammaConstraint), r.betaRegularizer = Jhe(e.betaRegularizer), r.gammaRegularizer = Jhe(e.gammaRegularizer), r
        }
        return p(n, [{
            key: "build",
            value: function(e) {
                e = hce(e);
                var t = this.axis >= 0 ? this.axis : this.axis + e.length,
                    n = e[t];
                if (null == n) throw new Cse("Axis ".concat(t, " of input tensor should have a defined dimension but ") + "the layer received an input with shape " + "".concat(JSON.stringify(e), "."));
                this.inputSpec = [new gce({
                    ndim: e.length,
                    axes: f({}, t, n)
                })];
                var r = [n];
                this.scale && (this.gamma = this.addWeight("gamma", r, null, this.gammaInitializer, this.gammaRegularizer, !0, this.gammaConstraint)), this.center && (this.beta = this.addWeight("beta", r, null, this.betaInitializer, this.betaRegularizer, !0, this.betaConstraint)), this.movingMean = this.addWeight("moving_mean", r, null, this.movingMeanInitializer, null, !1), this.movingVariance = this.addWeight("moving_variance", r, null, this.movingVarianceInitializer, null, !1), this.built = !0
            }
        }, {
            key: "call",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    var r = null != t.training && t.training,
                        a = lce(e),
                        i = a.shape,
                        o = i.length,
                        s = xue(0, o),
                        u = n.axis >= 0 ? n.axis : n.axis + o;
                    s.splice(u, 1);
                    var c = Ose(1, o);
                    c[u] = i[u];
                    var l = s.slice();
                    l.sort();
                    var h = !P$(l, xue(0, o).slice(0, o - 1));
                    if (!r) return function() {
                        if (h) {
                            var e = X8(n.movingMean.read(), c),
                                t = X8(n.movingVariance.read(), c),
                                r = n.center ? X8(n.beta.read(), c) : null,
                                i = n.scale ? X8(n.gamma.read(), c) : null;
                            return sfe(a, e, t, r, i, n.epsilon)
                        }
                        return sfe(a, n.movingMean.read(), n.movingVariance.read(), null == n.beta ? null : n.beta.read(), null == n.gamma ? null : n.gamma.read(), n.epsilon)
                    }();
                    var p = function(e, t, n, r) {
                            var a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : .001;
                            return P$(r.slice().sort(), xue(0, e.rank - 1)) ? ufe(e, t, n, r, a) : cfe(e, t, n, r, a)
                        }(a, n.gamma.read(), n.beta.read(), s, n.epsilon),
                        f = S(p, 3),
                        d = f[0],
                        v = f[1],
                        m = f[2],
                        g = function(e, t, n) {
                            X5((function() {
                                var r = 1 - n,
                                    a = e.read(),
                                    i = g8(P9(a, t), r);
                                e.write(P9(a, i))
                            }))
                        };
                    return g(n.movingMean, v, n.momentum), g(n.movingVariance, m, n.momentum), d
                }))
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = {
                        axis: this.axis,
                        momentum: this.momentum,
                        epsilon: this.epsilon,
                        center: this.center,
                        scale: this.scale,
                        betaInitializer: oce(this.betaInitializer),
                        gammaInitializer: oce(this.gammaInitializer),
                        movingMeanInitializer: oce(this.movingMeanInitializer),
                        movingVarianceInitializer: oce(this.movingVarianceInitializer),
                        betaRegularizer: Xhe(this.betaRegularizer),
                        gammaRegularizer: Xhe(this.gammaRegularizer),
                        betaConstraint: Wce(this.betaConstraint),
                        gammaConstraint: Wce(this.gammaConstraint)
                    },
                    t = N(v(n.prototype), "getConfig", this).call(this);
                return Object.assign(e, t), e
            }
        }]), n
    }(wce);
    lfe.className = "BatchNormalization", Kre(lfe);
    var hfe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            if (l(this, n), null == e && (e = {}), (r = t.call(this, e)).axis = null == e.axis ? -1 : e.axis, "number" == typeof r.axis) {
                if (!Number.isInteger(r.axis)) throw new Error("Expected axis to be an integer, but received ".concat(r.axis))
            } else {
                if (!Array.isArray(r.axis)) throw new Error("Expected axis to be an integer or an array of integers, " + "but received ".concat(JSON.stringify(r.axis)));
                var a, i = O(r.axis);
                try {
                    for (i.s(); !(a = i.n()).done;) {
                        var o = a.value;
                        if (!Number.isInteger(o)) throw new Error("Expected axis to be an array of integers, " + "but received ".concat(JSON.stringify(r.axis)))
                    }
                } catch (e) {
                    i.e(e)
                } finally {
                    i.f()
                }
            }
            return r.epsilon = null == e.epsilon ? .001 : e.epsilon, r.center = null == e.center || e.center, r.scale = null == e.scale || e.scale, r.betaInitializer = sce(e.betaInitializer || "zeros"), r.gammaInitializer = sce(e.gammaInitializer || "ones"), r.betaRegularizer = Jhe(e.betaRegularizer), r.gammaRegularizer = Jhe(e.gammaRegularizer), r.supportsMasking = !0, r
        }
        return p(n, [{
            key: "build",
            value: function(e) {
                var t = (e = hce(e)).length;
                "number" == typeof this.axis && (this.axis = [this.axis]);
                for (var n = 0; n < this.axis.length; ++n) this.axis[n] < 0 && (this.axis[n] += t);
                var r, a = O(this.axis);
                try {
                    for (a.s(); !(r = a.n()).done;) {
                        var i = r.value;
                        if (i < 0 || i >= t) throw new Error("Invalid axis: ".concat(i))
                    }
                } catch (e) {
                    a.e(e)
                } finally {
                    a.f()
                }
                if (this.axis.length !== jse(this.axis).length) throw new Error("Found duplicate axes in: ".concat(this.axis));
                var o = this.axis.map((function(t) {
                    return e[t]
                }));
                this.scale ? this.gamma = this.addWeight("gamma", o, "float32", this.gammaInitializer, this.gammaRegularizer, true) : this.gamma = null, this.center ? this.beta = this.addWeight("beta", o, "float32", this.betaInitializer, this.betaRegularizer, true) : this.beta = null, this.built = !0
            }
        }, {
            key: "call",
            value: function(e, t) {
                var n = this,
                    r = lce(e),
                    a = r.shape,
                    i = a.length;
                return X5((function() {
                    var e, t = iee(r, n.axis, !0),
                        o = t.mean,
                        s = t.variance,
                        u = Ose(1, i),
                        c = O(n.axis);
                    try {
                        for (c.s(); !(e = c.n()).done;) {
                            var l = e.value;
                            u[l] = a[l]
                        }
                    } catch (e) {
                        c.e(e)
                    } finally {
                        c.f()
                    }
                    for (var h = function(e) {
                            return null != e && e.shape.length !== i ? X8(e, u) : e
                        }, p = n.scale ? h(n.gamma.read()) : null, f = n.center ? h(n.beta.read()) : null, d = [], v = [], m = 0; m < i; ++m) - 1 !== n.axis.indexOf(m) ? (d.push(a[m]), v.push(1)) : (d.push(1), v.push(a[m]));
                    return o = v9(o, d), s = v9(s, d), null != p && (p = v9(p, v)), null != f && (f = v9(f, v)), sfe(r, o, s, f, p, n.epsilon)
                }))
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = {
                        axis: this.axis,
                        epsilon: this.epsilon,
                        center: this.center,
                        scale: this.scale,
                        betaInitializer: oce(this.betaInitializer),
                        gammaInitializer: oce(this.gammaInitializer),
                        betaRegularizer: Xhe(this.betaRegularizer),
                        gammaRegularizer: Xhe(this.gammaRegularizer)
                    },
                    t = N(v(n.prototype), "getConfig", this).call(this);
                return Object.assign(e, t), e
            }
        }]), n
    }(wce);
    hfe.className = "LayerNormalization", Kre(hfe);
    var pfe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            if (l(this, n), null == e && (e = {}), (r = t.call(this, e)).dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, null == e.padding) r.padding = [
                [1, 1],
                [1, 1]
            ];
            else if ("number" == typeof e.padding) r.padding = [
                [e.padding, e.padding],
                [e.padding, e.padding]
            ];
            else {
                if (e.padding = e.padding, 2 !== e.padding.length) throw new Cse("ZeroPadding2D expects padding to be a length-2 array, but " + "received a length-".concat(e.padding.length, " array."));
                var a, i;
                if ("number" == typeof e.padding[0]) a = [e.padding[0], e.padding[0]], i = [e.padding[1], e.padding[1]];
                else {
                    if (e.padding = e.padding, 2 !== e.padding[0].length) throw new Cse("ZeroPadding2D expects height padding to be a length-2 array, " + "but received a length-".concat(e.padding[0].length, " array."));
                    if (a = e.padding[0], 2 !== e.padding[1].length) throw new Cse("ZeroPadding2D expects width padding to be a length-2 array, " + "but received a length-".concat(e.padding[1].length, " array."));
                    i = e.padding[1]
                }
                r.padding = [a, i]
            }
            return r.inputSpec = [new gce({
                ndim: 4
            })], r
        }
        return p(n, [{
            key: "computeOutputShape",
            value: function(e) {
                var t, n;
                return e = hce(e), "channelsFirst" === this.dataFormat ? (t = null != e[2] && e[2] >= 0 ? e[2] + this.padding[0][0] + this.padding[0][1] : null, n = null != e[3] && e[3] >= 0 ? e[3] + this.padding[1][0] + this.padding[1][1] : null, [e[0], e[1], t, n]) : (t = null != e[1] && e[1] >= 0 ? e[1] + this.padding[0][0] + this.padding[0][1] : null, n = null != e[2] && e[2] >= 0 ? e[2] + this.padding[1][0] + this.padding[1][1] : null, [e[0], t, n, e[3]])
            }
        }, {
            key: "call",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    return t = lce(e), r = n.padding, a = n.dataFormat, X5((function() {
                        if (4 !== t.rank) throw new Cse("temporalPadding expects input tensor to be 4-D, but received a " + "".concat(t.rank, "-D tensor."));
                        if (null == r && (r = [
                                [1, 1],
                                [1, 1]
                            ]), 2 !== r.length || 2 !== r[0].length || 2 !== r[1].length) throw new Cse("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");
                        if (null == a && (a = "channelsLast"), "channelsLast" !== a && "channelsFirst" !== a) throw new Cse("Unknown data format: ".concat(a, ". ") + "Supported data formats are 'channelsLast' and 'channelsFirst.");
                        var e;
                        return e = "channelsFirst" === a ? [
                            [0, 0],
                            [0, 0], r[0], r[1]
                        ] : [
                            [0, 0], r[0], r[1],
                            [0, 0]
                        ], pee(t, e)
                    }));
                    var t, r, a
                }))
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = {
                        padding: this.padding,
                        dataFormat: this.dataFormat
                    },
                    t = N(v(n.prototype), "getConfig", this).call(this);
                return Object.assign(e, t), e
            }
        }]), n
    }(wce);

    function ffe(e, t, n, r, a, i) {
        return X5((function() {
            var o;
            sue(a), cue(i), uue(r), null == n && (n = [1, 1]), null == r && (r = "valid"), null == a && (a = "channelsLast"), null == i && (i = "max"), e = ope(e, a);
            var s = "same" === r ? "same" : "valid";
            return o = "max" === i ? X9(e, t, n, s) : Y8(e, t, n, s), "channelsFirst" === a && (o = hne(o, [0, 3, 1, 2])), o
        }))
    }

    function dfe(e, t, n, r, a, i) {
        return X5((function() {
            var o;
            sue(a), cue(i), uue(r), null == n && (n = [1, 1, 1]), null == r && (r = "valid"), null == a && (a = "channelsLast"), null == i && (i = "max"), e = spe(e, a);
            var s = "same" === r ? "same" : "valid";
            return o = "max" === i ? Y9(e, t, n, s) : J8(e, t, n, s), "channelsFirst" === a && (o = hne(o, [0, 4, 1, 2, 3])), o
        }))
    }
    pfe.className = "ZeroPadding2D", Kre(pfe);
    var vfe = function(e) {
            d(n, e);
            var t = w(n);

            function n(e) {
                var r;
                if (l(this, n), null == e.poolSize && (e.poolSize = 2), r = t.call(this, e), "number" == typeof e.poolSize) r.poolSize = [e.poolSize];
                else {
                    if (!Array.isArray(e.poolSize) || 1 !== e.poolSize.length || "number" != typeof e.poolSize[0]) throw new Cse("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received " + "".concat(JSON.stringify(e.poolSize)));
                    r.poolSize = e.poolSize
                }
                if (Xse(r.poolSize, "poolSize"), null == e.strides) r.strides = r.poolSize;
                else if ("number" == typeof e.strides) r.strides = [e.strides];
                else {
                    if (!Array.isArray(e.strides) || 1 !== e.strides.length || "number" != typeof e.strides[0]) throw new Cse("strides for 1D convolutional layer must be a number or an Array of a single number, but received " + "".concat(JSON.stringify(e.strides)));
                    r.strides = e.strides
                }
                return Xse(r.strides, "strides"), r.padding = null == e.padding ? "valid" : e.padding, uue(r.padding), r.inputSpec = [new gce({
                    ndim: 3
                })], r
            }
            return p(n, [{
                key: "computeOutputShape",
                value: function(e) {
                    var t = ape((e = hce(e))[1], this.poolSize[0], this.padding, this.strides[0]);
                    return [e[0], t, e[2]]
                }
            }, {
                key: "call",
                value: function(e, t) {
                    var n = this;
                    return X5((function() {
                        n.invokeCallHook(e, t), e = Iue(lce(e), 2);
                        var r = n.poolingFunction(lce(e), [n.poolSize[0], 1], [n.strides[0], 1], n.padding, "channelsLast");
                        return zte(r, [2])
                    }))
                }
            }, {
                key: "getConfig",
                value: function() {
                    var e = {
                            poolSize: this.poolSize,
                            padding: this.padding,
                            strides: this.strides
                        },
                        t = N(v(n.prototype), "getConfig", this).call(this);
                    return Object.assign(e, t), e
                }
            }]), n
        }(wce),
        mfe = function(e) {
            d(n, e);
            var t = w(n);

            function n(e) {
                return l(this, n), t.call(this, e)
            }
            return p(n, [{
                key: "poolingFunction",
                value: function(e, t, n, r, a) {
                    return sue(a), uue(r), ffe(e, t, n, r, a, "max")
                }
            }]), n
        }(vfe);
    mfe.className = "MaxPooling1D", Kre(mfe);
    var gfe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            return l(this, n), t.call(this, e)
        }
        return p(n, [{
            key: "poolingFunction",
            value: function(e, t, n, r, a) {
                return sue(a), uue(r), ffe(e, t, n, r, a, "avg")
            }
        }]), n
    }(vfe);
    gfe.className = "AveragePooling1D", Kre(gfe);
    var yfe = function(e) {
            d(n, e);
            var t = w(n);

            function n(e) {
                var r;
                if (l(this, n), null == e.poolSize && (e.poolSize = [2, 2]), (r = t.call(this, e)).poolSize = Array.isArray(e.poolSize) ? e.poolSize : [e.poolSize, e.poolSize], null == e.strides) r.strides = r.poolSize;
                else if (Array.isArray(e.strides)) {
                    if (2 !== e.strides.length) throw new Cse("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length " + "".concat(e.strides.length, "."));
                    r.strides = e.strides
                } else r.strides = [e.strides, e.strides];
                return Xse(r.poolSize, "poolSize"), Xse(r.strides, "strides"), r.padding = null == e.padding ? "valid" : e.padding, r.dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, sue(r.dataFormat), uue(r.padding), r.inputSpec = [new gce({
                    ndim: 4
                })], r
            }
            return p(n, [{
                key: "computeOutputShape",
                value: function(e) {
                    e = hce(e);
                    var t = "channelsFirst" === this.dataFormat ? e[2] : e[1],
                        n = "channelsFirst" === this.dataFormat ? e[3] : e[2];
                    return t = ape(t, this.poolSize[0], this.padding, this.strides[0]), n = ape(n, this.poolSize[1], this.padding, this.strides[1]), "channelsFirst" === this.dataFormat ? [e[0], e[1], t, n] : [e[0], t, n, e[3]]
                }
            }, {
                key: "call",
                value: function(e, t) {
                    var n = this;
                    return X5((function() {
                        return n.invokeCallHook(e, t), n.poolingFunction(lce(e), n.poolSize, n.strides, n.padding, n.dataFormat)
                    }))
                }
            }, {
                key: "getConfig",
                value: function() {
                    var e = {
                            poolSize: this.poolSize,
                            padding: this.padding,
                            strides: this.strides,
                            dataFormat: this.dataFormat
                        },
                        t = N(v(n.prototype), "getConfig", this).call(this);
                    return Object.assign(e, t), e
                }
            }]), n
        }(wce),
        bfe = function(e) {
            d(n, e);
            var t = w(n);

            function n(e) {
                return l(this, n), t.call(this, e)
            }
            return p(n, [{
                key: "poolingFunction",
                value: function(e, t, n, r, a) {
                    return sue(a), uue(r), ffe(e, t, n, r, a, "max")
                }
            }]), n
        }(yfe);
    bfe.className = "MaxPooling2D", Kre(bfe);
    var xfe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            return l(this, n), t.call(this, e)
        }
        return p(n, [{
            key: "poolingFunction",
            value: function(e, t, n, r, a) {
                return sue(a), uue(r), ffe(e, t, n, r, a, "avg")
            }
        }]), n
    }(yfe);
    xfe.className = "AveragePooling2D", Kre(xfe);
    var kfe = function(e) {
            d(n, e);
            var t = w(n);

            function n(e) {
                var r;
                if (l(this, n), null == e.poolSize && (e.poolSize = [2, 2, 2]), (r = t.call(this, e)).poolSize = Array.isArray(e.poolSize) ? e.poolSize : [e.poolSize, e.poolSize, e.poolSize], null == e.strides) r.strides = r.poolSize;
                else if (Array.isArray(e.strides)) {
                    if (3 !== e.strides.length) throw new Cse("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length " + "".concat(e.strides.length, "."));
                    r.strides = e.strides
                } else r.strides = [e.strides, e.strides, e.strides];
                return Xse(r.poolSize, "poolSize"), Xse(r.strides, "strides"), r.padding = null == e.padding ? "valid" : e.padding, r.dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, sue(r.dataFormat), uue(r.padding), r.inputSpec = [new gce({
                    ndim: 5
                })], r
            }
            return p(n, [{
                key: "computeOutputShape",
                value: function(e) {
                    e = hce(e);
                    var t = "channelsFirst" === this.dataFormat ? e[2] : e[1],
                        n = "channelsFirst" === this.dataFormat ? e[3] : e[2],
                        r = "channelsFirst" === this.dataFormat ? e[4] : e[3];
                    return t = ape(t, this.poolSize[0], this.padding, this.strides[0]), n = ape(n, this.poolSize[1], this.padding, this.strides[1]), r = ape(r, this.poolSize[2], this.padding, this.strides[2]), "channelsFirst" === this.dataFormat ? [e[0], e[1], t, n, r] : [e[0], t, n, r, e[4]]
                }
            }, {
                key: "call",
                value: function(e, t) {
                    var n = this;
                    return X5((function() {
                        return n.invokeCallHook(e, t), n.poolingFunction(lce(e), n.poolSize, n.strides, n.padding, n.dataFormat)
                    }))
                }
            }, {
                key: "getConfig",
                value: function() {
                    var e = {
                            poolSize: this.poolSize,
                            padding: this.padding,
                            strides: this.strides,
                            dataFormat: this.dataFormat
                        },
                        t = N(v(n.prototype), "getConfig", this).call(this);
                    return Object.assign(e, t), e
                }
            }]), n
        }(wce),
        wfe = function(e) {
            d(n, e);
            var t = w(n);

            function n(e) {
                return l(this, n), t.call(this, e)
            }
            return p(n, [{
                key: "poolingFunction",
                value: function(e, t, n, r, a) {
                    return sue(a), uue(r), dfe(e, t, n, r, a, "max")
                }
            }]), n
        }(kfe);
    wfe.className = "MaxPooling3D", Kre(wfe);
    var Ife = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            return l(this, n), t.call(this, e)
        }
        return p(n, [{
            key: "poolingFunction",
            value: function(e, t, n, r, a) {
                return sue(a), uue(r), dfe(e, t, n, r, a, "avg")
            }
        }]), n
    }(kfe);
    Ife.className = "AveragePooling3D", Kre(Ife);
    var Nfe = function(e) {
            d(n, e);
            var t = w(n);

            function n(e) {
                var r;
                return l(this, n), (r = t.call(this, e)).inputSpec = [new gce({
                    ndim: 3
                })], r
            }
            return p(n, [{
                key: "computeOutputShape",
                value: function(e) {
                    return [e[0], e[2]]
                }
            }, {
                key: "call",
                value: function(e, t) {
                    throw new Ase
                }
            }]), n
        }(wce),
        Sfe = function(e) {
            d(n, e);
            var t = w(n);

            function n(e) {
                return l(this, n), t.call(this, e || {})
            }
            return p(n, [{
                key: "call",
                value: function(e, t) {
                    return X5((function() {
                        var t = lce(e);
                        return Q9(t, 1)
                    }))
                }
            }]), n
        }(Nfe);
    Sfe.className = "GlobalAveragePooling1D", Kre(Sfe);
    var Tfe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            return l(this, n), t.call(this, e || {})
        }
        return p(n, [{
            key: "call",
            value: function(e, t) {
                return X5((function() {
                    var t = lce(e);
                    return n9(t, 1)
                }))
            }
        }]), n
    }(Nfe);
    Tfe.className = "GlobalMaxPooling1D", Kre(Tfe);
    var Efe = function(e) {
            d(n, e);
            var t = w(n);

            function n(e) {
                var r;
                return l(this, n), (r = t.call(this, e)).dataFormat = null == e.dataFormat ? "channelsLast" : e.dataFormat, sue(r.dataFormat), r.inputSpec = [new gce({
                    ndim: 4
                })], r
            }
            return p(n, [{
                key: "computeOutputShape",
                value: function(e) {
                    return "channelsLast" === this.dataFormat ? [e[0], e[3]] : [e[0], e[1]]
                }
            }, {
                key: "call",
                value: function(e, t) {
                    throw new Ase
                }
            }, {
                key: "getConfig",
                value: function() {
                    var e = {
                            dataFormat: this.dataFormat
                        },
                        t = N(v(n.prototype), "getConfig", this).call(this);
                    return Object.assign(e, t), e
                }
            }]), n
        }(wce),
        Cfe = function(e) {
            d(n, e);
            var t = w(n);

            function n() {
                return l(this, n), t.apply(this, arguments)
            }
            return p(n, [{
                key: "call",
                value: function(e, t) {
                    var n = this;
                    return X5((function() {
                        var t = lce(e);
                        return "channelsLast" === n.dataFormat ? Q9(t, [1, 2]) : Q9(t, [2, 3])
                    }))
                }
            }]), n
        }(Efe);
    Cfe.className = "GlobalAveragePooling2D", Kre(Cfe);
    var Afe = function(e) {
        d(n, e);
        var t = w(n);

        function n() {
            return l(this, n), t.apply(this, arguments)
        }
        return p(n, [{
            key: "call",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    var t = lce(e);
                    return "channelsLast" === n.dataFormat ? n9(t, [1, 2]) : n9(t, [2, 3])
                }))
            }
        }]), n
    }(Efe);
    Afe.className = "GlobalMaxPooling2D", Kre(Afe);
    var Rfe = function(e) {
            d(n, e);
            var t = w(n);

            function n(e) {
                var r;
                return l(this, n), (r = t.call(this, e)).layer = e.layer, r
            }
            return p(n, [{
                key: "build",
                value: function(e) {
                    this.built = !0
                }
            }, {
                key: "trainable",
                get: function() {
                    return null != this.layer && this.layer.trainable
                },
                set: function(e) {
                    null != this.layer && (this.layer.trainable = e)
                }
            }, {
                key: "trainableWeights",
                get: function() {
                    return this.layer.trainableWeights
                }
            }, {
                key: "nonTrainableWeights",
                get: function() {
                    return this.layer.nonTrainableWeights
                }
            }, {
                key: "updates",
                get: function() {
                    return this.layer._updates
                }
            }, {
                key: "losses",
                get: function() {
                    return this.layer.losses
                }
            }, {
                key: "getWeights",
                value: function() {
                    return this.layer.getWeights()
                }
            }, {
                key: "setWeights",
                value: function(e) {
                    this.layer.setWeights(e)
                }
            }, {
                key: "getConfig",
                value: function() {
                    var e = {
                            layer: {
                                className: this.layer.getClassName(),
                                config: this.layer.getConfig()
                            }
                        },
                        t = N(v(n.prototype), "getConfig", this).call(this);
                    return Object.assign(e, t), e
                }
            }, {
                key: "setFastWeightInitDuringBuild",
                value: function(e) {
                    N(v(n.prototype), "setFastWeightInitDuringBuild", this).call(this, e), null != this.layer && this.layer.setFastWeightInitDuringBuild(e)
                }
            }], [{
                key: "fromConfig",
                value: function(e, t) {
                    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                        r = t.layer,
                        a = rle(r, n);
                    delete t.layer;
                    var i = {
                        layer: a
                    };
                    return Object.assign(i, t), new e(i)
                }
            }]), n
        }(wce),
        _fe = function(e) {
            d(n, e);
            var t = w(n);

            function n(e) {
                var r;
                return l(this, n), (r = t.call(this, e)).supportsMasking = !0, r
            }
            return p(n, [{
                key: "build",
                value: function(e) {
                    if ((e = hce(e)).length < 3) throw new Cse("TimeDistributed layer expects an input shape >= 3D, but received " + "input shape ".concat(JSON.stringify(e)));
                    this.inputSpec = [{
                        shape: e
                    }];
                    var t = [e[0]].concat(e.slice(2));
                    this.layer.built || (this.layer.build(t), this.layer.built = !0), N(v(n.prototype), "build", this).call(this, e)
                }
            }, {
                key: "computeOutputShape",
                value: function(e) {
                    var t = [(e = hce(e))[0]].concat(e.slice(2)),
                        n = this.layer.computeOutputShape(t),
                        r = e[1];
                    return [n[0], r].concat(n.slice(1))
                }
            }, {
                key: "call",
                value: function(e, t) {
                    var n = this;
                    return X5((function() {
                        return Npe((function(e, r) {
                            return [lce(n.layer.call(e, t)), []]
                        }), e = lce(e), [], !1, null, null, !1, !0)[1]
                    }))
                }
            }]), n
        }(Rfe);
    _fe.className = "TimeDistributed", Kre(_fe);
    var Ofe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            l(this, n), r = t.call(this, e);
            var a = e.layer.getConfig(),
                i = {};
            i.className = e.layer.getClassName(), i.config = a, r.forwardLayer = rle(i), a.goBackwards = !0 !== a.goBackwards;
            var o, s = {};
            if (s.className = e.layer.getClassName(), s.config = a, r.backwardLayer = rle(s), r.forwardLayer.name = "forward_" + r.forwardLayer.name, r.backwardLayer.name = "backward_" + r.backwardLayer.name, r.mergeMode = void 0 === e.mergeMode ? "concat" : e.mergeMode, o = r.mergeMode, qse(iue, "BidirectionalMergeMode", o), e.weights) throw new Ase("weights support is not implemented for Bidirectional layer yet.");
            return r._stateful = e.layer.stateful, r.returnSequences = e.layer.returnSequences, r.returnState = e.layer.returnState, r.supportsMasking = !0, r._trainable = !0, r.inputSpec = e.layer.inputSpec, r.numConstants = null, r
        }
        return p(n, [{
            key: "trainable",
            get: function() {
                return this._trainable
            },
            set: function(e) {
                this._trainable = e, null != this.forwardLayer && (this.forwardLayer.trainable = e), null != this.backwardLayer && (this.backwardLayer.trainable = e)
            }
        }, {
            key: "getWeights",
            value: function() {
                return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())
            }
        }, {
            key: "setWeights",
            value: function(e) {
                var t = e.length,
                    n = Math.floor(t / 2);
                this.forwardLayer.setWeights(e.slice(0, n)), this.backwardLayer.setWeights(e.slice(n))
            }
        }, {
            key: "computeOutputShape",
            value: function(e) {
                var t, n, r, a = this.forwardLayer.computeOutputShape(e);
                return Array.isArray(a) && Array.isArray(a[0]) || (a = [a]), this.returnState ? (r = a.slice(1), t = a[0]) : t = a[0], "concat" === this.mergeMode ? (t[t.length - 1] *= 2, n = [t]) : n = null == this.mergeMode ? [t, t.slice()] : [t], this.returnState ? null == this.mergeMode ? n.concat(r).concat(r.slice()) : [t].concat(r).concat(r.slice()) : Mse(n)
            }
        }, {
            key: "apply",
            value: function(e, t) {
                var r = null == t ? null : t.initialState,
                    a = null == t ? null : t.constants;
                null == t && (t = {});
                var i = Ipe(e, r, a, this.numConstants);
                if (e = i.inputs, r = i.initialState, a = i.constants, Array.isArray(e) && (r = e.slice(1), e = e[0]), (null == r || 0 === r.length) && null == a) return N(v(n.prototype), "apply", this).call(this, e, t);
                var o = [],
                    s = [];
                if (null != r) {
                    var u = r.length;
                    if (u % 2 > 0) throw new Cse("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");
                    t.initialState = r, o.push.apply(o, T(r));
                    var c = r.map((function(e) {
                        return new gce({
                            shape: e.shape
                        })
                    }));
                    this.forwardLayer.stateSpec = c.slice(0, u / 2), this.backwardLayer.stateSpec = c.slice(u / 2), s.push.apply(s, T(c))
                }
                if (null != a) throw new Ase("Support for constants in Bidirectional layers is not implemented yet.");
                for (var l = o[0] instanceof yce, h = 0, p = o; h < p.length; h++) {
                    if (p[h] instanceof yce !== l) throw new Cse("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors")
                }
                if (l) {
                    var f = [e].concat(o),
                        d = this.inputSpec.concat(s),
                        m = this.inputSpec;
                    this.inputSpec = d;
                    var g = N(v(n.prototype), "apply", this).call(this, f, t);
                    return this.inputSpec = m, g
                }
                return N(v(n.prototype), "apply", this).call(this, e, t)
            }
        }, {
            key: "call",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    var r, a, i, o, s = t.initialState;
                    if (null == s) r = n.forwardLayer.call(e, t), a = n.backwardLayer.call(e, t);
                    else {
                        var u = s.slice(0, s.length / 2),
                            c = s.slice(s.length / 2);
                        r = n.forwardLayer.call(e, Object.assign(t, {
                            initialState: u
                        })), a = n.backwardLayer.call(e, Object.assign(t, {
                            initialState: c
                        }))
                    }
                    return n.returnState && (Array.isArray(r) && (i = r.slice(1).concat(a.slice(1))), r = r[0], a = a[0]), n.returnSequences && (a = pte(a, 1)), "concat" === n.mergeMode ? o = Cue([r, a]) : "sum" === n.mergeMode ? o = d8(r, a) : "ave" === n.mergeMode ? o = g8(.5, d8(r, a)) : "mul" === n.mergeMode ? o = g8(r, a) : null == n.mergeMode && (o = [r, a]), n.returnState ? null == n.mergeMode ? o.concat(i) : [o].concat(i) : o
                }))
            }
        }, {
            key: "resetStates",
            value: function(e) {
                this.forwardLayer.resetStates(), this.backwardLayer.resetStates()
            }
        }, {
            key: "build",
            value: function(e) {
                var t = this;
                hue(this.forwardLayer.name, (function() {
                    t.forwardLayer.build(e)
                })), hue(this.backwardLayer.name, (function() {
                    t.backwardLayer.build(e)
                })), this.built = !0
            }
        }, {
            key: "computeMask",
            value: function(e, t) {
                var n;
                if (Array.isArray(t) && (t = t[0]), n = this.returnSequences ? null == this.mergeMode ? [t, t] : t : null == this.mergeMode ? [null, null] : null, this.returnState) {
                    var r = this.forwardLayer.states.map((function(e) {
                        return null
                    }));
                    return Array.isArray(n) ? n.concat(r).concat(r) : [n].concat(r).concat(r)
                }
                return n
            }
        }, {
            key: "trainableWeights",
            get: function() {
                return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)
            }
        }, {
            key: "nonTrainableWeights",
            get: function() {
                return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)
            }
        }, {
            key: "setFastWeightInitDuringBuild",
            value: function(e) {
                N(v(n.prototype), "setFastWeightInitDuringBuild", this).call(this, e), null != this.forwardLayer && this.forwardLayer.setFastWeightInitDuringBuild(e), null != this.backwardLayer && this.backwardLayer.setFastWeightInitDuringBuild(e)
            }
        }, {
            key: "getConfig",
            value: function() {
                var e = {
                        mergeMode: this.mergeMode
                    },
                    t = N(v(n.prototype), "getConfig", this).call(this);
                return Object.assign(e, t), e
            }
        }], [{
            key: "fromConfig",
            value: function(e, t) {
                var n = rle(t.layer);
                if (delete t.layer, null != t.numConstants) throw new Ase("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");
                var r = t;
                return r.layer = n, new e(r)
            }
        }]), n
    }(Rfe);
    Ofe.className = "Bidirectional", Kre(Ofe);
    var Ffe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            return l(this, n), (r = t.call(this, e)).scale = e.scale, e.offset ? r.offset = e.offset : r.offset = 0, r
        }
        return p(n, [{
            key: "getConfig",
            value: function() {
                var e = {
                        scale: this.scale,
                        offset: this.offset
                    },
                    t = N(v(n.prototype), "getConfig", this).call(this);
                return Object.assign(e, t), e
            }
        }, {
            key: "call",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    return "float32" !== (e = lce(e)).dtype && (e = wue(e, "float32")), d8(g8(e, n.scale), n.offset)
                }))
            }
        }]), n
    }(wce);
    Ffe.className = "Rescaling", Kre(Ffe);
    var Dfe = Pre.resizeBilinear,
        Mfe = Pre.cropAndResize,
        Lfe = function(e) {
            d(n, e);
            var t = w(n);

            function n(e) {
                var r;
                return l(this, n), (r = t.call(this, e)).height = e.height, r.width = e.width, r
            }
            return p(n, [{
                key: "centerCrop",
                value: function(e, t, n, r, a, i, o, s) {
                    return X5((function() {
                        var u, c = !1,
                            l = [t / i, n / o, (r + t) / i, (a + n) / o],
                            h = [];
                        3 === e.rank ? (c = !0, u = Pte([e])) : u = e;
                        for (var p = 0; p < u.shape[0]; p++) h.push(l);
                        var f = V5(h, [h.length, 4]),
                            d = ste(0, h.length, 1, "int32"),
                            v = Mfe(u, f, d, [r, a], "nearest");
                        return wue(c ? lce(rne(v)) : v, s)
                    }))
                }
            }, {
                key: "upsize",
                value: function(e, t, n, r) {
                    return X5((function() {
                        return wue(Dfe(e, [t, n]), r)
                    }))
                }
            }, {
                key: "call",
                value: function(e, t) {
                    var n = this;
                    return X5((function() {
                        var t = lce(e),
                            r = t.dtype,
                            a = t.shape,
                            i = a[a.length - 3],
                            o = a[a.length - 2],
                            s = 0;
                        i !== n.height && (s = Math.floor((i - n.height) / 2));
                        var u = 0;
                        return o !== n.width && 0 === (u = Math.floor((o - n.width) / 2)) && (u = 1), s >= 0 && u >= 0 ? n.centerCrop(t, s, u, n.height, n.width, i, o, r) : n.upsize(e, n.height, n.width, r)
                    }))
                }
            }, {
                key: "getConfig",
                value: function() {
                    var e = {
                            height: this.height,
                            width: this.width
                        },
                        t = N(v(n.prototype), "getConfig", this).call(this);
                    return Object.assign(e, t), e
                }
            }, {
                key: "computeOutputShape",
                value: function(e) {
                    var t = (e = hce(e)).length - 3,
                        n = e.length - 2;
                    return e[t] = this.height, e[n] = this.width, e
                }
            }]), n
        }(wce);
    Lfe.className = "CenterCrop", Kre(Lfe);
    var zfe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            return l(this, n), (r = t.call(this, e)).numTokens = e.numTokens, e.outputMode ? r.outputMode = e.outputMode : r.outputMode = "multiHot", r
        }
        return p(n, [{
            key: "getConfig",
            value: function() {
                var e = {
                        numTokens: this.numTokens,
                        outputMode: this.outputMode
                    },
                    t = N(v(n.prototype), "getConfig", this).call(this);
                return Object.assign(e, t), e
            }
        }, {
            key: "computeOutputShape",
            value: function(e) {
                return null == (e = hce(e)) ? [this.numTokens] : "oneHot" === this.outputMode && 1 !== e[e.length - 1] ? (e.push(this.numTokens), e) : (e[e.length - 1] = this.numTokens, e)
            }
        }, {
            key: "call",
            value: function(e, t) {
                var n = this;
                return X5((function() {
                    var r;
                    if ("int32" !== (e = lce(e)).dtype && (e = wue(e, "int32")), void 0 !== t.countWeights) {
                        if ("count" !== n.outputMode) throw new Cse("countWeights is not used when outputMode !== count.\n              Received countWeights=".concat(t.countWeights));
                        r = lce(t.countWeights)
                    }
                    var a = n9(e),
                        i = r9(e),
                        o = b9(n.numTokens, a).bufferSync().get(0),
                        s = x9(i, 0).bufferSync().get(0);
                    if (!o || !s) throw new Cse("Input values must be between 0 < values <=" + " numTokens with numTokens=".concat(n.numTokens));
                    return function(e, t, n, r) {
                        var a = lce(e);
                        if ("int32" !== a.dtype && (a = wue(a, "int32")), "int" === t) return a;
                        var i = a.shape;
                        if (0 === a.rank && (a = f9(a, -1)), "oneHot" === t && 1 !== a.shape[a.shape.length - 1] && (a = f9(a, -1)), a.rank > 2) throw new Cse("When outputMode is not int, maximum output rank is 2" + " Received outputMode ".concat(t, " and input shape ").concat(i) + " which would result in output rank ".concat(a.rank, "."));
                        var o, s = ["multiHot", "oneHot"].includes(t);
                        if (o = R7(a, void 0 !== r && "count" === t ? r : [], n, s), "tfIdf" !== t) return o;
                        if (r) return g8(o, r);
                        throw new Cse("When outputMode is 'tfIdf', weights must be provided.")
                    }(e, n.outputMode, n.numTokens, r)
                }))
            }
        }]), n
    }(wce);
    zfe.className = "CategoryEncoding", Kre(zfe);
    var Pfe = new Set(["bilinear", "nearest"]),
        Bfe = function(e) {
            d(n, e);
            var t = w(n);

            function n(e) {
                var r;
                if (l(this, n), (r = t.call(this, e)).height = e.height, r.width = e.width, e.interpolation) {
                    if (!Pfe.has(e.interpolation)) throw new Cse("Invalid interpolation parameter: ".concat(e.interpolation, " is not implemented"));
                    r.interpolation = e.interpolation
                } else r.interpolation = "bilinear";
                return r.cropToAspectRatio = Boolean(e.cropToAspectRatio), r
            }
            return p(n, [{
                key: "computeOutputShape",
                value: function(e) {
                    var t = (e = hce(e))[2];
                    return [this.height, this.width, t]
                }
            }, {
                key: "getConfig",
                value: function() {
                    var e = {
                            height: this.height,
                            width: this.width,
                            interpolation: this.interpolation,
                            cropToAspectRatio: this.cropToAspectRatio
                        },
                        t = N(v(n.prototype), "getConfig", this).call(this);
                    return Object.assign(e, t), e
                }
            }, {
                key: "call",
                value: function(e, t) {
                    var n = this;
                    return X5((function() {
                        var t = [n.height, n.width];
                        if ("bilinear" === n.interpolation) return Pre.resizeBilinear(e, t, !n.cropToAspectRatio);
                        if ("nearest" === n.interpolation) return Pre.resizeNearestNeighbor(e, t, !n.cropToAspectRatio);
                        throw new Error("Interpolation is ".concat(n.interpolation, " but only ").concat(T(Pfe), " are supported"))
                    }))
                }
            }]), n
        }(wce);
    Bfe.className = "Resizing", Kre(Bfe);
    var Wfe = function() {
        function e(t) {
            l(this, e), this.seed = t
        }
        return p(e, [{
            key: "next",
            value: function() {
                if (void 0 !== this.seed) return this.seed++
            }
        }]), e
    }();
    Wfe.className = "RandomSeed";
    var Ufe = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            var r;
            return l(this, n), (r = t.call(this, e)).randomGenerator = new Wfe(e.seed), r
        }
        return p(n, [{
            key: "getConfig",
            value: function() {
                var e = {
                        seed: this.randomGenerator.seed
                    },
                    t = N(v(n.prototype), "getConfig", this).call(this);
                return Object.assign(e, t), e
            }
        }]), n
    }(wce);
    Ufe.className = "BaseRandomLayer";
    var Vfe = new Set(["bilinear", "nearest"]),
        Gfe = function(e) {
            d(n, e);
            var t = w(n);

            function n(e) {
                var r;
                l(this, n), r = t.call(this, e);
                var a = e.factor,
                    i = e.interpolation,
                    o = void 0 === i ? "bilinear" : i;
                if (r.factor = a, Array.isArray(r.factor) && 2 === r.factor.length) r.widthLower = r.factor[0], r.widthUpper = r.factor[1];
                else {
                    if (Array.isArray(r.factor) || !(r.factor > 0)) throw new Cse("Invalid factor: ".concat(r.factor, ". Must be positive number or tuple of 2 numbers"));
                    r.widthLower = -r.factor, r.widthUpper = r.factor
                }
                if (r.widthLower < -1 || r.widthUpper < -1) throw new Cse("factor must have values larger than -1. Got: ".concat(r.factor));
                if (r.widthUpper < r.widthLower) throw new Cse("factor cannot have upper bound less than lower bound.\n        Got upper bound: ".concat(r.widthUpper, ".\n        Got lower bound: ").concat(r.widthLower, "\n      "));
                if (o) {
                    if (!Vfe.has(o)) throw new Cse("Invalid interpolation parameter: ".concat(o, " is not implemented"));
                    r.interpolation = o
                }
                return r
            }
            return p(n, [{
                key: "getConfig",
                value: function() {
                    var e = {
                            factor: this.factor,
                            interpolation: this.interpolation
                        },
                        t = N(v(n.prototype), "getConfig", this).call(this);
                    return Object.assign(e, t), e
                }
            }, {
                key: "computeOutputShape",
                value: function(e) {
                    var t = (e = hce(e))[2];
                    return [this.imgHeight, -1, t]
                }
            }, {
                key: "call",
                value: function(e, t) {
                    var n = this;
                    return X5((function() {
                        var t = lce(e);
                        n.imgHeight = t.shape[t.shape.length - 3];
                        var r = t.shape[t.shape.length - 2];
                        n.widthFactor = ite([1], 1 + n.widthLower, 1 + n.widthUpper, "float32", n.randomGenerator.next());
                        var a = n.widthFactor.dataSync()[0] * r;
                        a = Math.round(a);
                        var i = [n.imgHeight, a];
                        switch (n.interpolation) {
                            case "bilinear":
                                return Pre.resizeBilinear(e, i);
                            case "nearest":
                                return Pre.resizeNearestNeighbor(e, i);
                            default:
                                throw new Error("Interpolation is ".concat(n.interpolation, "\n          but only ").concat(T(Vfe), " are supported"))
                        }
                    }))
                }
            }]), n
        }(Ufe);

    function jfe(e) {
        return new gfe(e)
    }

    function Hfe(e) {
        return new xfe(e)
    }

    function qfe(e) {
        return new Ife(e)
    }

    function Kfe(e) {
        return new Tfe(e)
    }

    function Xfe(e) {
        return new Afe(e)
    }

    function Yfe(e) {
        return new mfe(e)
    }

    function Jfe(e) {
        return new bfe(e)
    }
    Gfe.className = "RandomWidth", Kre(Gfe);
    var Zfe = {
        __proto__: null,
        Layer: wce,
        RNN: Spe,
        RNNCell: Tpe,
        activation: function(e) {
            return new Gpe(e)
        },
        add: function(e) {
            return new Jpe(e)
        },
        alphaDropout: function(e) {
            return new ofe(e)
        },
        average: function(e) {
            return new Qpe(e)
        },
        averagePooling1d: jfe,
        averagePooling2d: Hfe,
        averagePooling3d: qfe,
        avgPool1d: function(e) {
            return jfe(e)
        },
        avgPool2d: function(e) {
            return Hfe(e)
        },
        avgPool3d: function(e) {
            return qfe(e)
        },
        avgPooling1d: function(e) {
            return jfe(e)
        },
        avgPooling2d: function(e) {
            return Hfe(e)
        },
        avgPooling3d: function(e) {
            return qfe(e)
        },
        batchNormalization: function(e) {
            return new lfe(e)
        },
        bidirectional: function(e) {
            return new Ofe(e)
        },
        categoryEncoding: function(e) {
            return new zfe(e)
        },
        centerCrop: function(e) {
            return new Lfe(e)
        },
        concatenate: function(e) {
            return new tfe(e)
        },
        conv1d: function(e) {
            return new bpe(e)
        },
        conv2d: function(e) {
            return new fpe(e)
        },
        conv2dTranspose: function(e) {
            return new vpe(e)
        },
        conv3d: function(e) {
            return new dpe(e)
        },
        conv3dTranspose: function(e) {
            return new mpe(e)
        },
        convLstm2d: function(e) {
            return new Ppe(e)
        },
        convLstm2dCell: function(e) {
            return new zpe(e)
        },
        cropping2D: function(e) {
            return new xpe(e)
        },
        dense: function(e) {
            return new Upe(e)
        },
        depthwiseConv2d: function(e) {
            return new wpe(e)
        },
        dot: function(e) {
            return new rfe(e)
        },
        dropout: function(e) {
            return new Bpe(e)
        },
        elu: function(e) {
            return new epe(e)
        },
        embedding: function(e) {
            return new Xpe(e)
        },
        flatten: function(e) {
            return new Vpe(e)
        },
        gaussianDropout: function(e) {
            return new ife(e)
        },
        gaussianNoise: function(e) {
            return new afe(e)
        },
        globalAveragePooling1d: function(e) {
            return new Sfe(e)
        },
        globalAveragePooling2d: function(e) {
            return new Cfe(e)
        },
        globalMaxPool1d: Kfe,
        globalMaxPool2d: Xfe,
        globalMaxPooling1d: Kfe,
        globalMaxPooling2d: Xfe,
        gru: function(e) {
            return new Rpe(e)
        },
        gruCell: function(e) {
            return new Ape(e)
        },
        input: Ihe,
        inputLayer: function(e) {
            return new Nce(e)
        },
        layerNormalization: function(e) {
            return new hfe(e)
        },
        leakyReLU: function(e) {
            return new Qhe(e)
        },
        lstm: function(e) {
            return new Ope(e)
        },
        lstmCell: function(e) {
            return new _pe(e)
        },
        masking: function(e) {
            return new Kpe(e)
        },
        maxPool1d: Yfe,
        maxPool2d: Jfe,
        maxPooling1d: Yfe,
        maxPooling2d: Jfe,
        maxPooling3d: function(e) {
            return new wfe(e)
        },
        maximum: function(e) {
            return new $pe(e)
        },
        minimum: function(e) {
            return new efe(e)
        },
        multiply: function(e) {
            return new Zpe(e)
        },
        permute: function(e) {
            return new qpe(e)
        },
        prelu: function(e) {
            return new $he(e)
        },
        randomWidth: function(e) {
            return new Gfe(e)
        },
        reLU: function(e) {
            return new Zhe(e)
        },
        repeatVector: function(e) {
            return new jpe(e)
        },
        rescaling: function(e) {
            return new Ffe(e)
        },
        reshape: function(e) {
            return new Hpe(e)
        },
        resizing: function(e) {
            return new Bfe(e)
        },
        rnn: function(e) {
            return new Spe(e)
        },
        separableConv2d: function(e) {
            return new ype(e)
        },
        simpleRNN: function(e) {
            return new Cpe(e)
        },
        simpleRNNCell: function(e) {
            return new Epe(e)
        },
        softmax: function(e) {
            return new npe(e)
        },
        spatialDropout1d: function(e) {
            return new Wpe(e)
        },
        stackedRNNCells: function(e) {
            return new Fpe(e)
        },
        thresholdedReLU: function(e) {
            return new tpe(e)
        },
        timeDistributed: function(e) {
            return new _fe(e)
        },
        upSampling2d: function(e) {
            return new kpe(e)
        },
        zeroPadding2d: function(e) {
            return new pfe(e)
        }
    };
    var Qfe = {
            __proto__: null,
            MAPE: function(e, t) {
                return sle(e, t)
            },
            MSE: function(e, t) {
                return ile(e, t)
            },
            binaryAccuracy: function(e, t) {
                return mle(e, t)
            },
            binaryCrossentropy: function(e, t) {
                return kle(e, t)
            },
            categoricalAccuracy: function(e, t) {
                return gle(e, t)
            },
            categoricalCrossentropy: function(e, t) {
                return Ile(e, t)
            },
            cosineProximity: function(e, t) {
                return fle(e, t)
            },
            mape: function(e, t) {
                return sle(e, t)
            },
            meanAbsoluteError: function(e, t) {
                return ole(e, t)
            },
            meanAbsolutePercentageError: function(e, t) {
                return sle(e, t)
            },
            meanSquaredError: function(e, t) {
                return ile(e, t)
            },
            mse: function(e, t) {
                return ile(e, t)
            },
            precision: function(e, t) {
                return ble(e, t)
            },
            r2Score: function(e, t) {
                return function(e, t) {
                    return X5((function() {
                        var n = e.sub(t).square().sum(),
                            r = e.sub(e.mean()).square().sum();
                        return i9(1).sub(n.div(r))
                    }))
                }(e, t)
            },
            recall: function(e, t) {
                return xle(e, t)
            },
            sparseCategoricalAccuracy: function(e, t) {
                return wle(e, t)
            }
        },
        $fe = {
            __proto__: null,
            modelFromJSON: function(e, t) {
                return ghe.apply(this, arguments)
            }
        };
    var ede = {
            __proto__: null,
            l1: function(e) {
                return jhe(t = e), new qhe({
                    l1: null != t ? t.l1 : null,
                    l2: 0
                });
                var t
            },
            l1l2: function(e) {
                return new qhe(e)
            },
            l2: function(e) {
                return jhe(t = e), new qhe({
                    l2: null != t ? t.l2 : null,
                    l1: 0
                });
                var t
            }
        },
        tde = function(e) {
            d(n, e);
            var t = w(n);

            function n() {
                var e;
                return l(this, n), (e = t.apply(this, arguments)).model = null, e
            }
            return p(n, [{
                key: "setModel",
                value: function(e) {
                    if (!(e instanceof vhe)) throw new Error("model must be a LayersModel, not some other Container");
                    this.model = e
                }
            }]), n
        }(Yce);

    function nde(e, t) {
        return e < t
    }

    function rde(e, t) {
        return e > t
    }
    var ade = function(e) {
        d(i, e);
        var t, n, r, a = w(i);

        function i(e) {
            var t;
            if (l(this, i), t = a.call(this), null == e && (e = {}), e.restoreBestWeights) throw new Ase("restoreBestWeights = True is not implemented in EarlyStopping yet.");
            return t.monitor = e.monitor || "val_loss", t.minDelta = Math.abs(e.minDelta || 0), t.patience = e.patience || 0, t.verbose = e.verbose || 0, t.mode = e.mode || "auto", t.baseline = e.baseline, -1 === ["auto", "min", "max"].indexOf(t.mode) && (console.warn("EarlyStopping mode '".concat(t.mode, "' is invalid. ") + "Falling back to mode 'auto'."), t.mode = "auto"), "min" === t.mode ? t.monitorFunc = nde : "max" === t.mode || -1 !== t.monitor.indexOf("acc") ? t.monitorFunc = rde : t.monitorFunc = nde, t.monitorFunc === nde && (t.minDelta *= -1), t
        }
        return p(i, [{
            key: "onTrainBegin",
            value: (r = c(o().mark((function e(t) {
                return o().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            this.wait = 0, this.stoppedEpoch = 0, null != this.baseline ? this.best = this.baseline : this.best = this.monitorFunc === nde ? 1 / 0 : -1 / 0;
                        case 3:
                        case "end":
                            return e.stop()
                    }
                }), e, this)
            }))), function(e) {
                return r.apply(this, arguments)
            })
        }, {
            key: "onEpochEnd",
            value: (n = c(o().mark((function e(t, n) {
                var r;
                return o().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            return e.next = 2, qce(n);
                        case 2:
                            if (null != (r = this.getMonitorValue(n))) {
                                e.next = 5;
                                break
                            }
                            return e.abrupt("return");
                        case 5:
                            this.monitorFunc(r - this.minDelta, this.best) ? (this.best = r, this.wait = 0) : (this.wait++, this.wait >= this.patience && (this.stoppedEpoch = t, this.model.stopTraining = !0));
                        case 6:
                        case "end":
                            return e.stop()
                    }
                }), e, this)
            }))), function(e, t) {
                return n.apply(this, arguments)
            })
        }, {
            key: "onTrainEnd",
            value: (t = c(o().mark((function e(t) {
                return o().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            this.stoppedEpoch > 0 && this.verbose && console.log("Epoch ".concat(this.stoppedEpoch, ": early stopping."));
                        case 1:
                        case "end":
                            return e.stop()
                    }
                }), e, this)
            }))), function(e) {
                return t.apply(this, arguments)
            })
        }, {
            key: "getMonitorValue",
            value: function(e) {
                null == e && (e = {});
                var t = e[this.monitor];
                return null == t && console.warn("Metric for EarlyStopping ".concat(this.monitor, " is not available. ") + "Available metrics are: ".concat(Object.keys(e))), t
            }
        }]), i
    }(tde);
    var ide, ode, sde = {
        earlyStopping: function(e) {
            return new ade(e)
        }
    };
    k0().registerFlag("KEEP_INTERMEDIATE_TENSORS", (function() {
            return !1
        }), (function(e) {
            e && console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")
        })),
        function(e) {
            e[e.DT_INVALID = 0] = "DT_INVALID", e[e.DT_FLOAT = 1] = "DT_FLOAT", e[e.DT_DOUBLE = 2] = "DT_DOUBLE", e[e.DT_INT32 = 3] = "DT_INT32", e[e.DT_UINT8 = 4] = "DT_UINT8", e[e.DT_INT16 = 5] = "DT_INT16", e[e.DT_INT8 = 6] = "DT_INT8", e[e.DT_STRING = 7] = "DT_STRING", e[e.DT_COMPLEX64 = 8] = "DT_COMPLEX64", e[e.DT_INT64 = 9] = "DT_INT64", e[e.DT_BOOL = 10] = "DT_BOOL", e[e.DT_QINT8 = 11] = "DT_QINT8", e[e.DT_QUINT8 = 12] = "DT_QUINT8", e[e.DT_QINT32 = 13] = "DT_QINT32", e[e.DT_BFLOAT16 = 14] = "DT_BFLOAT16", e[e.DT_QINT16 = 15] = "DT_QINT16", e[e.DT_QUINT16 = 16] = "DT_QUINT16", e[e.DT_UINT16 = 17] = "DT_UINT16", e[e.DT_COMPLEX128 = 18] = "DT_COMPLEX128", e[e.DT_HALF = 19] = "DT_HALF", e[e.DT_RESOURCE = 20] = "DT_RESOURCE", e[e.DT_VARIANT = 21] = "DT_VARIANT", e[e.DT_UINT32 = 22] = "DT_UINT32", e[e.DT_UINT64 = 23] = "DT_UINT64", e[e.DT_FLOAT_REF = 101] = "DT_FLOAT_REF", e[e.DT_DOUBLE_REF = 102] = "DT_DOUBLE_REF", e[e.DT_INT32_REF = 103] = "DT_INT32_REF", e[e.DT_UINT8_REF = 104] = "DT_UINT8_REF", e[e.DT_INT16_REF = 105] = "DT_INT16_REF", e[e.DT_INT8_REF = 106] = "DT_INT8_REF", e[e.DT_STRING_REF = 107] = "DT_STRING_REF", e[e.DT_COMPLEX64_REF = 108] = "DT_COMPLEX64_REF", e[e.DT_INT64_REF = 109] = "DT_INT64_REF", e[e.DT_BOOL_REF = 110] = "DT_BOOL_REF", e[e.DT_QINT8_REF = 111] = "DT_QINT8_REF", e[e.DT_QUINT8_REF = 112] = "DT_QUINT8_REF", e[e.DT_QINT32_REF = 113] = "DT_QINT32_REF", e[e.DT_BFLOAT16_REF = 114] = "DT_BFLOAT16_REF", e[e.DT_QINT16_REF = 115] = "DT_QINT16_REF", e[e.DT_QUINT16_REF = 116] = "DT_QUINT16_REF", e[e.DT_UINT16_REF = 117] = "DT_UINT16_REF", e[e.DT_COMPLEX128_REF = 118] = "DT_COMPLEX128_REF", e[e.DT_HALF_REF = 119] = "DT_HALF_REF", e[e.DT_RESOURCE_REF = 120] = "DT_RESOURCE_REF", e[e.DT_VARIANT_REF = 121] = "DT_VARIANT_REF", e[e.DT_UINT32_REF = 122] = "DT_UINT32_REF", e[e.DT_UINT64_REF = 123] = "DT_UINT64_REF"
        }(ide || (ide = {})),
        function(e) {
            ! function(e) {
                e[e.LEGACY = 0] = "LEGACY", e[e.V1 = 1] = "V1", e[e.V2 = 2] = "V2"
            }(e.CheckpointFormatVersion || (e.CheckpointFormatVersion = {}))
        }(ode || (ode = {}));
    var ude = {};

    function cde(e) {
        return ude[e]
    }

    function lde(e, t, n, r, a) {
        var i = t.inputParams[e];
        if (i && void 0 !== i.inputIndexStart) {
            var o = i.inputIndexStart,
                s = 0 === i.inputIndexEnd ? void 0 : void 0 === i.inputIndexEnd ? o + 1 : i.inputIndexEnd,
                u = o < 0 ? t.inputNames.length + o : o;
            if ("tensor" === i.type) return hde(t.inputNames[u], n, r, a);
            if ("tensors" === i.type) {
                var c = t.inputs.slice(o, s),
                    l = t.inputNames.slice(o, s).filter((function(e, t) {
                        var n;
                        return "NoOp" !== (null === (n = c[t]) || void 0 === n ? void 0 : n.op)
                    }));
                return l.map((function(e) {
                    return hde(e, n, r, a)
                }))
            }
            var h = hde(t.inputNames[u], n, r, a),
                p = h.dataSync();
            return "number" === i.type ? p[0] : s0(h.shape, p)
        }
        var f = t.attrParams[e];
        return f && f.value
    }

    function hde(e, t, n, r) {
        var a = S(vde(e, n), 2),
            i = a[0],
            o = a[1];
        if (null != r) {
            var s = r.getHashTableHandleByName(i);
            if (null != s) return s
        }
        var u = n.currentContextIds.find((function(e) {
            return !!t[dde(i, e)]
        }));
        return void 0 !== u ? t[dde(i, u)][o] : void 0
    }

    function pde(e, t, n) {
        return t[dde(e, n.currentContextId)]
    }

    function fde(e, t) {
        var n = S(vde(e, t), 3),
            r = n[0],
            a = n[1],
            i = n[2];
        return [dde(r, t && t.currentContextId), a, i]
    }

    function dde(e, t) {
        return t ? "".concat(e, "-").concat(t) : e
    }

    function vde(e, t) {
        if ("" === e) return ["", 0, void 0];
        var n = null != t && null != t.parseNodeNameCache;
        if (n) {
            var r = t.parseNodeNameCache.get(e);
            if (null != r) return r
        }
        var a, i = e.split(":");
        if (1 === i.length) a = [e, 0, void 0];
        else {
            var o = i[0],
                s = 3 === i.length ? i[1] : void 0;
            a = [o, Number(i[i.length - 1]), s]
        }
        return n && t.parseNodeNameCache.set(e, a), a
    }

    function mde(e, t, n) {
        var r = lde("pad", e, t, n);
        if ("explicit" === r) {
            r = lde("explicitPaddings", e, t, n);
            for (var a = [
                    [0, 0],
                    [0, 0],
                    [0, 0],
                    [0, 0]
                ], i = 0; i < 4; i++) a[i][0] = r[2 * i], a[i][1] = r[2 * i + 1];
            return a
        }
        return r
    }

    function gde(e) {
        return e.kept ? e : p8(e)
    }
    var yde = {
            __proto__: null,
            json: [{
                tfOpName: "Add",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "AddV2",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "AddN",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    end: 0,
                    name: "tensors",
                    type: "tensors"
                }]
            }, {
                tfOpName: "BiasAdd",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Sub",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "RealDiv",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Div",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "DivNoNan",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "FloorDiv",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Mul",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Maximum",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Minimum",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Pow",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "SquaredDifference",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Mod",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "FloorMod",
                category: "arithmetic",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }]
        },
        bde = {
            __proto__: null,
            json: [{
                tfOpName: "Abs",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Acos",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Asin",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Atan",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Atan2",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "y",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Ceil",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "ClipByValue",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "clipValueMin",
                    type: "number"
                }, {
                    start: 2,
                    name: "clipValueMax",
                    type: "number"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Complex",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "real",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "imag",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "ComplexAbs",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Cos",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Cosh",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Elu",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Exp",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Floor",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Log",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Imag",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "Tout",
                    name: "outputType",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Neg",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Real",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "Tout",
                    name: "outputType",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Prelu",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "alpha",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Relu",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Relu6",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Selu",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Sigmoid",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Sin",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Sinh",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Sqrt",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Rsqrt",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Square",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Tan",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Tanh",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Sign",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Round",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Expm1",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Log1p",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Reciprocal",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Softplus",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Asinh",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Acosh",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Atanh",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Erf",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "LeakyRelu",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "alpha",
                    name: "alpha",
                    type: "number",
                    defaultValue: .2
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "IsNan",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "IsFinite",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "IsInf",
                category: "basic_math",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }]
        },
        xde = {
            __proto__: null,
            json: [{
                tfOpName: "EmptyTensorList",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "elementShape",
                    type: "shape"
                }, {
                    start: 1,
                    name: "maxNumElements",
                    type: "number"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "LoopCond",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "pred",
                    type: "tensor"
                }]
            }, {
                tfOpName: "Switch",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "data",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "pred",
                    type: "tensor"
                }]
            }, {
                tfOpName: "Merge",
                category: "control",
                inputs: [{
                    start: 0,
                    end: 0,
                    name: "tensors",
                    type: "tensors"
                }]
            }, {
                tfOpName: "Enter",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensor",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "frame_name",
                    name: "frameName",
                    type: "string"
                }, {
                    tfName: "is_constant",
                    name: "isConstant",
                    type: "bool"
                }]
            }, {
                tfOpName: "Exit",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensor",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "NextIteration",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensor",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "TensorArrayV3",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "size",
                    type: "number"
                }],
                attrs: [{
                    tfName: "dtype",
                    name: "dtype",
                    type: "dtype"
                }, {
                    tfName: "element_shape",
                    name: "elementShape",
                    type: "shape"
                }, {
                    tfName: "dynamic_size",
                    name: "dynamicSize",
                    type: "bool"
                }, {
                    tfName: "clear_after_read",
                    name: "clearAfterRead",
                    type: "bool"
                }, {
                    tfName: "identical_element_shapes",
                    name: "identicalElementShapes",
                    type: "bool"
                }, {
                    tfName: "tensor_array_name",
                    name: "name",
                    type: "string"
                }]
            }, {
                tfOpName: "TensorArrayWriteV3",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorArrayId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "index",
                    type: "number"
                }, {
                    start: 2,
                    name: "tensor",
                    type: "tensor"
                }, {
                    start: 3,
                    name: "flowIn",
                    type: "number"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "TensorArrayReadV3",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorArrayId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "index",
                    type: "number"
                }, {
                    start: 2,
                    name: "flowIn",
                    type: "number"
                }],
                attrs: [{
                    tfName: "dtype",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "TensorArrayGatherV3",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorArrayId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "indices",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "flowIn",
                    type: "number"
                }],
                attrs: [{
                    tfName: "dtype",
                    name: "dtype",
                    type: "dtype"
                }, {
                    tfName: "element_shape",
                    name: "elementShape",
                    type: "shape"
                }]
            }, {
                tfOpName: "TensorArrayScatterV3",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorArrayId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "indices",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "tensor",
                    type: "tensor"
                }, {
                    start: 3,
                    name: "flowIn",
                    type: "number"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorArrayConcatV3",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorArrayId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "flowIn",
                    type: "number"
                }],
                attrs: [{
                    tfName: "dtype",
                    name: "dtype",
                    type: "dtype"
                }, {
                    tfName: "element_shape_except0",
                    name: "elementShapeExcept0",
                    type: "shape",
                    notSupported: !0
                }]
            }, {
                tfOpName: "TensorArraySplitV3",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorArrayId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "tensor",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "lengths",
                    type: "number[]"
                }, {
                    start: 3,
                    name: "flowIn",
                    type: "number"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorArraySizeV3",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorArrayId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "flowIn",
                    type: "number"
                }]
            }, {
                tfOpName: "TensorArrayCloseV3",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorArrayId",
                    type: "tensor"
                }]
            }, {
                tfOpName: "StatelessIf",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "cond",
                    type: "tensor"
                }, {
                    start: 1,
                    end: 0,
                    name: "args",
                    type: "tensors"
                }],
                attrs: [{
                    tfName: "then_branch",
                    name: "thenBranch",
                    type: "func"
                }, {
                    tfName: "else_branch",
                    name: "elseBranch",
                    type: "func"
                }]
            }, {
                tfOpName: "If",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "cond",
                    type: "tensor"
                }, {
                    start: 1,
                    end: 0,
                    name: "args",
                    type: "tensors"
                }],
                attrs: [{
                    tfName: "then_branch",
                    name: "thenBranch",
                    type: "func"
                }, {
                    tfName: "else_branch",
                    name: "elseBranch",
                    type: "func"
                }]
            }, {
                tfOpName: "StatelessWhile",
                category: "control",
                inputs: [{
                    start: 0,
                    end: 0,
                    name: "args",
                    type: "tensors"
                }],
                attrs: [{
                    tfName: "cond",
                    name: "cond",
                    type: "func"
                }, {
                    tfName: "body",
                    name: "body",
                    type: "func"
                }]
            }, {
                tfOpName: "While",
                category: "control",
                inputs: [{
                    start: 0,
                    end: 0,
                    name: "args",
                    type: "tensors"
                }],
                attrs: [{
                    tfName: "cond",
                    name: "cond",
                    type: "func"
                }, {
                    tfName: "body",
                    name: "body",
                    type: "func"
                }]
            }, {
                tfOpName: "TensorListScatter",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensor",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "indices",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "elementShape",
                    type: "shape"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListScatterV2",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensor",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "indices",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "elementShape",
                    type: "shape"
                }, {
                    start: 3,
                    name: "numElements",
                    type: "number"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListGather",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorListId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "indices",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "elementShape",
                    type: "shape"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListGetItem",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorListId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "index",
                    type: "number"
                }, {
                    start: 2,
                    name: "elementShape",
                    type: "shape"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListSetItem",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorListId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "index",
                    type: "number"
                }, {
                    start: 2,
                    name: "tensor",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListReserve",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "elementShape",
                    type: "shape"
                }, {
                    start: 1,
                    name: "numElements",
                    type: "number"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListFromTensor",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensor",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "elementShape",
                    type: "shape"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListStack",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorListId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "elementShape",
                    type: "shape"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }, {
                    tfName: "num_elements",
                    name: "numElements",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListSplit",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensor",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "elementShape",
                    type: "shape"
                }, {
                    start: 2,
                    name: "lengths",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListConcat",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorListId",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "element_shape",
                    name: "elementShape",
                    type: "shape"
                }, {
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListConcatV2",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorListId",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "element_shape",
                    name: "elementShape",
                    type: "shape"
                }, {
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListPopBack",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorListId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "elementShape",
                    type: "shape"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListPushBack",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorListId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "tensor",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "element_dtype",
                    name: "elementDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TensorListLength",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorListId",
                    type: "tensor"
                }]
            }, {
                tfOpName: "TensorListResize",
                category: "control",
                inputs: [{
                    start: 0,
                    name: "tensorListId",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "size",
                    type: "number"
                }]
            }]
        },
        kde = {
            __proto__: null,
            json: [{
                tfOpName: "AvgPool",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    notSupported: !0
                }, {
                    tfName: "ksize",
                    name: "kernelSize",
                    type: "number[]"
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "MaxPool",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    notSupported: !0
                }, {
                    tfName: "ksize",
                    name: "kernelSize",
                    type: "number[]"
                }, {
                    tfName: "explicit_paddings",
                    name: "explicitPaddings",
                    type: "number[]",
                    defaultValue: [],
                    notSupported: !0
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "MaxPoolWithArgmax",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "ksize",
                    name: "kernelSize",
                    type: "number[]"
                }, {
                    tfName: "include_batch_in_index",
                    name: "includeBatchInIndex",
                    type: "bool"
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "AvgPool3D",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    notSupported: !0
                }, {
                    tfName: "ksize",
                    name: "kernelSize",
                    type: "number[]"
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "MaxPool3D",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    notSupported: !0
                }, {
                    tfName: "ksize",
                    name: "kernelSize",
                    type: "number[]"
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Conv1D",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "filter",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "stride",
                    name: "stride",
                    type: "number"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    defaultValue: "NWC"
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "dilation",
                    name: "dilation",
                    type: "number",
                    defaultValue: 1
                }]
            }, {
                tfOpName: "Conv2D",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "filter",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "useCudnnOnGpu",
                    name: "useCudnnOnGpu",
                    type: "bool"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    defaultValue: "NHWC"
                }, {
                    tfName: "explicit_paddings",
                    name: "explicitPaddings",
                    type: "number[]",
                    defaultValue: []
                }, {
                    tfName: "dilations",
                    name: "dilations",
                    type: "number[]"
                }]
            }, {
                tfOpName: "_FusedConv2D",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "filter",
                    type: "tensor"
                }, {
                    start: 2,
                    end: 0,
                    name: "args",
                    type: "tensors"
                }],
                attrs: [{
                    tfName: "num_args",
                    name: "numArgs",
                    type: "number"
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "explicit_paddings",
                    name: "explicitPaddings",
                    type: "number[]",
                    defaultValue: []
                }, {
                    tfName: "use_cudnn_on_gpu",
                    name: "useCudnnOnGpu",
                    type: "bool",
                    defaultValue: !0
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    defaultValue: "NHWC"
                }, {
                    tfName: "dilations",
                    name: "dilations",
                    type: "number[]",
                    defaultValue: [1, 1, 1, 1]
                }, {
                    tfName: "fused_ops",
                    name: "fusedOps",
                    type: "string[]",
                    defaultValue: []
                }, {
                    tfName: "epsilon",
                    name: "epsilon",
                    type: "number",
                    defaultValue: 1e-4
                }, {
                    tfName: "leakyrelu_alpha",
                    name: "leakyreluAlpha",
                    type: "number",
                    defaultValue: .2
                }]
            }, {
                tfOpName: "Conv2DBackpropInput",
                category: "convolution",
                inputs: [{
                    start: 2,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "filter",
                    type: "tensor"
                }, {
                    start: 0,
                    name: "outputShape",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    notSupported: !0
                }, {
                    tfName: "explicit_paddings",
                    name: "explicitPaddings",
                    type: "number[]",
                    defaultValue: []
                }, {
                    tfName: "dilations",
                    name: "dilations",
                    type: "number[]",
                    notSupported: !0
                }]
            }, {
                tfOpName: "DepthwiseConv2d",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "input",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "filter",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    defaultValue: "NHWC"
                }, {
                    tfName: "explicit_paddings",
                    name: "explicitPaddings",
                    type: "number[]",
                    defaultValue: []
                }, {
                    tfName: "dilations",
                    name: "dilations",
                    type: "number[]"
                }]
            }, {
                tfOpName: "DepthwiseConv2dNative",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "input",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "filter",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    defaultValue: "NHWC"
                }, {
                    tfName: "explicit_paddings",
                    name: "explicitPaddings",
                    type: "number[]",
                    defaultValue: []
                }, {
                    tfName: "dilations",
                    name: "dilations",
                    type: "number[]"
                }]
            }, {
                tfOpName: "FusedDepthwiseConv2dNative",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "filter",
                    type: "tensor"
                }, {
                    start: 2,
                    end: 0,
                    name: "args",
                    type: "tensors"
                }],
                attrs: [{
                    tfName: "num_args",
                    name: "numArgs",
                    type: "number"
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    defaultValue: "NHWC"
                }, {
                    tfName: "dilations",
                    name: "dilations",
                    type: "number[]",
                    defaultValue: [1, 1, 1, 1]
                }, {
                    tfName: "fused_ops",
                    name: "fusedOps",
                    type: "string[]",
                    defaultValue: []
                }, {
                    tfName: "explicit_paddings",
                    name: "explicitPaddings",
                    type: "number[]",
                    defaultValue: []
                }]
            }, {
                tfOpName: "Conv3D",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "filter",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    defaultValue: "NHWC"
                }, {
                    tfName: "dilations",
                    name: "dilations",
                    type: "number[]"
                }]
            }, {
                tfOpName: "Dilation2D",
                category: "convolution",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "filter",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "strides",
                    name: "strides",
                    type: "number[]"
                }, {
                    tfName: "rates",
                    name: "dilations",
                    type: "number[]"
                }, {
                    tfName: "padding",
                    name: "pad",
                    type: "string"
                }]
            }]
        },
        wde = {
            __proto__: null,
            json: [{
                tfOpName: "Fill",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "shape",
                    type: "number[]"
                }, {
                    start: 1,
                    name: "value",
                    type: "number"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "LinSpace",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "start",
                    type: "number"
                }, {
                    start: 1,
                    name: "stop",
                    type: "number"
                }, {
                    start: 2,
                    name: "num",
                    type: "number"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "OneHot",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "indices",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "depth",
                    type: "number"
                }, {
                    start: 2,
                    name: "onValue",
                    type: "number",
                    defaultValue: 1
                }, {
                    start: 3,
                    name: "offValue",
                    type: "number",
                    defaultValue: 0
                }],
                attrs: [{
                    tfName: "axis",
                    name: "axis",
                    type: "number",
                    notSupported: !0
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "Ones",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "shape",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "OnesLike",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "dtype",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "RandomStandardNormal",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "shape",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "seed",
                    name: "seed",
                    type: "number",
                    defaultValue: 0
                }, {
                    tfName: "seed2",
                    name: "seed2",
                    type: "number",
                    defaultValue: 0,
                    notSupported: !0
                }, {
                    tfName: "dtype",
                    name: "dtype",
                    type: "dtype"
                }, {
                    tfName: "T",
                    name: "T",
                    type: "number",
                    notSupported: !0
                }]
            }, {
                tfOpName: "RandomUniform",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "shape",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "minval",
                    name: "minval",
                    type: "number",
                    defaultValue: 0
                }, {
                    tfName: "maxval",
                    name: "maxval",
                    type: "number",
                    defaultValue: 1
                }, {
                    tfName: "dtype",
                    name: "dtype",
                    type: "dtype"
                }, {
                    tfName: "seed",
                    name: "seed",
                    type: "number",
                    defaultValue: 0
                }, {
                    tfName: "seed2",
                    name: "seed2",
                    type: "number",
                    defaultValue: 0,
                    notSupported: !0
                }, {
                    tfName: "T",
                    name: "T",
                    type: "number",
                    notSupported: !0
                }]
            }, {
                tfOpName: "RandomUniformInt",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "shape",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "minval",
                    name: "minval",
                    type: "number"
                }, {
                    tfName: "maxval",
                    name: "maxval",
                    type: "number"
                }, {
                    tfName: "seed",
                    name: "seed",
                    type: "number",
                    defaultValue: 0
                }, {
                    tfName: "seed2",
                    name: "seed2",
                    type: "number",
                    defaultValue: 0,
                    notSupported: !0
                }]
            }, {
                tfOpName: "Range",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "start",
                    type: "number"
                }, {
                    start: 1,
                    name: "stop",
                    type: "number"
                }, {
                    start: 2,
                    name: "step",
                    type: "number",
                    defaultValue: 0
                }],
                attrs: [{
                    tfName: "Tidx",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "TruncatedNormal",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "shape",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "means",
                    name: "mean",
                    type: "number",
                    defaultValue: 0
                }, {
                    tfName: "stddev",
                    name: "stdDev",
                    type: "number",
                    defaultValue: 1
                }, {
                    tfName: "seed",
                    name: "seed",
                    type: "number"
                }, {
                    tfName: "seed2",
                    name: "seed2",
                    type: "number",
                    defaultValue: 0,
                    notSupported: !0
                }, {
                    tfName: "dtype",
                    name: "dtype",
                    type: "dtype"
                }, {
                    tfName: "T",
                    name: "T",
                    type: "number",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Zeros",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "shape",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "ZerosLike",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "Multinomial",
                category: "creation",
                inputs: [{
                    start: 0,
                    name: "logits",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "numSamples",
                    type: "number"
                }],
                attrs: [{
                    tfName: "seed",
                    name: "seed",
                    type: "number"
                }, {
                    tfName: "seed2",
                    name: "seed2",
                    type: "number"
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype"
                }, {
                    tfName: "output_dtype",
                    name: "output_dtype",
                    type: "dtype"
                }]
            }]
        },
        Ide = {
            __proto__: null,
            json: [{
                tfOpName: "NonMaxSuppressionV2",
                category: "dynamic",
                inputs: [{
                    start: 0,
                    name: "boxes",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "scores",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "maxOutputSize",
                    type: "number"
                }, {
                    start: 3,
                    name: "iouThreshold",
                    type: "number"
                }]
            }, {
                tfOpName: "NonMaxSuppressionV3",
                category: "dynamic",
                inputs: [{
                    start: 0,
                    name: "boxes",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "scores",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "maxOutputSize",
                    type: "number"
                }, {
                    start: 3,
                    name: "iouThreshold",
                    type: "number"
                }, {
                    start: 4,
                    name: "scoreThreshold",
                    type: "number"
                }]
            }, {
                tfOpName: "NonMaxSuppressionV4",
                category: "dynamic",
                inputs: [{
                    start: 0,
                    name: "boxes",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "scores",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "maxOutputSize",
                    type: "number"
                }, {
                    start: 3,
                    name: "iouThreshold",
                    type: "number"
                }, {
                    start: 4,
                    name: "scoreThreshold",
                    type: "number"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "T_threshold",
                    name: "threshold",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "pad_to_max_output_size",
                    name: "padToMaxOutputSize",
                    type: "bool"
                }]
            }, {
                tfOpName: "NonMaxSuppressionV5",
                category: "dynamic",
                inputs: [{
                    start: 0,
                    name: "boxes",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "scores",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "maxOutputSize",
                    type: "number"
                }, {
                    start: 3,
                    name: "iouThreshold",
                    type: "number"
                }, {
                    start: 4,
                    name: "scoreThreshold",
                    type: "number"
                }, {
                    start: 5,
                    name: "softNmsSigma",
                    type: "number"
                }]
            }, {
                tfOpName: "Where",
                category: "dynamic",
                inputs: [{
                    start: 0,
                    name: "condition",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "ListDiff",
                category: "dynamic",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "y",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }]
        },
        Nde = {
            __proto__: null,
            json: [{
                tfOpName: "LowerBound",
                category: "evaluation",
                inputs: [{
                    start: 0,
                    name: "sortedSequence",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "values",
                    type: "tensor"
                }]
            }, {
                tfOpName: "TopKV2",
                category: "evaluation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "k",
                    type: "number"
                }],
                attrs: [{
                    tfName: "sorted",
                    name: "sorted",
                    type: "bool"
                }]
            }, {
                tfOpName: "UpperBound",
                category: "evaluation",
                inputs: [{
                    start: 0,
                    name: "sortedSequence",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "values",
                    type: "tensor"
                }]
            }, {
                tfOpName: "Unique",
                category: "evaluation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }]
            }, {
                tfOpName: "UniqueV2",
                category: "evaluation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number"
                }]
            }]
        },
        Sde = {
            __proto__: null,
            json: [{
                tfOpName: "PlaceholderWithDefault",
                category: "graph",
                inputs: [{
                    start: 0,
                    name: "default",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "shape",
                    name: "shape",
                    type: "shape"
                }, {
                    tfName: "dtype",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "Placeholder",
                category: "graph",
                attrs: [{
                    tfName: "shape",
                    name: "shape",
                    type: "shape"
                }, {
                    tfName: "dtype",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "Const",
                category: "graph"
            }, {
                tfOpName: "Identity",
                category: "graph",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }]
            }, {
                tfOpName: "IdentityN",
                category: "graph",
                inputs: [{
                    start: 0,
                    end: 0,
                    name: "x",
                    type: "tensors"
                }]
            }, {
                tfOpName: "Snapshot",
                category: "graph",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }]
            }, {
                tfOpName: "Rank",
                category: "graph",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }]
            }, {
                tfOpName: "Size",
                category: "graph",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }]
            }, {
                tfOpName: "Shape",
                category: "graph",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }]
            }, {
                tfOpName: "ShapeN",
                category: "graph",
                inputs: [{
                    start: 0,
                    end: 0,
                    name: "x",
                    type: "tensors"
                }]
            }, {
                tfOpName: "Print",
                category: "graph",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "data",
                    type: "tensors"
                }],
                attrs: [{
                    tfName: "message",
                    name: "message",
                    type: "string"
                }, {
                    tfName: "first_n",
                    name: "firstN",
                    type: "number",
                    notSupported: !0
                }, {
                    tfName: "summarize",
                    name: "summarize",
                    type: "number",
                    defaultValue: 3
                }]
            }, {
                tfOpName: "NoOp",
                category: "graph",
                inputs: []
            }, {
                tfOpName: "StopGradient",
                category: "graph",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }]
            }, {
                tfOpName: "FakeQuantWithMinMaxVars",
                category: "graph",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "min",
                    name: "min",
                    type: "number"
                }, {
                    tfName: "max",
                    name: "max",
                    type: "number"
                }]
            }]
        },
        Tde = {
            __proto__: null,
            json: [{
                tfOpName: "HashTable",
                category: "hash_table",
                inputs: [],
                attrs: [{
                    tfName: "shared_name",
                    name: "sharedName",
                    type: "string"
                }, {
                    tfName: "use_node_name_sharing",
                    name: "useNodeNameSharing",
                    type: "bool"
                }, {
                    tfName: "key_dtype",
                    name: "keyDType",
                    type: "dtype"
                }, {
                    tfName: "value_dtype",
                    name: "valueDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "HashTableV2",
                category: "hash_table",
                inputs: [],
                attrs: [{
                    tfName: "shared_name",
                    name: "sharedName",
                    type: "string"
                }, {
                    tfName: "use_node_name_sharing",
                    name: "useNodeNameSharing",
                    type: "bool"
                }, {
                    tfName: "key_dtype",
                    name: "keyDType",
                    type: "dtype"
                }, {
                    tfName: "value_dtype",
                    name: "valueDType",
                    type: "dtype"
                }]
            }, {
                tfOpName: "LookupTableImport",
                category: "hash_table",
                inputs: [{
                    start: 0,
                    name: "tableHandle",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "keys",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "values",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "Tin",
                    name: "tIn",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "Tout",
                    name: "tOut",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "LookupTableImportV2",
                category: "hash_table",
                inputs: [{
                    start: 0,
                    name: "tableHandle",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "keys",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "values",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "Tin",
                    name: "tIn",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "Tout",
                    name: "tOut",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "LookupTableFind",
                category: "hash_table",
                inputs: [{
                    start: 0,
                    name: "tableHandle",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "keys",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "defaultValue",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "Tin",
                    name: "tIn",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "Tout",
                    name: "tOut",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "LookupTableFindV2",
                category: "hash_table",
                inputs: [{
                    start: 0,
                    name: "tableHandle",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "keys",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "defaultValue",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "Tin",
                    name: "tIn",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "Tout",
                    name: "tOut",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "LookupTableSize",
                category: "hash_table",
                inputs: [{
                    start: 0,
                    name: "tableHandle",
                    type: "tensor"
                }]
            }, {
                tfOpName: "LookupTableSizeV2",
                category: "hash_table",
                inputs: [{
                    start: 0,
                    name: "tableHandle",
                    type: "tensor"
                }]
            }, {
                tfOpName: "InitializeTable",
                category: "hash_table",
                inputs: [{
                    start: 0,
                    name: "tableHandle",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "keys",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "values",
                    type: "tensor"
                }]
            }, {
                tfOpName: "InitializeTableV2",
                category: "hash_table",
                inputs: [{
                    start: 0,
                    name: "tableHandle",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "keys",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "values",
                    type: "tensor"
                }]
            }]
        },
        Ede = {
            __proto__: null,
            json: [{
                tfOpName: "ResizeBilinear",
                category: "image",
                inputs: [{
                    start: 0,
                    name: "images",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "size",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "align_corners",
                    name: "alignCorners",
                    type: "bool"
                }, {
                    tfName: "half_pixel_centers",
                    name: "halfPixelCenters",
                    type: "bool"
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "ResizeNearestNeighbor",
                category: "image",
                inputs: [{
                    start: 0,
                    name: "images",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "size",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "align_corners",
                    name: "alignCorners",
                    type: "bool"
                }, {
                    tfName: "half_pixel_centers",
                    name: "halfPixelCenters",
                    type: "bool"
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "CropAndResize",
                category: "image",
                inputs: [{
                    start: 0,
                    name: "image",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "boxes",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "boxInd",
                    type: "tensor"
                }, {
                    start: 3,
                    name: "cropSize",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "method",
                    name: "method",
                    type: "string"
                }, {
                    tfName: "extrapolation_value",
                    name: "extrapolationValue",
                    type: "number"
                }]
            }, {
                tfOpName: "ImageProjectiveTransformV3",
                category: "image",
                inputs: [{
                    start: 0,
                    name: "images",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "transforms",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "outputShape",
                    type: "number[]"
                }, {
                    start: 3,
                    name: "fillValue",
                    type: "number"
                }],
                attrs: [{
                    tfName: "interpolation",
                    name: "interpolation",
                    type: "string"
                }, {
                    tfName: "fill_mode",
                    name: "fillMode",
                    type: "string"
                }]
            }]
        },
        Cde = {
            __proto__: null,
            json: [{
                tfOpName: "Equal",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "NotEqual",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Greater",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "GreaterEqual",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Less",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "LessEqual",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "LogicalAnd",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "LogicalNot",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "LogicalOr",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Select",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "condition",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "SelectV2",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "condition",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "BitwiseAnd",
                category: "logical",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "y",
                    type: "tensor"
                }]
            }]
        },
        Ade = {
            __proto__: null,
            json: [{
                tfOpName: "_FusedMatMul",
                category: "matrices",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }, {
                    start: 2,
                    end: 0,
                    name: "args",
                    type: "tensors"
                }],
                attrs: [{
                    tfName: "num_args",
                    name: "numArgs",
                    type: "number"
                }, {
                    tfName: "fused_ops",
                    name: "fusedOps",
                    type: "string[]",
                    defaultValue: []
                }, {
                    tfName: "epsilon",
                    name: "epsilon",
                    type: "number",
                    defaultValue: 1e-4
                }, {
                    tfName: "transpose_a",
                    name: "transposeA",
                    type: "bool",
                    defaultValue: !1
                }, {
                    tfName: "transpose_b",
                    name: "transposeB",
                    type: "bool",
                    defaultValue: !1
                }, {
                    tfName: "leakyrelu_alpha",
                    name: "leakyreluAlpha",
                    type: "number",
                    defaultValue: .2
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "MatMul",
                category: "matrices",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "transpose_a",
                    name: "transposeA",
                    type: "bool",
                    defaultValue: !1
                }, {
                    tfName: "transpose_b",
                    name: "transposeB",
                    type: "bool",
                    defaultValue: !1
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "BatchMatMul",
                category: "matrices",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "adj_x",
                    name: "transposeA",
                    type: "bool",
                    defaultValue: !1
                }, {
                    tfName: "adj_y",
                    name: "transposeB",
                    type: "bool",
                    defaultValue: !1
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "BatchMatMulV2",
                category: "matrices",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "b",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "adj_x",
                    name: "transposeA",
                    type: "bool",
                    defaultValue: !1
                }, {
                    tfName: "adj_y",
                    name: "transposeB",
                    type: "bool",
                    defaultValue: !1
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Transpose",
                category: "matrices",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "perm",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Einsum",
                category: "matrices",
                inputs: [{
                    start: 0,
                    end: 0,
                    name: "tensors",
                    type: "tensors"
                }],
                attrs: [{
                    tfName: "equation",
                    name: "equation",
                    type: "string"
                }, {
                    tfName: "N",
                    name: "n",
                    type: "number",
                    defaultValue: 2
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "MatrixBandPart",
                category: "matrices",
                inputs: [{
                    start: 0,
                    name: "a",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "numLower",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "numUpper",
                    type: "tensor"
                }]
            }]
        },
        Rde = {
            __proto__: null,
            json: [{
                tfOpName: "EuclideanNorm",
                category: "normalization",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "keep_dims",
                    name: "keepDims",
                    type: "bool",
                    defaultValue: !1
                }]
            }, {
                tfOpName: "FusedBatchNorm",
                category: "normalization",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "scale",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "offset",
                    type: "tensor"
                }, {
                    start: 3,
                    name: "mean",
                    type: "tensor"
                }, {
                    start: 4,
                    name: "variance",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "epsilon",
                    name: "epsilon",
                    type: "number",
                    defaultValue: .001
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    notSupported: !0
                }]
            }, {
                tfOpName: "FusedBatchNormV2",
                category: "normalization",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "scale",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "offset",
                    type: "tensor"
                }, {
                    start: 3,
                    name: "mean",
                    type: "tensor"
                }, {
                    start: 4,
                    name: "variance",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "epsilon",
                    name: "epsilon",
                    type: "number",
                    defaultValue: .001
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    notSupported: !0
                }]
            }, {
                tfOpName: "FusedBatchNormV3",
                category: "normalization",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "scale",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "offset",
                    type: "tensor"
                }, {
                    start: 3,
                    name: "mean",
                    type: "tensor"
                }, {
                    start: 4,
                    name: "variance",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "epsilon",
                    name: "epsilon",
                    type: "number",
                    defaultValue: .001
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string",
                    notSupported: !0
                }]
            }, {
                tfOpName: "LRN",
                category: "normalization",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "depth_radius",
                    name: "radius",
                    type: "number",
                    defaultValue: 5
                }, {
                    tfName: "bias",
                    name: "bias",
                    type: "number",
                    defaultValue: 1
                }, {
                    tfName: "alpha",
                    name: "alpha",
                    type: "number",
                    defaultValue: 1
                }, {
                    tfName: "beta",
                    name: "beta",
                    type: "number",
                    defaultValue: .5
                }]
            }, {
                tfOpName: "Softmax",
                category: "normalization",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }]
            }, {
                tfOpName: "LogSoftmax",
                category: "normalization",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }]
            }]
        },
        _de = {
            __proto__: null,
            json: [{
                tfOpName: "Bincount",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "size",
                    type: "number"
                }, {
                    start: 2,
                    name: "weights",
                    type: "tensor"
                }]
            }, {
                tfOpName: "DenseBincount",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "size",
                    type: "number"
                }, {
                    start: 2,
                    name: "weights",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "binary_output",
                    name: "binaryOutput",
                    type: "bool"
                }]
            }, {
                tfOpName: "Max",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "keep_dims",
                    name: "keepDims",
                    type: "bool"
                }]
            }, {
                tfOpName: "Mean",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "keep_dims",
                    name: "keepDims",
                    type: "bool"
                }]
            }, {
                tfOpName: "Min",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "keep_dims",
                    name: "keepDims",
                    type: "bool"
                }]
            }, {
                tfOpName: "Sum",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "keep_dims",
                    name: "keepDims",
                    type: "bool"
                }]
            }, {
                tfOpName: "All",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "keep_dims",
                    name: "keepDims",
                    type: "bool"
                }]
            }, {
                tfOpName: "Any",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "keep_dims",
                    name: "keepDims",
                    type: "bool"
                }]
            }, {
                tfOpName: "ArgMax",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number"
                }]
            }, {
                tfOpName: "ArgMin",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number"
                }]
            }, {
                tfOpName: "Prod",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "keep_dims",
                    name: "keepDims",
                    type: "bool"
                }, {
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Cumprod",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number"
                }],
                attrs: [{
                    tfName: "exclusive",
                    name: "exclusive",
                    type: "bool"
                }, {
                    tfName: "reverse",
                    name: "reverse",
                    type: "bool"
                }]
            }, {
                tfOpName: "Cumsum",
                category: "reduction",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number"
                }],
                attrs: [{
                    tfName: "exclusive",
                    name: "exclusive",
                    type: "bool"
                }, {
                    tfName: "reverse",
                    name: "reverse",
                    type: "bool"
                }]
            }]
        },
        Ode = {
            __proto__: null,
            json: [{
                tfOpName: "ConcatV2",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    end: -1,
                    name: "tensors",
                    type: "tensors"
                }, {
                    start: -1,
                    name: "axis",
                    type: "number"
                }],
                attrs: [{
                    tfName: "N",
                    name: "n",
                    type: "number",
                    defaultValue: 2
                }]
            }, {
                tfOpName: "Concat",
                category: "slice_join",
                inputs: [{
                    start: 1,
                    end: 0,
                    name: "tensors",
                    type: "tensors"
                }, {
                    start: 0,
                    name: "axis",
                    type: "number"
                }],
                attrs: [{
                    tfName: "N",
                    name: "n",
                    type: "number",
                    defaultValue: 2
                }]
            }, {
                tfOpName: "GatherV2",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "indices",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "axis",
                    type: "number",
                    defaultValue: 0
                }],
                attrs: [{
                    tfName: "batch_dims",
                    name: "batchDims",
                    type: "number",
                    defaultValue: 0
                }]
            }, {
                tfOpName: "Gather",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "indices",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "validate_indices",
                    name: "validateIndices",
                    type: "bool",
                    notSupported: !0
                }]
            }, {
                tfOpName: "Reverse",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "dims",
                    type: "bool[]"
                }]
            }, {
                tfOpName: "ReverseV2",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number[]"
                }]
            }, {
                tfOpName: "Slice",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "begin",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "size",
                    type: "number[]"
                }]
            }, {
                tfOpName: "StridedSlice",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "begin",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "end",
                    type: "number[]"
                }, {
                    start: 3,
                    name: "strides",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "begin_mask",
                    name: "beginMask",
                    type: "number",
                    defaultValue: 0
                }, {
                    tfName: "end_mask",
                    name: "endMask",
                    type: "number",
                    defaultValue: 0
                }, {
                    tfName: "new_axis_mask",
                    name: "newAxisMask",
                    type: "number",
                    defaultValue: 0
                }, {
                    tfName: "ellipsis_mask",
                    name: "ellipsisMask",
                    type: "number",
                    defaultValue: 0
                }, {
                    tfName: "shrink_axis_mask",
                    name: "shrinkAxisMask",
                    type: "number",
                    defaultValue: 0
                }]
            }, {
                tfOpName: "Pack",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    end: 0,
                    name: "tensors",
                    type: "tensors"
                }],
                attrs: [{
                    tfName: "axis",
                    name: "axis",
                    type: "number",
                    defaultValue: 0
                }]
            }, {
                tfOpName: "Unpack",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "tensor",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "axis",
                    name: "axis",
                    type: "number",
                    defaultValue: 0
                }, {
                    tfName: "num",
                    name: "num",
                    type: "number",
                    defaultValue: 0,
                    notSupported: !0
                }]
            }, {
                tfOpName: "Tile",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "reps",
                    type: "number[]"
                }]
            }, {
                tfOpName: "Split",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "axis",
                    type: "number",
                    defaultValue: 0
                }, {
                    start: 1,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "num_split",
                    name: "numOrSizeSplits",
                    type: "number",
                    defaultValue: 1
                }]
            }, {
                tfOpName: "SplitV",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "numOrSizeSplits",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "axis",
                    type: "number",
                    defaultValue: 0
                }]
            }, {
                tfOpName: "ScatterNd",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "indices",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "values",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "shape",
                    type: "number[]"
                }]
            }, {
                tfOpName: "GatherNd",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "indices",
                    type: "tensor"
                }]
            }, {
                tfOpName: "SparseToDense",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "sparseIndices",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "outputShape",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "sparseValues",
                    type: "tensor"
                }, {
                    start: 3,
                    name: "defaultValue",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "validate_indices",
                    name: "validateIndices",
                    type: "bool",
                    defaultValue: !1,
                    notSupported: !0
                }]
            }, {
                tfOpName: "TensorScatterUpdate",
                category: "slice_join",
                inputs: [{
                    start: 0,
                    name: "tensor",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "indices",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "values",
                    type: "tensor"
                }]
            }]
        },
        Fde = {
            __proto__: null,
            json: [{
                tfOpName: "SparseFillEmptyRows",
                category: "sparse",
                inputs: [{
                    start: 0,
                    name: "indices",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "values",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "denseShape",
                    type: "tensor"
                }, {
                    start: 3,
                    name: "defaultValue",
                    type: "tensor"
                }]
            }, {
                tfOpName: "SparseReshape",
                category: "sparse",
                inputs: [{
                    start: 0,
                    name: "inputIndices",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "inputShape",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "newShape",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "T",
                    name: "dtype",
                    type: "dtype",
                    notSupported: !0
                }]
            }, {
                tfOpName: "SparseSegmentMean",
                category: "sparse",
                inputs: [{
                    start: 0,
                    name: "data",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "indices",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "segmentIds",
                    type: "tensor"
                }]
            }, {
                tfOpName: "SparseSegmentSum",
                category: "sparse",
                inputs: [{
                    start: 0,
                    name: "data",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "indices",
                    type: "tensor"
                }, {
                    start: 2,
                    name: "segmentIds",
                    type: "tensor"
                }]
            }]
        },
        Dde = {
            __proto__: null,
            json: [{
                tfOpName: "FFT",
                category: "spectral",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }]
            }, {
                tfOpName: "IFFT",
                category: "spectral",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }]
            }, {
                tfOpName: "RFFT",
                category: "spectral",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "fft_length",
                    type: "number",
                    notSupported: !0
                }]
            }, {
                tfOpName: "IRFFT",
                category: "spectral",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "fft_length",
                    type: "number",
                    notSupported: !0
                }]
            }]
        },
        Mde = {
            __proto__: null,
            json: [{
                tfOpName: "StaticRegexReplace",
                category: "string",
                inputs: [{
                    start: 0,
                    name: "input",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "pattern",
                    name: "pattern",
                    type: "string"
                }, {
                    tfName: "rewrite",
                    name: "rewrite",
                    type: "string"
                }, {
                    tfName: "replace_global",
                    name: "replaceGlobal",
                    type: "bool"
                }]
            }, {
                tfOpName: "StringNGrams",
                category: "string",
                inputs: [{
                    start: 0,
                    name: "data",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "dataSplits",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "separator",
                    name: "separator",
                    type: "string"
                }, {
                    tfName: "ngram_widths",
                    name: "nGramWidths",
                    type: "number[]"
                }, {
                    tfName: "left_pad",
                    name: "leftPad",
                    type: "string"
                }, {
                    tfName: "right_pad",
                    name: "rightPad",
                    type: "string"
                }, {
                    tfName: "pad_width",
                    name: "padWidth",
                    type: "number"
                }, {
                    tfName: "preserve_short_sequences",
                    name: "preserveShortSequences",
                    type: "bool"
                }],
                outputs: ["ngrams", "ngrams_splits"]
            }, {
                tfOpName: "StringSplit",
                category: "string",
                inputs: [{
                    start: 0,
                    name: "input",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "delimiter",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "skip_empty",
                    name: "skipEmpty",
                    type: "bool"
                }],
                outputs: ["indices", "values", "shape"]
            }, {
                tfOpName: "StringToHashBucketFast",
                category: "string",
                inputs: [{
                    start: 0,
                    name: "input",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "num_buckets",
                    name: "numBuckets",
                    type: "number"
                }]
            }]
        },
        Lde = {
            __proto__: null,
            json: [{
                tfOpName: "Cast",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "SrcT",
                    name: "sdtype",
                    type: "dtype",
                    notSupported: !0
                }, {
                    tfName: "DstT",
                    name: "dtype",
                    type: "dtype"
                }]
            }, {
                tfOpName: "ExpandDims",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "axis",
                    type: "number"
                }]
            }, {
                tfOpName: "MirrorPad",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "padding",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "mode",
                    name: "mode",
                    type: "string"
                }]
            }, {
                tfOpName: "Pad",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "padding",
                    type: "number[]"
                }],
                attrs: [{
                    tfName: "constant_value",
                    name: "constantValue",
                    type: "number",
                    defaultValue: 0
                }]
            }, {
                tfOpName: "PadV2",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "padding",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "constantValue",
                    type: "number",
                    defaultValue: 0
                }]
            }, {
                tfOpName: "Reshape",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "shape",
                    type: "number[]"
                }]
            }, {
                tfOpName: "EnsureShape",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "shape",
                    type: "number[]"
                }]
            }, {
                tfOpName: "Squeeze",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "axis",
                    tfDeprecatedName: "squeeze_dims",
                    name: "axis",
                    type: "number[]"
                }]
            }, {
                tfOpName: "SpaceToBatchND",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "blockShape",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "paddings",
                    type: "number[]"
                }]
            }, {
                tfOpName: "BatchToSpaceND",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "blockShape",
                    type: "number[]"
                }, {
                    start: 2,
                    name: "crops",
                    type: "number[]"
                }]
            }, {
                tfOpName: "DepthToSpace",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }],
                attrs: [{
                    tfName: "block_size",
                    name: "blockSize",
                    type: "number"
                }, {
                    tfName: "data_format",
                    name: "dataFormat",
                    type: "string"
                }]
            }, {
                tfOpName: "BroadcastTo",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "x",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "shape",
                    type: "number[]"
                }],
                attrs: []
            }, {
                tfOpName: "BroadcastArgs",
                category: "transformation",
                inputs: [{
                    start: 0,
                    name: "s0",
                    type: "tensor"
                }, {
                    start: 1,
                    name: "s1",
                    type: "tensor"
                }],
                attrs: []
            }]
        },
        zde = function() {
            function e() {
                var t;
                l(this, e);
                var n = [yde, bde, xde, kde, wde, Ide, Nde, Sde, Tde, Ede, Cde, Ade, Rde, _de, Ode, Fde, Dde, Mde, Lde],
                    r = (t = []).concat.apply(t, T(n.map((function(e) {
                        return e.json
                    }))));
                this.opMappers = r.reduce((function(e, t) {
                    return e[t.tfOpName] = t, e
                }), {})
            }
            return p(e, [{
                key: "transformGraph",
                value: function(e) {
                    var t = this,
                        n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                        r = e.node,
                        a = [],
                        i = [],
                        o = [],
                        s = r.reduce((function(e, n) {
                            return e[n.name] = t.mapNode(n), n.op.startsWith("Placeholder") ? a.push(e[n.name]) : "Const" === n.op ? i.push(e[n.name]) : null != n.input && 0 !== n.input.length || o.push(e[n.name]), e
                        }), {}),
                        u = [],
                        c = [],
                        l = {},
                        h = {};
                    null != n && (l = this.mapSignatureEntries(n.inputs), h = this.mapSignatureEntries(n.outputs));
                    var p = Object.keys(s);
                    p.forEach((function(e) {
                        var t = s[e];
                        t.inputNames.forEach((function(e, n) {
                            var r = S(fde(e), 3),
                                a = r[0],
                                i = r[2],
                                o = s[a];
                            if (null != o.outputs) {
                                var u = o.outputs.indexOf(i);
                                if (-1 !== u) {
                                    var c = "".concat(a, ":").concat(u);
                                    t.inputNames[n] = c
                                }
                            }
                            t.inputs.push(o), o.children.push(t)
                        }))
                    })), 0 === Object.keys(h).length ? p.forEach((function(e) {
                        var t = s[e];
                        0 === t.children.length && c.push(t)
                    })) : Object.keys(h).forEach((function(e) {
                        var t = S(fde(e), 1)[0],
                            n = s[t];
                        null != n && (n.signatureKey = h[e], c.push(n))
                    })), Object.keys(l).length > 0 ? Object.keys(l).forEach((function(e) {
                        var t = S(fde(e), 1)[0],
                            n = s[t];
                        n && (n.signatureKey = l[e], u.push(n))
                    })) : u = a;
                    var f = {};
                    null != e.library && null != e.library.function && (f = e.library.function.reduce((function(e, n) {
                        return e[n.signature.name] = t.mapFunction(n), e
                    }), {}));
                    var d = {
                        nodes: s,
                        inputs: u,
                        outputs: c,
                        weights: i,
                        placeholders: a,
                        signature: n,
                        functions: f
                    };
                    return o.length > 0 && (d.initNodes = o), d
                }
            }, {
                key: "mapSignatureEntries",
                value: function(e) {
                    return Object.keys(e || {}).reduce((function(t, n) {
                        return t[e[n].name] = n, t
                    }), {})
                }
            }, {
                key: "mapNode",
                value: function(e) {
                    var t = cde(e.op) || this.opMappers[e.op] || {};
                    null == e.attr && (e.attr = {});
                    var n = {
                        name: e.name,
                        op: e.op,
                        category: t.category,
                        inputNames: (e.input || []).map((function(e) {
                            return e.startsWith("^") ? e.slice(1) : e
                        })),
                        inputs: [],
                        children: [],
                        inputParams: {},
                        attrParams: {},
                        rawAttrs: e.attr,
                        outputs: t.outputs
                    };
                    return null != t.inputs && (n.inputParams = t.inputs.reduce((function(e, t) {
                        return e[t.name] = {
                            type: t.type,
                            inputIndexStart: t.start,
                            inputIndexEnd: t.end
                        }, e
                    }), {})), null != t.attrs && (n.attrParams = t.attrs.reduce((function(t, n) {
                        var r = n.type,
                            a = void 0;
                        switch (n.type) {
                            case "string":
                                void 0 === (a = Bde(e.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (a = Bde(e.attr, n.tfDeprecatedName, n.defaultValue));
                                break;
                            case "string[]":
                                void 0 === (a = Yde(e.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (a = Yde(e.attr, n.tfDeprecatedName, n.defaultValue));
                                break;
                            case "number":
                                void 0 === (a = Ude(e.attr, n.tfName, n.defaultValue || 0)) && n.tfDeprecatedName && (a = Ude(e.attr, n.tfDeprecatedName, n.defaultValue));
                                break;
                            case "number[]":
                                void 0 === (a = Xde(e.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (a = Xde(e.attr, n.tfDeprecatedName, n.defaultValue));
                                break;
                            case "bool":
                                void 0 === (a = Wde(e.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (a = Wde(e.attr, n.tfDeprecatedName, n.defaultValue));
                                break;
                            case "bool[]":
                                void 0 === (a = Zde(e.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (a = Zde(e.attr, n.tfDeprecatedName, n.defaultValue));
                                break;
                            case "shape":
                                void 0 === (a = Kde(e.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (a = Kde(e.attr, n.tfDeprecatedName, n.defaultValue));
                                break;
                            case "shape[]":
                                void 0 === (a = Jde(e.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (a = Jde(e.attr, n.tfDeprecatedName, n.defaultValue));
                                break;
                            case "dtype":
                                void 0 === (a = jde(e.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (a = jde(e.attr, n.tfDeprecatedName, n.defaultValue));
                                break;
                            case "dtype[]":
                                void 0 === (a = Hde(e.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (a = Hde(e.attr, n.tfDeprecatedName, n.defaultValue));
                                break;
                            case "func":
                                void 0 === (a = Gde(e.attr, n.tfName, n.defaultValue)) && n.tfDeprecatedName && (a = Gde(e.attr, n.tfDeprecatedName, n.defaultValue));
                                break;
                            case "tensor":
                            case "tensors":
                                break;
                            default:
                                throw new Error("Unsupported param type: ".concat(n.type, " for op: ").concat(e.op))
                        }
                        return t[n.name] = {
                            value: a,
                            type: r
                        }, t
                    }), {})), n
                }
            }, {
                key: "mapFunction",
                value: function(e) {
                    var t = this,
                        n = e.nodeDef,
                        r = [],
                        a = {};
                    null != n && (a = n.reduce((function(e, n) {
                        return e[n.name] = t.mapNode(n), "Const" === n.op && r.push(e[n.name]), e
                    }), {}));
                    var i = [],
                        o = [];
                    e.signature.inputArg.forEach((function(e) {
                        var t = S(fde(e.name), 1)[0],
                            n = {
                                name: t,
                                op: "Placeholder",
                                inputs: [],
                                inputNames: [],
                                category: "graph",
                                inputParams: {},
                                attrParams: {
                                    dtype: {
                                        value: Vde(e.type),
                                        type: "dtype"
                                    }
                                },
                                children: []
                            };
                        n.signatureKey = e.name, i.push(n), a[t] = n
                    })), Object.keys(a).forEach((function(e) {
                        var t = a[e];
                        t.inputNames.forEach((function(e, n) {
                            var r = S(fde(e), 3),
                                i = r[0],
                                o = r[2],
                                s = a[i];
                            if (null != s.outputs) {
                                var u = s.outputs.indexOf(o);
                                if (-1 !== u) {
                                    var c = "".concat(i, ":").concat(u);
                                    t.inputNames[n] = c
                                }
                            }
                            t.inputs.push(s), s.children.push(t)
                        }))
                    }));
                    var s = e.ret;
                    e.signature.outputArg.forEach((function(e) {
                        var t = S(fde(s[e.name]), 2),
                            n = t[0],
                            r = t[1],
                            i = a[n];
                        null != i && (i.defaultOutput = r, o.push(i))
                    }));
                    var u = this.mapArgsToSignature(e);
                    return {
                        nodes: a,
                        inputs: i,
                        outputs: o,
                        weights: r,
                        placeholders: [],
                        signature: u
                    }
                }
            }, {
                key: "mapArgsToSignature",
                value: function(e) {
                    var t = this;
                    return {
                        methodName: e.signature.name,
                        inputs: e.signature.inputArg.reduce((function(e, n) {
                            return e[n.name] = t.mapArgToTensorInfo(n), e
                        }), {}),
                        outputs: e.signature.outputArg.reduce((function(n, r) {
                            return n[r.name] = t.mapArgToTensorInfo(r, e.ret), n
                        }), {})
                    }
                }
            }, {
                key: "mapArgToTensorInfo",
                value: function(e, t) {
                    var n = e.name;
                    return null != t && (n = t[n]), {
                        name: n,
                        dtype: e.type
                    }
                }
            }], [{
                key: "Instance",
                get: function() {
                    return this._instance || (this._instance = new this)
                }
            }]), e
        }();

    function Pde(e, t) {
        var n = Array.isArray(e) ? String.fromCharCode.apply(null, e) : function(e) {
            var t = k0().global;
            if (void 0 !== t.atob) return t.atob(e);
            if ("undefined" != typeof Buffer) return new Buffer(e, "base64").toString();
            throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")
        }(e);
        return t ? n : n.toLowerCase()
    }

    function Bde(e, t, n) {
        var r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
            a = e[t];
        return null != a ? Pde(a.s, r) : n
    }

    function Wde(e, t, n) {
        var r = e[t];
        return r ? r.b : n
    }

    function Ude(e, t, n) {
        var r = e[t] || {},
            a = null != r.i ? r.i : null != r.f ? r.f : n;
        return "number" == typeof a ? a : parseInt(a, 10)
    }

    function Vde(e) {
        switch ("string" == typeof e && (e = ide[e]), e) {
            case ide.DT_FLOAT:
            case ide.DT_HALF:
                return "float32";
            case ide.DT_INT32:
            case ide.DT_INT64:
            case ide.DT_INT8:
            case ide.DT_UINT8:
                return "int32";
            case ide.DT_BOOL:
                return "bool";
            case ide.DT_DOUBLE:
                return "float32";
            case ide.DT_STRING:
                return "string";
            case ide.DT_COMPLEX64:
            case ide.DT_COMPLEX128:
                return "complex64";
            default:
                return null
        }
    }

    function Gde(e, t, n) {
        var r = e[t];
        return r && r.func ? r.func.name : n
    }

    function jde(e, t, n) {
        var r = e[t];
        return r && r.type ? Vde(r.type) : n
    }

    function Hde(e, t, n) {
        var r = e[t];
        return r && r.list && r.list.type ? r.list.type.map((function(e) {
            return Vde(e)
        })) : n
    }

    function qde(e) {
        if (!e.unknownRank) return null != e.dim ? e.dim.map((function(e) {
            return "number" == typeof e.size ? e.size : parseInt(e.size, 10)
        })) : []
    }

    function Kde(e, t, n) {
        var r = e[t];
        return r && r.shape ? qde(r.shape) : n
    }

    function Xde(e, t, n) {
        var r = e[t];
        return r ? ((r.list.f && r.list.f.length ? r.list.f : r.list.i) || []).map((function(e) {
            return "number" == typeof e ? e : parseInt(e, 10)
        })) : n
    }

    function Yde(e, t, n) {
        var r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
            a = e[t];
        return a && a.list && a.list.s ? a.list.s.map((function(e) {
            return Pde(e, r)
        })) : n
    }

    function Jde(e, t, n) {
        var r = e[t];
        return r && r.list && r.list.shape ? r.list.shape.map((function(e) {
            return qde(e)
        })) : n
    }

    function Zde(e, t, n) {
        var r = e[t];
        return r && r.list && r.list.b ? r.list.b : n
    }
    var Qde = function() {
            function e(t, n, r) {
                var a = this;
                l(this, e), this.node = t, this.tensorMap = n, this.context = r, this.inputs = [], this.attrs = {}, this.inputs = t.inputNames.map((function(e) {
                    return a.getInput(e)
                })), null != t.rawAttrs && (this.attrs = Object.keys(t.rawAttrs).reduce((function(e, t) {
                    return e[t] = a.getAttr(t), e
                }), {}))
            }
            return p(e, [{
                key: "getInput",
                value: function(e) {
                    return hde(e, this.tensorMap, this.context)
                }
            }, {
                key: "getAttr",
                value: function(e, t) {
                    var n = this.node.rawAttrs[e];
                    if (null != n.tensor) return hde(e, this.tensorMap, this.context);
                    if (null != n.i || null != n.f) return Ude(this.node.rawAttrs, e, t);
                    if (null != n.s) return Bde(this.node.rawAttrs, e, t);
                    if (null != n.b) return Wde(this.node.rawAttrs, e, t);
                    if (null != n.shape) return Kde(this.node.rawAttrs, e, t);
                    if (null != n.type) return jde(this.node.rawAttrs, e, t);
                    if (null != n.list) {
                        if (null != n.list.i || null != n.list.f) return Xde(this.node.rawAttrs, e, t);
                        if (null != n.list.s) return Yde(this.node.rawAttrs, e, t);
                        if (null != n.list.shape) return Jde(this.node.rawAttrs, e, t);
                        if (null != n.list.b) return Zde(this.node.rawAttrs, e, t);
                        if (null != n.list.type) return Hde(this.node.rawAttrs, e, t)
                    }
                    return t
                }
            }]), e
        }(),
        $de = {
            __proto__: null,
            OP_SCOPE_SUFFIX: P5,
            abs: y8,
            acos: b8,
            acosh: x8,
            add: d8,
            addN: k8,
            all: w8,
            any: I8,
            argMax: N8,
            argMin: S8,
            asin: T8,
            asinh: E8,
            atan: C8,
            atan2: A8,
            atanh: R8,
            avgPool: Y8,
            avgPool3d: J8,
            basicLSTMCell: n7,
            batchNorm: a7,
            batchNorm2d: i7,
            batchNorm3d: o7,
            batchNorm4d: s7,
            batchToSpaceND: r7,
            bincount: u7,
            bitwiseAnd: c7,
            booleanMaskAsync: lne,
            broadcastArgs: l7,
            broadcastTo: h7,
            buffer: l8,
            cast: h8,
            ceil: p7,
            clipByValue: d7,
            clone: p8,
            complex: W5,
            concat: Z8,
            concat1d: v7,
            concat2d: m7,
            concat3d: g7,
            concat4d: y7,
            conv1d: x7,
            conv2d: b7,
            conv2dTranspose: w7,
            conv3d: I7,
            conv3dTranspose: S7,
            cos: T7,
            cosh: E7,
            cosineWindow: bne,
            cumprod: C7,
            cumsum: A7,
            denseBincount: R7,
            depthToSpace: _7,
            depthwiseConv2d: O7,
            diag: F7,
            dilation2d: D7,
            div: m8,
            divNoNan: V7,
            dot: G7,
            dropout: gne,
            einsum: j7,
            elu: H7,
            enclosingPowerOfTwo: yne,
            ensureShape: q7,
            equal: B7,
            erf: K7,
            euclideanNorm: h9,
            exp: p9,
            expandDims: f9,
            expm1: d9,
            eye: m9,
            fft: _te,
            fill: f7,
            floor: g9,
            floorDiv: v8,
            fused: One,
            gather: y9,
            gatherND: mne,
            greater: b9,
            greaterEqual: x9,
            ifft: Ote,
            imag: k9,
            image: Pre,
            inTopKAsync: kne,
            irfft: Fte,
            isFinite: w9,
            isInf: I9,
            isNaN: N9,
            leakyRelu: S9,
            less: T9,
            lessEqual: E9,
            linalg: Bre,
            linspace: C9,
            localResponseNormalization: A9,
            log: R9,
            log1p: _9,
            logSigmoid: z9,
            logSoftmax: B9,
            logSumExp: W9,
            logicalAnd: U9,
            logicalNot: V9,
            logicalOr: G9,
            logicalXor: j9,
            losses: Wre,
            lowerBound: K9,
            matMul: Q8,
            max: n9,
            maxPool: X9,
            maxPool3d: Y9,
            maxPoolWithArgmax: J9,
            maximum: Z9,
            mean: Q9,
            meshgrid: tee,
            min: r9,
            minimum: nee,
            mirrorPad: ree,
            mod: aee,
            moments: iee,
            movingAverage: pne,
            mul: g8,
            multiRNNCell: oee,
            multinomial: see,
            neg: M9,
            norm: l9,
            notEqual: uee,
            oneHot: cee,
            ones: eee,
            onesLike: lee,
            op: B5,
            outerProduct: hee,
            pad: pee,
            pad1d: fee,
            pad2d: dee,
            pad3d: vee,
            pad4d: mee,
            pool: yee,
            pow: a9,
            prelu: bee,
            print: f8,
            prod: xee,
            raggedGather: kee,
            raggedRange: wee,
            raggedTensorToTensor: Iee,
            rand: Nee,
            randomGamma: nte,
            randomNormal: rte,
            randomStandardNormal: ate,
            randomUniform: ite,
            randomUniformInt: ote,
            range: ste,
            real: ute,
            reciprocal: cte,
            relu: lte,
            relu6: hte,
            reshape: X8,
            reverse: pte,
            reverse1d: fte,
            reverse2d: dte,
            reverse3d: vte,
            reverse4d: mte,
            rfft: Mte,
            round: gte,
            rsqrt: yte,
            scalar: i9,
            scatterND: fne,
            searchSorted: q9,
            selu: bte,
            separableConv2d: xte,
            setdiff1dAsync: wte,
            sigmoid: $8,
            sign: Ite,
            signal: zre,
            sin: Nte,
            sinh: Ste,
            slice: e7,
            slice1d: Tte,
            slice2d: Ete,
            slice3d: Cte,
            slice4d: Ate,
            softmax: Rte,
            softplus: L9,
            spaceToBatchND: gee,
            sparse: Ure,
            sparseToDense: vne,
            spectral: Lre,
            split: Dte,
            sqrt: o9,
            square: s9,
            squaredDifference: Lte,
            squeeze: zte,
            stack: Pte,
            step: Bte,
            stridedSlice: Wte,
            string: Vre,
            sub: P9,
            sum: u9,
            tan: Ute,
            tanh: t7,
            tensor: V5,
            tensor1d: Vte,
            tensor2d: Gte,
            tensor3d: jte,
            tensor4d: Hte,
            tensor5d: qte,
            tensor6d: Kte,
            tensorScatterUpdate: Qte,
            tile: v9,
            topk: $te,
            transpose: hne,
            truncatedNormal: ene,
            unique: tne,
            unsortedSegmentSum: nne,
            unstack: rne,
            upperBound: ane,
            variable: ine,
            where: W7,
            whereAsync: une,
            zeros: $9,
            zerosLike: U7
        },
        eve = function(e, t, n) {
            var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : $de;
            switch (e.op) {
                case "BiasAdd":
                case "AddV2":
                case "Add":
                    return [r.add(lde("a", e, t, n), lde("b", e, t, n))];
                case "AddN":
                    return [r.addN(lde("tensors", e, t, n))];
                case "FloorMod":
                case "Mod":
                    return [r.mod(lde("a", e, t, n), lde("b", e, t, n))];
                case "Mul":
                    return [r.mul(lde("a", e, t, n), lde("b", e, t, n))];
                case "RealDiv":
                case "Div":
                    return [r.div(lde("a", e, t, n), lde("b", e, t, n))];
                case "DivNoNan":
                    return [r.divNoNan(lde("a", e, t, n), lde("b", e, t, n))];
                case "FloorDiv":
                    return [r.floorDiv(lde("a", e, t, n), lde("b", e, t, n))];
                case "Sub":
                    return [r.sub(lde("a", e, t, n), lde("b", e, t, n))];
                case "Minimum":
                    return [r.minimum(lde("a", e, t, n), lde("b", e, t, n))];
                case "Maximum":
                    return [r.maximum(lde("a", e, t, n), lde("b", e, t, n))];
                case "Pow":
                    return [r.pow(lde("a", e, t, n), lde("b", e, t, n))];
                case "SquaredDifference":
                    return [r.squaredDifference(lde("a", e, t, n), lde("b", e, t, n))];
                default:
                    throw TypeError("Node type ".concat(e.op, " is not implemented"))
            }
        },
        tve = function(e, t, n) {
            var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : $de;
            switch (e.op) {
                case "Abs":
                case "ComplexAbs":
                    return [r.abs(lde("x", e, t, n))];
                case "Acos":
                    return [r.acos(lde("x", e, t, n))];
                case "Acosh":
                    return [r.acosh(lde("x", e, t, n))];
                case "Asin":
                    return [r.asin(lde("x", e, t, n))];
                case "Asinh":
                    return [r.asinh(lde("x", e, t, n))];
                case "Atan":
                    return [r.atan(lde("x", e, t, n))];
                case "Atan2":
                    return [r.atan2(lde("x", e, t, n), lde("y", e, t, n))];
                case "Atanh":
                    return [r.atanh(lde("x", e, t, n))];
                case "Ceil":
                    return [r.ceil(lde("x", e, t, n))];
                case "Complex":
                    return [r.complex(lde("real", e, t, n), lde("imag", e, t, n))];
                case "Cos":
                    return [r.cos(lde("x", e, t, n))];
                case "Cosh":
                    return [r.cosh(lde("x", e, t, n))];
                case "Elu":
                    return [r.elu(lde("x", e, t, n))];
                case "Erf":
                    return [r.erf(lde("x", e, t, n))];
                case "Exp":
                    return [r.exp(lde("x", e, t, n))];
                case "Expm1":
                    return [r.expm1(lde("x", e, t, n))];
                case "Floor":
                    return [r.floor(lde("x", e, t, n))];
                case "Log":
                    return [r.log(lde("x", e, t, n))];
                case "Log1p":
                    return [r.log1p(lde("x", e, t, n))];
                case "Imag":
                    return [r.imag(lde("x", e, t, n))];
                case "Neg":
                    return [r.neg(lde("x", e, t, n))];
                case "Reciprocal":
                    return [r.reciprocal(lde("x", e, t, n))];
                case "Real":
                    return [r.real(lde("x", e, t, n))];
                case "Relu":
                    return [r.relu(lde("x", e, t, n))];
                case "Round":
                    return [r.round(lde("x", e, t, n))];
                case "Selu":
                    return [r.selu(lde("x", e, t, n))];
                case "Sigmoid":
                    return [r.sigmoid(lde("x", e, t, n))];
                case "Sin":
                    return [r.sin(lde("x", e, t, n))];
                case "Sign":
                    return [r.sign(lde("x", e, t, n))];
                case "Sinh":
                    return [r.sinh(lde("x", e, t, n))];
                case "Softplus":
                    return [r.softplus(lde("x", e, t, n))];
                case "Sqrt":
                    return [r.sqrt(lde("x", e, t, n))];
                case "Square":
                    return [r.square(lde("x", e, t, n))];
                case "Tanh":
                    return [r.tanh(lde("x", e, t, n))];
                case "Tan":
                    return [r.tan(lde("x", e, t, n))];
                case "ClipByValue":
                    return [r.clipByValue(lde("x", e, t, n), lde("clipValueMin", e, t, n), lde("clipValueMax", e, t, n))];
                case "Relu6":
                    return [r.relu6(lde("x", e, t, n))];
                case "Rsqrt":
                    return [r.rsqrt(hde(e.inputNames[0], t, n))];
                case "LeakyRelu":
                    return [r.leakyRelu(lde("x", e, t, n), lde("alpha", e, t, n))];
                case "Prelu":
                    return [r.prelu(lde("x", e, t, n), lde("alpha", e, t, n))];
                case "IsNan":
                    return [r.isNaN(hde(e.inputNames[0], t, n))];
                case "IsInf":
                    return [r.isInf(hde(e.inputNames[0], t, n))];
                case "IsFinite":
                    return [r.isFinite(hde(e.inputNames[0], t, n))];
                default:
                    throw TypeError("Node type ".concat(e.op, " is not implemented"))
            }
        };

    function nve(e, t) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "";
        if ("number" != typeof e && "number" != typeof t) {
            F$(e.length === t.length, (function() {
                return n + " Shapes ".concat(e, " and ").concat(t, " must match")
            }));
            for (var r = 0; r < e.length; r++) {
                var a = e[r],
                    i = t[r];
                F$(a < 0 || i < 0 || a === i, (function() {
                    return n + " Shapes ".concat(e, " and ").concat(t, " must match")
                }))
            }
        }
    }

    function rve(e) {
        return "number" != typeof e && !e.some((function(e) {
            return e < 0
        }))
    }

    function ave(e, t, n) {
        var r = ive(e, n),
            a = !rve(r);
        if (a && 0 === t.length) throw new Error("Tried to calculate elements of an empty list" + " with non-fully-defined elementShape: ".concat(r));
        if (a && t.forEach((function(e) {
                r = ive(e.shape, r)
            })), !rve(r)) throw new Error("Non-fully-defined elementShape: ".concat(r));
        return r
    }

    function ive(e, t) {
        if ("number" == typeof e) return t;
        if ("number" == typeof t) return e;
        if (e.length !== t.length) throw new Error("Incompatible ranks during merge: ".concat(e, " vs. ").concat(t));
        for (var n = [], r = 0; r < e.length; ++r) {
            var a = e[r],
                i = t[r];
            if (a >= 0 && i >= 0 && a !== i) throw new Error("Incompatible shape during merge: ".concat(e, " vs. ").concat(t));
            n[r] = a >= 0 ? a : i
        }
        return n
    }
    var ove = function() {
            function e(t, n, r, a, i, o, s) {
                l(this, e), this.name = t, this.dtype = n, this.maxSize = r, this.elementShape = a, this.identicalElementShapes = i, this.dynamicSize = o, this.clearAfterRead = s, this.tensors = [], this.closed_ = !1, this.idTensor = i9(0), J5(this.idTensor)
            }
            return p(e, [{
                key: "id",
                get: function() {
                    return this.idTensor.id
                }
            }, {
                key: "closed",
                get: function() {
                    return this.closed_
                }
            }, {
                key: "clearAndClose",
                value: function(e) {
                    this.tensors.forEach((function(t) {
                        null != e && e.has(t.tensor.id) || t.tensor.dispose()
                    })), this.tensors = [], this.closed_ = !0, this.idTensor.dispose()
                }
            }, {
                key: "size",
                value: function() {
                    return this.tensors.length
                }
            }, {
                key: "read",
                value: function(e) {
                    if (this.closed_) throw new Error("TensorArray ".concat(this.name, " has already been closed."));
                    if (e < 0 || e >= this.size()) throw new Error("Tried to read from index ".concat(e, ", but array size is: ").concat(this.size()));
                    var t = this.tensors[e];
                    if (t.cleared) throw new Error("TensorArray ".concat(this.name, ": Could not read index ").concat(e, " twice because it was cleared after a previous read ") + "(perhaps try setting clear_after_read = false?).");
                    return this.clearAfterRead && (t.cleared = !0), t.read = !0, t.tensor
                }
            }, {
                key: "readMany",
                value: function(e) {
                    var t = this;
                    return e.map((function(e) {
                        return t.read(e)
                    }))
                }
            }, {
                key: "write",
                value: function(e, t) {
                    if (this.closed_) throw new Error("TensorArray ".concat(this.name, " has already been closed."));
                    if (e < 0 || !this.dynamicSize && e >= this.maxSize) throw new Error("Tried to write to index ".concat(e, ", but array is not resizeable and size is: ").concat(this.maxSize));
                    var n = this.tensors[e] || {};
                    if (t.dtype !== this.dtype) throw new Error("TensorArray ".concat(this.name, ": Could not write to TensorArray index ").concat(e, ",\n          because the value dtype is ").concat(t.dtype, ", but TensorArray dtype is ").concat(this.dtype, "."));
                    if (0 !== this.size() || null != this.elementShape && 0 !== this.elementShape.length || (this.elementShape = t.shape), nve(this.elementShape, t.shape, "TensorArray ".concat(this.name, ": Could not write to TensorArray index ").concat(e, ".")), n.read) throw new Error("TensorArray ".concat(this.name, ": Could not write to TensorArray index ").concat(e, ", because it has already been read."));
                    if (n.written) throw new Error("TensorArray ".concat(this.name, ": Could not write to TensorArray index ").concat(e, ", because it has already been written."));
                    n.tensor = t, J5(t), n.written = !0, this.tensors[e] = n
                }
            }, {
                key: "writeMany",
                value: function(e, t) {
                    var n = this;
                    if (e.length !== t.length) throw new Error("TensorArray ".concat(this.name, ": could not write multiple tensors,") + "because the index size: ".concat(e.length, " is not the same as tensors size: ").concat(t.length, "."));
                    e.forEach((function(e, r) {
                        return n.write(e, t[r])
                    }))
                }
            }, {
                key: "gather",
                value: function(e, t) {
                    if (t && t !== this.dtype) throw new Error("TensorArray dtype is ".concat(this.dtype, " but gather requested dtype ").concat(t));
                    if (e) e = e.slice(0, this.size());
                    else {
                        e = [];
                        for (var n = 0; n < this.size(); n++) e.push(n)
                    }
                    if (0 === e.length) return V5([], [0].concat(this.elementShape));
                    var r = this.readMany(e);
                    return nve(this.elementShape, r[0].shape, "TensorArray shape mismatch: "), Pte(r, 0)
                }
            }, {
                key: "concat",
                value: function(e) {
                    if (e && e !== this.dtype) throw new Error("TensorArray dtype is ".concat(this.dtype, " but concat requested dtype ").concat(e));
                    if (0 === this.size()) return V5([], [0].concat(this.elementShape));
                    for (var t = [], n = 0; n < this.size(); n++) t.push(n);
                    var r = this.readMany(t);
                    return nve(this.elementShape, r[0].shape, "TensorArray shape mismatch: tensor array shape (".concat(this.elementShape, ") vs first tensor shape (").concat(r[0].shape, ")")), Z8(r, 0)
                }
            }, {
                key: "scatter",
                value: function(e, t) {
                    if (t.dtype !== this.dtype) throw new Error("TensorArray dtype is ".concat(this.dtype, " but tensor has dtype ").concat(t.dtype));
                    if (e.length !== t.shape[0]) throw new Error("Expected len(indices) == tensor.shape[0], but saw: ".concat(e.length, " vs. ").concat(t.shape[0]));
                    var n = Math.max.apply(Math, T(e));
                    if (!this.dynamicSize && n >= this.maxSize) throw new Error("Max index must be < array size (".concat(n, "  vs. ").concat(this.maxSize, ")"));
                    this.writeMany(e, rne(t, 0))
                }
            }, {
                key: "split",
                value: function(e, t) {
                    var n = this;
                    if (t.dtype !== this.dtype) throw new Error("TensorArray dtype is ".concat(this.dtype, " but tensor has dtype ").concat(t.dtype));
                    var r = 0,
                        a = e.map((function(e) {
                            return r += e
                        }));
                    if (r !== t.shape[0]) throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ".concat(r, ", and tensor's shape is: ").concat(t.shape));
                    if (!this.dynamicSize && e.length !== this.maxSize) throw new Error("TensorArray's size is not equal to the size of lengths (".concat(this.maxSize, " vs. ").concat(e.length, "), ") + "and the TensorArray is not marked as dynamically resizeable");
                    var i = 0 === r ? 0 : t.size / r,
                        o = [];
                    X5((function() {
                        t = X8(t, [1, r, i]);
                        for (var s = 0; s < e.length; ++s) {
                            var u = [0, 0 === s ? 0 : a[s - 1], 0],
                                c = [1, e[s], i];
                            o[s] = X8(e7(t, u, c), n.elementShape)
                        }
                        return o
                    }));
                    for (var s = [], u = 0; u < e.length; u++) s[u] = u;
                    this.writeMany(s, o)
                }
            }]), e
        }(),
        sve = function() {
            function e(t, n, r) {
                var a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : -1;
                l(this, e), this.tensors = t, this.elementShape = n, this.elementDtype = r, null != t && t.forEach((function(e) {
                    if (r !== e.dtype) throw new Error("Invalid data types; op elements ".concat(r, ", but list elements ").concat(e.dtype));
                    nve(n, e.shape, "TensorList shape mismatch: "), J5(e)
                })), this.idTensor = i9(0), this.maxNumElements = a, J5(this.idTensor)
            }
            return p(e, [{
                key: "id",
                get: function() {
                    return this.idTensor.id
                }
            }, {
                key: "copy",
                value: function() {
                    return new e(T(this.tensors), this.elementShape, this.elementDtype)
                }
            }, {
                key: "clearAndClose",
                value: function(e) {
                    this.tensors.forEach((function(t) {
                        null != e && e.has(t.id) || t.dispose()
                    })), this.tensors.length = 0, this.idTensor.dispose()
                }
            }, {
                key: "size",
                value: function() {
                    return this.tensors.length
                }
            }, {
                key: "stack",
                value: function(e, t) {
                    var n = this,
                        r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -1;
                    if (t !== this.elementDtype) throw new Error("Invalid data types; op elements ".concat(t, ", but list elements ").concat(this.elementDtype));
                    if (-1 !== r && this.tensors.length !== r) throw new Error("Operation expected a list with ".concat(r, " elements but got a list with ").concat(this.tensors.length, " elements."));
                    nve(e, this.elementShape, "TensorList shape mismatch: ");
                    var a = ave(this.elementShape, this.tensors, e);
                    return X5((function() {
                        var e = n.tensors.map((function(e) {
                            return X8(e, a)
                        }));
                        return Pte(e, 0)
                    }))
                }
            }, {
                key: "popBack",
                value: function(e, t) {
                    if (t !== this.elementDtype) throw new Error("Invalid data types; op elements ".concat(t, ", but list elements ").concat(this.elementDtype));
                    if (0 === this.size()) throw new Error("Trying to pop from an empty list.");
                    var n = ave(this.elementShape, this.tensors, e),
                        r = this.tensors.pop();
                    return r.kept = !1, nve(r.shape, e, "TensorList shape mismatch: "), X8(r, n)
                }
            }, {
                key: "pushBack",
                value: function(e) {
                    if (e.dtype !== this.elementDtype) throw new Error("Invalid data types; op elements ".concat(e.dtype, ", but list elements ").concat(this.elementDtype));
                    if (nve(e.shape, this.elementShape, "TensorList shape mismatch: "), this.maxNumElements === this.size()) throw new Error("Trying to push element into a full list.");
                    J5(e), this.tensors.push(e)
                }
            }, {
                key: "resize",
                value: function(t) {
                    if (t < 0) throw new Error("TensorListResize expects size to be non-negative. Got: ".concat(t));
                    if (-1 !== this.maxNumElements && t > this.maxNumElements) throw new Error("TensorListResize input size ".concat(t, " is greater maxNumElement ").concat(this.maxNumElements, "."));
                    var n = new e([], this.elementShape, this.elementDtype, this.maxNumElements);
                    n.tensors.length = t;
                    for (var r = 0; r < Math.min(this.tensors.length, t); ++r) n.tensors[r] = this.tensors[r];
                    return n
                }
            }, {
                key: "getItem",
                value: function(e, t, n) {
                    if (n !== this.elementDtype) throw new Error("Invalid data types; op elements ".concat(n, ", but list elements ").concat(this.elementDtype));
                    if (e < 0 || e > this.tensors.length) throw new Error("Trying to access element ".concat(e, " in a list with ").concat(this.tensors.length, " elements."));
                    if (null == this.tensors[e]) throw new Error("element at index ".concat(e, " is null."));
                    nve(this.tensors[e].shape, t, "TensorList shape mismatch: ");
                    var r = ave(this.elementShape, this.tensors, t);
                    return X8(this.tensors[e], r)
                }
            }, {
                key: "setItem",
                value: function(e, t) {
                    if (t.dtype !== this.elementDtype) throw new Error("Invalid data types; op elements ".concat(t.dtype, ", but list elements ").concat(this.elementDtype));
                    if (e < 0 || -1 !== this.maxNumElements && e >= this.maxNumElements) throw new Error("Trying to set element ".concat(e, " in a list with max ").concat(this.maxNumElements, " elements."));
                    nve(this.elementShape, t.shape, "TensorList shape mismatch: "), J5(t), null != this.tensors[e] && (this.tensors[e].kept = !1), this.tensors[e] = t
                }
            }, {
                key: "gather",
                value: function(e, t, n) {
                    var r = this;
                    if (t !== this.elementDtype) throw new Error("Invalid data types; op elements ".concat(t, ", but list elements ").concat(this.elementDtype));
                    nve(this.elementShape, n, "TensorList shape mismatch: "), e = e.slice(0, this.size());
                    var a = ave(this.elementShape, this.tensors, n);
                    return 0 === e.length ? V5([], [0].concat(a)) : X5((function() {
                        var t = e.map((function(e) {
                            return X8(r.tensors[e], a)
                        }));
                        return Pte(t, 0)
                    }))
                }
            }, {
                key: "concat",
                value: function(e, t) {
                    var n = this;
                    if (e && e !== this.elementDtype) throw new Error("TensorList dtype is ".concat(this.elementDtype, " but concat requested dtype ").concat(e));
                    nve(this.elementShape, t, "TensorList shape mismatch: ");
                    var r = ave(this.elementShape, this.tensors, t);
                    return 0 === this.size() ? V5([], [0].concat(r)) : X5((function() {
                        var e = n.tensors.map((function(e) {
                            return X8(e, r)
                        }));
                        return Z8(e, 0)
                    }))
                }
            }]), e
        }();

    function uve(e, t, n) {
        var r = e.dtype;
        if (e.shape.length < 1) throw new Error("Tensor must be at least a vector, but saw shape: ".concat(e.shape));
        if (e.dtype !== n) throw new Error("Invalid data types; op elements ".concat(e.dtype, ", but list elements ").concat(n));
        nve(e.shape.slice(1), t, "TensorList shape mismatch: ");
        var a = rne(e);
        return new sve(a, t, r)
    }

    function cve(e, t, n, r) {
        return new sve([], e, t, r)
    }

    function lve(e, t, n, r) {
        if (t.length !== e.shape[0]) throw new Error("Expected len(indices) == tensor.shape[0], but saw: ".concat(t.length, " vs. ").concat(e.shape[0]));
        var a = Math.max.apply(Math, T(t));
        if (null != r && -1 !== r && a >= r) throw new Error("Max index must be < array size (".concat(a, "  vs. ").concat(r, ")"));
        var i = new sve([], n, e.dtype, r),
            o = rne(e, 0);
        return t.forEach((function(e, t) {
            i.setItem(e, o[t])
        })), i
    }

    function hve(e, t, n) {
        var r = 0,
            a = t.map((function(e) {
                return r += e
            }));
        if (r !== e.shape[0]) throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ".concat(r, ", and tensor's shape is: ").concat(e.shape));
        for (var i = ive(e.shape.slice(1), n), o = 0 === r ? 0 : e.size / r, s = X5((function() {
                var n = [];
                e = X8(e, [1, r, o]);
                for (var s = 0; s < t.length; ++s) {
                    var u = [0, 0 === s ? 0 : a[s - 1], 0],
                        c = [1, t[s], o];
                    n[s] = X8(e7(e, u, c), i)
                }
                return e.dispose(), n
            })), u = new sve([], n, e.dtype, t.length), c = 0; c < s.length; c++) u.setItem(c, s[c]);
        return u
    }
    var pve = function() {
        var e = c(o().mark((function e(t, n, r) {
            var a, i, s, u, c, l, h, p, f, d, v, m, g, y, b, x, k, w, I, N, S, T, E, C, A, R, _, O, F, D, M, L, z, P, B, W, U, V, G, j, H, q, K, X, Y, J, Z, Q, $, ee, te, ne, re, ae, ie, oe, se, ue, ce, le, he, pe, fe, de, ve, me, ge, ye, be, xe, ke, we, Ie, Ne, Se, Te, Ee, Ce, Ae, Re, _e, Oe, Fe, De, Me, Le, ze, Pe, Be, We, Ue, Ve, Ge, je, He, qe, Ke, Xe, Ye, Je, Ze, Qe, $e, et, tt, nt, rt, at, it, ot;
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        e.t0 = t.op, e.next = "If" === e.t0 || "StatelessIf" === e.t0 ? 3 : "While" === e.t0 || "StatelessWhile" === e.t0 ? 15 : "LoopCond" === e.t0 ? 33 : "Switch" === e.t0 ? 35 : "Merge" === e.t0 ? 46 : "Enter" === e.t0 ? 51 : "Exit" === e.t0 ? 55 : "NextIteration" === e.t0 ? 58 : "TensorArrayV3" === e.t0 ? 61 : "TensorArrayWriteV3" === e.t0 ? 71 : "TensorArrayReadV3" === e.t0 ? 77 : "TensorArrayGatherV3" === e.t0 ? 81 : "TensorArrayScatterV3" === e.t0 ? 86 : "TensorArrayConcatV3" === e.t0 ? 92 : "TensorArraySplitV3" === e.t0 ? 96 : "TensorArraySizeV3" === e.t0 ? 102 : "TensorArrayCloseV3" === e.t0 ? 105 : "TensorListSetItem" === e.t0 ? 109 : "TensorListGetItem" === e.t0 ? 115 : "TensorListScatterV2" === e.t0 || "TensorListScatter" === e.t0 ? 121 : "TensorListReserve" === e.t0 || "EmptyTensorList" === e.t0 ? 128 : "TensorListGather" === e.t0 ? 136 : "TensorListStack" === e.t0 ? 142 : "TensorListFromTensor" === e.t0 ? 148 : "TensorListConcat" === e.t0 || "TensorListConcatV2" === e.t0 ? 154 : "TensorListPushBack" === e.t0 ? 159 : "TensorListPopBack" === e.t0 ? 164 : "TensorListSplit" === e.t0 ? 169 : "TensorListLength" === e.t0 ? 175 : "TensorListResize" === e.t0 ? 178 : 184;
                        break;
                    case 3:
                        return a = lde("thenBranch", t, n, r), i = lde("elseBranch", t, n, r), s = lde("cond", t, n, r), u = lde("args", t, n, r), e.next = 9, s.data();
                    case 9:
                        if (!e.sent[0]) {
                            e.next = 14;
                            break
                        }
                        return e.abrupt("return", r.functionMap[a].executeFunctionAsync(u, r.tensorArrayMap, r.tensorListMap));
                    case 14:
                        return e.abrupt("return", r.functionMap[i].executeFunctionAsync(u, r.tensorArrayMap, r.tensorListMap));
                    case 15:
                        return c = lde("body", t, n, r), l = lde("cond", t, n, r), h = lde("args", t, n, r), e.next = 20, r.functionMap[l].executeFunctionAsync(h, r.tensorArrayMap, r.tensorListMap);
                    case 20:
                        return p = e.sent, f = h.map((function(e) {
                            return e.id
                        })), e.next = 24, p[0].data();
                    case 24:
                        d = e.sent, p.forEach((function(e) {
                            e.kept || -1 !== f.indexOf(e.id) || e.dispose()
                        })), v = h, m = o().mark((function e() {
                            var t, n, a;
                            return o().wrap((function(e) {
                                for (;;) switch (e.prev = e.next) {
                                    case 0:
                                        return t = v, e.next = 3, r.functionMap[c].executeFunctionAsync(v, r.tensorArrayMap, r.tensorListMap);
                                    case 3:
                                        return v = e.sent, n = v.map((function(e) {
                                            return e.id
                                        })), t.forEach((function(e) {
                                            e.kept || -1 !== f.indexOf(e.id) || -1 !== n.indexOf(e.id) || e.dispose()
                                        })), e.next = 8, r.functionMap[l].executeFunctionAsync(v, r.tensorArrayMap, r.tensorListMap);
                                    case 8:
                                        return a = e.sent, e.next = 11, a[0].data();
                                    case 11:
                                        d = e.sent, a.forEach((function(e) {
                                            e.kept || -1 !== f.indexOf(e.id) || -1 !== n.indexOf(e.id) || e.dispose()
                                        }));
                                    case 13:
                                    case "end":
                                        return e.stop()
                                }
                            }), e)
                        }));
                    case 28:
                        if (!d[0]) {
                            e.next = 32;
                            break
                        }
                        return e.delegateYield(m(), "t1", 30);
                    case 30:
                        e.next = 28;
                        break;
                    case 32:
                        return e.abrupt("return", v);
                    case 33:
                        return g = lde("pred", t, n, r), e.abrupt("return", [gde(g)]);
                    case 35:
                        return y = lde("pred", t, n, r), (b = lde("data", t, n, r)).kept || (b = gde(b)), e.next = 40, y.data();
                    case 40:
                        if (!e.sent[0]) {
                            e.next = 44;
                            break
                        }
                        e.t2 = [void 0, b], e.next = 45;
                        break;
                    case 44:
                        e.t2 = [b, void 0];
                    case 45:
                        return e.abrupt("return", e.t2);
                    case 46:
                        if (x = t.inputNames.find((function(e) {
                                return void 0 !== hde(e, n, r)
                            })), !x) {
                            e.next = 50;
                            break
                        }
                        return k = hde(x, n, r), e.abrupt("return", [gde(k)]);
                    case 50:
                        return e.abrupt("return", void 0);
                    case 51:
                        return w = lde("frameName", t, n, r), I = lde("tensor", t, n, r), r.enterFrame(w), e.abrupt("return", [gde(I)]);
                    case 55:
                        return N = lde("tensor", t, n, r), r.exitFrame(), e.abrupt("return", [gde(N)]);
                    case 58:
                        return S = lde("tensor", t, n, r), r.nextIteration(), e.abrupt("return", [gde(S)]);
                    case 61:
                        return T = lde("size", t, n, r), E = lde("dtype", t, n, r), C = lde("elementShape", t, n, r), A = lde("dynamicSize", t, n, r), R = lde("clearAfterRead", t, n, r), _ = lde("identicalElementShapes", t, n, r), O = lde("name", t, n, r), F = new ove(O, E, T, C, _, A, R), r.addTensorArray(F), e.abrupt("return", [F.idTensor, i9(1)]);
                    case 71:
                        return D = lde("tensorArrayId", t, n, r), M = lde("index", t, n, r), L = lde("tensor", t, n, r), (z = r.getTensorArray(D.id)).write(M, L), e.abrupt("return", [z.idTensor]);
                    case 77:
                        return P = lde("tensorArrayId", t, n, r), B = lde("index", t, n, r), W = r.getTensorArray(P.id), e.abrupt("return", [W.read(B)]);
                    case 81:
                        return U = lde("tensorArrayId", t, n, r), V = lde("indices", t, n, r), G = lde("dtype", t, n, r), j = r.getTensorArray(U.id), e.abrupt("return", [j.gather(V, G)]);
                    case 86:
                        return H = lde("tensorArrayId", t, n, r), q = lde("indices", t, n, r), K = lde("tensor", t, n, r), (X = r.getTensorArray(H.id)).scatter(q, K), e.abrupt("return", [X.idTensor]);
                    case 92:
                        return Y = lde("tensorArrayId", t, n, r), J = r.getTensorArray(Y.id), Z = lde("dtype", t, n, r), e.abrupt("return", [J.concat(Z)]);
                    case 96:
                        return Q = lde("tensorArrayId", t, n, r), $ = lde("tensor", t, n, r), ee = lde("lengths", t, n, r), (te = r.getTensorArray(Q.id)).split(ee, $), e.abrupt("return", [te.idTensor]);
                    case 102:
                        return ne = lde("tensorArrayId", t, n, r), re = r.getTensorArray(ne.id), e.abrupt("return", [i9(re.size(), "int32")]);
                    case 105:
                        return ae = lde("tensorArrayId", t, n, r), (ie = r.getTensorArray(ae.id)).clearAndClose(), e.abrupt("return", [ie.idTensor]);
                    case 109:
                        return oe = lde("tensorListId", t, n, r), se = lde("index", t, n, r), ue = lde("tensor", t, n, r), (ce = r.getTensorList(oe.id)).setItem(se, ue), e.abrupt("return", [ce.idTensor]);
                    case 115:
                        return le = lde("tensorListId", t, n, r), he = lde("index", t, n, r), pe = lde("elementShape", t, n, r), fe = lde("elementDType", t, n, r), de = r.getTensorList(le.id), e.abrupt("return", [de.getItem(he, pe, fe)]);
                    case 121:
                        return ve = lde("indices", t, n, r), me = lde("tensor", t, n, r), ge = lde("elementShape", t, n, r), ye = lde("numElements", t, n, r), be = lve(me, ve, ge, ye), r.addTensorList(be), e.abrupt("return", [be.idTensor]);
                    case 128:
                        return xe = lde("elementShape", t, n, r), ke = lde("elementDType", t, n, r), we = "TensorListReserve" === t.op ? "numElements" : "maxNumElements", Ie = lde(we, t, n, r), Ne = "TensorListReserve" === t.op ? -1 : Ie, Se = cve(xe, ke, 0, Ne), r.addTensorList(Se), e.abrupt("return", [Se.idTensor]);
                    case 136:
                        return Te = lde("tensorListId", t, n, r), Ee = lde("indices", t, n, r), Ce = lde("elementShape", t, n, r), Ae = lde("elementDType", t, n, r), Re = r.getTensorList(Te.id), e.abrupt("return", [Re.gather(Ee, Ae, Ce)]);
                    case 142:
                        return _e = lde("tensorListId", t, n, r), Oe = lde("elementShape", t, n, r), Fe = lde("elementDType", t, n, r), De = lde("numElements", t, n, r), Me = r.getTensorList(_e.id), e.abrupt("return", [Me.stack(Oe, Fe, De)]);
                    case 148:
                        return Le = lde("tensor", t, n, r), ze = lde("elementShape", t, n, r), Pe = lde("elementDType", t, n, r), Be = uve(Le, ze, Pe), r.addTensorList(Be), e.abrupt("return", [Be.idTensor]);
                    case 154:
                        return We = lde("tensorListId", t, n, r), Ue = r.getTensorList(We.id), Ve = lde("dtype", t, n, r), Ge = lde("elementShape", t, n, r), e.abrupt("return", [Ue.concat(Ve, Ge)]);
                    case 159:
                        return je = lde("tensorListId", t, n, r), He = lde("tensor", t, n, r), (qe = r.getTensorList(je.id)).pushBack(He), e.abrupt("return", [qe.idTensor]);
                    case 164:
                        return Ke = lde("tensorListId", t, n, r), Xe = lde("elementShape", t, n, r), Ye = lde("elementDType", t, n, r), Je = r.getTensorList(Ke.id), e.abrupt("return", [Je.popBack(Xe, Ye)]);
                    case 169:
                        return Ze = lde("tensor", t, n, r), Qe = lde("elementShape", t, n, r), $e = lde("lengths", t, n, r), et = hve(Ze, $e, Qe), r.addTensorList(et), e.abrupt("return", [et.idTensor]);
                    case 175:
                        return tt = lde("tensorListId", t, n, r), nt = r.getTensorList(tt.id), e.abrupt("return", [i9(nt.size(), "int32")]);
                    case 178:
                        return rt = lde("tensorListId", t, n, r), at = lde("size", t, n, r), it = r.getTensorList(rt.id), ot = it.resize(at), r.addTensorList(ot), e.abrupt("return", [ot.idTensor]);
                    case 184:
                        throw TypeError("Node type ".concat(t.op, " is not implemented"));
                    case 185:
                    case "end":
                        return e.stop()
                }
            }), e)
        })));
        return function(t, n, r) {
            return e.apply(this, arguments)
        }
    }();

    function fve(e, t, n) {
        var r = S(lde("fusedOps", e, t, n), 2),
            a = r[0],
            i = r[1],
            o = "biasadd" === a,
            s = !o,
            u = "prelu" === i,
            c = "fusedbatchnorm" === a,
            l = lde("numArgs", e, t, n);
        if (o) {
            if (u && 2 !== l) throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
            if (!u && o && 1 !== l) throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")
        }
        if (c) throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");
        var h = lde("strides", e, t, n),
            p = mde(e, t, n),
            f = lde("dataFormat", e, t, n).toUpperCase(),
            d = lde("dilations", e, t, n),
            v = S(lde("args", e, t, n), 2),
            m = v[0],
            g = v[1];
        return s && (g = m, m = void 0), {
            stride: h,
            pad: p,
            dataFormat: f,
            dilations: d,
            biasArg: m,
            preluArg: g,
            activationFunc: i,
            leakyreluAlpha: lde("leakyreluAlpha", e, t, n)
        }
    }
    var dve = function(e, t, n) {
            var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : $de;
            switch (e.op) {
                case "Conv1D":
                    var a = lde("stride", e, t, n),
                        i = lde("pad", e, t, n),
                        o = lde("dataFormat", e, t, n).toUpperCase(),
                        s = lde("dilation", e, t, n);
                    return [r.conv1d(lde("x", e, t, n), lde("filter", e, t, n), a, i, o, s)];
                case "Conv2D":
                    var u = lde("strides", e, t, n),
                        c = mde(e, t, n),
                        l = lde("dataFormat", e, t, n).toUpperCase(),
                        h = lde("dilations", e, t, n);
                    return [r.conv2d(lde("x", e, t, n), lde("filter", e, t, n), [u[1], u[2]], c, l, [h[1], h[2]])];
                case "_FusedConv2D":
                    var p = fve(e, t, n),
                        f = p.stride,
                        d = p.pad,
                        v = p.dataFormat,
                        m = p.dilations,
                        g = p.biasArg,
                        y = p.preluArg,
                        b = p.activationFunc,
                        x = p.leakyreluAlpha;
                    return [r.fused.conv2d({
                        x: lde("x", e, t, n),
                        filter: lde("filter", e, t, n),
                        strides: [f[1], f[2]],
                        pad: d,
                        dataFormat: v,
                        dilations: [m[1], m[2]],
                        bias: g,
                        activation: b,
                        preluActivationWeights: y,
                        leakyreluAlpha: x
                    })];
                case "FusedDepthwiseConv2dNative":
                    var k = fve(e, t, n),
                        w = k.stride,
                        I = k.pad,
                        N = k.dataFormat,
                        S = k.dilations,
                        T = k.biasArg,
                        E = k.preluArg,
                        C = k.activationFunc,
                        A = k.leakyreluAlpha;
                    return [r.fused.depthwiseConv2d({
                        x: lde("x", e, t, n),
                        filter: lde("filter", e, t, n),
                        strides: [w[1], w[2]],
                        pad: I,
                        dataFormat: N,
                        dilations: [S[1], S[2]],
                        bias: T,
                        activation: C,
                        preluActivationWeights: E,
                        leakyreluAlpha: A
                    })];
                case "Conv2DBackpropInput":
                case "Conv2dTranspose":
                    var R = lde("outputShape", e, t, n),
                        _ = lde("strides", e, t, n),
                        O = mde(e, t, n);
                    return [r.conv2dTranspose(lde("x", e, t, n), lde("filter", e, t, n), R, [_[1], _[2]], O)];
                case "DepthwiseConv2dNative":
                case "DepthwiseConv2d":
                    var F = lde("strides", e, t, n),
                        D = mde(e, t, n),
                        M = lde("dilations", e, t, n),
                        L = lde("dataFormat", e, t, n).toUpperCase();
                    return [r.depthwiseConv2d(lde("input", e, t, n), lde("filter", e, t, n), [F[1], F[2]], D, L, [M[1], M[2]])];
                case "Conv3D":
                    var z = lde("strides", e, t, n),
                        P = lde("pad", e, t, n),
                        B = lde("dataFormat", e, t, n).toUpperCase(),
                        W = lde("dilations", e, t, n);
                    return [r.conv3d(lde("x", e, t, n), lde("filter", e, t, n), [z[1], z[2], z[3]], P, B, [W[1], W[2], W[3]])];
                case "AvgPool":
                    var U = lde("strides", e, t, n),
                        V = lde("pad", e, t, n),
                        G = lde("kernelSize", e, t, n);
                    return [r.avgPool(lde("x", e, t, n), [G[1], G[2]], [U[1], U[2]], V)];
                case "MaxPool":
                    var j = lde("strides", e, t, n),
                        H = lde("pad", e, t, n),
                        q = lde("kernelSize", e, t, n);
                    return [r.maxPool(lde("x", e, t, n), [q[1], q[2]], [j[1], j[2]], H)];
                case "MaxPoolWithArgmax":
                    var K = lde("strides", e, t, n),
                        X = lde("pad", e, t, n),
                        Y = lde("kernelSize", e, t, n),
                        J = lde("includeBatchInIndex", e, t, n),
                        Z = r.maxPoolWithArgmax(lde("x", e, t, n), [Y[1], Y[2]], [K[1], K[2]], X, J),
                        Q = Z.result,
                        $ = Z.indexes;
                    return [Q, $];
                case "AvgPool3D":
                    var ee = lde("strides", e, t, n),
                        te = lde("pad", e, t, n),
                        ne = lde("kernelSize", e, t, n);
                    return [r.avgPool3d(lde("x", e, t, n), [ne[1], ne[2], ne[3]], [ee[1], ee[2], ee[3]], te)];
                case "MaxPool3D":
                    var re = lde("strides", e, t, n),
                        ae = lde("pad", e, t, n),
                        ie = lde("kernelSize", e, t, n);
                    return [r.maxPool3d(lde("x", e, t, n), [ie[1], ie[2], ie[3]], [re[1], re[2], re[3]], ae)];
                case "Dilation2D":
                    var oe = lde("strides", e, t, n),
                        se = lde("pad", e, t, n),
                        ue = lde("dilations", e, t, n),
                        ce = oe[1],
                        le = oe[2],
                        he = ue[1],
                        pe = ue[2];
                    return [r.dilation2d(lde("x", e, t, n), lde("filter", e, t, n), [ce, le], se, [he, pe], "NHWC")];
                default:
                    throw TypeError("Node type ".concat(e.op, " is not implemented"))
            }
        },
        vve = function(e, t, n) {
            var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : $de;
            switch (e.op) {
                case "Fill":
                    var a = lde("shape", e, t, n),
                        i = lde("dtype", e, t, n),
                        o = lde("value", e, t, n);
                    return [r.fill(a, o, i)];
                case "LinSpace":
                    var s = lde("start", e, t, n),
                        u = lde("stop", e, t, n),
                        c = lde("num", e, t, n);
                    return [r.linspace(s, u, c)];
                case "Multinomial":
                    var l = lde("logits", e, t, n),
                        h = lde("numSamples", e, t, n),
                        p = lde("seed", e, t, n);
                    return [r.multinomial(l, h, p)];
                case "OneHot":
                    var f = lde("indices", e, t, n),
                        d = lde("depth", e, t, n),
                        v = lde("onValue", e, t, n),
                        m = lde("offValue", e, t, n),
                        g = lde("dtype", e, t, n);
                    return [r.oneHot(f, d, v, m, g)];
                case "Ones":
                    return [r.ones(lde("shape", e, t, n), lde("dtype", e, t, n))];
                case "OnesLike":
                    return [r.onesLike(lde("x", e, t, n))];
                case "RandomStandardNormal":
                    return [r.randomStandardNormal(lde("shape", e, t, n), lde("dtype", e, t, n), lde("seed", e, t, n))];
                case "RandomUniform":
                    return [r.randomUniform(lde("shape", e, t, n), lde("minval", e, t, n), lde("maxval", e, t, n), lde("dtype", e, t, n))];
                case "RandomUniformInt":
                    return [r.randomUniformInt(lde("shape", e, t, n), lde("minval", e, t, n), lde("maxval", e, t, n), lde("seed", e, t, n))];
                case "Range":
                    var y = lde("start", e, t, n),
                        b = lde("stop", e, t, n),
                        x = lde("step", e, t, n);
                    return [r.range(y, b, x, lde("dtype", e, t, n))];
                case "TruncatedNormal":
                    var k = lde("shape", e, t, n),
                        w = lde("mean", e, t, n),
                        I = lde("stdDev", e, t, n),
                        N = lde("seed", e, t, n);
                    return [r.truncatedNormal(k, w, I, lde("dtype", e, t, n), N)];
                case "Zeros":
                    return [r.zeros(lde("shape", e, t, n), lde("dtype", e, t, n))];
                case "ZerosLike":
                    return [r.zerosLike(lde("x", e, t, n))];
                default:
                    throw TypeError("Node type ".concat(e.op, " is not implemented"))
            }
        };

    function mve(e, t, n) {
        return {
            boxes: lde("boxes", e, t, n),
            scores: lde("scores", e, t, n),
            maxOutputSize: lde("maxOutputSize", e, t, n),
            iouThreshold: lde("iouThreshold", e, t, n),
            scoreThreshold: lde("scoreThreshold", e, t, n),
            softNmsSigma: lde("softNmsSigma", e, t, n)
        }
    }
    var gve = function() {
            var e = c(o().mark((function e(t, n, r, a) {
                var i, s, u, c, l, h, p, f, d, v, m, g, y, b, x, k, w, I, N, S, T, E, C, A, R, _ = arguments;
                return o().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            i = _.length > 4 && void 0 !== _[4] ? _[4] : $de, e.t0 = t.op, e.next = "NonMaxSuppressionV5" === e.t0 ? 4 : "NonMaxSuppressionV4" === e.t0 ? 9 : "NonMaxSuppressionV3" === e.t0 || "NonMaxSuppressionV2" === e.t0 ? 15 : "Where" === e.t0 ? 20 : "ListDiff" === e.t0 ? 27 : 28;
                            break;
                        case 4:
                            return s = mve(t, n, r), u = s.boxes, c = s.scores, l = s.maxOutputSize, h = s.iouThreshold, p = s.scoreThreshold, f = s.softNmsSigma, e.next = 7, i.image.nonMaxSuppressionWithScoreAsync(u, c, l, h, p, f);
                        case 7:
                            return d = e.sent, e.abrupt("return", [d.selectedIndices, d.selectedScores]);
                        case 9:
                            return v = mve(t, n, r), m = v.boxes, g = v.scores, y = v.maxOutputSize, b = v.iouThreshold, x = v.scoreThreshold, k = lde("padToMaxOutputSize", t, n, r), e.next = 13, i.image.nonMaxSuppressionPaddedAsync(m, g, y, b, x, k);
                        case 13:
                            return w = e.sent, e.abrupt("return", [w.selectedIndices, w.validOutputs]);
                        case 15:
                            return I = mve(t, n, r), N = I.boxes, S = I.scores, T = I.maxOutputSize, E = I.iouThreshold, C = I.scoreThreshold, e.next = 18, i.image.nonMaxSuppressionAsync(N, S, T, E, C);
                        case 18:
                            return e.t1 = e.sent, e.abrupt("return", [e.t1]);
                        case 20:
                            return A = i.cast(lde("condition", t, n, r), "bool"), e.next = 23, i.whereAsync(A);
                        case 23:
                            return e.t2 = e.sent, R = [e.t2], A.dispose(), e.abrupt("return", R);
                        case 27:
                            return e.abrupt("return", i.setdiff1dAsync(lde("x", t, n, r), lde("y", t, n, r)));
                        case 28:
                            throw TypeError("Node type ".concat(t.op, " is not implemented"));
                        case 29:
                        case "end":
                            return e.stop()
                    }
                }), e)
            })));
            return function(t, n, r, a) {
                return e.apply(this, arguments)
            }
        }(),
        yve = function(e, t, n) {
            var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : $de;
            switch (e.op) {
                case "LowerBound":
                    var a = lde("sortedSequence", e, t, n),
                        i = lde("values", e, t, n);
                    return [r.lowerBound(a, i)];
                case "TopKV2":
                    var o = lde("x", e, t, n),
                        s = lde("k", e, t, n),
                        u = lde("sorted", e, t, n),
                        c = r.topk(o, s, u);
                    return [c.values, c.indices];
                case "UpperBound":
                    var l = lde("sortedSequence", e, t, n),
                        h = lde("values", e, t, n);
                    return [r.upperBound(l, h)];
                case "Unique":
                    var p = lde("x", e, t, n),
                        f = r.unique(p);
                    return [f.values, f.indices];
                case "UniqueV2":
                    var d = lde("x", e, t, n),
                        v = lde("axis", e, t, n),
                        m = r.unique(d, v);
                    return [m.values, m.indices];
                default:
                    throw TypeError("Node type ".concat(e.op, " is not implemented"))
            }
        },
        bve = function(e, t, n) {
            var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : $de;
            switch (e.op) {
                case "Const":
                    return t[e.name];
                case "PlaceholderWithDefault":
                    var a = lde("default", e, t, n);
                    return [hde(e.name, t, n) || a];
                case "Placeholder":
                    return [hde(e.name, t, n)];
                case "Identity":
                case "StopGradient":
                case "FakeQuantWithMinMaxVars":
                    var i = lde("x", e, t, n);
                    return [gde(i)];
                case "IdentityN":
                    return lde("x", e, t, n).map((function(e) {
                        return gde(e)
                    }));
                case "Snapshot":
                    var o = lde("x", e, t, n);
                    return [gde(o)];
                case "Shape":
                    return [r.tensor1d(lde("x", e, t, n).shape, "int32")];
                case "ShapeN":
                    return lde("x", e, t, n).map((function(e) {
                        return r.tensor1d(e.shape)
                    }));
                case "Size":
                    return [r.scalar(lde("x", e, t, n).size, "int32")];
                case "Rank":
                    return [r.scalar(lde("x", e, t, n).rank, "int32")];
                case "NoOp":
                    return [r.scalar(1)];
                case "Print":
                    var s = lde("x", e, t, n),
                        u = lde("data", e, t, n),
                        c = lde("message", e, t, n),
                        l = lde("summarize", e, t, n);
                    console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."), console.log(c);
                    for (var h = 0; h < u.length; h++) console.log(Array.prototype.slice.call(u[h].dataSync()).slice(0, l));
                    return [s];
                default:
                    throw TypeError("Node type ".concat(e.op, " is not implemented"))
            }
        },
        xve = function() {
            function e(t, n) {
                l(this, e), this.keyDType = t, this.valueDType = n, this.handle = i9(0), this.tensorMap = new Map, J5(this.handle)
            }
            var t, n;
            return p(e, [{
                key: "id",
                get: function() {
                    return this.handle.id
                }
            }, {
                key: "clearAndClose",
                value: function() {
                    this.tensorMap.forEach((function(e) {
                        return e.dispose()
                    })), this.tensorMap.clear(), this.handle.dispose()
                }
            }, {
                key: "size",
                value: function() {
                    return this.tensorMap.size
                }
            }, {
                key: "tensorSize",
                value: function() {
                    return i9(this.size(), "int32")
                }
            }, {
                key: "import",
                value: (n = c(o().mark((function e(t, n) {
                    var r, a = this;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return this.checkKeyAndValueTensor(t, n), e.next = 3, t.data();
                            case 3:
                                return r = e.sent, this.tensorMap.forEach((function(e) {
                                    return e.dispose()
                                })), this.tensorMap.clear(), e.abrupt("return", X5((function() {
                                    var e = rne(n),
                                        t = r.length,
                                        i = e.length;
                                    F$(t === i, (function() {
                                        return "The number of elements doesn't match, keys has " + "".concat(t, " elements, the values has ").concat(i, " ") + "elements."
                                    }));
                                    for (var o = 0; o < t; o++) {
                                        var s = r[o],
                                            u = e[o];
                                        J5(u), a.tensorMap.set(s, u)
                                    }
                                    return a.handle
                                })));
                            case 7:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e, t) {
                    return n.apply(this, arguments)
                })
            }, {
                key: "find",
                value: (t = c(o().mark((function e(t, n) {
                    var r, a = this;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return this.checkKeyAndValueTensor(t, n), e.next = 3, t.data();
                            case 3:
                                return r = e.sent, e.abrupt("return", X5((function() {
                                    for (var e = [], t = 0; t < r.length; t++) {
                                        var i = r[t],
                                            o = a.findWithDefault(i, n);
                                        e.push(o)
                                    }
                                    return Pte(e)
                                })));
                            case 5:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e, n) {
                    return t.apply(this, arguments)
                })
            }, {
                key: "findWithDefault",
                value: function(e, t) {
                    var n = this.tensorMap.get(e);
                    return null != n ? n : t
                }
            }, {
                key: "checkKeyAndValueTensor",
                value: function(e, t) {
                    if (e.dtype !== this.keyDType) throw new Error("Expect key dtype ".concat(this.keyDType, ", but got ") + "".concat(e.dtype));
                    if (t.dtype !== this.valueDType) throw new Error("Expect value dtype ".concat(this.valueDType, ", but got ") + "".concat(t.dtype))
                }
            }]), e
        }(),
        kve = function() {
            var e = c(o().mark((function e(t, n, r, a) {
                var i, s, u, c, l, h, p, f, d, v, m, g, y, b;
                return o().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            e.t0 = t.op, e.next = "HashTable" === e.t0 || "HashTableV2" === e.t0 ? 3 : "InitializeTable" === e.t0 || "InitializeTableV2" === e.t0 || "LookupTableImport" === e.t0 || "LookupTableImportV2" === e.t0 ? 13 : "LookupTableFind" === e.t0 || "LookupTableFindV2" === e.t0 ? 21 : "LookupTableSize" === e.t0 || "LookupTableSizeV2" === e.t0 ? 29 : 32;
                            break;
                        case 3:
                            if (null == (i = a.getHashTableHandleByName(t.name))) {
                                e.next = 8;
                                break
                            }
                            return e.abrupt("return", [i]);
                        case 8:
                            return s = lde("keyDType", t, n, r), u = lde("valueDType", t, n, r), c = new xve(s, u), a.addHashTable(t.name, c), e.abrupt("return", [c.handle]);
                        case 13:
                            return l = lde("tableHandle", t, n, r, a), h = lde("keys", t, n, r), p = lde("values", t, n, r), f = a.getHashTableById(l.id), e.next = 19, f.import(h, p);
                        case 19:
                            return e.t1 = e.sent, e.abrupt("return", [e.t1]);
                        case 21:
                            return d = lde("tableHandle", t, n, r, a), v = lde("keys", t, n, r), m = lde("defaultValue", t, n, r), g = a.getHashTableById(d.id), e.next = 27, g.find(v, m);
                        case 27:
                            return e.t2 = e.sent, e.abrupt("return", [e.t2]);
                        case 29:
                            return y = lde("tableHandle", t, n, r, a), b = a.getHashTableById(y.id), e.abrupt("return", [b.tensorSize()]);
                        case 32:
                            throw TypeError("Node type ".concat(t.op, " is not implemented"));
                        case 33:
                        case "end":
                            return e.stop()
                    }
                }), e)
            })));
            return function(t, n, r, a) {
                return e.apply(this, arguments)
            }
        }(),
        wve = function(e, t, n) {
            var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : $de;
            switch (e.op) {
                case "ResizeBilinear":
                    var a = lde("images", e, t, n),
                        i = lde("size", e, t, n),
                        o = lde("alignCorners", e, t, n),
                        s = lde("halfPixelCenters", e, t, n);
                    return [r.image.resizeBilinear(a, [i[0], i[1]], o, s)];
                case "ResizeNearestNeighbor":
                    var u = lde("images", e, t, n),
                        c = lde("size", e, t, n),
                        l = lde("alignCorners", e, t, n),
                        h = lde("halfPixelCenters", e, t, n);
                    return [r.image.resizeNearestNeighbor(u, [c[0], c[1]], l, h)];
                case "CropAndResize":
                    var p = lde("image", e, t, n),
                        f = lde("boxes", e, t, n),
                        d = lde("boxInd", e, t, n),
                        v = lde("cropSize", e, t, n),
                        m = lde("method", e, t, n),
                        g = lde("extrapolationValue", e, t, n);
                    return [r.image.cropAndResize(p, f, d, v, m, g)];
                case "ImageProjectiveTransformV3":
                    var y = lde("images", e, t, n),
                        b = lde("transforms", e, t, n),
                        x = lde("outputShape", e, t, n),
                        k = lde("fillValue", e, t, n),
                        w = lde("interpolation", e, t, n),
                        I = lde("fillMode", e, t, n);
                    return [r.image.transform(y, b, w.toLowerCase(), I.toLowerCase(), k, x)];
                default:
                    throw TypeError("Node type ".concat(e.op, " is not implemented"))
            }
        },
        Ive = function(e, t, n) {
            var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : $de;
            switch (e.op) {
                case "Equal":
                    return [r.equal(lde("a", e, t, n), lde("b", e, t, n))];
                case "NotEqual":
                    return [r.notEqual(lde("a", e, t, n), lde("b", e, t, n))];
                case "Greater":
                    return [r.greater(lde("a", e, t, n), lde("b", e, t, n))];
                case "GreaterEqual":
                    return [r.greaterEqual(lde("a", e, t, n), lde("b", e, t, n))];
                case "Less":
                    return [r.less(lde("a", e, t, n), lde("b", e, t, n))];
                case "LessEqual":
                    return [r.lessEqual(lde("a", e, t, n), lde("b", e, t, n))];
                case "LogicalAnd":
                    return [r.logicalAnd(lde("a", e, t, n), lde("b", e, t, n))];
                case "LogicalNot":
                    return [r.logicalNot(lde("a", e, t, n))];
                case "LogicalOr":
                    return [r.logicalOr(lde("a", e, t, n), lde("b", e, t, n))];
                case "Select":
                case "SelectV2":
                    return [r.where(lde("condition", e, t, n), lde("a", e, t, n), lde("b", e, t, n))];
                case "BitwiseAnd":
                    return [r.bitwiseAnd(lde("a", e, t, n), lde("b", e, t, n))];
                default:
                    throw TypeError("Node type ".concat(e.op, " is not implemented"))
            }
        },
        Nve = function(e, t, n) {
            var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : $de;
            switch (e.op) {
                case "BatchMatMul":
                case "BatchMatMulV2":
                case "MatMul":
                    return [r.matMul(lde("a", e, t, n), lde("b", e, t, n), lde("transposeA", e, t, n), lde("transposeB", e, t, n))];
                case "Einsum":
                    return [r.einsum.apply(r, [lde("equation", e, t, n)].concat(T(lde("tensors", e, t, n))))];
                case "Transpose":
                    return [r.transpose(lde("x", e, t, n), lde("perm", e, t, n))];
                case "_FusedMatMul":
                    var a = lde("fusedOps", e, t, n),
                        i = S(a, 2),
                        o = i[0],
                        s = i[1],
                        u = "biasadd" === o,
                        c = "prelu" === s,
                        l = lde("numArgs", e, t, n),
                        h = lde("leakyreluAlpha", e, t, n);
                    if (u) {
                        if (c && 2 !== l) throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
                        if (!c && 1 !== l) throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")
                    }
                    var p = lde("args", e, t, n),
                        f = S(p, 2),
                        d = f[0],
                        v = f[1];
                    return [r.fused.matMul({
                        a: lde("a", e, t, n),
                        b: lde("b", e, t, n),
                        transposeA: lde("transposeA", e, t, n),
                        transposeB: lde("transposeB", e, t, n),
                        bias: d,
                        activation: s,
                        preluActivationWeights: v,
                        leakyreluAlpha: h
                    })];
                case "MatrixBandPart":
                    return [r.linalg.bandPart(lde("a", e, t, n), lde("numLower", e, t, n), lde("numUpper", e, t, n))];
                default:
                    throw TypeError("Node type ".concat(e.op, " is not implemented"))
            }
        },
        Sve = function(e, t, n) {
            var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : $de;
            switch (e.op) {
                case "EuclideanNorm":
                    return [r.euclideanNorm(lde("x", e, t, n), lde("axis", e, t, n), lde("keepDims", e, t, n))];
                case "FusedBatchNorm":
                case "FusedBatchNormV2":
                case "FusedBatchNormV3":
                    return [r.batchNorm(lde("x", e, t, n), lde("mean", e, t, n), lde("variance", e, t, n), lde("offset", e, t, n), lde("scale", e, t, n), lde("epsilon", e, t, n))];
                case "LRN":
                    return [r.localResponseNormalization(lde("x", e, t, n), lde("radius", e, t, n), lde("bias", e, t, n), lde("alpha", e, t, n), lde("beta", e, t, n))];
                case "Softmax":
                    return [r.softmax(lde("x", e, t, n))];
                case "LogSoftmax":
                    return [r.logSoftmax(lde("x", e, t, n))];
                default:
                    throw TypeError("Node type ".concat(e.op, " is not implemented"))
            }
        },
        Tve = function(e, t, n) {
            var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : $de;
            switch (e.op) {
                case "RaggedGather":
                    var a = r.raggedGather(lde("paramsNestedSplits", e, t, n), lde("paramsDenseValues", e, t, n), lde("indices", e, t, n), lde("outputRaggedRank", e, t, n)),
                        i = a.outputNestedSplits,
                        o = a.outputDenseValues;
                    return i.concat(o);
                case "RaggedRange":
                    var s = r.raggedRange(lde("starts", e, t, n), lde("limits", e, t, n), lde("splits", e, t, n)),
                        u = s.rtNestedSplits,
                        c = s.rtDenseValues;
                    return [u, c];
                case "RaggedTensorToTensor":
                    return [r.raggedTensorToTensor(lde("shape", e, t, n), lde("values", e, t, n), lde("defaultValue", e, t, n), lde("rowPartitionTensors", e, t, n), lde("rowPartitionTypes", e, t, n))];
                default:
                    throw TypeError("Node type ".concat(e.op, " is not implemented"))
            }
        },
        Eve = function(e, t, n) {
            var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : $de;
            switch (e.op) {
                case "Max":
                    var a = lde("axis", e, t, n),
                        i = lde("keepDims", e, t, n);
                    return [r.max(lde("x", e, t, n), a, i)];
                case "Mean":
                    var o = lde("axis", e, t, n),
                        s = lde("keepDims", e, t, n);
                    return [r.mean(lde("x", e, t, n), o, s)];
                case "Min":
                    var u = lde("axis", e, t, n),
                        c = lde("keepDims", e, t, n);
                    return [r.min(lde("x", e, t, n), u, c)];
                case "Sum":
                    var l = lde("axis", e, t, n),
                        h = lde("keepDims", e, t, n);
                    return [r.sum(lde("x", e, t, n), l, h)];
                case "All":
                    var p = lde("axis", e, t, n),
                        f = lde("keepDims", e, t, n);
                    return [r.all(lde("x", e, t, n), p, f)];
                case "Any":
                    var d = lde("axis", e, t, n),
                        v = lde("keepDims", e, t, n);
                    return [r.any(lde("x", e, t, n), d, v)];
                case "ArgMax":
                    var m = lde("axis", e, t, n);
                    return [r.argMax(lde("x", e, t, n), m)];
                case "ArgMin":
                    var g = lde("axis", e, t, n);
                    return [r.argMin(lde("x", e, t, n), g)];
                case "Prod":
                    var y = lde("axis", e, t, n),
                        b = lde("keepDims", e, t, n);
                    return [r.prod(lde("x", e, t, n), y, b)];
                case "Cumprod":
                    var x = lde("axis", e, t, n),
                        k = lde("exclusive", e, t, n),
                        w = lde("reverse", e, t, n);
                    return [r.cumprod(lde("x", e, t, n), x, k, w)];
                case "Cumsum":
                    var I = lde("axis", e, t, n),
                        N = lde("exclusive", e, t, n),
                        S = lde("reverse", e, t, n);
                    return [r.cumsum(lde("x", e, t, n), I, N, S)];
                case "Bincount":
                    var T = lde("x", e, t, n),
                        E = lde("weights", e, t, n),
                        C = lde("size", e, t, n);
                    return [r.bincount(T, E, C)];
                case "DenseBincount":
                    var A = lde("x", e, t, n),
                        R = lde("weights", e, t, n),
                        _ = lde("size", e, t, n),
                        O = lde("binaryOutput", e, t, n);
                    return [r.denseBincount(A, R, _, O)];
                default:
                    throw TypeError("Node type ".concat(e.op, " is not implemented"))
            }
        },
        Cve = function(e, t, n) {
            var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : $de;
            switch (e.op) {
                case "ConcatV2":
                case "Concat":
                    var a = lde("n", e, t, n),
                        i = lde("axis", e, t, n),
                        o = lde("tensors", e, t, n);
                    return o = o.slice(0, a), [r.concat(o, i)];
                case "Gather":
                    var s = lde("x", e, t, n),
                        u = lde("indices", e, t, n);
                    return [r.gather(s, r.cast(u, "int32"), 0)];
                case "GatherV2":
                    var c = lde("axis", e, t, n),
                        l = lde("batchDims", e, t, n),
                        h = lde("x", e, t, n),
                        p = lde("indices", e, t, n);
                    return [r.gather(h, r.cast(p, "int32"), c, l)];
                case "Reverse":
                    for (var f = lde("dims", e, t, n), d = [], v = 0; v < f.length; v++) f[v] && d.push(v);
                    var m = lde("x", e, t, n);
                    return [r.reverse(m, d)];
                case "ReverseV2":
                    var g = lde("axis", e, t, n),
                        y = lde("x", e, t, n);
                    return [r.reverse(y, g)];
                case "Slice":
                    var b = lde("begin", e, t, n),
                        x = lde("size", e, t, n);
                    return [r.slice(lde("x", e, t, n), b, x)];
                case "StridedSlice":
                    var k = lde("begin", e, t, n),
                        w = lde("end", e, t, n),
                        I = lde("strides", e, t, n),
                        N = lde("beginMask", e, t, n),
                        S = lde("endMask", e, t, n),
                        T = lde("ellipsisMask", e, t, n),
                        E = lde("newAxisMask", e, t, n),
                        C = lde("shrinkAxisMask", e, t, n),
                        A = lde("x", e, t, n);
                    return [r.stridedSlice(A, k, w, I, N, S, T, E, C)];
                case "Pack":
                    return X5((function() {
                        var a = lde("axis", e, t, n),
                            i = lde("tensors", e, t, n),
                            o = i[0].shape,
                            s = r.squeeze(i[0]).shape,
                            u = i.map((function(e) {
                                var t = P$(e.shape, o);
                                if (!t && !P$(r.squeeze(e).shape, s)) throw new Error("the input tensors shape does not match");
                                return t ? e : r.reshape(e, o)
                            }));
                        return [r.stack(u, a)]
                    }));
                case "Unpack":
                    var R = lde("axis", e, t, n),
                        _ = lde("tensor", e, t, n);
                    return r.unstack(_, R);
                case "Tile":
                    var O = lde("reps", e, t, n);
                    return [r.tile(lde("x", e, t, n), O)];
                case "Split":
                case "SplitV":
                    var F = lde("axis", e, t, n),
                        D = lde("numOrSizeSplits", e, t, n),
                        M = lde("x", e, t, n);
                    return r.split(M, D, F);
                case "ScatterNd":
                    var L = lde("indices", e, t, n),
                        z = lde("values", e, t, n),
                        P = lde("shape", e, t, n);
                    return [r.scatterND(L, z, P)];
                case "GatherNd":
                    var B = lde("x", e, t, n),
                        W = lde("indices", e, t, n);
                    return [r.gatherND(B, W)];
                case "SparseToDense":
                    var U = lde("sparseIndices", e, t, n),
                        V = lde("outputShape", e, t, n),
                        G = lde("sparseValues", e, t, n),
                        j = lde("defaultValue", e, t, n);
                    return [r.sparseToDense(U, G, V, G.dtype === j.dtype ? j : r.cast(j, G.dtype))];
                case "TensorScatterUpdate":
                    var H = lde("indices", e, t, n),
                        q = lde("values", e, t, n),
                        K = lde("tensor", e, t, n);
                    return [r.tensorScatterUpdate(K, H, q)];
                default:
                    throw TypeError("Node type ".concat(e.op, " is not implemented"))
            }
        },
        Ave = function(e, t, n) {
            var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : $de;
            switch (e.op) {
                case "SparseFillEmptyRows":
                    var a = r.sparse.sparseFillEmptyRows(lde("indices", e, t, n), lde("values", e, t, n), lde("denseShape", e, t, n), lde("defaultValue", e, t, n)),
                        i = a.outputIndices,
                        o = a.outputValues,
                        s = a.emptyRowIndicator,
                        u = a.reverseIndexMap;
                    return [i, o, s, u];
                case "SparseReshape":
                    var c = r.sparse.sparseReshape(lde("inputIndices", e, t, n), lde("inputShape", e, t, n), lde("newShape", e, t, n)),
                        l = c.outputIndices,
                        h = c.outputShape;
                    return [l, h];
                case "SparseSegmentMean":
                    var p = r.sparse.sparseSegmentMean(lde("data", e, t, n), lde("indices", e, t, n), lde("segmentIds", e, t, n));
                    return [p];
                case "SparseSegmentSum":
                    var f = r.sparse.sparseSegmentSum(lde("data", e, t, n), lde("indices", e, t, n), lde("segmentIds", e, t, n));
                    return [f];
                default:
                    throw TypeError("Node type ".concat(e.op, " is not implemented"))
            }
        },
        Rve = function(e, t, n) {
            var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : $de;
            switch (e.op) {
                case "FFT":
                    return [r.fft(lde("x", e, t, n))];
                case "IFFT":
                    return [r.ifft(lde("x", e, t, n))];
                case "RFFT":
                    return [r.rfft(lde("x", e, t, n))];
                case "IRFFT":
                    return [r.irfft(lde("x", e, t, n))];
                default:
                    throw TypeError("Node type ".concat(e.op, " is not implemented"))
            }
        },
        _ve = function(e, t, n) {
            var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : $de;
            switch (e.op) {
                case "StaticRegexReplace":
                    return [r.string.staticRegexReplace(lde("input", e, t, n), lde("pattern", e, t, n), lde("rewrite", e, t, n), lde("replaceGlobal", e, t, n))];
                case "StringNGrams":
                    var a = r.string.stringNGrams(lde("data", e, t, n), lde("dataSplits", e, t, n), lde("separator", e, t, n), lde("nGramWidths", e, t, n), lde("leftPad", e, t, n), lde("rightPad", e, t, n), lde("padWidth", e, t, n), lde("preserveShortSequences", e, t, n)),
                        i = a.nGrams,
                        o = a.nGramsSplits;
                    return [i, o];
                case "StringSplit":
                    var s = r.string.stringSplit(lde("input", e, t, n), lde("delimiter", e, t, n), lde("skipEmpty", e, t, n)),
                        u = s.indices,
                        c = s.values,
                        l = s.shape;
                    return [u, c, l];
                case "StringToHashBucketFast":
                    var h = r.string.stringToHashBucketFast(lde("input", e, t, n), lde("numBuckets", e, t, n));
                    return [h];
                default:
                    throw TypeError("Node type ".concat(e.op, " is not implemented"))
            }
        },
        Ove = function(e, t, n) {
            var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : $de;
            switch (e.op) {
                case "Cast":
                    return [r.cast(lde("x", e, t, n), lde("dtype", e, t, n))];
                case "ExpandDims":
                    var a = lde("axis", e, t, n);
                    return [r.expandDims(lde("x", e, t, n), a)];
                case "Squeeze":
                    var i = lde("axis", e, t, n);
                    return [r.squeeze(lde("x", e, t, n), i)];
                case "Reshape":
                    return [r.reshape(lde("x", e, t, n), lde("shape", e, t, n))];
                case "EnsureShape":
                    return [r.ensureShape(lde("x", e, t, n), lde("shape", e, t, n))];
                case "MirrorPad":
                    return [r.mirrorPad(lde("x", e, t, n), lde("padding", e, t, n), lde("mode", e, t, n))];
                case "PadV2":
                case "Pad":
                    return [r.pad(lde("x", e, t, n), lde("padding", e, t, n), lde("constantValue", e, t, n))];
                case "SpaceToBatchND":
                    var o = lde("blockShape", e, t, n),
                        s = lde("paddings", e, t, n);
                    return [r.spaceToBatchND(lde("x", e, t, n), o, s)];
                case "BatchToSpaceND":
                    var u = lde("blockShape", e, t, n),
                        c = lde("crops", e, t, n);
                    return [r.batchToSpaceND(lde("x", e, t, n), u, c)];
                case "DepthToSpace":
                    var l = lde("blockSize", e, t, n),
                        h = lde("dataFormat", e, t, n).toUpperCase();
                    return [r.depthToSpace(lde("x", e, t, n), l, h)];
                case "BroadcastTo":
                    return [r.broadcastTo(lde("x", e, t, n), lde("shape", e, t, n))];
                case "BroadcastArgs":
                    return [r.broadcastArgs(lde("s0", e, t, n), lde("s1", e, t, n))];
                default:
                    throw TypeError("Node type ".concat(e.op, " is not implemented"))
            }
        };

    function Fve(e, t, n, r) {
        var a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : X5,
            i = function(e, t, n) {
                switch (e.category) {
                    case "arithmetic":
                        return a((function() {
                            return eve(e, t, n)
                        }));
                    case "basic_math":
                        return a((function() {
                            return tve(e, t, n)
                        }));
                    case "control":
                        return pve(e, t, n);
                    case "convolution":
                        return a((function() {
                            return dve(e, t, n)
                        }));
                    case "creation":
                        return a((function() {
                            return vve(e, t, n)
                        }));
                    case "dynamic":
                        return gve(e, t, n);
                    case "evaluation":
                        return a((function() {
                            return yve(e, t, n)
                        }));
                    case "image":
                        return a((function() {
                            return wve(e, t, n)
                        }));
                    case "graph":
                        return a((function() {
                            return bve(e, t, n)
                        }));
                    case "logical":
                        return a((function() {
                            return Ive(e, t, n)
                        }));
                    case "matrices":
                        return a((function() {
                            return Nve(e, t, n)
                        }));
                    case "normalization":
                        return a((function() {
                            return Sve(e, t, n)
                        }));
                    case "ragged":
                        return a((function() {
                            return Tve(e, t, n)
                        }));
                    case "reduction":
                        return a((function() {
                            return Eve(e, t, n)
                        }));
                    case "slice_join":
                        return a((function() {
                            return Cve(e, t, n)
                        }));
                    case "sparse":
                        return a((function() {
                            return Ave(e, t, n)
                        }));
                    case "spectral":
                        return a((function() {
                            return Rve(e, t, n)
                        }));
                    case "string":
                        return a((function() {
                            return _ve(e, t, n)
                        }));
                    case "transformation":
                        return a((function() {
                            return Ove(e, t, n)
                        }));
                    case "hash_table":
                        return kve(e, t, n, r);
                    case "custom":
                        var i = cde(e.op);
                        if (i && i.customExecutor) return i.customExecutor(new Qde(e, t, n));
                        throw TypeError("Custom op ".concat(e.op, " is not registered."));
                    default:
                        throw TypeError("Unknown op '".concat(e.op, "'. File an issue at ") + "https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()")
                }
            }(e, t, n);
        return v0(i) ? i.then((function(e) {
            return [].concat(e)
        })) : [].concat(i)
    }
    var Dve = function() {
        function e() {
            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},
                i = arguments.length > 4 ? arguments[4] : void 0;
            l(this, e), this.weightMap = t, this.tensorArrayMap = n, this.tensorListMap = r, this.functionMap = a, this.parseNodeNameCache = i, this.rootContext = {
                id: 0,
                frameName: "",
                iterationId: 0
            }, this.contexts = [this.rootContext], this.lastId = 0, this.generateCurrentContextIds()
        }
        return p(e, [{
            key: "newFrame",
            value: function(e, t) {
                return {
                    id: e,
                    frameName: t,
                    iterationId: 0
                }
            }
        }, {
            key: "currentContext",
            get: function() {
                return this.contexts
            },
            set: function(e) {
                this.contexts !== e && (this.contexts = e, this.generateCurrentContextIds())
            }
        }, {
            key: "currentContextId",
            get: function() {
                return this._currentContextIds[0]
            }
        }, {
            key: "currentContextIds",
            get: function() {
                return this._currentContextIds
            }
        }, {
            key: "generateCurrentContextIds",
            value: function() {
                for (var e = [], t = 0; t < this.contexts.length - 1; t++) {
                    var n = this.contexts.slice(0, this.contexts.length - t);
                    e.push(this.contextIdforContexts(n))
                }
                e.push(""), this._currentContextIds = e
            }
        }, {
            key: "contextIdforContexts",
            value: function(e) {
                return e ? e.map((function(e) {
                    return 0 === e.id && 0 === e.iterationId ? "" : "".concat(e.frameName, "-").concat(e.iterationId)
                })).join("/") : ""
            }
        }, {
            key: "enterFrame",
            value: function(e) {
                this.contexts && (this.lastId++, this.contexts = this.contexts.slice(), this.contexts.push(this.newFrame(this.lastId, e)), this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))
            }
        }, {
            key: "exitFrame",
            value: function() {
                if (!(this.contexts && this.contexts.length > 1)) throw new Error("Cannot exit frame, the context is empty");
                this.contexts = this.contexts.slice(), this.contexts.splice(-1), this.currentContextIds.shift()
            }
        }, {
            key: "nextIteration",
            value: function() {
                if (!(this.contexts && this.contexts.length > 0)) throw new Error("Cannot increase frame iteration, the context is empty");
                this.contexts = this.contexts.slice(), this.lastId++;
                var e = Object.assign({}, this.contexts[this.contexts.length - 1]);
                e.iterationId += 1, e.id = this.lastId, this.contexts.splice(-1, 1, e), this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts))
            }
        }, {
            key: "getWeight",
            value: function(e) {
                return this.weightMap[e]
            }
        }, {
            key: "addTensorArray",
            value: function(e) {
                this.tensorArrayMap[e.id] = e
            }
        }, {
            key: "getTensorArray",
            value: function(e) {
                return this.tensorArrayMap[e]
            }
        }, {
            key: "addTensorList",
            value: function(e) {
                this.tensorListMap[e.id] = e
            }
        }, {
            key: "getTensorList",
            value: function(e) {
                return this.tensorListMap[e]
            }
        }, {
            key: "dispose",
            value: function(e) {
                for (var t in this.tensorArrayMap) this.tensorArrayMap[t].clearAndClose(e);
                for (var n in this.tensorListMap) this.tensorListMap[n].clearAndClose(e)
            }
        }]), e
    }();

    function Mve(e, t, n, r) {
        var a = new Set,
            i = [],
            o = null,
            s = null,
            u = new Set,
            c = new Set(Object.keys(e).map((function(e) {
                return vde(e)[0]
            })));
        r = r || [];
        for (var l = new Set(r.map((function(e) {
                return vde(e.name)[0]
            }))), h = T(t); h.length > 0;) {
            var p = h.pop();
            (Uve(p) || Vve(p) || Gve(p)) && null == o && (s = (o = p).children.map((function(e) {
                return e.name
            })).filter((function(e) {
                return a.has(e)
            }))), a.add(p.name), null == n[p.name] && (c.has(p.name) || l.has(p.name) || (0 !== p.inputs.length ? p.inputs.forEach((function(e) {
                u.has(e.name) || (u.add(e.name), h.push(e))
            })) : i.push(p.name)))
        }
        return {
            inputs: e,
            outputs: t,
            usedNodes: a,
            missingInputs: i,
            dynamicNode: o,
            syncInputs: s
        }
    }

    function Lve(e, t) {
        var n = t.usedNodes,
            r = t.inputs,
            a = Object.keys(r).map((function(e) {
                return vde(e)[0]
            })).map((function(t) {
                return e.nodes[t]
            })),
            i = e.initNodes || [],
            o = function(e) {
                return n.has("string" == typeof e ? e : e.name)
            };

        function s(e) {
            return T(new Map(e.map((function(e) {
                return [e.name, e]
            }))).values())
        }
        var u, c = s([].concat(T(a), T(e.weights), T(i))).filter(o),
            l = s([].concat(T(c), T(Object.values(e.nodes)))).filter(o),
            h = new Map(l.map((function(e) {
                return [e.name, e]
            }))),
            p = {},
            f = O(l);
        try {
            for (f.s(); !(u = f.n()).done;) {
                var d = u.value;
                p[d.name] = p[d.name] || 0;
                var v, m = O(d.children);
                try {
                    for (m.s(); !(v = m.n()).done;) {
                        var g = v.value;
                        o(g) || (p[g.name] = Number.POSITIVE_INFINITY), p[g.name] = (p[g.name] || 0) + 1
                    }
                } catch (e) {
                    m.e(e)
                } finally {
                    m.f()
                }
            }
        } catch (e) {
            f.e(e)
        } finally {
            f.f()
        }
        for (var y = Object.entries(p).filter((function(e) {
                return 0 === S(e, 2)[1]
            })).map((function(e) {
                return S(e, 1)[0]
            })), b = T(y); y.length > 0;) {
            var x, k = y.pop(),
                w = O(h.get(k).children.filter(o));
            try {
                for (w.s(); !(x = w.n()).done;) {
                    var I = x.value;
                    0 == --p[I.name] && (b.push(I.name), y.push(I.name))
                }
            } catch (e) {
                w.e(e)
            } finally {
                w.f()
            }
        }
        var N = function(e, t) {
            var n = new Map(e.map((function(e) {
                    return [e.name, e]
                }))),
                r = t.map((function(e) {
                    return e.name
                })),
                a = new Set(r);
            for (; r.length > 0;) {
                var i, o = r.pop(),
                    s = O(n.get(o).children);
                try {
                    for (s.s(); !(i = s.n()).done;) {
                        var u = i.value;
                        n.has(u.name) && !a.has(u.name) && (a.add(u.name), r.push(u.name))
                    }
                } catch (e) {
                    s.e(e)
                } finally {
                    s.f()
                }
            }
            var c = e.filter((function(e) {
                return a.has(e.name)
            }));
            return c
        }(b.map((function(e) {
            return h.get(e)
        })), c);
        return function(e, t) {
            var n, r = new Map(e.map((function(e, t) {
                    return [e.name, t]
                }))),
                a = new Set(t.map((function(e) {
                    return e.name
                }))),
                i = function(e) {
                    return a.has("string" == typeof e ? e : e.name)
                },
                o = new Set(e.map((function(e) {
                    return e.name
                }))),
                s = function(e) {
                    return o.has("string" == typeof e ? e : e.name)
                },
                u = O(e);
            try {
                for (u.s(); !(n = u.n()).done;) {
                    var c, l = n.value,
                        h = O(l.children.filter(s));
                    try {
                        for (h.s(); !(c = h.n()).done;) {
                            var p = c.value;
                            if (!r.has(p.name)) throw new zve("Child ".concat(p.name, " of node ").concat(l.name, " is unreachable."));
                            if (r.get(l.name) > r.get(p.name)) throw new zve("Node ".concat(l.name, " is scheduled to run after its child ").concat(p.name, "."))
                        }
                    } catch (e) {
                        h.e(e)
                    } finally {
                        h.f()
                    }
                    if (!i(l)) {
                        var f, d = O(l.inputs);
                        try {
                            for (d.s(); !(f = d.n()).done;) {
                                var v = f.value;
                                if (!r.has(v.name)) throw new zve("Input ".concat(v.name, " of node ").concat(l.name, " is unreachable."));
                                if (r.get(v.name) > r.get(l.name)) throw new zve("Node ".concat(l.name, " is scheduled to run before its input ").concat(v.name, "."))
                            }
                        } catch (e) {
                            d.e(e)
                        } finally {
                            d.f()
                        }
                    }
                }
            } catch (e) {
                u.e(e)
            } finally {
                u.f()
            }
        }(N, c), N
    }
    var zve = function(e) {
        d(n, e);
        var t = w(n);

        function n(e) {
            return l(this, n), t.call(this, "NodesExecutionOrderError: ".concat(e))
        }
        return p(n)
    }(b(Error));
    var Pve = new Set(["Switch", "Merge", "Enter", "Exit", "NextIteration", "StatelessIf", "StatelessWhile", "if", "While"]),
        Bve = new Set(["NonMaxSuppressionV2", "NonMaxSuppressionV3", "NonMaxSuppressionV5", "Where"]),
        Wve = new Set(["HashTable", "HashTableV2", "LookupTableImport", "LookupTableImportV2", "LookupTableFind", "LookupTableFindV2", "LookupTableSize", "LookupTableSizeV2"]);

    function Uve(e) {
        return Pve.has(e.op)
    }

    function Vve(e) {
        return Bve.has(e.op)
    }

    function Gve(e) {
        return Wve.has(e.op)
    }
    var jve = function() {
            function e(t, n) {
                var r = this;
                l(this, e), this.graph = t, this.parent = n, this.compiledMap = new Map, this.parseNodeNameCache = new Map, this._weightMap = {}, this.SEPARATOR = ",", this._functions = {}, this._functionExecutorMap = {}, this.keepIntermediateTensors = !1, this._outputs = t.outputs, this._inputs = t.inputs, this._initNodes = t.initNodes, this._signature = t.signature, this._functions = t.functions, null != t.functions && Object.keys(t.functions).forEach((function(n) {
                    r._functionExecutorMap[n] = new e(t.functions[n], r)
                }))
            }
            var t, n, r, a;
            return p(e, [{
                key: "weightIds",
                get: function() {
                    return this.parent ? this.parent.weightIds : this._weightIds
                }
            }, {
                key: "functionExecutorMap",
                get: function() {
                    return this.parent ? this.parent.functionExecutorMap : this._functionExecutorMap
                }
            }, {
                key: "weightMap",
                get: function() {
                    return this.parent ? this.parent.weightMap : this._weightMap
                },
                set: function(e) {
                    var t, n = Object.keys(e).map((function(t) {
                        return e[t].map((function(e) {
                            return e.id
                        }))
                    }));
                    this._weightIds = (t = []).concat.apply(t, T(n)), this._weightMap = e
                }
            }, {
                key: "resourceManager",
                set: function(e) {
                    this._resourceManager = e
                }
            }, {
                key: "inputs",
                get: function() {
                    return this._inputs.map((function(e) {
                        return {
                            name: e.name,
                            shape: e.attrParams.shape ? e.attrParams.shape.value : void 0,
                            dtype: e.attrParams.dtype ? e.attrParams.dtype.value : void 0
                        }
                    }))
                }
            }, {
                key: "outputs",
                get: function() {
                    return this._outputs.map((function(e) {
                        return {
                            name: e.name,
                            shape: e.attrParams.shape ? e.attrParams.shape.value : void 0,
                            dtype: e.attrParams.dtype ? e.attrParams.dtype.value : void 0
                        }
                    }))
                }
            }, {
                key: "inputNodes",
                get: function() {
                    return this._inputs.map((function(e) {
                        return e.signatureKey || e.name
                    }))
                }
            }, {
                key: "outputNodes",
                get: function() {
                    return this._outputs.map((function(e) {
                        var t = e.signatureKey || e.name;
                        return e.defaultOutput ? "".concat(t, ":").concat(e.defaultOutput) : t
                    }))
                }
            }, {
                key: "functions",
                get: function() {
                    var e = this;
                    return Object.keys(this._functions).reduce((function(t, n) {
                        return t[n] = e._functions[n].signature, t
                    }), {})
                }
            }, {
                key: "getCompilationKey",
                value: function(e, t) {
                    var n = e.map((function(e) {
                            return e.name
                        })).sort(),
                        r = t.map((function(e) {
                            return e.name
                        })).sort();
                    return n.join(this.SEPARATOR) + "--" + r.join(this.SEPARATOR)
                }
            }, {
                key: "compile",
                value: function(e, t) {
                    var n = Mve(e, t, this.weightMap, this._initNodes),
                        r = n.missingInputs,
                        a = n.dynamicNode,
                        i = n.syncInputs;
                    if (null != a) throw new Error("This execution contains the node '".concat(a.name, "', which has ") + "the dynamic op '".concat(a.op, "'. Please use ") + "model.executeAsync() instead. Alternatively, to avoid the " + "dynamic ops, specify the inputs [".concat(i, "]"));
                    if (r.length > 0) {
                        var o = t.map((function(e) {
                                return e.name
                            })),
                            s = Object.keys(e);
                        throw new Error("Cannot compute the outputs [".concat(o, "] from the provided inputs ") + "[".concat(s, "]. Missing the following inputs: [").concat(r, "]"))
                    }
                    var u = Lve(this.graph, n),
                        c = function(e) {
                            for (var t = new Map(e.map((function(e, t) {
                                    return [e.name, t]
                                }))), n = Number.MAX_SAFE_INTEGER, r = e.map((function(e, t) {
                                    return Uve(e) ? n : t
                                })), a = function(e) {
                                    var n = r[t.get(e.name)];
                                    return null == n ? -1 : n
                                }, i = e.map((function(e, t) {
                                    return e.children.map(a).reduce((function(e, t) {
                                        return Math.max(e, t)
                                    }), r[t])
                                })), o = new Map, s = 0; s < e.length; ++s) {
                                var u = i[s];
                                if (u !== n) {
                                    var c = e[s],
                                        l = e[u];
                                    o.has(l.name) || o.set(l.name, []), o.get(l.name).push(c)
                                }
                            }
                            return o
                        }(u);
                    return {
                        orderedNodes: u,
                        nodeLiveUntilMap: c
                    }
                }
            }, {
                key: "cloneAndKeepTensor",
                value: function(e) {
                    if (null == e) return null;
                    var t = e.clone();
                    return J5(t), t
                }
            }, {
                key: "cloneTensorList",
                value: function(e) {
                    var t = this;
                    if (!e) return null;
                    var n = e.map((function(e) {
                        return t.cloneAndKeepTensor(e)
                    }));
                    return n
                }
            }, {
                key: "cloneTensorMap",
                value: function(e) {
                    var t = this;
                    return Object.fromEntries(Object.entries(e).map((function(e) {
                        var n = S(e, 2),
                            r = n[0],
                            a = n[1];
                        return [r, t.cloneTensorList(a)]
                    })))
                }
            }, {
                key: "execute",
                value: function(e, t) {
                    var n = this;
                    this.disposeIntermediateTensors(), e = this.mapInputs(e);
                    var r = Object.keys(e).sort();
                    this.checkInputs(e), this.checkInputShapeAndType(e), t = this.mapOutputs(t), this.checkOutputs(t);
                    var a = r.map((function(e) {
                            return n.graph.nodes[vde(e)[0]]
                        })),
                        i = t.map((function(e) {
                            return vde(e)[0]
                        })),
                        o = new Set(i),
                        s = i.map((function(e) {
                            return n.graph.nodes[e]
                        }));
                    0 === s.length && (s = this._outputs);
                    var u = this.getCompilationKey(a, s),
                        c = this.compiledMap.get(u);
                    null == c && (c = this.compile(e, s), this.compiledMap.set(u, c));
                    try {
                        this.keepIntermediateTensors = k0().getBool("KEEP_INTERMEDIATE_TENSORS")
                    } catch (e) {
                        this.keepIntermediateTensors = !1, console.warn(e.message)
                    }
                    var l = {},
                        h = {};
                    return X5((function() {
                        var r = new Dve(n.weightMap, l, h, n.functionExecutorMap, n.parseNodeNameCache),
                            a = Object.assign({}, n.weightMap);
                        n.keepIntermediateTensors && (n.clonedTensorsMap = n.cloneTensorMap(n.weightMap)), Object.keys(e).forEach((function(t) {
                            var i = S(vde(t, r), 2),
                                o = i[0],
                                s = [];
                            s[i[1]] = e[t], a[o] = s, n.keepIntermediateTensors && (n.clonedTensorsMap[o] = n.cloneTensorList(s))
                        }));
                        var i, s = n.getFrozenTensorIds(a),
                            u = c,
                            p = u.orderedNodes,
                            f = u.nodeLiveUntilMap,
                            d = O(p);
                        try {
                            for (d.s(); !(i = d.n()).done;) {
                                var v = i.value;
                                if (!a[v.name]) {
                                    var m = Fve(v, a, r, n._resourceManager);
                                    if (v0(m)) throw new Error("The execution of the op '".concat(v.op, "' returned a promise. ") + "Please use model.executeAsync() instead.");
                                    a[v.name] = m, n.keepIntermediateTensors && (n.clonedTensorsMap[v.name] = n.cloneTensorList(m)), n.checkTensorForDisposalWithNodeLiveUntilInfo(v, a, r, s, o, f.get(v.name))
                                }
                            }
                        } catch (e) {
                            d.e(e)
                        } finally {
                            d.f()
                        }
                        return null == n.parent && r.dispose(s), t.map((function(e) {
                            return hde(e, a, r)
                        }))
                    }))
                }
            }, {
                key: "getFrozenTensorIds",
                value: function(e) {
                    var t = [].concat.apply([], Object.keys(e).map((function(t) {
                        return e[t]
                    })).map((function(e) {
                        return e.map((function(e) {
                            return e.id
                        }))
                    })));
                    return new Set(t)
                }
            }, {
                key: "checkTensorForDisposal",
                value: function(e, t, n, r, a, i, o) {
                    if (!Uve(t) && !i.has(e)) {
                        var s, u = O(n[e]);
                        try {
                            for (u.s(); !(s = u.n()).done;) {
                                var c = s.value;
                                null != c && (o[c.id] = (o[c.id] || 0) + t.children.length)
                            }
                        } catch (e) {
                            u.e(e)
                        } finally {
                            u.f()
                        }
                        var l, h = O(t.inputs);
                        try {
                            for (h.s(); !(l = h.n()).done;) {
                                var p = l.value;
                                if (!Uve(p)) {
                                    var f = pde(p.name, n, r);
                                    if (null != f) {
                                        var d, v = O(f);
                                        try {
                                            for (v.s(); !(d = v.n()).done;) {
                                                var m = d.value;
                                                if (m && !m.kept && !a.has(m.id)) {
                                                    var g = o[m.id];
                                                    1 === g ? (m.dispose(), delete o[m.id]) : null != g && o[m.id]--
                                                }
                                            }
                                        } catch (e) {
                                            v.e(e)
                                        } finally {
                                            v.f()
                                        }
                                    }
                                }
                            }
                        } catch (e) {
                            h.e(e)
                        } finally {
                            h.f()
                        }
                    }
                }
            }, {
                key: "checkTensorForDisposalWithNodeLiveUntilInfo",
                value: function(e, t, n, r, a, i) {
                    function o(e) {
                        return Uve(e) || a.has(e.name)
                    }
                    if (!Uve(e) && null != i) {
                        var s, u = O(i);
                        try {
                            for (u.s(); !(s = u.n()).done;) {
                                var c = s.value;
                                if (!o(c)) {
                                    var l, h = O(pde(c.name, t, n));
                                    try {
                                        for (h.s(); !(l = h.n()).done;) {
                                            var p = l.value;
                                            !p || p.kept || r.has(p.id) || p.dispose()
                                        }
                                    } catch (e) {
                                        h.e(e)
                                    } finally {
                                        h.f()
                                    }
                                }
                            }
                        } catch (e) {
                            u.e(e)
                        } finally {
                            u.f()
                        }
                    }
                }
            }, {
                key: "executeAsync",
                value: (a = c(o().mark((function e(t, n) {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.abrupt("return", this._executeAsync(t, n));
                            case 1:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e, t) {
                    return a.apply(this, arguments)
                })
            }, {
                key: "disposeIntermediateTensors",
                value: function() {
                    this.clonedTensorsMap && (Object.values(this.clonedTensorsMap).forEach((function(e) {
                        var t, n = O(e);
                        try {
                            for (n.s(); !(t = n.n()).done;) {
                                var r = t.value;
                                r && !r.isDisposed && r.dispose()
                            }
                        } catch (e) {
                            n.e(e)
                        } finally {
                            n.f()
                        }
                    })), this.clonedTensorsMap = null)
                }
            }, {
                key: "getIntermediateTensors",
                value: function() {
                    return this.clonedTensorsMap
                }
            }, {
                key: "_executeAsync",
                value: (r = c(o().mark((function e(t, n) {
                    var r, a, i, s, u, c, l, h, p, f = arguments;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                r = f.length > 2 && void 0 !== f[2] && f[2], a = f.length > 3 && void 0 !== f[3] ? f[3] : {}, i = f.length > 4 && void 0 !== f[4] ? f[4] : {}, this.disposeIntermediateTensors(), r || (t = this.mapInputs(t), this.checkInputs(t), this.checkInputShapeAndType(t), n = this.mapOutputs(n), this.checkOutputs(n));
                                try {
                                    this.keepIntermediateTensors = k0().getBool("KEEP_INTERMEDIATE_TENSORS")
                                } catch (e) {
                                    this.keepIntermediateTensors = !1, console.warn(e.message)
                                }
                                return s = new Dve(this.weightMap, a, i, this.functionExecutorMap, this.parseNodeNameCache), this.keepIntermediateTensors && (this.clonedTensorsMap = this.cloneTensorMap(this.weightMap)), e.next = 10, this.executeWithControlFlow(t, s, n, r);
                            case 10:
                                return u = e.sent, c = n.map((function(e) {
                                    return hde(e, u, s)
                                })), l = c.map((function(e) {
                                    return e.id
                                })), h = Object.keys(t).map((function(e) {
                                    return t[e].id
                                })), p = new Set([].concat(T(l), T(h), T(this.weightIds))), Object.values(u).forEach((function(e) {
                                    e.forEach((function(e) {
                                        !e || e.isDisposed || p.has(e.id) || e.dispose()
                                    }))
                                })), null == this.parent && s.dispose(p), e.abrupt("return", c);
                            case 18:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e, t) {
                    return r.apply(this, arguments)
                })
            }, {
                key: "executeFunctionAsync",
                value: (n = c(o().mark((function e(t, n, r) {
                    var a, i = this;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return a = t.reduce((function(e, t, n) {
                                    return e[i.inputs[n].name] = t, e
                                }), {}), e.abrupt("return", this._executeAsync(a, this.outputNodes, !0, n, r));
                            case 2:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e, t, r) {
                    return n.apply(this, arguments)
                })
            }, {
                key: "executeWithControlFlow",
                value: (t = c(o().mark((function e(t, n, r, a) {
                    var i, s, u, c, l, h, p, f, d, v, m, g, y, b, x, k, w, I, N = this;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                i = Object.keys(t), s = i.map((function(e) {
                                    return N.graph.nodes[vde(e)[0]]
                                })), u = r.map((function(e) {
                                    return vde(e)[0]
                                })), c = new Set(u), 0 === (l = u.map((function(e) {
                                    return N.graph.nodes[e]
                                }))).length && (l = this._outputs), h = Mve(t, l, this.weightMap, this._initNodes), p = h.usedNodes, f = h.missingInputs, d = h.dynamicNode, v = h.syncInputs, m = [].concat(T(s), T(this.graph.weights), T(this._initNodes || [])).map((function(e) {
                                    return {
                                        node: e,
                                        contexts: n.currentContext
                                    }
                                })), g = Object.assign({}, this.weightMap), Object.keys(t).forEach((function(e) {
                                    var n = S(vde(e), 2),
                                        r = n[0],
                                        a = [];
                                    a[n[1]] = t[e], g[r] = a
                                })), y = {}, b = this.getFrozenTensorIds(g), x = {};
                            case 13:
                                if (!(m.length > 0)) {
                                    e.next = 19;
                                    break
                                }
                                return k = this.processStack(s, m, n, g, x, b, c, y, p), e.next = 17, Promise.all(k);
                            case 17:
                                e.next = 13;
                                break;
                            case 19:
                                if (null != d || a || console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead."), w = l.filter((function(e) {
                                        return !Uve(e) && !hde(e.name, g, n)
                                    })).map((function(e) {
                                        return e.name
                                    })), !(w.length > 0)) {
                                    e.next = 25;
                                    break
                                }
                                throw I = "", null != d && (I = "Alternatively, to avoid the dynamic ops, use model.execute() " + "and specify the inputs [".concat(v, "]")), new Error("Cannot compute the outputs [".concat(w, "] from the provided ") + "inputs [".concat(i, "]. Consider providing the following inputs: ") + "[".concat(f, "]. ").concat(I));
                            case 25:
                                return e.abrupt("return", g);
                            case 26:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e, n, r, a) {
                    return t.apply(this, arguments)
                })
            }, {
                key: "processStack",
                value: function(e, t, n, r, a, i, o, s, u) {
                    for (var c = this, l = [], h = function() {
                            var e = t.pop();
                            n.currentContext = e.contexts;
                            var h = "";
                            if ("Enter" === e.node.op && lde("isConstant", e.node, r, n)) {
                                var p = S(fde(e.node.name, n), 1);
                                h = p[0]
                            }
                            if (null == r[e.node.name]) {
                                var f = Fve(e.node, r, n, c._resourceManager);
                                if (!h) {
                                    var d = S(fde(e.node.name, n), 1);
                                    h = d[0]
                                }
                                var v = n.currentContext;
                                v0(f) ? l.push(f.then((function(l) {
                                    return r[h] = l, c.keepIntermediateTensors && (c.clonedTensorsMap[h] = c.cloneTensorList(l)), n.currentContext = v, c.checkTensorForDisposal(h, e.node, r, n, i, o, s), c.processChildNodes(e.node, t, n, r, a, u), l
                                }))) : (r[h] = f, c.keepIntermediateTensors && (c.clonedTensorsMap[h] = c.cloneTensorList(f)), c.checkTensorForDisposal(h, e.node, r, n, i, o, s), c.processChildNodes(e.node, t, n, r, a, u))
                            } else c.processChildNodes(e.node, t, n, r, a, u)
                        }; t.length > 0;) h();
                    return l
                }
            }, {
                key: "processChildNodes",
                value: function(e, t, n, r, a, i) {
                    e.children.forEach((function(e) {
                        var o = S(fde(e.name, n), 1)[0];
                        !a[o] && i.has(e.name) && ("Merge" === e.op ? e.inputNames.some((function(e) {
                            return !!hde(e, r, n)
                        })) && (a[o] = !0, t.push({
                            contexts: n.currentContext,
                            node: e
                        })) : e.inputNames.every((function(e) {
                            return !!hde(e, r, n)
                        })) && (a[o] = !0, t.push({
                            contexts: n.currentContext,
                            node: e
                        })))
                    }))
                }
            }, {
                key: "dispose",
                value: function() {
                    var e = this;
                    Object.keys(this.weightMap).forEach((function(t) {
                        return e.weightMap[t].forEach((function(e) {
                            return e.dispose()
                        }))
                    }))
                }
            }, {
                key: "checkInputShapeAndType",
                value: function(e) {
                    var t = this;
                    Object.keys(e).forEach((function(n) {
                        var r = e[n],
                            a = S(vde(n), 1)[0],
                            i = t.graph.nodes[a];
                        if (i.attrParams.shape && i.attrParams.shape.value) {
                            var o = i.attrParams.shape.value,
                                s = o.length === r.shape.length && r.shape.every((function(e, t) {
                                    return -1 === o[t] || o[t] === e
                                }));
                            F$(s, (function() {
                                return "The shape of dict['".concat(i.name, "'] provided in ") + "model.execute(dict) must be [".concat(o, "], but was ") + "[".concat(r.shape, "]")
                            }))
                        }
                        i.attrParams.dtype && i.attrParams.dtype.value && F$(r.dtype === i.attrParams.dtype.value, (function() {
                            return "The dtype of dict['".concat(i.name, "'] provided in ") + "model.execute(dict) must be " + "".concat(i.attrParams.dtype.value, ", but was ").concat(r.dtype)
                        }))
                    }))
                }
            }, {
                key: "mapInputs",
                value: function(e) {
                    var t, n, r = {};
                    for (var a in e) {
                        var i = null === (n = null === (t = this._signature) || void 0 === t ? void 0 : t.inputs) || void 0 === n ? void 0 : n[a];
                        null != i ? r[i.name] = e[a] : r[a] = e[a]
                    }
                    return r
                }
            }, {
                key: "checkInputs",
                value: function(e) {
                    var t = this,
                        n = Object.keys(e).filter((function(e) {
                            var n = S(vde(e), 1)[0];
                            return null == t.graph.nodes[n]
                        }));
                    if (n.length > 0) throw new Error("The dict provided in model.execute(dict) has " + "keys: [".concat(n, "] that are not part of graph"))
                }
            }, {
                key: "mapOutputs",
                value: function(e) {
                    var t = this;
                    return e.map((function(e) {
                        var n, r, a = null === (r = null === (n = t._signature) || void 0 === n ? void 0 : n.outputs) || void 0 === r ? void 0 : r[e];
                        return null != a ? a.name : e
                    }), {})
                }
            }, {
                key: "checkOutputs",
                value: function(e) {
                    var t = this;
                    e.forEach((function(e) {
                        var n = S(vde(e), 1)[0];
                        if (!t.graph.nodes[n]) throw new Error("The output '".concat(e, "' is not found in the graph"))
                    }))
                }
            }]), e
        }(),
        Hve = function() {
            function e() {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                    n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                l(this, e), this.hashTableNameToHandle = t, this.hashTableMap = n
            }
            return p(e, [{
                key: "addHashTable",
                value: function(e, t) {
                    this.hashTableNameToHandle[e] = t.handle, this.hashTableMap[t.id] = t
                }
            }, {
                key: "getHashTableHandleByName",
                value: function(e) {
                    return this.hashTableNameToHandle[e]
                }
            }, {
                key: "getHashTableById",
                value: function(e) {
                    return this.hashTableMap[e]
                }
            }, {
                key: "dispose",
                value: function() {
                    for (var e in this.hashTableMap) this.hashTableMap[e].clearAndClose(), delete this.hashTableMap[e];
                    for (var t in this.hashTableNameToHandle) this.hashTableNameToHandle[t].dispose(), delete this.hashTableNameToHandle[t]
                }
            }]), e
        }(),
        qve = function() {
            function e(t) {
                var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Nae;
                l(this, e), this.modelUrl = t, this.loadOptions = n, this.version = "n/a", this.io = r, null == n && (this.loadOptions = {}), this.resourceManager = new Hve
            }
            var t, n, r, a, i;
            return p(e, [{
                key: "modelVersion",
                get: function() {
                    return this.version
                }
            }, {
                key: "inputNodes",
                get: function() {
                    return this.executor.inputNodes
                }
            }, {
                key: "outputNodes",
                get: function() {
                    return this.executor.outputNodes
                }
            }, {
                key: "inputs",
                get: function() {
                    return this.executor.inputs
                }
            }, {
                key: "outputs",
                get: function() {
                    return this.executor.outputs
                }
            }, {
                key: "weights",
                get: function() {
                    return this.executor.weightMap
                }
            }, {
                key: "metadata",
                get: function() {
                    return this.artifacts.userDefinedMetadata
                }
            }, {
                key: "modelSignature",
                get: function() {
                    return this.signature
                }
            }, {
                key: "modelStructuredOutputKeys",
                get: function() {
                    return this.structuredOutputKeys
                }
            }, {
                key: "findIOHandler",
                value: function() {
                    var e = this.modelUrl;
                    if (null != e.load) this.handler = e;
                    else if (null != this.loadOptions.requestInit) this.handler = this.io.browserHTTPRequest(e, this.loadOptions);
                    else {
                        var t = this.io.getLoadHandlers(e, this.loadOptions);
                        if (0 === t.length) t.push(this.io.browserHTTPRequest(e, this.loadOptions));
                        else if (t.length > 1) throw new Error("Found more than one (".concat(t.length, ") load handlers for ") + "URL '".concat([e], "'"));
                        this.handler = t[0]
                    }
                }
            }, {
                key: "load",
                value: function() {
                    var e = this;
                    if (this.findIOHandler(), null == this.handler.load) throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
                    var t = this.handler.load();
                    return v0(t) ? t.then((function(t) {
                        return null == t.getWeightStream ? e.loadSync(t) : e.loadStreaming(t)
                    })) : this.loadSync(t)
                }
            }, {
                key: "loadSync",
                value: function(e) {
                    var t = this.io.decodeWeights(e.weightData, e.weightSpecs);
                    return this.loadWithWeightMap(e, t)
                }
            }, {
                key: "loadStreaming",
                value: (i = c(o().mark((function e(t) {
                    var n;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (null != t.getWeightStream) {
                                    e.next = 2;
                                    break
                                }
                                throw new Error("Model artifacts missing streamWeights function");
                            case 2:
                                return e.next = 4, l6(t.getWeightStream(), t.weightSpecs);
                            case 4:
                                return n = e.sent, e.abrupt("return", this.loadWithWeightMap(t, n));
                            case 6:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e) {
                    return i.apply(this, arguments)
                })
            }, {
                key: "loadWithWeightMap",
                value: function(e, t) {
                    this.artifacts = e;
                    var n = this.artifacts.modelTopology,
                        r = this.artifacts.signature;
                    if (null != this.artifacts.userDefinedMetadata) {
                        var a = this.artifacts.userDefinedMetadata;
                        null != a.signature && (r = a.signature), null != a.structuredOutputKeys && (this.structuredOutputKeys = a.structuredOutputKeys)
                    }
                    if (this.signature = r, this.version = "".concat(n.versions.producer, ".").concat(n.versions.minConsumer), this.executor = new jve(zde.Instance.transformGraph(n, this.signature)), this.executor.weightMap = this.convertTensorMapToTensorsMap(t), this.executor.resourceManager = this.resourceManager, null != e.modelInitializer && null != e.modelInitializer.node) {
                        var i = zde.Instance.transformGraph(e.modelInitializer);
                        this.initializer = new jve(i), this.initializer.weightMap = this.executor.weightMap, this.initializer.resourceManager = this.resourceManager, this.initializerSignature = e.initializerSignature
                    }
                    return !0
                }
            }, {
                key: "save",
                value: (a = c(o().mark((function e(t, n) {
                    var r;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if ("string" != typeof t) {
                                    e.next = 9;
                                    break
                                }
                                if (0 !== (r = this.io.getSaveHandlers(t)).length) {
                                    e.next = 6;
                                    break
                                }
                                throw new Error("Cannot find any save handlers for URL '".concat(t, "'"));
                            case 6:
                                if (!(r.length > 1)) {
                                    e.next = 8;
                                    break
                                }
                                throw new Error("Found more than one (".concat(r.length, ") save handlers for ") + "URL '".concat(t, "'"));
                            case 8:
                                t = r[0];
                            case 9:
                                if (null != t.save) {
                                    e.next = 11;
                                    break
                                }
                                throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
                            case 11:
                                return e.abrupt("return", t.save(this.artifacts));
                            case 12:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e, t) {
                    return a.apply(this, arguments)
                })
            }, {
                key: "addStructuredOutputNames",
                value: function(e) {
                    var t = this;
                    if (this.structuredOutputKeys) {
                        var n = {};
                        return (e instanceof n5 ? [e] : e).forEach((function(e, r) {
                            return n[t.structuredOutputKeys[r]] = e
                        })), n
                    }
                    return e
                }
            }, {
                key: "predict",
                value: function(e, t) {
                    var n = this.execute(e, this.outputNodes);
                    return this.addStructuredOutputNames(n)
                }
            }, {
                key: "predictAsync",
                value: (r = c(o().mark((function e(t, n) {
                    var r;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.executeAsync(t, this.outputNodes);
                            case 2:
                                return r = e.sent, e.abrupt("return", this.addStructuredOutputNames(r));
                            case 4:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e, t) {
                    return r.apply(this, arguments)
                })
            }, {
                key: "normalizeInputs",
                value: function(e) {
                    var t, n = this;
                    if (!(e instanceof n5 || Array.isArray(e))) {
                        var r = null === (t = this.signature) || void 0 === t ? void 0 : t.inputs;
                        if (null != r)
                            for (var a in r) {
                                var i = r[a];
                                null != i.resourceId && (e[a] = this.resourceIdToCapturedInput[i.resourceId])
                            }
                        return e
                    }
                    e = Array.isArray(e) ? e : [e];
                    var o = Object.keys(this.resourceIdToCapturedInput).length;
                    if (e.length + o !== this.inputNodes.length) throw new Error("Input tensor count mismatch, the graph model has ".concat(this.inputNodes.length - o, " non-resource placeholders, while there are ").concat(e.length, " input tensors provided."));
                    var s = 0;
                    return this.inputNodes.reduce((function(t, r) {
                        var a, i, o, u = null === (o = null === (i = null === (a = n.signature) || void 0 === a ? void 0 : a.inputs) || void 0 === i ? void 0 : i[r]) || void 0 === o ? void 0 : o.resourceId;
                        return t[r] = null != u ? n.resourceIdToCapturedInput[u] : e[s++], t
                    }), {})
                }
            }, {
                key: "normalizeOutputs",
                value: function(e) {
                    return e = e || this.outputNodes, Array.isArray(e) ? e : [e]
                }
            }, {
                key: "executeInitializerGraph",
                value: function() {
                    return null == this.initializer ? [] : null == this.initializerSignature ? this.initializer.execute({}, []) : this.initializer.execute({}, Object.keys(this.initializerSignature.outputs))
                }
            }, {
                key: "executeInitializerGraphAsync",
                value: (n = c(o().mark((function e() {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (null != this.initializer) {
                                    e.next = 2;
                                    break
                                }
                                return e.abrupt("return", []);
                            case 2:
                                if (null != this.initializerSignature) {
                                    e.next = 6;
                                    break
                                }
                                return e.abrupt("return", this.initializer.executeAsync({}, []));
                            case 6:
                                return e.abrupt("return", this.initializer.executeAsync({}, Object.keys(this.initializerSignature.outputs)));
                            case 7:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return n.apply(this, arguments)
                })
            }, {
                key: "setResourceIdToCapturedInput",
                value: function(e) {
                    if (this.resourceIdToCapturedInput = {}, this.initializerSignature)
                        for (var t = this.initializerSignature.outputs, n = Object.keys(t), r = 0; r < n.length; r++) {
                            var a = t[n[r]];
                            this.resourceIdToCapturedInput[a.resourceId] = e[r]
                        }
                }
            }, {
                key: "execute",
                value: function(e, t) {
                    null == this.resourceIdToCapturedInput && this.setResourceIdToCapturedInput(this.executeInitializerGraph()), e = this.normalizeInputs(e), t = this.normalizeOutputs(t);
                    var n = this.executor.execute(e, t);
                    return n.length > 1 ? n : n[0]
                }
            }, {
                key: "executeAsync",
                value: (t = c(o().mark((function e(t, n) {
                    var r;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (null != this.resourceIdToCapturedInput) {
                                    e.next = 6;
                                    break
                                }
                                return e.t0 = this, e.next = 4, this.executeInitializerGraphAsync();
                            case 4:
                                e.t1 = e.sent, e.t0.setResourceIdToCapturedInput.call(e.t0, e.t1);
                            case 6:
                                return t = this.normalizeInputs(t), n = this.normalizeOutputs(n), e.next = 10, this.executor.executeAsync(t, n);
                            case 10:
                                return r = e.sent, e.abrupt("return", r.length > 1 ? r : r[0]);
                            case 12:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e, n) {
                    return t.apply(this, arguments)
                })
            }, {
                key: "getIntermediateTensors",
                value: function() {
                    return this.executor.getIntermediateTensors()
                }
            }, {
                key: "disposeIntermediateTensors",
                value: function() {
                    this.executor.disposeIntermediateTensors()
                }
            }, {
                key: "convertTensorMapToTensorsMap",
                value: function(e) {
                    return Object.keys(e).reduce((function(t, n) {
                        return t[n] = [e[n]], t
                    }), {})
                }
            }, {
                key: "dispose",
                value: function() {
                    this.executor.dispose(), this.initializer && (this.initializer.dispose(), this.resourceIdToCapturedInput && Y5(this.resourceIdToCapturedInput)), this.resourceManager.dispose()
                }
            }]), e
        }();

    function Kve() {
        return Kve = c(o().mark((function e(t) {
            var n, r, a, i = arguments;
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        if (n = i.length > 1 && void 0 !== i[1] ? i[1] : {}, r = i.length > 2 && void 0 !== i[2] ? i[2] : Nae, null != t) {
                            e.next = 4;
                            break
                        }
                        throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");
                    case 4:
                        return null == n && (n = {}), n.fromTFHub && "string" == typeof t && (t = Xve(t)), a = new qve(t, n, r), e.next = 9, a.load();
                    case 9:
                        return e.abrupt("return", a);
                    case 10:
                    case "end":
                        return e.stop()
                }
            }), e)
        }))), Kve.apply(this, arguments)
    }

    function Xve(e) {
        return e.endsWith("/") || (e += "/"), "".concat(e).concat("model.json").concat("?tfjs-format=file")
    }
    var Yve = "4.22.0";

    function Jve(e, t) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new Map,
            r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : new Set;
        if (null == e) return null;
        if ("function" == typeof Blob && e instanceof Blob) return e.slice();
        if (r.has(e)) throw new Error("Circular references are not supported.");
        if (n.has(e)) return n.get(e);
        var a = t(e);
        if (a.recurse && null !== a.value) throw new Error("A deep map function may not return both a value and recurse=true.");
        if (a.recurse) {
            if (nme(e)) {
                var i = Array.isArray(e) ? [] : {};
                for (var o in r.add(e), e) {
                    var s = e[o],
                        u = Jve(s, t, n, r);
                    i[o] = u
                }
                return r.delete(e), e.__proto__ && (i.__proto__ = e.__proto__), i
            }
            throw new Error("Can't recurse into non-iterable type: ".concat(e))
        }
        return n.set(e, a.value), a.value
    }

    function Zve(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : $ve;
        return Qve(e, t)
    }

    function Qve(e, t) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new Set,
            r = e[0];
        if (n.has(r)) throw new Error("Circular references are not supported.");
        var a = t(e);
        if (a.recurse && null !== a.value) throw new Error("A deep zip function may not return both a value and recurse=true.");
        if (a.recurse) {
            if (nme(r)) {
                var i = Array.isArray(r) ? [] : {};
                n.add(r);
                var o = function(r) {
                    var a = Qve(e.map((function(e) {
                        return e[r]
                    })), t, n);
                    i[r] = a
                };
                for (var s in r) o(s);
                return n.delete(r), i
            }
            throw new Error("Can't recurse into non-iterable type: ".concat(r))
        }
        return a.value
    }

    function $ve(e) {
        return null === e ? null : nme(e[0]) ? {
            value: null,
            recurse: !0
        } : {
            value: e,
            recurse: !1
        }
    }

    function eme(e, t) {
        return tme.apply(this, arguments)
    }

    function tme() {
        return tme = c(o().mark((function e(t, n) {
            var r, a, i, s, u, c, l;
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        r = new Map, Jve(t, n, r), a = 0, i = Array.from(r.keys());
                    case 3:
                        if (!(a < i.length)) {
                            e.next = 14;
                            break
                        }
                        if (s = i[a], !v0(u = r.get(s))) {
                            e.next = 11;
                            break
                        }
                        return e.next = 9, u;
                    case 9:
                        c = e.sent, r.set(s, c);
                    case 11:
                        a++, e.next = 3;
                        break;
                    case 14:
                        return l = Jve(t, n, r), e.abrupt("return", l);
                    case 16:
                    case "end":
                        return e.stop()
                }
            }), e)
        }))), tme.apply(this, arguments)
    }

    function nme(e) {
        var t = !1;
        k0().get("IS_BROWSER") ? t = e instanceof TextDecoder : t = e instanceof require("string_decoder").StringDecoder;
        return null != e && !ArrayBuffer.isView(e) && (Array.isArray(e) || "object" === s(e) && !(e instanceof n5) && !(e instanceof Promise) && !t)
    }

    function rme(e) {
        return null == e || (null === (t = e) || "object" !== s(t) && "function" != typeof t) || Array.isArray(e) || "object" === s(e) && e instanceof n5 || U4(e);
        var t
    }

    function ame(e) {
        return function(e, t) {
            return Jve(e, t)
        }(e, ime)
    }

    function ime(e) {
        return e instanceof n5 ? {
            value: e.clone(),
            recurse: !1
        } : nme(e) ? {
            value: null,
            recurse: !0
        } : {
            value: e,
            recurse: !1
        }
    }
    var ome = function() {
            function e(t) {
                if (l(this, e), this.capacity = t, this.begin = 0, this.end = 0, null == t) throw new RangeError("Can't create a ring buffer of unknown capacity.");
                if (t < 1) throw new RangeError("Can't create ring buffer of capacity < 1.");
                this.data = new Array(t), this.doubledCapacity = 2 * t
            }
            return p(e, [{
                key: "wrap",
                value: function(e) {
                    for (; e < 0;) e += this.doubledCapacity;
                    return e % this.doubledCapacity
                }
            }, {
                key: "get",
                value: function(e) {
                    if (e < 0) throw new RangeError("Can't get item at a negative index.");
                    return this.data[e % this.capacity]
                }
            }, {
                key: "set",
                value: function(e, t) {
                    if (e < 0) throw new RangeError("Can't set item at a negative index.");
                    this.data[e % this.capacity] = t
                }
            }, {
                key: "length",
                value: function() {
                    var e = this.end - this.begin;
                    return e < 0 && (e = this.doubledCapacity + e), e
                }
            }, {
                key: "isFull",
                value: function() {
                    return this.length() === this.capacity
                }
            }, {
                key: "isEmpty",
                value: function() {
                    return 0 === this.length()
                }
            }, {
                key: "push",
                value: function(e) {
                    if (this.isFull()) throw new RangeError("Ring buffer is full.");
                    this.set(this.end, e), this.end = this.wrap(this.end + 1)
                }
            }, {
                key: "pushAll",
                value: function(e) {
                    var t, n = O(e);
                    try {
                        for (n.s(); !(t = n.n()).done;) {
                            var r = t.value;
                            this.push(r)
                        }
                    } catch (e) {
                        n.e(e)
                    } finally {
                        n.f()
                    }
                }
            }, {
                key: "pop",
                value: function() {
                    if (this.isEmpty()) throw new RangeError("Ring buffer is empty.");
                    this.end = this.wrap(this.end - 1);
                    var e = this.get(this.end);
                    return this.set(this.end, void 0), e
                }
            }, {
                key: "unshift",
                value: function(e) {
                    if (this.isFull()) throw new RangeError("Ring buffer is full.");
                    this.begin = this.wrap(this.begin - 1), this.set(this.begin, e)
                }
            }, {
                key: "shift",
                value: function() {
                    if (this.isEmpty()) throw new RangeError("Ring buffer is empty.");
                    var e = this.get(this.begin);
                    return this.set(this.begin, void 0), this.begin = this.wrap(this.begin + 1), e
                }
            }, {
                key: "shuffleExcise",
                value: function(e) {
                    if (this.isEmpty()) throw new RangeError("Ring buffer is empty.");
                    var t = this.wrap(this.begin + e),
                        n = this.get(t);
                    return this.set(t, this.pop()), n
                }
            }]), e
        }(),
        sme = function(e) {
            d(n, e);
            var t = w(n);

            function n() {
                return l(this, n), t.call(this, n.INITIAL_CAPACITY)
            }
            return p(n, [{
                key: "isFull",
                value: function() {
                    return !1
                }
            }, {
                key: "push",
                value: function(e) {
                    N(v(n.prototype), "isFull", this).call(this) && this.expand(), N(v(n.prototype), "push", this).call(this, e)
                }
            }, {
                key: "unshift",
                value: function(e) {
                    N(v(n.prototype), "isFull", this).call(this) && this.expand(), N(v(n.prototype), "unshift", this).call(this, e)
                }
            }, {
                key: "expand",
                value: function() {
                    for (var e = 2 * this.capacity, t = new Array(e), n = this.length(), r = 0; r < n; r++) t[r] = this.get(this.wrap(this.begin + r));
                    this.data = t, this.capacity = e, this.doubledCapacity = 2 * this.capacity, this.begin = 0, this.end = n
                }
            }]), n
        }(ome);

    function ume(e) {
        return new dme(e)
    }

    function cme(e) {
        return new vme(e)
    }

    function lme(e, t) {
        return new Tme(e, t)
    }

    function hme(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : pme.FAIL;
        return new Eme(e, t)
    }
    sme.INITIAL_CAPACITY = 32;
    var pme, fme = function() {
            function e() {
                l(this, e)
            }
            var t, n, r, a, i;
            return p(e, [{
                key: "toArray",
                value: function() {
                    var e = c(o().mark((function e() {
                        var t, n;
                        return o().wrap((function(e) {
                            for (;;) switch (e.prev = e.next) {
                                case 0:
                                    return t = [], e.next = 3, this.next();
                                case 3:
                                    n = e.sent;
                                case 4:
                                    if (n.done) {
                                        e.next = 11;
                                        break
                                    }
                                    return t.push(n.value), e.next = 8, this.next();
                                case 8:
                                    n = e.sent, e.next = 4;
                                    break;
                                case 11:
                                    return e.abrupt("return", t);
                                case 12:
                                case "end":
                                    return e.stop()
                            }
                        }), e, this)
                    })));
                    return function() {
                        return e.apply(this, arguments)
                    }
                }()
            }, {
                key: "toArrayForTest",
                value: (i = c(o().mark((function e() {
                    var t, n, r;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return t = this.prefetch(100), n = [], e.next = 4, t.next();
                            case 4:
                                r = e.sent;
                            case 5:
                                if (r.done) {
                                    e.next = 12;
                                    break
                                }
                                return n.push(r.value), e.next = 9, t.next();
                            case 9:
                                r = e.sent, e.next = 5;
                                break;
                            case 12:
                                return e.abrupt("return", n);
                            case 13:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return i.apply(this, arguments)
                })
            }, {
                key: "resolveFully",
                value: (a = c(o().mark((function e() {
                    var t;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.next();
                            case 2:
                                t = e.sent;
                            case 3:
                                if (t.done) {
                                    e.next = 9;
                                    break
                                }
                                return e.next = 6, this.next();
                            case 6:
                                t = e.sent, e.next = 3;
                                break;
                            case 9:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return a.apply(this, arguments)
                })
            }, {
                key: "resolveWhile",
                value: (r = c(o().mark((function e(t) {
                    var n, r;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.next();
                            case 2:
                                n = e.sent, r = t(n.value);
                            case 4:
                                if (n.done || !r) {
                                    e.next = 11;
                                    break
                                }
                                return e.next = 7, this.next();
                            case 7:
                                n = e.sent, r = t(n.value), e.next = 4;
                                break;
                            case 11:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e) {
                    return r.apply(this, arguments)
                })
            }, {
                key: "handleErrors",
                value: function(e) {
                    return new wme(this, e)
                }
            }, {
                key: "filter",
                value: function(e) {
                    return new xme(this, e)
                }
            }, {
                key: "map",
                value: function(e) {
                    return new kme(this, e)
                }
            }, {
                key: "mapAsync",
                value: function(e) {
                    return new Ime(this, e)
                }
            }, {
                key: "serialMapAsync",
                value: function(e) {
                    return new Ime(this, e).serial()
                }
            }, {
                key: "flatmap",
                value: function(e) {
                    return new Sme(this, e)
                }
            }, {
                key: "forEachAsync",
                value: (n = c(o().mark((function e(t) {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.abrupt("return", this.map(t).resolveFully());
                            case 1:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e) {
                    return n.apply(this, arguments)
                })
            }, {
                key: "serialForEach",
                value: (t = c(o().mark((function e(t) {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.abrupt("return", this.serialMapAsync(t).resolveWhile((function(e) {
                                    return !0 === e
                                })));
                            case 1:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e) {
                    return t.apply(this, arguments)
                })
            }, {
                key: "rowMajorBatch",
                value: function(e) {
                    var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                    return new bme(this, e, t)
                }
            }, {
                key: "columnMajorBatch",
                value: function(e) {
                    var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                        n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : $ve,
                        r = this.rowMajorBatch(e, t);
                    return r.map((function(e) {
                        return Zve(e, n)
                    }))
                }
            }, {
                key: "concatenate",
                value: function(e, t) {
                    return new Tme(ume([this, e]), t)
                }
            }, {
                key: "take",
                value: function(e) {
                    return e < 0 || null == e ? this : new yme(this, e)
                }
            }, {
                key: "skip",
                value: function(e) {
                    return e < 0 || null == e ? this : new gme(this, e)
                }
            }, {
                key: "prefetch",
                value: function(e) {
                    return new Cme(this, e)
                }
            }, {
                key: "shuffle",
                value: function(e, t) {
                    return new Ame(this, e, t)
                }
            }, {
                key: "serial",
                value: function() {
                    return new mme(this)
                }
            }]), e
        }(),
        dme = function(e) {
            d(r, e);
            var t, n = w(r);

            function r(e) {
                var t;
                return l(this, r), (t = n.call(this)).items = e, t.trav = 0, t
            }
            return p(r, [{
                key: "summary",
                value: function() {
                    return "Array of ".concat(this.items.length, " items")
                }
            }, {
                key: "next",
                value: (t = c(o().mark((function e() {
                    var t;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (!(this.trav >= this.items.length)) {
                                    e.next = 2;
                                    break
                                }
                                return e.abrupt("return", {
                                    value: null,
                                    done: !0
                                });
                            case 2:
                                return t = this.items[this.trav], this.trav++, e.abrupt("return", {
                                    value: ame(t),
                                    done: !1
                                });
                            case 5:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return t.apply(this, arguments)
                })
            }]), r
        }(fme),
        vme = function(e) {
            d(r, e);
            var t, n = w(r);

            function r(e) {
                var t;
                return l(this, r), (t = n.call(this)).nextFn = e, t
            }
            return p(r, [{
                key: "summary",
                value: function() {
                    return "Function call"
                }
            }, {
                key: "next",
                value: (t = c(o().mark((function e() {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.prev = 0, e.abrupt("return", this.nextFn());
                            case 4:
                                throw e.prev = 4, e.t0 = e.catch(0), e.t0.message = "Error thrown while iterating through a dataset: ".concat(e.t0.message), e.t0;
                            case 8:
                            case "end":
                                return e.stop()
                        }
                    }), e, this, [
                        [0, 4]
                    ])
                }))), function() {
                    return t.apply(this, arguments)
                })
            }]), r
        }(fme),
        mme = function(e) {
            d(a, e);
            var t, n, r = w(a);

            function a(e) {
                var t;
                return l(this, a), (t = r.call(this)).upstream = e, t.lastRead = Promise.resolve({
                    value: null,
                    done: !1
                }), t
            }
            return p(a, [{
                key: "summary",
                value: function() {
                    return "".concat(this.upstream.summary(), " -> Serial")
                }
            }, {
                key: "next",
                value: (n = c(o().mark((function e() {
                    var t = this;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return this.lastRead = this.lastRead.then((function() {
                                    return t.serialNext()
                                })), e.abrupt("return", this.lastRead);
                            case 2:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return n.apply(this, arguments)
                })
            }, {
                key: "serialNext",
                value: (t = c(o().mark((function e() {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.abrupt("return", this.upstream.next());
                            case 1:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return t.apply(this, arguments)
                })
            }]), a
        }(fme),
        gme = function(e) {
            d(a, e);
            var t, n, r = w(a);

            function a(e, t) {
                var n;
                return l(this, a), (n = r.call(this)).upstream = e, n.maxCount = t, n.count = 0, n.lastRead = Promise.resolve({
                    value: null,
                    done: !1
                }), n
            }
            return p(a, [{
                key: "summary",
                value: function() {
                    return "".concat(this.upstream.summary(), " -> Skip")
                }
            }, {
                key: "next",
                value: (n = c(o().mark((function e() {
                    var t = this;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return this.lastRead = this.lastRead.then((function() {
                                    return t.serialNext()
                                })), e.abrupt("return", this.lastRead);
                            case 2:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return n.apply(this, arguments)
                })
            }, {
                key: "serialNext",
                value: (t = c(o().mark((function e() {
                    var t;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (!(this.count++ < this.maxCount)) {
                                    e.next = 9;
                                    break
                                }
                                return e.next = 3, this.upstream.next();
                            case 3:
                                if (!(t = e.sent).done) {
                                    e.next = 6;
                                    break
                                }
                                return e.abrupt("return", t);
                            case 6:
                                Y5(t.value), e.next = 0;
                                break;
                            case 9:
                                return e.abrupt("return", this.upstream.next());
                            case 10:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return t.apply(this, arguments)
                })
            }]), a
        }(fme),
        yme = function(e) {
            d(r, e);
            var t, n = w(r);

            function r(e, t) {
                var a;
                return l(this, r), (a = n.call(this)).upstream = e, a.maxCount = t, a.count = 0, a
            }
            return p(r, [{
                key: "summary",
                value: function() {
                    return "".concat(this.upstream.summary(), " -> Take")
                }
            }, {
                key: "next",
                value: (t = c(o().mark((function e() {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (!(this.count++ >= this.maxCount)) {
                                    e.next = 2;
                                    break
                                }
                                return e.abrupt("return", {
                                    value: null,
                                    done: !0
                                });
                            case 2:
                                return e.abrupt("return", this.upstream.next());
                            case 3:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return t.apply(this, arguments)
                })
            }]), r
        }(fme),
        bme = function(e) {
            d(a, e);
            var t, n, r = w(a);

            function a(e, t) {
                var n, i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                return l(this, a), (n = r.call(this)).upstream = e, n.batchSize = t, n.enableSmallLastBatch = i, n.lastRead = Promise.resolve({
                    value: null,
                    done: !1
                }), n
            }
            return p(a, [{
                key: "summary",
                value: function() {
                    return "".concat(this.upstream.summary(), " -> RowMajorBatch")
                }
            }, {
                key: "next",
                value: (n = c(o().mark((function e() {
                    var t = this;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return this.lastRead = this.lastRead.then((function() {
                                    return t.serialNext()
                                })), e.abrupt("return", this.lastRead);
                            case 2:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return n.apply(this, arguments)
                })
            }, {
                key: "serialNext",
                value: (t = c(o().mark((function e() {
                    var t, n;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                t = [];
                            case 1:
                                if (!(t.length < this.batchSize)) {
                                    e.next = 12;
                                    break
                                }
                                return e.next = 4, this.upstream.next();
                            case 4:
                                if (!(n = e.sent).done) {
                                    e.next = 9;
                                    break
                                }
                                if (!(this.enableSmallLastBatch && t.length > 0)) {
                                    e.next = 8;
                                    break
                                }
                                return e.abrupt("return", {
                                    value: t,
                                    done: !1
                                });
                            case 8:
                                return e.abrupt("return", {
                                    value: null,
                                    done: !0
                                });
                            case 9:
                                t.push(n.value), e.next = 1;
                                break;
                            case 12:
                                return e.abrupt("return", {
                                    value: t,
                                    done: !1
                                });
                            case 13:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return t.apply(this, arguments)
                })
            }]), a
        }(fme),
        xme = function(e) {
            d(a, e);
            var t, n, r = w(a);

            function a(e, t) {
                var n;
                return l(this, a), (n = r.call(this)).upstream = e, n.predicate = t, n.lastRead = Promise.resolve({
                    value: null,
                    done: !1
                }), n
            }
            return p(a, [{
                key: "summary",
                value: function() {
                    return "".concat(this.upstream.summary(), " -> Filter")
                }
            }, {
                key: "next",
                value: (n = c(o().mark((function e() {
                    var t = this;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return this.lastRead = this.lastRead.then((function() {
                                    return t.serialNext()
                                })), e.abrupt("return", this.lastRead);
                            case 2:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return n.apply(this, arguments)
                })
            }, {
                key: "serialNext",
                value: (t = c(o().mark((function e() {
                    var t;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 3, this.upstream.next();
                            case 3:
                                if (!(t = e.sent).done && !this.predicate(t.value)) {
                                    e.next = 6;
                                    break
                                }
                                return e.abrupt("return", t);
                            case 6:
                                Y5(t.value), e.next = 0;
                                break;
                            case 9:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return t.apply(this, arguments)
                })
            }]), a
        }(fme),
        kme = function(e) {
            d(r, e);
            var t, n = w(r);

            function r(e, t) {
                var a;
                return l(this, r), (a = n.call(this)).upstream = e, a.transform = t, a
            }
            return p(r, [{
                key: "summary",
                value: function() {
                    return "".concat(this.upstream.summary(), " -> Map")
                }
            }, {
                key: "next",
                value: (t = c(o().mark((function e() {
                    var t, n, r, a, i, s, u;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.upstream.next();
                            case 2:
                                if (!(t = e.sent).done) {
                                    e.next = 5;
                                    break
                                }
                                return e.abrupt("return", {
                                    value: null,
                                    done: !0
                                });
                            case 5:
                                n = y5(t.value), r = this.transform(t.value), a = y5(r), i = O(n);
                                try {
                                    for (i.s(); !(s = i.n()).done;) g5(u = s.value, a) || u.dispose()
                                } catch (e) {
                                    i.e(e)
                                } finally {
                                    i.f()
                                }
                                return e.abrupt("return", {
                                    value: r,
                                    done: !1
                                });
                            case 11:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return t.apply(this, arguments)
                })
            }]), r
        }(fme),
        wme = function(e) {
            d(a, e);
            var t, n, r = w(a);

            function a(e, t) {
                var n;
                return l(this, a), (n = r.call(this)).upstream = e, n.handler = t, n.count = 0, n.lastRead = Promise.resolve({
                    value: null,
                    done: !1
                }), n
            }
            return p(a, [{
                key: "summary",
                value: function() {
                    return "".concat(this.upstream.summary(), " -> handleErrors")
                }
            }, {
                key: "next",
                value: (n = c(o().mark((function e() {
                    var t = this;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return this.lastRead = this.lastRead.then((function() {
                                    return t.serialNext()
                                })), e.abrupt("return", this.lastRead);
                            case 2:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return n.apply(this, arguments)
                })
            }, {
                key: "serialNext",
                value: (t = c(o().mark((function e() {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.prev = 1, e.next = 4, this.upstream.next();
                            case 4:
                                return e.abrupt("return", e.sent);
                            case 7:
                                if (e.prev = 7, e.t0 = e.catch(1), this.handler(e.t0)) {
                                    e.next = 11;
                                    break
                                }
                                return e.abrupt("return", {
                                    value: null,
                                    done: !0
                                });
                            case 11:
                                e.next = 0;
                                break;
                            case 13:
                            case "end":
                                return e.stop()
                        }
                    }), e, this, [
                        [1, 7]
                    ])
                }))), function() {
                    return t.apply(this, arguments)
                })
            }]), a
        }(fme),
        Ime = function(e) {
            d(r, e);
            var t, n = w(r);

            function r(e, t) {
                var a;
                return l(this, r), (a = n.call(this)).upstream = e, a.transform = t, a
            }
            return p(r, [{
                key: "summary",
                value: function() {
                    return "".concat(this.upstream.summary(), " -> AsyncMap")
                }
            }, {
                key: "next",
                value: (t = c(o().mark((function e() {
                    var t, n, r, a, i, s, u;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.upstream.next();
                            case 2:
                                if (!(t = e.sent).done) {
                                    e.next = 5;
                                    break
                                }
                                return e.abrupt("return", {
                                    value: null,
                                    done: !0
                                });
                            case 5:
                                return n = y5(t.value), e.next = 8, this.transform(t.value);
                            case 8:
                                r = e.sent, a = y5(r), i = O(n);
                                try {
                                    for (i.s(); !(s = i.n()).done;) g5(u = s.value, a) || u.dispose()
                                } catch (e) {
                                    i.e(e)
                                } finally {
                                    i.f()
                                }
                                return e.abrupt("return", {
                                    value: r,
                                    done: !1
                                });
                            case 13:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return t.apply(this, arguments)
                })
            }]), r
        }(fme),
        Nme = function(e) {
            d(a, e);
            var t, n, r = w(a);

            function a() {
                var e;
                return l(this, a), (e = r.call(this)).outputQueue = new sme, e.lastRead = Promise.resolve({
                    value: null,
                    done: !1
                }), e
            }
            return p(a, [{
                key: "next",
                value: (n = c(o().mark((function e() {
                    var t = this;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return this.lastRead = this.lastRead.then((function() {
                                    return t.serialNext()
                                })), e.abrupt("return", this.lastRead);
                            case 2:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return n.apply(this, arguments)
                })
            }, {
                key: "serialNext",
                value: (t = c(o().mark((function e() {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (0 !== this.outputQueue.length()) {
                                    e.next = 7;
                                    break
                                }
                                return e.next = 3, this.pump();
                            case 3:
                                if (e.sent) {
                                    e.next = 5;
                                    break
                                }
                                return e.abrupt("return", {
                                    value: null,
                                    done: !0
                                });
                            case 5:
                                e.next = 0;
                                break;
                            case 7:
                                return e.abrupt("return", {
                                    value: this.outputQueue.shift(),
                                    done: !1
                                });
                            case 8:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return t.apply(this, arguments)
                })
            }]), a
        }(fme),
        Sme = function(e) {
            d(r, e);
            var t, n = w(r);

            function r(e, t) {
                var a;
                return l(this, r), (a = n.call(this)).upstream = e, a.transform = t, a
            }
            return p(r, [{
                key: "summary",
                value: function() {
                    return "".concat(this.upstream.summary(), " -> Flatmap")
                }
            }, {
                key: "pump",
                value: (t = c(o().mark((function e() {
                    var t, n, r, a, i, s, u;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.upstream.next();
                            case 2:
                                if (!(t = e.sent).done) {
                                    e.next = 5;
                                    break
                                }
                                return e.abrupt("return", !1);
                            case 5:
                                n = y5(t.value), r = this.transform(t.value), a = y5(r), this.outputQueue.pushAll(r), i = O(n);
                                try {
                                    for (i.s(); !(s = i.n()).done;) g5(u = s.value, a) || u.dispose()
                                } catch (e) {
                                    i.e(e)
                                } finally {
                                    i.f()
                                }
                                return e.abrupt("return", !0);
                            case 12:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return t.apply(this, arguments)
                })
            }]), r
        }(Nme),
        Tme = function(e) {
            d(a, e);
            var t, n, r = w(a);

            function a(e, t) {
                var n;
                return l(this, a), (n = r.call(this)).baseErrorHandler = t, n.lastRead = null, n.iterator = null, n.moreIterators = e, n
            }
            return p(a, [{
                key: "summary",
                value: function() {
                    return "".concat("TODO: fill in upstream of chained summaries", " -> Chained")
                }
            }, {
                key: "next",
                value: (n = c(o().mark((function e() {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return this.lastRead = this.readFromChain(this.lastRead), e.abrupt("return", this.lastRead);
                            case 2:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return n.apply(this, arguments)
                })
            }, {
                key: "readFromChain",
                value: (t = c(o().mark((function e(t) {
                    var n, r;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, t;
                            case 2:
                                if (null != this.iterator) {
                                    e.next = 10;
                                    break
                                }
                                return e.next = 5, this.moreIterators.next();
                            case 5:
                                if (!(n = e.sent).done) {
                                    e.next = 8;
                                    break
                                }
                                return e.abrupt("return", {
                                    value: null,
                                    done: !0
                                });
                            case 8:
                                this.iterator = n.value, null != this.baseErrorHandler && (this.iterator = this.iterator.handleErrors(this.baseErrorHandler));
                            case 10:
                                return e.next = 12, this.iterator.next();
                            case 12:
                                if (!(r = e.sent).done) {
                                    e.next = 16;
                                    break
                                }
                                return this.iterator = null, e.abrupt("return", this.readFromChain(t));
                            case 16:
                                return e.abrupt("return", r);
                            case 17:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e) {
                    return t.apply(this, arguments)
                })
            }]), a
        }(fme);
    ! function(e) {
        e[e.FAIL = 0] = "FAIL", e[e.SHORTEST = 1] = "SHORTEST", e[e.LONGEST = 2] = "LONGEST"
    }(pme || (pme = {}));
    var Eme = function(e) {
            d(a, e);
            var t, n, r = w(a);

            function a(e) {
                var t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : pme.FAIL;
                return l(this, a), (t = r.call(this)).iterators = e, t.mismatchMode = n, t.count = 0, t.currentPromise = null, t
            }
            return p(a, [{
                key: "summary",
                value: function() {
                    return "{".concat("TODO: fill in upstream of zip summaries", "} -> Zip")
                }
            }, {
                key: "nextState",
                value: (n = c(o().mark((function e(t) {
                    var n, r, a, i;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return a = function(e) {
                                    return e instanceof fme ? {
                                        value: e.next().then((function(e) {
                                            return n++, e.done && r++, e.value
                                        })),
                                        recurse: !1
                                    } : {
                                        value: null,
                                        recurse: !0
                                    }
                                }, e.next = 3, t;
                            case 3:
                                return n = 0, r = 0, e.next = 7, eme(this.iterators, a);
                            case 7:
                                if (i = e.sent, n !== r) {
                                    e.next = 10;
                                    break
                                }
                                return e.abrupt("return", {
                                    value: null,
                                    done: !0
                                });
                            case 10:
                                if (!(r > 0)) {
                                    e.next = 16;
                                    break
                                }
                                e.t0 = this.mismatchMode, e.next = e.t0 === pme.FAIL ? 14 : e.t0 === pme.SHORTEST ? 15 : (e.t0, pme.LONGEST, 16);
                                break;
                            case 14:
                                throw new Error("Zipped streams should have the same length. " + "Mismatched at element ".concat(this.count, "."));
                            case 15:
                                return e.abrupt("return", {
                                    value: null,
                                    done: !0
                                });
                            case 16:
                                return this.count++, e.abrupt("return", {
                                    value: i,
                                    done: !1
                                });
                            case 18:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e) {
                    return n.apply(this, arguments)
                })
            }, {
                key: "next",
                value: (t = c(o().mark((function e() {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return this.currentPromise = this.nextState(this.currentPromise), e.abrupt("return", this.currentPromise);
                            case 2:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return t.apply(this, arguments)
                })
            }]), a
        }(fme),
        Cme = function(e) {
            d(n, e);
            var t = w(n);

            function n(e, r) {
                var a;
                return l(this, n), (a = t.call(this)).upstream = e, a.bufferSize = r, a.buffer = new ome(r), a
            }
            return p(n, [{
                key: "summary",
                value: function() {
                    return "".concat(this.upstream.summary(), " -> Prefetch")
                }
            }, {
                key: "refill",
                value: function() {
                    for (; !this.buffer.isFull();) {
                        var e = this.upstream.next();
                        this.buffer.push(e)
                    }
                }
            }, {
                key: "next",
                value: function() {
                    return this.refill(), this.buffer.shift()
                }
            }]), n
        }(fme),
        Ame = function(e) {
            d(a, e);
            var t, n, r = w(a);

            function a(e, t, n) {
                var i;
                return l(this, a), (i = r.call(this, e, t)).upstream = e, i.windowSize = t, i.upstreamExhausted = !1, i.random = qee.alea(n || z4().toString()), i.lastRead = Promise.resolve({
                    value: null,
                    done: !1
                }), i
            }
            return p(a, [{
                key: "next",
                value: (n = c(o().mark((function e() {
                    var t = this;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return this.lastRead = this.lastRead.then((function() {
                                    return t.serialNext()
                                })), e.abrupt("return", this.lastRead);
                            case 2:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return n.apply(this, arguments)
                })
            }, {
                key: "randomInt",
                value: function(e) {
                    return Math.floor(this.random() * e)
                }
            }, {
                key: "chooseIndex",
                value: function() {
                    return this.randomInt(this.buffer.length())
                }
            }, {
                key: "serialNext",
                value: (t = c(o().mark((function e() {
                    var t, n;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                this.upstreamExhausted || this.refill();
                            case 1:
                                if (this.buffer.isEmpty()) {
                                    e.next = 14;
                                    break
                                }
                                return t = this.chooseIndex(), e.next = 5, this.buffer.shuffleExcise(t);
                            case 5:
                                if (!(n = e.sent).done) {
                                    e.next = 10;
                                    break
                                }
                                this.upstreamExhausted = !0, e.next = 12;
                                break;
                            case 10:
                                return this.refill(), e.abrupt("return", n);
                            case 12:
                                e.next = 1;
                                break;
                            case 14:
                                return e.abrupt("return", {
                                    value: null,
                                    done: !0
                                });
                            case 15:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return t.apply(this, arguments)
                })
            }]), a
        }(Cme),
        Rme = function() {
            function e() {
                l(this, e), this.size = null
            }
            var t, n;
            return p(e, [{
                key: "batch",
                value: function(e) {
                    var t, n = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                        r = this;
                    return F$(e > 0, (function() {
                        return "batchSize needs to be positive, but it is\n      ".concat(e)
                    })), t = this.size === 1 / 0 || null == this.size ? this.size : n ? Math.ceil(this.size / e) : Math.floor(this.size / e), _me(c(o().mark((function t() {
                        return o().wrap((function(t) {
                            for (;;) switch (t.prev = t.next) {
                                case 0:
                                    return t.next = 2, r.iterator();
                                case 2:
                                    return t.abrupt("return", t.sent.columnMajorBatch(e, n, Ome));
                                case 3:
                                case "end":
                                    return t.stop()
                            }
                        }), t)
                    }))), t)
                }
            }, {
                key: "concatenate",
                value: function(e) {
                    var t, n = this;
                    return t = this.size === 1 / 0 || e.size === 1 / 0 ? 1 / 0 : null != this.size && null != e.size ? this.size + e.size : null, _me(c(o().mark((function t() {
                        return o().wrap((function(t) {
                            for (;;) switch (t.prev = t.next) {
                                case 0:
                                    return t.next = 2, n.iterator();
                                case 2:
                                    return t.t0 = t.sent, t.next = 5, e.iterator();
                                case 5:
                                    return t.t1 = t.sent, t.abrupt("return", t.t0.concatenate.call(t.t0, t.t1));
                                case 7:
                                case "end":
                                    return t.stop()
                            }
                        }), t)
                    }))), t)
                }
            }, {
                key: "filter",
                value: function(e) {
                    var t, n = this;
                    return t = this.size === 1 / 0 ? 1 / 0 : null, _me(c(o().mark((function t() {
                        return o().wrap((function(t) {
                            for (;;) switch (t.prev = t.next) {
                                case 0:
                                    return t.next = 2, n.iterator();
                                case 2:
                                    return t.abrupt("return", t.sent.filter((function(t) {
                                        return X5((function() {
                                            return e(t)
                                        }))
                                    })));
                                case 3:
                                case "end":
                                    return t.stop()
                            }
                        }), t)
                    }))), t)
                }
            }, {
                key: "forEachAsync",
                value: (n = c(o().mark((function e(t) {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.iterator();
                            case 2:
                                return e.abrupt("return", e.sent.forEachAsync(t));
                            case 3:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e) {
                    return n.apply(this, arguments)
                })
            }, {
                key: "map",
                value: function(e) {
                    var t = this;
                    return _me(c(o().mark((function n() {
                        return o().wrap((function(n) {
                            for (;;) switch (n.prev = n.next) {
                                case 0:
                                    return n.next = 2, t.iterator();
                                case 2:
                                    return n.abrupt("return", n.sent.map((function(t) {
                                        return X5((function() {
                                            return e(t)
                                        }))
                                    })));
                                case 3:
                                case "end":
                                    return n.stop()
                            }
                        }), n)
                    }))), this.size)
                }
            }, {
                key: "mapAsync",
                value: function(e) {
                    var t = this;
                    return _me(c(o().mark((function n() {
                        return o().wrap((function(n) {
                            for (;;) switch (n.prev = n.next) {
                                case 0:
                                    return n.next = 2, t.iterator();
                                case 2:
                                    return n.abrupt("return", n.sent.mapAsync(e));
                                case 3:
                                case "end":
                                    return n.stop()
                            }
                        }), n)
                    }))), this.size)
                }
            }, {
                key: "prefetch",
                value: function(e) {
                    if (null == e) throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");
                    var t = this;
                    return _me(c(o().mark((function n() {
                        return o().wrap((function(n) {
                            for (;;) switch (n.prev = n.next) {
                                case 0:
                                    return n.next = 2, t.iterator();
                                case 2:
                                    return n.abrupt("return", n.sent.prefetch(e));
                                case 3:
                                case "end":
                                    return n.stop()
                            }
                        }), n)
                    }))), this.size)
                }
            }, {
                key: "repeat",
                value: function(e) {
                    var t, n = this;
                    return t = null != this.size && e > 0 ? this.size * e : 0 === e ? 0 : null != this.size && (void 0 === e || e < 0) ? 1 / 0 : null, _me(c(o().mark((function t() {
                        var r;
                        return o().wrap((function(t) {
                            for (;;) switch (t.prev = t.next) {
                                case 0:
                                    return r = cme(c(o().mark((function e() {
                                        return o().wrap((function(e) {
                                            for (;;) switch (e.prev = e.next) {
                                                case 0:
                                                    return e.next = 2, n.iterator();
                                                case 2:
                                                    return e.t0 = e.sent, e.abrupt("return", {
                                                        value: e.t0,
                                                        done: !1
                                                    });
                                                case 4:
                                                case "end":
                                                    return e.stop()
                                            }
                                        }), e)
                                    })))), t.abrupt("return", lme(r.take(e)));
                                case 2:
                                case "end":
                                    return t.stop()
                            }
                        }), t)
                    }))), t)
                }
            }, {
                key: "skip",
                value: function(e) {
                    var t, n = this;
                    return t = null != this.size && e >= 0 && this.size >= e ? this.size - e : null != this.size && (this.size < e || void 0 === e || e < 0) ? 0 : null, _me(c(o().mark((function t() {
                        return o().wrap((function(t) {
                            for (;;) switch (t.prev = t.next) {
                                case 0:
                                    return t.next = 2, n.iterator();
                                case 2:
                                    return t.abrupt("return", t.sent.skip(e));
                                case 3:
                                case "end":
                                    return t.stop()
                            }
                        }), t)
                    }))), t)
                }
            }, {
                key: "shuffle",
                value: function(e, t) {
                    var n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                    if (null == e || e < 0) throw null == this.size ? new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.") : new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for `tf.Tensor`s), consider setting " + "bufferSize to the dataset size (".concat(this.size, " elements)"));
                    var r = this,
                        a = qee.alea(t || z4().toString());
                    return _me(c(o().mark((function t() {
                        var i;
                        return o().wrap((function(t) {
                            for (;;) switch (t.prev = t.next) {
                                case 0:
                                    return i = a.int32(), n && (i += a.int32()), t.next = 4, r.iterator();
                                case 4:
                                    return t.abrupt("return", t.sent.shuffle(e, i.toString()));
                                case 5:
                                case "end":
                                    return t.stop()
                            }
                        }), t)
                    }))), this.size)
                }
            }, {
                key: "take",
                value: function(e) {
                    var t, n = this;
                    return t = null != this.size && this.size > e ? e : null != this.size && this.size <= e ? this.size : null, _me(c(o().mark((function t() {
                        return o().wrap((function(t) {
                            for (;;) switch (t.prev = t.next) {
                                case 0:
                                    return t.next = 2, n.iterator();
                                case 2:
                                    return t.abrupt("return", t.sent.take(e));
                                case 3:
                                case "end":
                                    return t.stop()
                            }
                        }), t)
                    }))), t)
                }
            }, {
                key: "toArray",
                value: function() {
                    var e = c(o().mark((function e() {
                        return o().wrap((function(e) {
                            for (;;) switch (e.prev = e.next) {
                                case 0:
                                    if (this.size !== 1 / 0) {
                                        e.next = 2;
                                        break
                                    }
                                    throw new Error("Can not convert infinite data stream to array.");
                                case 2:
                                    return e.next = 4, this.iterator();
                                case 4:
                                    return e.abrupt("return", e.sent.toArray());
                                case 5:
                                case "end":
                                    return e.stop()
                            }
                        }), e, this)
                    })));
                    return function() {
                        return e.apply(this, arguments)
                    }
                }()
            }, {
                key: "toArrayForTest",
                value: (t = c(o().mark((function e() {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (this.size !== 1 / 0) {
                                    e.next = 2;
                                    break
                                }
                                throw new Error("Can not convert infinite data stream to array.");
                            case 2:
                                return e.next = 4, this.iterator();
                            case 4:
                                return e.abrupt("return", e.sent.toArrayForTest());
                            case 5:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return t.apply(this, arguments)
                })
            }]), e
        }();

    function _me(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
        return new(function(n) {
            d(i, n);
            var r, a = w(i);

            function i() {
                var e;
                return l(this, i), (e = a.apply(this, arguments)).size = t, e
            }
            return p(i, [{
                key: "iterator",
                value: (r = c(o().mark((function t() {
                    return o().wrap((function(t) {
                        for (;;) switch (t.prev = t.next) {
                            case 0:
                                return t.abrupt("return", e());
                            case 1:
                            case "end":
                                return t.stop()
                        }
                    }), t)
                }))), function() {
                    return r.apply(this, arguments)
                })
            }]), i
        }(Rme))
    }

    function Ome(e) {
        return null === e ? null : rme(e[0]) ? {
            value: function(e) {
                if (0 === e.length) throw new Error("Can't make a batch of zero elements.");
                return e[0] instanceof n5 ? Pte(e) : V5(e)
            }(e),
            recurse: !1
        } : {
            value: null,
            recurse: !0
        }
    }
    Rme.MAX_BUFFER_SIZE = 1e4;
    var Fme = function(e) {
            d(r, e);
            var t, n = w(r);

            function r(e) {
                var t;
                return l(this, r), (t = n.call(this)).input = e, t
            }
            return p(r, [{
                key: "iterator",
                value: (t = c(o().mark((function e() {
                    var t, n, r;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.input.iterator();
                            case 2:
                                return t = e.sent, n = t.decodeUTF8(), r = n.split("\n").map((function(e) {
                                    return e.endsWith("\r") && (e = e.slice(0, -1)), e
                                })), e.abrupt("return", r);
                            case 6:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return t.apply(this, arguments)
                })
            }]), r
        }(Rme),
        Dme = '"',
        Mme = Symbol("out"),
        Lme = Symbol("field"),
        zme = Symbol("quote"),
        Pme = Symbol("quoteafterquote"),
        Bme = Symbol("quoteinquote"),
        Wme = function(e) {
            d(s, e);
            var t, n, r, a, i = w(s);

            function s(e, t) {
                var n;
                return l(this, s), (n = i.call(this)).input = e, n.hasHeader = !0, n.fullColumnNames = null, n.columnNamesValidated = !1, n.columnConfigs = null, n.configuredColumnsOnly = !1, n.delimiter = ",", n.delimWhitespace = !1, n.base = new Fme(e), t || (t = {}), n.hasHeader = !1 !== t.hasHeader, n.fullColumnNames = t.columnNames, n.columnConfigs = t.columnConfigs, n.configuredColumnsOnly = t.configuredColumnsOnly, t.delimWhitespace ? (F$(null == t.delimiter, (function() {
                    return "Delimiter should not be provided when delimWhitespace is true."
                })), n.delimWhitespace = !0, n.delimiter = " ") : n.delimiter = t.delimiter ? t.delimiter : ",", n
            }
            return p(s, [{
                key: "columnNames",
                value: (a = c(o().mark((function e() {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (this.columnNamesValidated) {
                                    e.next = 3;
                                    break
                                }
                                return e.next = 3, this.setColumnNames();
                            case 3:
                                return e.abrupt("return", this.configuredColumnsOnly ? Object.keys(this.columnConfigs) : this.fullColumnNames);
                            case 4:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return a.apply(this, arguments)
                })
            }, {
                key: "setColumnNames",
                value: (r = c(o().mark((function e() {
                    var t, n, r, a, i, s, u = this;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.maybeReadHeaderLine();
                            case 2:
                                if (t = e.sent, this.fullColumnNames || t) {
                                    e.next = 7;
                                    break
                                }
                                throw new Error("Column names must be provided if there is no header line.");
                            case 7:
                                this.fullColumnNames && t && F$(t.length === this.fullColumnNames.length, (function() {
                                    return "The length of provided columnNames (" + u.fullColumnNames.length.toString() + ") does not match the length of the header line read from file (" + t.length.toString() + ")."
                                }));
                            case 8:
                                if (this.fullColumnNames || (this.fullColumnNames = t), n = this.fullColumnNames.reduce((function(e, t) {
                                        return e[t] = e[t] + 1 || 1, e
                                    }), {}), F$(0 === (r = Object.keys(n).filter((function(e) {
                                        return n[e] > 1
                                    }))).length, (function() {
                                        return "Duplicate column names found: " + r.toString()
                                    })), !this.columnConfigs) {
                                    e.next = 22;
                                    break
                                }
                                a = 0, i = Object.keys(this.columnConfigs);
                            case 14:
                                if (!(a < i.length)) {
                                    e.next = 22;
                                    break
                                }
                                if (s = i[a], -1 !== this.fullColumnNames.indexOf(s)) {
                                    e.next = 19;
                                    break
                                }
                                throw new Error('The key "' + s + '" provided in columnConfigs does not match any of the column names (' + this.fullColumnNames.toString() + ").");
                            case 19:
                                a++, e.next = 14;
                                break;
                            case 22:
                                this.columnNamesValidated = !0;
                            case 23:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return r.apply(this, arguments)
                })
            }, {
                key: "maybeReadHeaderLine",
                value: (n = c(o().mark((function e() {
                    var t, n, r, a;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (!this.hasHeader) {
                                    e.next = 14;
                                    break
                                }
                                return e.next = 3, this.base.iterator();
                            case 3:
                                return t = e.sent, e.next = 6, t.next();
                            case 6:
                                if (!(n = e.sent).done) {
                                    e.next = 9;
                                    break
                                }
                                throw new Error("No data was found for CSV parsing.");
                            case 9:
                                return r = n.value, a = this.parseRow(r, !1), e.abrupt("return", a);
                            case 14:
                                return e.abrupt("return", null);
                            case 15:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return n.apply(this, arguments)
                })
            }, {
                key: "iterator",
                value: (t = c(o().mark((function e() {
                    var t, n = this;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (this.columnNamesValidated) {
                                    e.next = 3;
                                    break
                                }
                                return e.next = 3, this.setColumnNames();
                            case 3:
                                return e.next = 5, this.base.iterator();
                            case 5:
                                return t = e.sent, this.hasHeader && (t = t.skip(1)), e.abrupt("return", t.map((function(e) {
                                    return n.makeDataElement(e)
                                })));
                            case 8:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return t.apply(this, arguments)
                })
            }, {
                key: "makeDataElement",
                value: function(e) {
                    for (var t = this.parseRow(e), n = {}, r = {}, a = 0; a < this.fullColumnNames.length; a++) {
                        var i = this.fullColumnNames[a],
                            o = this.columnConfigs ? this.columnConfigs[i] : null;
                        if (!this.configuredColumnsOnly || o) {
                            var s = t[a],
                                u = null;
                            if ("" === s)
                                if (o && void 0 !== o.default) u = o.default;
                                else {
                                    if (o && (o.required || o.isLabel)) throw new Error("Required column ".concat(i, " is empty in this line: ").concat(e));
                                    u = void 0
                                } else {
                                var c = Number(s);
                                if (isNaN(c)) u = o && "bool" === o.dtype ? this.getBoolean(s) : s;
                                else if (o && o.dtype) switch (o.dtype) {
                                    case "float32":
                                    default:
                                        u = c;
                                        break;
                                    case "int32":
                                        u = Math.floor(c);
                                        break;
                                    case "bool":
                                        u = this.getBoolean(s)
                                } else u = c
                            }
                            o && o.isLabel ? r[i] = u : n[i] = u
                        }
                    }
                    return 0 === Object.keys(r).length ? n : {
                        xs: n,
                        ys: r
                    }
                }
            }, {
                key: "getBoolean",
                value: function(e) {
                    return "1" === e || "true" === e.toLowerCase() ? 1 : 0
                }
            }, {
                key: "parseRow",
                value: function(e) {
                    for (var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], n = [], r = 0, a = e.length, i = Mme, o = 0; o < a; o++) switch (i) {
                        case Mme:
                            switch (e.charAt(o)) {
                                case Dme:
                                    r = o + 1, i = zme;
                                    break;
                                case this.delimiter:
                                    if (r = o + 1, " " === this.delimiter && this.delimWhitespace) break;
                                    n.push(""), i = Mme;
                                    break;
                                default:
                                    i = Lme, r = o
                            }
                            break;
                        case Lme:
                            if (e.charAt(o) === this.delimiter) n.push(e.substring(r, o)), i = Mme, r = o + 1;
                            break;
                        case zme:
                            if (e.charAt(o) === Dme) i = Pme;
                            break;
                        case Pme:
                            switch (e.charAt(o)) {
                                case this.delimiter:
                                    n.push(e.substring(r, o - 1)), i = Mme, r = o + 1;
                                    break;
                                case Dme:
                                    i = zme;
                                    break;
                                default:
                                    i = Bme
                            }
                            break;
                        case Bme:
                            if (e.charAt(o) === Dme) i = zme
                    }
                    if (i === Pme ? n.push(e.substring(r, a - 1)) : n.push(e.substring(r)), t && n.length !== this.fullColumnNames.length) throw new Error("Invalid row in csv file. Should have ".concat(this.fullColumnNames.length, " elements in a row, but got ").concat(n));
                    return n
                }
            }]), s
        }(Rme),
        Ume = function(e) {
            d(u, e);
            var t, n, r, a, i, s = w(u);

            function u(e) {
                var t;
                l(this, u), (t = s.call(this)).microphoneConfig = e, t.isClosed = !1, t.fftSize = e.fftSize || 1024;
                var n = Math.log2(t.fftSize);
                if (t.fftSize < 0 || n < 4 || n > 14 || !Number.isInteger(n)) throw new Error("Invalid fftSize: it must be a power of 2 between " + "2 to 4 and 2 to 14, but got ".concat(t.fftSize));
                if (t.numFrames = e.numFramesPerSpectrogram || 43, t.sampleRateHz = e.sampleRateHz, t.columnTruncateLength = e.columnTruncateLength || t.fftSize, t.audioTrackConstraints = e.audioTrackConstraints, t.smoothingTimeConstant = e.smoothingTimeConstant || 0, t.includeSpectrogram = !1 !== e.includeSpectrogram, t.includeWaveform = !0 === e.includeWaveform, !t.includeSpectrogram && !t.includeWaveform) throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.");
                return t
            }
            return p(u, [{
                key: "summary",
                value: function() {
                    return "microphone"
                }
            }, {
                key: "start",
                value: (i = c(o().mark((function e() {
                    var t, n;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.prev = 0, e.next = 3, navigator.mediaDevices.getUserMedia({
                                    audio: null == this.audioTrackConstraints || this.audioTrackConstraints,
                                    video: !1
                                });
                            case 3:
                                this.stream = e.sent, e.next = 9;
                                break;
                            case 6:
                                throw e.prev = 6, e.t0 = e.catch(0), new Error("Error thrown while initializing video stream: ".concat(e.t0.message));
                            case 9:
                                if (this.stream) {
                                    e.next = 11;
                                    break
                                }
                                throw new Error("Could not obtain audio from microphone.");
                            case 11:
                                if (t = window.AudioContext || window.webkitAudioContext, this.audioContext = new t, this.sampleRateHz) {
                                    e.next = 17;
                                    break
                                }
                                this.sampleRateHz = this.audioContext.sampleRate, e.next = 19;
                                break;
                            case 17:
                                if (this.audioContext.sampleRate === this.sampleRateHz) {
                                    e.next = 19;
                                    break
                                }
                                throw new Error("Mismatch in sampling rate: " + "Expected: ".concat(this.sampleRateHz, "; ") + "Actual: ".concat(this.audioContext.sampleRate));
                            case 19:
                                return n = this.audioContext.createMediaStreamSource(this.stream), this.analyser = this.audioContext.createAnalyser(), this.analyser.fftSize = 2 * this.fftSize, this.analyser.smoothingTimeConstant = this.smoothingTimeConstant, n.connect(this.analyser), this.freqData = new Float32Array(this.fftSize), this.timeData = new Float32Array(this.fftSize), e.abrupt("return");
                            case 27:
                            case "end":
                                return e.stop()
                        }
                    }), e, this, [
                        [0, 6]
                    ])
                }))), function() {
                    return i.apply(this, arguments)
                })
            }, {
                key: "next",
                value: (a = c(o().mark((function e() {
                    var t, n, r, a, i;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (!this.isClosed) {
                                    e.next = 2;
                                    break
                                }
                                return e.abrupt("return", {
                                    value: null,
                                    done: !0
                                });
                            case 2:
                                return e.next = 4, this.getAudioData();
                            case 4:
                                return r = e.sent, this.includeSpectrogram && (a = this.flattenQueue(r.freqDataQueue), t = this.getTensorFromAudioDataArray(a, [this.numFrames, this.columnTruncateLength, 1])), this.includeWaveform && (i = this.flattenQueue(r.timeDataQueue), n = this.getTensorFromAudioDataArray(i, [this.numFrames * this.fftSize, 1])), e.abrupt("return", {
                                    value: {
                                        spectrogram: t,
                                        waveform: n
                                    },
                                    done: !1
                                });
                            case 8:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return a.apply(this, arguments)
                })
            }, {
                key: "capture",
                value: (r = c(o().mark((function e() {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.next();
                            case 2:
                                return e.abrupt("return", e.sent.value);
                            case 3:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return r.apply(this, arguments)
                })
            }, {
                key: "getAudioData",
                value: (n = c(o().mark((function e() {
                    var t, n, r, a = this;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return t = [], n = [], r = 0, e.abrupt("return", new Promise((function(e) {
                                    var i = setInterval((function() {
                                        a.includeSpectrogram && (a.analyser.getFloatFrequencyData(a.freqData), a.freqData[0] === -1 / 0 && e({
                                            freqDataQueue: t,
                                            timeDataQueue: n
                                        }), t.push(a.freqData.slice(0, a.columnTruncateLength))), a.includeWaveform && (a.analyser.getFloatTimeDomainData(a.timeData), n.push(a.timeData.slice())), ++r === a.numFrames && (clearInterval(i), e({
                                            freqDataQueue: t,
                                            timeDataQueue: n
                                        }))
                                    }), a.fftSize / a.sampleRateHz * 1e3)
                                })));
                            case 4:
                            case "end":
                                return e.stop()
                        }
                    }), e)
                }))), function() {
                    return n.apply(this, arguments)
                })
            }, {
                key: "stop",
                value: function() {
                    this.isClosed || (this.isClosed = !0, this.analyser.disconnect(), this.audioContext.close(), null != this.stream && this.stream.getTracks().length > 0 && this.stream.getTracks()[0].stop())
                }
            }, {
                key: "toArray",
                value: function() {
                    throw new Error("Can not convert infinite audio stream to array.")
                }
            }, {
                key: "getSampleRate",
                value: function() {
                    return this.sampleRateHz
                }
            }, {
                key: "flattenQueue",
                value: function(e) {
                    var t = e[0].length,
                        n = new Float32Array(e.length * t);
                    return e.forEach((function(e, r) {
                        return n.set(e, r * t)
                    })), n
                }
            }, {
                key: "getTensorFromAudioDataArray",
                value: function(e, t) {
                    var n = new Float32Array(L$(t));
                    return n.set(e, n.length - e.length), V5(n, t)
                }
            }], [{
                key: "create",
                value: (t = c(o().mark((function e() {
                    var t, n, r = arguments;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (t = r.length > 0 && void 0 !== r[0] ? r[0] : {}, k0().get("IS_BROWSER")) {
                                    e.next = 3;
                                    break
                                }
                                throw new Error("microphone API is only supported in browser environment.");
                            case 3:
                                return n = new u(t), e.next = 6, n.start();
                            case 6:
                                return e.abrupt("return", n);
                            case 7:
                            case "end":
                                return e.stop()
                        }
                    }), e)
                }))), function() {
                    return t.apply(this, arguments)
                })
            }]), u
        }(fme),
        Vme = function(e) {
            d(s, e);
            var t, n, r, a, i = w(s);

            function s(e, t) {
                var n;
                if (l(this, s), (n = i.call(this)).webcamVideoElement = e, n.webcamConfig = t, n.isClosed = !0, n.resize = !1, n.needToResize())
                    if (n.resize = !0, n.cropSize = [n.webcamConfig.resizeHeight, n.webcamConfig.resizeWidth], n.cropBoxInd = Vte([0], "int32"), n.webcamConfig.centerCrop) {
                        var r = 1 * n.webcamConfig.resizeWidth / n.webcamVideoElement.width,
                            a = 1 * n.webcamConfig.resizeHeight / n.webcamVideoElement.height,
                            o = (1 - r) / 2,
                            u = (1 - a) / 2,
                            c = o + r,
                            h = a + u;
                        n.cropBox = Gte([u, o, h, c], [1, 4])
                    } else n.cropBox = Gte([0, 0, 1, 1], [1, 4]);
                return n
            }
            return p(s, [{
                key: "summary",
                value: function() {
                    return "webcam"
                }
            }, {
                key: "start",
                value: (a = c(o().mark((function e() {
                    var t = this;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return this.webcamConfig.facingMode && F$("user" === this.webcamConfig.facingMode || "environment" === this.webcamConfig.facingMode, (function() {
                                    return "Invalid webcam facing mode: ".concat(t.webcamConfig.facingMode, ". ") + "Please provide 'user' or 'environment'"
                                })), e.prev = 1, e.next = 4, navigator.mediaDevices.getUserMedia({
                                    video: {
                                        deviceId: this.webcamConfig.deviceId,
                                        facingMode: this.webcamConfig.facingMode ? this.webcamConfig.facingMode : "user",
                                        width: this.webcamVideoElement.width,
                                        height: this.webcamVideoElement.height
                                    }
                                });
                            case 4:
                                this.stream = e.sent, e.next = 11;
                                break;
                            case 7:
                                throw e.prev = 7, e.t0 = e.catch(1), e.t0.message = "Error thrown while initializing video stream: ".concat(e.t0.message), e.t0;
                            case 11:
                                if (this.stream) {
                                    e.next = 13;
                                    break
                                }
                                throw new Error("Could not obtain video from webcam.");
                            case 13:
                                try {
                                    this.webcamVideoElement.srcObject = this.stream
                                } catch (e) {
                                    console.log(e), this.webcamVideoElement.src = window.URL.createObjectURL(this.stream)
                                }
                                return this.webcamVideoElement.play(), this.isClosed = !1, e.abrupt("return", new Promise((function(e) {
                                    t.webcamVideoElement.onloadedmetadata = function() {
                                        e()
                                    }
                                })));
                            case 17:
                            case "end":
                                return e.stop()
                        }
                    }), e, this, [
                        [1, 7]
                    ])
                }))), function() {
                    return a.apply(this, arguments)
                })
            }, {
                key: "next",
                value: (r = c(o().mark((function e() {
                    var t;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (!this.isClosed) {
                                    e.next = 2;
                                    break
                                }
                                return e.abrupt("return", {
                                    value: null,
                                    done: !0
                                });
                            case 2:
                                e.prev = 2, t = Fae(this.webcamVideoElement), e.next = 9;
                                break;
                            case 6:
                                throw e.prev = 6, e.t0 = e.catch(2), new Error("Error thrown converting video to pixels: ".concat(JSON.stringify(e.t0)));
                            case 9:
                                if (!this.resize) {
                                    e.next = 22;
                                    break
                                }
                                return e.prev = 10, e.abrupt("return", {
                                    value: this.cropAndResizeFrame(t),
                                    done: !1
                                });
                            case 14:
                                throw e.prev = 14, e.t1 = e.catch(10), new Error("Error thrown cropping the video: ".concat(e.t1.message));
                            case 17:
                                return e.prev = 17, t.dispose(), e.finish(17);
                            case 20:
                                e.next = 23;
                                break;
                            case 22:
                                return e.abrupt("return", {
                                    value: t,
                                    done: !1
                                });
                            case 23:
                            case "end":
                                return e.stop()
                        }
                    }), e, this, [
                        [2, 6],
                        [10, 14, 17, 20]
                    ])
                }))), function() {
                    return r.apply(this, arguments)
                })
            }, {
                key: "needToResize",
                value: function() {
                    return !(!this.webcamConfig.resizeWidth || !this.webcamConfig.resizeHeight || this.webcamVideoElement.width === this.webcamConfig.resizeWidth && this.webcamVideoElement.height === this.webcamConfig.resizeHeight)
                }
            }, {
                key: "cropAndResizeFrame",
                value: function(e) {
                    var t = this;
                    return X5((function() {
                        var n, r = f9(h8(e, "float32"), 0),
                            a = (n = Pre.cropAndResize(r, t.cropBox, t.cropBoxInd, t.cropSize, "bilinear")).shape;
                        return X8(n, a.slice(1))
                    }))
                }
            }, {
                key: "capture",
                value: (n = c(o().mark((function e() {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.next();
                            case 2:
                                return e.abrupt("return", e.sent.value);
                            case 3:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return n.apply(this, arguments)
                })
            }, {
                key: "stop",
                value: function() {
                    this.stream.getTracks().forEach((function(e) {
                        return e.stop()
                    }));
                    try {
                        this.webcamVideoElement.srcObject = null
                    } catch (e) {
                        console.log(e), this.webcamVideoElement.src = null
                    }
                    this.isClosed = !0
                }
            }, {
                key: "toArray",
                value: function() {
                    throw new Error("Can not convert infinite video stream to array.")
                }
            }], [{
                key: "create",
                value: (t = c(o().mark((function e(t) {
                    var n, r, a = arguments;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (n = a.length > 1 && void 0 !== a[1] ? a[1] : {}, k0().get("IS_BROWSER")) {
                                    e.next = 3;
                                    break
                                }
                                throw new Error("tf.data.webcam is only supported in browser environment.");
                            case 3:
                                if (t) {
                                    e.next = 9;
                                    break
                                }
                                if (t = document.createElement("video"), n.resizeWidth && n.resizeHeight) {
                                    e.next = 7;
                                    break
                                }
                                throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");
                            case 7:
                                t.width = n.resizeWidth, t.height = n.resizeHeight;
                            case 9:
                                return r = new s(t, n), e.next = 12, r.start();
                            case 12:
                                return e.abrupt("return", r);
                            case 13:
                            case "end":
                                return e.stop()
                        }
                    }), e)
                }))), function(e) {
                    return t.apply(this, arguments)
                })
            }]), s
        }(fme),
        Gme = p((function e() {
            l(this, e)
        })),
        jme = function(e) {
            d(n, e);
            var t = w(n);

            function n() {
                return l(this, n), t.apply(this, arguments)
            }
            return p(n, [{
                key: "split",
                value: function(e) {
                    return new Hme(this, e)
                }
            }]), n
        }(fme),
        Hme = function(e) {
            d(r, e);
            var t, n = w(r);

            function r(e, t) {
                var a;
                return l(this, r), (a = n.call(this)).upstream = e, a.impl = new qme(e, t), a
            }
            return p(r, [{
                key: "summary",
                value: function() {
                    return this.impl.summary()
                }
            }, {
                key: "next",
                value: (t = c(o().mark((function e() {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.abrupt("return", this.impl.next());
                            case 1:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return t.apply(this, arguments)
                })
            }]), r
        }(jme),
        qme = function(e) {
            d(r, e);
            var t, n = w(r);

            function r(e, t) {
                var a;
                return l(this, r), (a = n.call(this)).upstream = e, a.separator = t, a.carryover = "", a
            }
            return p(r, [{
                key: "summary",
                value: function() {
                    return "".concat(this.upstream.summary(), " -> Split('").concat(this.separator, "')")
                }
            }, {
                key: "pump",
                value: (t = c(o().mark((function e() {
                    var t, n, r, a, i;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.upstream.next();
                            case 2:
                                if (!(t = e.sent).done) {
                                    e.next = 9;
                                    break
                                }
                                if ("" !== this.carryover) {
                                    e.next = 6;
                                    break
                                }
                                return e.abrupt("return", !1);
                            case 6:
                                return this.outputQueue.push(this.carryover), this.carryover = "", e.abrupt("return", !0);
                            case 9:
                                (n = t.value.split(this.separator))[0] = this.carryover + n[0], r = O(n.slice(0, -1));
                                try {
                                    for (r.s(); !(a = r.n()).done;) i = a.value, this.outputQueue.push(i)
                                } catch (e) {
                                    r.e(e)
                                } finally {
                                    r.f()
                                }
                                return this.carryover = n[n.length - 1], e.abrupt("return", !0);
                            case 15:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return t.apply(this, arguments)
                })
            }]), r
        }(Nme),
        Kme = function(e) {
            d(n, e);
            var t = w(n);

            function n() {
                return l(this, n), t.apply(this, arguments)
            }
            return p(n, [{
                key: "decodeUTF8",
                value: function() {
                    return new Xme(this)
                }
            }]), n
        }(fme),
        Xme = function(e) {
            d(r, e);
            var t, n = w(r);

            function r(e) {
                var t;
                return l(this, r), (t = n.call(this)).upstream = e, t.impl = new Yme(e), t
            }
            return p(r, [{
                key: "summary",
                value: function() {
                    return this.impl.summary()
                }
            }, {
                key: "next",
                value: (t = c(o().mark((function e() {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.abrupt("return", this.impl.next());
                            case 1:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return t.apply(this, arguments)
                })
            }]), r
        }(jme),
        Yme = function(e) {
            d(r, e);
            var t, n = w(r);

            function r(e) {
                var t;
                if (l(this, r), (t = n.call(this)).upstream = e, k0().get("IS_BROWSER")) t.decoder = new TextDecoder("utf-8");
                else {
                    var a = require("string_decoder").StringDecoder;
                    t.decoder = new a("utf8")
                }
                return t
            }
            return p(r, [{
                key: "summary",
                value: function() {
                    return "".concat(this.upstream.summary(), " -> Utf8")
                }
            }, {
                key: "pump",
                value: (t = c(o().mark((function e() {
                    var t, n, r;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, this.upstream.next();
                            case 2:
                                if (!(t = e.sent).done) {
                                    e.next = 7;
                                    break
                                }
                                return e.abrupt("return", !1);
                            case 7:
                                n = t.value;
                            case 8:
                                return r = k0().get("IS_BROWSER") ? this.decoder.decode(n, {
                                    stream: !0
                                }) : this.decoder.write(Buffer.from(n.buffer)), this.outputQueue.push(r), e.abrupt("return", !0);
                            case 11:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return t.apply(this, arguments)
                })
            }]), r
        }(Nme),
        Jme = function(e) {
            d(r, e);
            var t, n = w(r);

            function r(e) {
                var t, a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                return l(this, r), (t = n.call(this)).file = e, t.options = a, F$(e instanceof Uint8Array || !!k0().get("IS_BROWSER") && (e instanceof File || e instanceof Blob), (function() {
                    return "FileChunkIterator only supports File, Blob and Uint8Array right now."
                })), t.offset = a.offset || 0, t.chunkSize = a.chunkSize || 1048576, t
            }
            return p(r, [{
                key: "summary",
                value: function() {
                    return "FileChunks ".concat(this.file)
                }
            }, {
                key: "next",
                value: (t = c(o().mark((function e() {
                    var t, n = this;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (!(this.offset >= (this.file instanceof Uint8Array ? this.file.byteLength : this.file.size))) {
                                    e.next = 2;
                                    break
                                }
                                return e.abrupt("return", {
                                    value: null,
                                    done: !0
                                });
                            case 2:
                                return t = new Promise((function(e, t) {
                                    var r = n.offset + n.chunkSize;
                                    if (n.file instanceof Uint8Array) e(new Uint8Array(n.file.slice(n.offset, r)));
                                    else {
                                        var a = new FileReader;
                                        a.onload = function(n) {
                                            var r = a.result;
                                            if (r instanceof ArrayBuffer && (r = new Uint8Array(r)), !(r instanceof Uint8Array)) return t(new TypeError("FileReader returned unknown type."));
                                            e(r)
                                        }, a.onabort = function(e) {
                                            return t(new Error("Aborted"))
                                        }, a.onerror = function(e) {
                                            return t(new Error(e.type))
                                        };
                                        var i = n.file.slice(n.offset, r);
                                        a.readAsArrayBuffer(i)
                                    }
                                    n.offset = r
                                })), e.next = 5, t;
                            case 5:
                                return e.t0 = e.sent, e.abrupt("return", {
                                    value: e.t0,
                                    done: !1
                                });
                            case 7:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return t.apply(this, arguments)
                })
            }]), r
        }(Kme);

    function Zme(e) {
        return Qme.apply(this, arguments)
    }

    function Qme() {
        return Qme = c(o().mark((function e(t) {
            var n, r, a, i, s, u, c = arguments;
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return n = c.length > 1 && void 0 !== c[1] ? c[1] : {}, r = c.length > 2 ? c[2] : void 0, "string" == typeof t ? a = t : (a = t.url, i = $me(t)), e.next = 5, (r || P4)(a, i);
                    case 5:
                        if (!(s = e.sent).ok) {
                            e.next = 15;
                            break
                        }
                        return e.t0 = Uint8Array, e.next = 10, s.arrayBuffer();
                    case 10:
                        return e.t1 = e.sent, u = new e.t0(e.t1), e.abrupt("return", new Jme(u, n));
                    case 15:
                        throw new Error(s.statusText);
                    case 16:
                    case "end":
                        return e.stop()
                }
            }), e)
        }))), Qme.apply(this, arguments)
    }
    var $me = function(e) {
        return {
            method: e.method,
            headers: e.headers,
            body: e.body,
            mode: e.mode,
            credentials: e.credentials,
            cache: e.cache,
            redirect: e.redirect,
            referrer: e.referrer,
            integrity: e.integrity
        }
    };

    function ege(e) {
        return "string" == typeof e && "file://" === e.slice(0, 7)
    }
    var tge = function(e) {
            d(r, e);
            var t, n = w(r);

            function r(e) {
                var t, a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                return l(this, r), (t = n.call(this)).input = e, t.options = a, t
            }
            return p(r, [{
                key: "iterator",
                value: (t = c(o().mark((function e() {
                    var t;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return ege(this.input) && k0().get("IS_NODE") && (t = require("fs"), this.input = t.readFileSync(this.input.slice(7))), e.abrupt("return", new Jme(this.input, this.options));
                            case 2:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return t.apply(this, arguments)
                })
            }]), r
        }(Gme),
        nge = function(e) {
            d(r, e);
            var t, n = w(r);

            function r(e) {
                var t, a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                return l(this, r), (t = n.call(this)).url = e, t.fileOptions = a, t
            }
            return p(r, [{
                key: "iterator",
                value: (t = c(o().mark((function e() {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (!ege(this.url)) {
                                    e.next = 4;
                                    break
                                }
                                return e.abrupt("return", new tge(this.url, this.fileOptions).iterator());
                            case 4:
                                return e.abrupt("return", Zme(this.url, this.fileOptions));
                            case 5:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function() {
                    return t.apply(this, arguments)
                })
            }]), r
        }(Gme);

    function rge() {
        return (rge = c(o().mark((function e(t, n) {
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return e.abrupt("return", Vme.create(t, n));
                    case 1:
                    case "end":
                        return e.stop()
                }
            }), e)
        })))).apply(this, arguments)
    }

    function age() {
        return (age = c(o().mark((function e(t) {
            return o().wrap((function(e) {
                for (;;) switch (e.prev = e.next) {
                    case 0:
                        return e.abrupt("return", Ume.create(t));
                    case 1:
                    case "end":
                        return e.stop()
                }
            }), e)
        })))).apply(this, arguments)
    }
    var ige = "4.22.0",
        oge = {
            __proto__: null,
            CSVDataset: Wme,
            Dataset: Rme,
            FileDataSource: tge,
            TextLineDataset: Fme,
            URLDataSource: nge,
            array: function(e) {
                return _me(c(o().mark((function t() {
                    return o().wrap((function(t) {
                        for (;;) switch (t.prev = t.next) {
                            case 0:
                                return t.abrupt("return", ume(e));
                            case 1:
                            case "end":
                                return t.stop()
                        }
                    }), t)
                }))), e.length)
            },
            csv: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                return new Wme(new nge(e), t)
            },
            func: function(e) {
                var t = cme(e);
                return _me(c(o().mark((function e() {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.abrupt("return", t);
                            case 1:
                            case "end":
                                return e.stop()
                        }
                    }), e)
                }))))
            },
            generator: function(e) {
                return _me(c(o().mark((function t() {
                    var n;
                    return o().wrap((function(t) {
                        for (;;) switch (t.prev = t.next) {
                            case 0:
                                return t.next = 2, e();
                            case 2:
                                return n = t.sent, t.abrupt("return", cme((function() {
                                    return n.next()
                                })));
                            case 4:
                            case "end":
                                return t.stop()
                        }
                    }), t)
                }))))
            },
            microphone: function(e) {
                return age.apply(this, arguments)
            },
            version_data: ige,
            webcam: function(e, t) {
                return rge.apply(this, arguments)
            },
            zip: function(e) {
                if (!nme(e)) throw new Error("The argument to zip() must be an object or array.");
                var t;
                if (Array.isArray(e))
                    for (var n = 0; n < e.length; n++) t = null == t ? e[n].size : Math.min(t, e[n].size);
                else if (e instanceof Object)
                    for (var r in e) t = null == t ? e[r].size : Math.min(t, e[r].size);
                return _me(c(o().mark((function t() {
                    var n;
                    return o().wrap((function(t) {
                        for (;;) switch (t.prev = t.next) {
                            case 0:
                                return t.next = 2, eme(e, (function(e) {
                                    if (e instanceof Rme) return {
                                        value: e.iterator(),
                                        recurse: !1
                                    };
                                    if (nme(e)) return {
                                        value: null,
                                        recurse: !0
                                    };
                                    throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")
                                }));
                            case 2:
                                return n = t.sent, t.abrupt("return", hme(n, pme.SHORTEST));
                            case 4:
                            case "end":
                                return t.stop()
                        }
                    }), t)
                }))), t)
            }
        };

    function sge(e, t) {
        Array.isArray(e) || (e = [e]), e.forEach((function(e) {
            null != e && F$("complex64" !== e.dtype, (function() {
                return "".concat(t, " does not support complex64 tensors in the CPU backend.")
            }))
        }))
    }
    var uge = one,
        cge = function(e) {
            d(a, e);
            var t, n, r = w(a);

            function a() {
                var e;
                return l(this, a), (e = r.call(this)).blockSize = 48, e.firstUse = !0, e.data = new S$(x(e), q5()), e
            }
            return p(a, [{
                key: "nextDataId",
                value: function() {
                    return a.nextDataId++
                }
            }, {
                key: "write",
                value: function(e, t, n) {
                    this.firstUse && (this.firstUse = !1, k0().get("IS_NODE") && z3("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));
                    var r = {
                        id: this.nextDataId()
                    };
                    return this.data.set(r, {
                        values: e,
                        dtype: n,
                        refCount: 1
                    }), r
                }
            }, {
                key: "makeTensorInfo",
                value: function(e, t, n) {
                    var r;
                    if ("string" === t && null != n && n.length > 0 && $$(n[0])) {
                        var a = n.map((function(e) {
                            return B4(e)
                        }));
                        r = this.write(a, e, t)
                    } else r = this.write(n, e, t);
                    return {
                        dataId: r,
                        shape: e,
                        dtype: t
                    }
                }
            }, {
                key: "refCount",
                value: function(e) {
                    return this.data.has(e) ? this.data.get(e).refCount : 0
                }
            }, {
                key: "incRef",
                value: function(e) {
                    this.data.get(e).refCount++
                }
            }, {
                key: "decRef",
                value: function(e) {
                    this.data.has(e) && this.data.get(e).refCount--
                }
            }, {
                key: "move",
                value: function(e, t, n, r, a) {
                    this.data.set(e, {
                        values: t,
                        dtype: r,
                        refCount: a
                    })
                }
            }, {
                key: "numDataIds",
                value: function() {
                    return this.data.numDataIds()
                }
            }, {
                key: "read",
                value: (n = c(o().mark((function e(t) {
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.abrupt("return", this.readSync(t));
                            case 1:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e) {
                    return n.apply(this, arguments)
                })
            }, {
                key: "readSync",
                value: function(e) {
                    var t = this.data.get(e),
                        n = t.dtype,
                        r = t.complexTensorInfos;
                    return "complex64" === n ? Tie(this.readSync(r.real.dataId), this.readSync(r.imag.dataId)) : u0(this.data.get(e).values, n)
                }
            }, {
                key: "bufferSync",
                value: function(e) {
                    var t = this.readSync(e.dataId);
                    if ("string" === e.dtype) try {
                        var n = t.map((function(e) {
                            return W4(e)
                        }));
                        return l8(e.shape, e.dtype, n)
                    } catch (e) {
                        throw new Error("Failed to decode encoded string bytes into utf-8")
                    }
                    return l8(e.shape, e.dtype, t)
                }
            }, {
                key: "makeOutput",
                value: function(e, t, n) {
                    return q5().makeTensorFromTensorInfo(this.makeTensorInfo(t, n, e), this)
                }
            }, {
                key: "disposeData",
                value: function(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    if (this.data.has(e)) {
                        if (this.data.get(e).refCount--, !t && this.data.get(e).refCount > 0) return !1;
                        var n = this.data.get(e),
                            r = n.complexTensorInfos;
                        null != r && (this.disposeData(r.real.dataId, !0), this.disposeData(r.imag.dataId, !0)), this.data.delete(e)
                    }
                    return !0
                }
            }, {
                key: "disposeIntermediateTensorInfo",
                value: function(e) {
                    this.disposeData(e.dataId)
                }
            }, {
                key: "time",
                value: (t = c(o().mark((function e(t) {
                    var n, r;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return n = z4(), t(), r = z4() - n, e.abrupt("return", {
                                    kernelMs: r
                                });
                            case 4:
                            case "end":
                                return e.stop()
                        }
                    }), e)
                }))), function(e) {
                    return t.apply(this, arguments)
                })
            }, {
                key: "memory",
                value: function() {
                    return {
                        unreliable: !0,
                        reasons: ["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]
                    }
                }
            }, {
                key: "where",
                value: function(e) {
                    sge([e], "where");
                    var t = this.readSync(e.dataId);
                    return uge(e.shape, t)
                }
            }, {
                key: "dispose",
                value: function() {}
            }, {
                key: "floatPrecision",
                value: function() {
                    return 32
                }
            }, {
                key: "epsilon",
                value: function() {
                    return N(v(a.prototype), "epsilon", this).call(this)
                }
            }]), a
        }(T$);

    function lge(e) {
        for (var t = new Float32Array(e.length), n = 0; n < e.length; ++n) t[n] = Math.abs(e[n]);
        return t
    }
    cge.nextDataId = 0;
    var hge = {
        kernelName: N0,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs.x,
                n = e.backend;
            sge(t, "abs");
            var r = new Float32Array(L$(t.shape));
            return r = lge(n.data.get(t.dataId).values), n.makeOutput(r, t.shape, t.dtype)
        }
    };

    function pge(e) {
        return function(t, n, r, a, i) {
            var o = z7(t, n),
                s = o.length,
                u = i0(o),
                c = q$(i, L$(o)),
                l = t.length,
                h = n.length,
                p = i0(t),
                f = i0(n),
                d = M7(t, o),
                v = M7(n, o);
            if (d.length + v.length === 0)
                for (var m = 0; m < c.length; ++m) c[m] = e(r[m % r.length], a[m % a.length]);
            else
                for (var g = function() {
                        var t = d0(y, s, u),
                            n = t.slice(-l);
                        d.forEach((function(e) {
                            return n[e] = 0
                        }));
                        var i = f0(n, l, p),
                            o = t.slice(-h);
                        v.forEach((function(e) {
                            return o[e] = 0
                        }));
                        var m = f0(o, h, f);
                        c[y] = e(r[i], a[m])
                    }, y = 0; y < c.length; ++y) g();
            return [c, o]
        }
    }

    function fge(e) {
        var t = e.inputs,
            n = e.backend,
            r = t.real,
            a = t.imag,
            i = n.data.get(r.dataId).values,
            o = n.data.get(a.dataId).values,
            s = n.makeTensorInfo(r.shape, "complex64");
        return n.data.get(s.dataId).complexTensorInfos = {
            real: n.makeTensorInfo(r.shape, "float32", i),
            imag: n.makeTensorInfo(a.shape, "float32", o)
        }, s
    }
    var dge = {
        kernelName: Z0,
        backendName: "cpu",
        kernelFunc: fge
    };

    function vge(e, t) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "float32";
        if ("complex64" === n) {
            var r = vge(e, t, "float32"),
                a = vge(e, t, "float32");
            return fge({
                inputs: {
                    real: r,
                    imag: a
                },
                backend: e
            })
        }
        var i = l0(L$(t), n);
        return e.makeTensorInfo(t, n, i)
    }

    function mge(e) {
        var t = e.inputs,
            n = e.backend,
            r = t.x;
        return n.incRef(r.dataId), {
            dataId: r.dataId,
            shape: r.shape,
            dtype: r.dtype
        }
    }
    var gge = {
        kernelName: W1,
        backendName: "cpu",
        kernelFunc: mge
    };

    function yge(e) {
        var t = e.inputs,
            n = e.backend,
            r = t.input,
            a = n.data.get(r.dataId).complexTensorInfos.real,
            i = n.data.get(a.dataId).values;
        return n.makeTensorInfo(a.shape, a.dtype, i)
    }
    var bge = {
        kernelName: D2,
        backendName: "cpu",
        kernelFunc: yge
    };

    function xge(e, t, n, r) {
        if ("int32" === r) return [t, "int32", Int32Array.from(e)];
        if ("bool" === r) {
            var a = L4([0], n),
                i = S(pge((function(e, t) {
                    return e !== t ? 1 : 0
                }))(t, [], e, a, "bool"), 2),
                o = i[0];
            return [i[1], "bool", o]
        }
        throw new Error("Error in Cast: failed to cast ".concat(n, " to ").concat(r))
    }

    function kge(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs,
            a = t.x,
            i = r.dtype;
        if ("complex64" === i) {
            if ("complex64" === a.dtype) return mge({
                inputs: {
                    x: a
                },
                backend: n
            });
            var o = vge(n, a.shape, a.dtype),
                s = kge({
                    inputs: {
                        x: a
                    },
                    backend: n,
                    attrs: {
                        dtype: "float32"
                    }
                }),
                u = fge({
                    inputs: {
                        real: s,
                        imag: o
                    },
                    backend: n
                });
            return n.disposeIntermediateTensorInfo(o), n.disposeIntermediateTensorInfo(s), u
        }
        if ("complex64" === a.dtype) {
            var c = yge({
                    inputs: {
                        input: a
                    },
                    backend: n
                }),
                l = kge({
                    inputs: {
                        x: c
                    },
                    backend: n,
                    attrs: {
                        dtype: i
                    }
                });
            return n.disposeIntermediateTensorInfo(c), l
        }
        if (!J$(a.dtype, i)) {
            var h = mge({
                inputs: {
                    x: a
                },
                backend: n
            });
            return {
                dataId: h.dataId,
                shape: h.shape,
                dtype: i
            }
        }
        var p = S(xge(n.data.get(a.dataId).values, a.shape, a.dtype, i), 3),
            f = p[0],
            d = p[1],
            v = p[2];
        return n.makeTensorInfo(f, d, v)
    }
    var wge = {
        kernelName: X0,
        backendName: "cpu",
        kernelFunc: kge
    };

    function Ige(e, t, n, r) {
        return null == n ? function(n) {
            var a = n.inputs,
                i = n.backend,
                o = a.a,
                s = a.b,
                u = i;
            sge([o, s], e);
            var c = u.data.get(o.dataId).values,
                l = u.data.get(s.dataId).values,
                h = "string" === o.dtype ? aoe(c) : c,
                p = "string" === o.dtype ? aoe(l) : l,
                f = r || o.dtype,
                d = S(t(o.shape, s.shape, h, p, f), 2),
                v = d[0],
                m = d[1];
            return u.makeTensorInfo(m, f, v)
        } : function(e) {
            var a = e.inputs,
                i = e.backend,
                o = a.a,
                s = a.b,
                u = i;
            if ("complex64" === o.dtype || "complex64" === s.dtype) {
                var c = kge({
                        inputs: {
                            x: o
                        },
                        backend: u,
                        attrs: {
                            dtype: "complex64"
                        }
                    }),
                    l = u.data.get(c.dataId),
                    h = l.complexTensorInfos.real,
                    p = l.complexTensorInfos.imag,
                    f = u.data.get(h.dataId).values,
                    d = u.data.get(p.dataId).values,
                    v = kge({
                        inputs: {
                            x: s
                        },
                        backend: u,
                        attrs: {
                            dtype: "complex64"
                        }
                    }),
                    m = u.data.get(v.dataId),
                    g = m.complexTensorInfos.real,
                    y = m.complexTensorInfos.imag,
                    b = u.data.get(g.dataId).values,
                    x = u.data.get(y.dataId).values,
                    k = S(n(o.shape, s.shape, f, d, b, x), 3),
                    w = k[0],
                    I = k[1],
                    N = k[2],
                    T = u.makeTensorInfo(N, "float32", w),
                    E = u.makeTensorInfo(N, "float32", I),
                    C = fge({
                        inputs: {
                            real: T,
                            imag: E
                        },
                        backend: u
                    });
                return u.disposeIntermediateTensorInfo(c), u.disposeIntermediateTensorInfo(v), u.disposeIntermediateTensorInfo(T), u.disposeIntermediateTensorInfo(E), C
            }
            var A = u.data.get(o.dataId).values,
                R = u.data.get(s.dataId).values,
                _ = r || o.dtype,
                O = S(t(o.shape, s.shape, A, R, _), 2),
                F = O[0],
                D = O[1];
            return u.makeTensorInfo(D, _, F)
        }
    }

    function Nge(e) {
        return function(t, n, r, a, i, o) {
            var s = z7(t, n),
                u = L$(s),
                c = s.length,
                l = i0(s),
                h = q$("float32", u),
                p = q$("float32", u),
                f = M7(t, s),
                d = M7(n, s),
                v = Tie(r, a),
                m = Tie(i, o),
                g = t.length,
                y = i0(t),
                b = n.length,
                x = i0(n);
            if (f.length + d.length === 0)
                for (var k = 0; k < h.length; k++) {
                    var w = k % v.length,
                        I = k % m.length,
                        N = e(v[2 * w], v[2 * w + 1], m[2 * I], m[2 * I + 1]);
                    h[k] = N.real, p[k] = N.imag
                } else
                    for (var S = function() {
                            var t = d0(T, c, l),
                                n = t.slice(-g);
                            f.forEach((function(e) {
                                return n[e] = 0
                            }));
                            var r = f0(n, g, y),
                                a = t.slice(-b);
                            d.forEach((function(e) {
                                return a[e] = 0
                            }));
                            var i = f0(a, b, x),
                                o = e(v[2 * r], v[2 * r + 1], m[2 * i], m[2 * i + 1]);
                            h[T] = o.real, p[T] = o.imag
                        }, T = 0; T < h.length; T++) S();
            return [h, p, s]
        }
    }
    var Sge = pge((function(e, t) {
            return e + t
        })),
        Tge = Nge((function(e, t, n, r) {
            return {
                real: e + n,
                imag: t + r
            }
        })),
        Ege = Ige(E0, Sge, Tge),
        Cge = {
            kernelName: E0,
            backendName: "cpu",
            kernelFunc: Ege
        };

    function Age(e, t, n, r, a) {
        for (var i = L$(r), o = l0(a, n), s = 0; s < e.length; s++) {
            var u = e[s];
            if (u < 0) throw new Error("Input x must be non-negative!");
            u >= a || (o[u] += i > 0 ? t[s] : 1)
        }
        return o
    }

    function Rge(e, t, n) {
        for (var r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], a = e.shape[0], i = e.shape[1], o = l8([a, n], t.dtype), s = 0; s < a; s++)
            for (var u = 0; u < i; u++) {
                var c = e.get(s, u);
                if (c < 0) throw new Error("Input x must be non-negative!");
                c >= n || (r ? o.set(1, s, c) : t.size > 0 ? o.set(o.get(s, c) + t.get(s, u), s, c) : o.set(o.get(s, c) + 1, s, c))
            }
        return o
    }
    var _ge = pge((function(e, t) {
            return e & t
        })),
        Oge = Ige(H0, _ge),
        Fge = {
            kernelName: H0,
            backendName: "cpu",
            kernelFunc: Oge
        };

    function Dge(e) {
        return function(t, n, r) {
            for (var a = K$(n, t.length), i = 0; i < t.length; ++i) a[i] = e(t[i], r);
            return a
        }
    }

    function Mge(e, t, n) {
        return Lge(e, Dge(t), n)
    }

    function Lge(e, t, n) {
        return function(r) {
            var a = r.inputs,
                i = r.attrs,
                o = r.backend,
                s = a.x;
            sge(s, e);
            var u, c = o,
                l = c.data.get(s.dataId).values;
            if ("string" === s.dtype) {
                if (!Array.isArray(l)) throw new Error("String tensor's value was not an instance of Array");
                u = aoe(l)
            } else u = l;
            var h = n || s.dtype,
                p = t(u, h, i);
            return c.makeTensorInfo(s.shape, h, p)
        }
    }
    var zge = Dge((function(e) {
            return Math.ceil(e)
        })),
        Pge = Lge(Y0, zge),
        Bge = {
            kernelName: Y0,
            backendName: "cpu",
            kernelFunc: Pge
        };

    function Wge(e, t, n, r) {
        var a = K$(n, L$(t));
        if (r && "string" !== n) {
            var i = 0;
            e.forEach((function(e) {
                var t = L$(e.shape);
                a.set(e.vals, i), i += t
            }))
        } else {
            var o = 0;
            e.forEach((function(e) {
                for (var r = "string" === n ? aoe(e.vals) : e.vals, i = 0, s = 0; s < e.shape[0]; ++s)
                    for (var u = s * t[1] + o, c = 0; c < e.shape[1]; ++c) a[u + c] = r[i++];
                o += e.shape[1]
            }))
        }
        return a
    }
    var Uge = pge((function(e, t) {
            return e === t ? 1 : 0
        })),
        Vge = Ige(T1, Uge, null, "bool"),
        Gge = {
            kernelName: T1,
            backendName: "cpu",
            kernelFunc: Vge
        },
        jge = Dge((function(e) {
            return Math.exp(e)
        })),
        Hge = Lge(E1, jge, "float32"),
        qge = {
            kernelName: E1,
            backendName: "cpu",
            kernelFunc: Hge
        },
        Kge = Dge((function(e) {
            return Math.expm1(e)
        })),
        Xge = Lge(A1, Kge),
        Yge = {
            kernelName: A1,
            backendName: "cpu",
            kernelFunc: Xge
        },
        Jge = Dge((function(e) {
            return Math.floor(e)
        })),
        Zge = Lge(F1, Jge),
        Qge = {
            kernelName: F1,
            backendName: "cpu",
            kernelFunc: Zge
        },
        $ge = pge((function(e, t) {
            return Math.floor(e / t)
        })),
        eye = Ige(D1, $ge, null, "int32"),
        tye = {
            kernelName: D1,
            backendName: "cpu",
            kernelFunc: eye
        };

    function nye(e, t, n, r, a, i, o, s, u) {
        for (var c = l8([r, i], n), l = 0; l < r; l++) {
            for (var h = [], p = 0, f = 0; f < a; f++) {
                var d = e[l * a + f];
                p += d * o[f], h.push(d)
            }
            if (p < 0 || p >= u / i) throw new Error("Invalid indices: ".concat(h, " does not index into ").concat(s));
            for (var v = 0; v < i; v++) c.values[l * i + v] = t.get.apply(t, T(t.indexToLoc(p * i + v)))
        }
        return c
    }

    function rye(e, t, n) {
        for (var r = l8(n, e.dtype), a = 0; a < r.size; ++a) {
            var i = r.indexToLoc(a).slice(),
                o = i[0],
                s = i[2],
                u = t.locToIndex([o, s]);
            i[2] = t.values[u];
            var c = e.locToIndex(i);
            0 <= c && c < e.values.length && (r.values[a] = e.values[c])
        }
        return r
    }
    var aye = pge((function(e, t) {
            return e > t ? 1 : 0
        })),
        iye = Ige(P1, aye, null, "bool"),
        oye = {
            kernelName: P1,
            backendName: "cpu",
            kernelFunc: iye
        },
        sye = pge((function(e, t) {
            return e >= t ? 1 : 0
        })),
        uye = Ige(B1, sye, null, "bool"),
        cye = {
            kernelName: B1,
            backendName: "cpu",
            kernelFunc: uye
        },
        lye = pge((function(e, t) {
            return e < t ? 1 : 0
        })),
        hye = Ige(K1, lye, null, "bool"),
        pye = {
            kernelName: K1,
            backendName: "cpu",
            kernelFunc: hye
        },
        fye = pge((function(e, t) {
            return e <= t ? 1 : 0
        })),
        dye = Ige(X1, fye, null, "bool"),
        vye = {
            kernelName: X1,
            backendName: "cpu",
            kernelFunc: dye
        };

    function mye(e, t, n) {
        var r = (t - e) / (n - 1),
            a = l0(n, "float32");
        a[0] = e;
        for (var i = 1; i < a.length; i++) a[i] = a[i - 1] + r;
        return a
    }
    var gye = Dge((function(e) {
            return Math.log(e)
        })),
        yye = Lge(J1, gye),
        bye = {
            kernelName: J1,
            backendName: "cpu",
            kernelFunc: yye
        };

    function xye(e, t, n, r) {
        for (var a = q$(r, L$(n)), i = 0; i < a.length; ++i) {
            for (var o = i * t, s = e[o], u = 0; u < t; ++u) {
                var c = e[o + u];
                (Number.isNaN(c) || c > s) && (s = c)
            }
            a[i] = s
        }
        return a
    }
    var kye = pge((function(e, t) {
            return Math.max(e, t)
        })),
        wye = Ige(i2, kye),
        Iye = {
            kernelName: i2,
            backendName: "cpu",
            kernelFunc: wye
        },
        Nye = pge((function(e, t) {
            return Math.min(e, t)
        })),
        Sye = Ige(f2, Nye),
        Tye = {
            kernelName: f2,
            backendName: "cpu",
            kernelFunc: Sye
        },
        Eye = pge((function(e, t) {
            return e * t
        })),
        Cye = Nge((function(e, t, n, r) {
            return {
                real: e * n - t * r,
                imag: e * r + t * n
            }
        })),
        Aye = Ige(g2, Eye, Cye),
        Rye = {
            kernelName: g2,
            backendName: "cpu",
            kernelFunc: Aye
        };

    function _ye(e, t, n) {
        var r = M4(-1, n);
        return Eye([], t, r, e, n)
    }
    var Oye = {
            kernelName: y2,
            backendName: "cpu",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = t.x;
                sge(r, "neg");
                var a = S(_ye(n.data.get(r.dataId).values, r.shape, r.dtype), 2),
                    i = a[0],
                    o = a[1];
                return n.makeTensorInfo(o, r.dtype, i)
            }
        },
        Fye = pge((function(e, t) {
            return e !== t ? 1 : 0
        })),
        Dye = Ige(b2, Fye, null, "bool"),
        Mye = {
            kernelName: b2,
            backendName: "cpu",
            kernelFunc: Dye
        };

    function Lye(e, t, n, r, a) {
        for (var i = t.length, o = L$(t), s = i0(t), u = i0(a), c = q$(n, L$(a)), l = 0; l < o; ++l) {
            for (var h = d0(l, i, s), p = new Array(h.length), f = 0; f < p.length; f++) p[f] = h[r[f]];
            c[f0(p, i, u)] = e[l]
        }
        return c
    }

    function zye(e) {
        var t = e.inputs,
            n = e.attrs,
            r = e.backend,
            a = t.x,
            i = n.perm;
        sge(a, "transpose");
        for (var o = a.shape.length, s = new Array(o), u = 0; u < s.length; u++) s[u] = a.shape[i[u]];
        var c = Lye(r.data.get(a.dataId).values, a.shape, a.dtype, i, s);
        return {
            dataId: r.write(c, s, a.dtype),
            shape: s,
            dtype: a.dtype
        }
    }
    var Pye = {
        kernelName: T3,
        backendName: "cpu",
        kernelFunc: zye
    };

    function Bye(e, t, n, r) {
        for (var a = S(J7(e, r), 2), i = a[0], o = a[1], s = h5(t, "int32"), u = l0(L$(i), s), c = L$(o), l = 0; l < u.length; ++l) {
            for (var h = l * c, p = 1, f = 0; f < c; ++f) p *= n[h + f];
            u[l] = p
        }
        return {
            outVals: u,
            outShape: i,
            outDtype: s
        }
    }
    var Wye = {
        kernelName: A2,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = r.axis,
                o = r.keepDims;
            sge(a, "prod");
            var s = a.shape.length,
                u = j$(i, a.shape),
                c = $7(u, s),
                l = u,
                h = a,
                p = [];
            null != c && (h = zye({
                inputs: {
                    x: a
                },
                backend: n,
                attrs: {
                    perm: c
                }
            }), p.push(h), l = t9(l.length, s));
            var f = n.data.get(h.dataId).values,
                d = Bye(h.shape, h.dtype, f, l),
                v = d.outVals,
                m = d.outShape,
                g = d.outDtype,
                y = m;
            return o && (y = Z7(m, u)), p.forEach((function(e) {
                return n.disposeIntermediateTensorInfo(e)
            })), n.makeTensorInfo(y, g, v)
        }
    };

    function Uye(e, t, n, r) {
        var a = [],
            i = 0,
            o = t.length - 1 + n.length,
            s = new Array(o).fill(null).map((function() {
                return [0]
            }));
        ! function(e, t) {
            for (var n = 0; n < e.length; ++n) {
                var r = e[n],
                    a = n === e.length - 1 ? t : e[n + 1].length;
                if (0 === r.length) throw new Error("Ragged splits may not be empty");
                if (r[0] < 0) throw new Error("Ragged splits must be non-negative");
                if (r[r.length - 1] > a) throw new Error("Ragged splits must not point past values");
                for (var i = 1; i < r.length; ++i)
                    if (r[i - 1] > r[i]) throw new Error("Ragged splits must be sorted in ascending order")
            }
        }(n, r);
        for (var u = 1, c = 0; c < t.length - 1; ++c) {
            u *= t[c];
            for (var l = t[c + 1], h = 1; h < u + 1; ++h) s[c].push(h * l)
        }
        for (var p = 0; p < e.length; ++p) {
            for (var f = e[p], d = e[p] + 1, v = 0; v < n.length; ++v) {
                var m = n[v],
                    g = v + t.length - 1;
                if (g >= 0)
                    for (var y = s[g], b = y[y.length - 1] - m[f], x = f; x < d; ++x) s[g].push(m[x + 1] + b);
                f = m[f], d = m[d]
            }
            d !== f && (a.push([f, d]), i += d - f)
        }
        return {
            outSplits: s,
            valueSlices: a,
            numValues: i
        }
    }

    function Vye(e, t) {
        for (var n = e.slice(0, t); n.length < t;) n.push(1);
        for (var r = t; r < e.length; r++) n[t - 1] *= e[r];
        return n
    }

    function Gye(e, t, n, r, a) {
        var i = t.slice();
        i[0] = a;
        var o = K$(n, L$(i)),
            s = e.length;
        return function(e, t, n, r, a, i) {
            var o, s = Vye(t, 2)[1],
                u = Vye(i, 2)[1],
                c = 0,
                l = O(n);
            try {
                for (l.s(); !(o = l.n()).done;)
                    for (var h = o.value, p = h[0]; p < h[1]; ++p) {
                        for (var f = 0; f < r; ++f) a[c * u + f] = e[p * s + f];
                        ++c
                    }
            } catch (e) {
                l.e(e)
            } finally {
                l.f()
            }
        }(e, t, r, 0 === s ? 0 : s / t[0], o, i), [o, i]
    }

    function jye(e, t, n, r, a, i, o, s) {
        if (0 === e.length) throw new Error("paramsNestedSplits must be non empty");
        if (0 === t[0].length) throw new Error("Split tensors must not be scalars");
        if (function(e, t, n) {
                e.forEach((function(e, r) {
                    if (e < 0 || e >= n) {
                        var a = d0(r, t.length, i0(t)).join(",");
                        throw new Error("indices[".concat(a, "] = ").concat(e, " is not in [0, ").concat(n, ")"))
                    }
                }))
            }(i, o, t[0][0] - 1), 0 === r.length) throw new Error("params.rank must be nonzero");
        var u = Uye(i, o, e, r[0]),
            c = u.outSplits,
            l = u.valueSlices,
            h = u.numValues,
            p = function(e) {
                for (var t = [], n = function() {
                        var n = K$("int32", e[r].length);
                        t.push(n), e[r].forEach((function(e, t) {
                            return n[t] = e
                        }))
                    }, r = 0; r < e.length; ++r) n();
                return t
            }(c),
            f = Gye(n, r, a, l, h);
        return [p, f[0], f[1]]
    }
    var Hye = 2147483647;

    function qye(e, t, n, r, a, i, o) {
        if (t.length > 1) throw new Error("starts must be a scalar or vector");
        if (a.length > 1) throw new Error("limits must be a scalar or vector");
        if (o.length > 1) throw new Error("deltas must be a scalar or vector");
        var s = 0 === t.length,
            u = 0 === a.length,
            c = 0 === o.length,
            l = [];
        s || l.push(t[0]), u || l.push(a[0]), c || l.push(o[0]);
        for (var h = 1; h < l.length; ++h)
            if (l[h] !== l[h - 1]) throw new Error("starts, limits, and deltas must have the same shape");
        var p = 0 === l.length ? 1 : l[0],
            f = K$("int32", p + 1);
        f[0] = 0;
        for (var d = 0; d < p; ++d) {
            var v = s ? e[0] : e[d],
                m = u ? r[0] : r[d],
                g = c ? i[0] : i[d];
            if (0 === g) throw new Error("Requires delta != 0");
            var y = void 0;
            if (g > 0 && m < v || g < 0 && m > v) y = 0;
            else if ((y = Math.ceil(Math.abs((m - v) / g))) > Hye) throw new Error("Requires ((limit - start) / delta) <= ".concat(Hye));
            f[d + 1] = f[d] + y
        }
        for (var b = K$(n, f[p]), x = 0, k = 0; k < p; ++k)
            for (var w = f[k + 1] - f[k], I = s ? e[0] : e[k], N = c ? i[0] : i[k], S = 0; S < w; ++S) b[x++] = I, I += N;
        return [f, b]
    }
    var Kye = Qae,
        Xye = function() {
            function e(t, n, r, a, i, o, s, u, c, h) {
                l(this, e), this.shape = t, this.shapeShape = n, this.values = r, this.valuesShape = a, this.valuesDType = i, this.defaultValue = o, this.defaultValueShape = s, this.rowPartitionValues = u, this.rowPartitionValuesShapes = c, this.rowPartitionTypes = uie(h), this.raggedRank = cie(this.rowPartitionTypes)
            }
            return p(e, [{
                key: "getRowPartitionTypeByDimension",
                value: function(e) {
                    return this.rowPartitionTypes[0] === Kye.FIRST_DIM_SIZE ? this.rowPartitionTypes[e + 1] : this.rowPartitionTypes[e]
                }
            }, {
                key: "getRowPartitionTensor",
                value: function(e) {
                    return this.rowPartitionTypes[0] === Kye.FIRST_DIM_SIZE ? this.rowPartitionValues[e + 1] : this.rowPartitionValues[e]
                }
            }, {
                key: "getMaxWidth",
                value: function(t) {
                    var n = this.getRowPartitionTensor(t - 1);
                    switch (this.getRowPartitionTypeByDimension(t - 1)) {
                        case Kye.VALUE_ROWIDS:
                            return e.getMaxWidthValueRowID(n);
                        case Kye.ROW_SPLITS:
                            return e.getMaxWidthRowSplit(n);
                        default:
                            throw new Error("Cannot handle partition type ".concat(Kye[this.getRowPartitionTypeByDimension(t - 1)]))
                    }
                }
            }, {
                key: "tensorShapeFromTensor",
                value: function(e, t) {
                    var n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                    if (0 === t.length) {
                        if (-1 === e[0]) return [];
                        throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")
                    }
                    return Jye(e, n)
                }
            }, {
                key: "calculateOutputSize",
                value: function(e) {
                    var t = this.valuesShape;
                    lie(this.defaultValueShape, t);
                    var n = this.tensorShapeFromTensor(this.shape, this.shapeShape),
                        r = sie(this.raggedRank, n, t);
                    r[0] < 0 && (r[0] = e);
                    for (var a = 1; a <= this.raggedRank; ++a) r[a] < 0 && (r[a] = this.getMaxWidth(a));
                    return r
                }
            }, {
                key: "calculateFirstParentOutputIndex",
                value: function(e, t, n) {
                    for (var r = Math.min(e, n), a = [], i = 0, o = 0; o < r; ++o, i += t) a.push(i);
                    for (var s = r; s < e; ++s) a.push(-1);
                    return F$(a.length === e, (function() {
                        return "Final length of result must be equal to firstDimension."
                    })), a
                }
            }, {
                key: "calculateOutputIndexRowSplit",
                value: function(e, t, n, r) {
                    for (var a = e.length, i = [], o = 0; o < a - 1; ++o) {
                        var s = e[o + 1] - e[o],
                            u = Math.min(r, s),
                            c = t[o]; - 1 === c && (u = 0);
                        for (var l = 0; l < u; ++l) i.push(c), c += n;
                        for (var h = 0; h < s - u; ++h) i.push(-1)
                    }
                    if (a > 0 && i.length !== e[a - 1]) throw new Error("Invalid row split size.");
                    return i
                }
            }, {
                key: "calculateOutputIndexValueRowID",
                value: function(e, t, n, r) {
                    var a = e.length,
                        i = [];
                    if (0 === a) return [];
                    var o = 0,
                        s = e[0];
                    if (s >= t.length) throw new Error("Got currentValueRowId=".concat(s, ", which is not less than ").concat(t.length));
                    var u = t[s];
                    i.push(u);
                    for (var c = 1; c < a; ++c) {
                        var l = e[c];
                        if (l === s) u >= 0 && (++o < r ? u += n : u = -1);
                        else {
                            if (o = 0, s = l, l >= t.length) throw new Error("Got nextValueRowId=".concat(l, " which is not less than ").concat(t.length));
                            u = t[l]
                        }
                        i.push(u)
                    }
                    if (i.length !== e.length) throw new Error("Invalid row ids.");
                    return i
                }
            }, {
                key: "calculateOutputIndex",
                value: function(e, t, n, r) {
                    var a = this.getRowPartitionTensor(e),
                        i = this.getRowPartitionTypeByDimension(e);
                    switch (i) {
                        case Kye.VALUE_ROWIDS:
                            return this.calculateOutputIndexValueRowID(a, t, n, r);
                        case Kye.ROW_SPLITS:
                            if (a.length - 1 > t.length) throw new Error("Row partition size is greater than output size: ".concat(a.length - 1, " > ").concat(t.length));
                            return this.calculateOutputIndexRowSplit(a, t, n, r);
                        default:
                            throw new Error("Unsupported partition type: ".concat(Kye[i]))
                    }
                }
            }, {
                key: "getFirstDimensionSize",
                value: function() {
                    var e = this.rowPartitionValues[0];
                    if (0 === this.rowPartitionTypes.length) throw new Error("No row_partition_types given.");
                    var t = this.rowPartitionTypes[0];
                    switch (t) {
                        case Kye.FIRST_DIM_SIZE:
                            return e[0];
                        case Kye.VALUE_ROWIDS:
                            throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");
                        case Kye.ROW_SPLITS:
                            return this.rowPartitionValuesShapes[0][0] - 1;
                        default:
                            throw new Error("Cannot handle type ".concat(Kye[t]))
                    }
                }
            }, {
                key: "compute",
                value: function() {
                    if (this.rowPartitionValues[0].length <= 0) throw new Error("Invalid first partition input. Tensor requires at least one element.");
                    var e = this.getFirstDimensionSize(),
                        t = this.calculateOutputSize(e),
                        n = new Array(this.raggedRank + 1);
                    n[n.length - 1] = 1;
                    for (var r = n.length - 2; r >= 0; --r) n[r] = n[r + 1] * t[r + 1];
                    var a = Jye(t, !1),
                        i = K$(this.valuesDType, L$(a));
                    if (n[0] * t[0] > 0) {
                        for (var o = this.calculateFirstParentOutputIndex(e, n[0], t[0]), s = 1; s <= this.raggedRank; ++s) {
                            o = this.calculateOutputIndex(s - 1, o, n[s], t[s])
                        }
                        this.setOutput(this.raggedRank, o, i, a)
                    }
                    return [a, i]
                }
            }, {
                key: "setOutput",
                value: function(e, t, n, r) {
                    if (0 !== n.length) {
                        var a = this.values,
                            i = n,
                            o = r.slice(),
                            s = L$(o = o.slice(e + 1)),
                            u = t.length,
                            c = this.defaultValue;
                        if (c.length !== s && 1 !== c.length) {
                            var l = this.defaultValueShape;
                            X5((function() {
                                var e = X8(c, l),
                                    t = h7(e, o);
                                c = t.dataSync()
                            }))
                        }
                        for (var h = 0, p = 0, f = 0, d = 0; d <= u; ++d) {
                            var v = d < u ? t[d] : -1;
                            if (v !== f) {
                                if (p < f) {
                                    var m = a.subarray(h * s);
                                    Yye(i.subarray(p * s), m, (f - p) * s)
                                }
                                if (d >= u) {
                                    var g = n.length;
                                    v = Math.floor(g / s)
                                }
                                if (v > f)
                                    if (1 === this.defaultValue.length) i.subarray(f * s, v * s).fill(this.defaultValue[0]), f = v;
                                    else
                                        for (; v > f;) {
                                            Yye(i.slice(f * s), c, s), ++f
                                        }
                                    v < 0 ? (h = d + 1, p = f) : (h = d, f = (p = f) + 1)
                            } else ++f
                        }
                    }
                }
            }], [{
                key: "getMaxWidthRowSplit",
                value: function(e) {
                    var t = e.length;
                    if (0 === t || 1 === t) return 0;
                    for (var n = 0, r = 0; r < t - 1; ++r) {
                        var a = e[r + 1] - e[r];
                        a > n && (n = a)
                    }
                    return n
                }
            }, {
                key: "getMaxWidthValueRowID",
                value: function(e) {
                    var t = e.length;
                    if (0 === t) return 0;
                    for (var n = 0, r = e[0], a = 0, i = 1; i < t; ++i) {
                        var o = e[i];
                        o !== r && (r = o, a = Math.max(i - n, a), n = i)
                    }
                    return Math.max(t - n, a)
                }
            }]), e
        }();

    function Yye(e, t, n) {
        for (var r = 0; r < n; r++) e[r] = t[r]
    }

    function Jye(e, t) {
        var n, r = [],
            a = O(e);
        try {
            for (a.s(); !(n = a.n()).done;) {
                var i = n.value;
                if (i < 0) {
                    if (!t) throw new Error("Dimension ".concat(i, " must be >= 0"));
                    if (i < -1) throw new Error("Dimension ".concat(i, " must be >= -1"));
                    i = -1
                }
                r.push(i)
            }
        } catch (e) {
            a.e(e)
        } finally {
            a.f()
        }
        return r
    }

    function Zye(e, t, n, r, a, i, o, s, u, c) {
        return new Xye(e, t, n, r, a, i, o, s, u, c).compute()
    }

    function Qye(e, t, n, r) {
        if (e === t || e < t && n < 0 || t < e && n > 1) return l0(0, r);
        var a = l0(Math.abs(Math.ceil((t - e) / n)), r);
        t < e && 1 === n && (n = -1), a[0] = e;
        for (var i = 1; i < a.length; i++) a[i] = a[i - 1] + n;
        return a
    }
    var $ye = Dge((function(e) {
            return 1 / Math.sqrt(e)
        })),
        ebe = Lge(H2, $ye),
        tbe = {
            kernelName: H2,
            backendName: "cpu",
            kernelFunc: ebe
        };

    function nbe(e, t, n, r, a, i, o, s, u, c) {
        var l = [r / a, a],
            h = e.values,
            p = t.values;
        if (0 === r) return l8(n, t.dtype);
        var f = u instanceof $4 ? u : l8(l, t.dtype);
        "string" == typeof u || "number" == typeof u ? f.values.fill(u) : "boolean" == typeof u && f.values.fill(+u);
        for (var d = 0; d < i; d++) {
            for (var v = [], m = 0, g = 0; g < o; g++) {
                var y = h[d * o + g];
                v.push(y), m += y * s[g]
            }
            if (m < 0 || m >= r / a) throw new Error("Invalid indices: ".concat(v, " does not index into ").concat(n));
            for (var b = 0; b < a; b++) c ? f.values[m * a + b] += p[d * a + b] : f.values[m * a + b] = 0 === t.rank ? p[0] : p[d * a + b]
        }
        return f
    }
    var rbe = Dge((function(e) {
            return 1 / (1 + Math.exp(-e))
        })),
        abe = Mge(t3, (function(e) {
            return 1 / (1 + Math.exp(-e))
        })),
        ibe = {
            kernelName: t3,
            backendName: "cpu",
            kernelFunc: abe
        };

    function obe(e, t, n, r, a) {
        var i = Kae(r, t, n),
            o = L$(n),
            s = i0(r);
        if (i) {
            var u = Xae(t, s);
            return "string" === a ? e.slice(u, u + o) : e.subarray(u, u + o)
        }
        for (var c = l8(r, a, "string" === a ? aoe(e) : e), l = l8(n, a), h = 0; h < l.size; ++h) {
            var p = l.indexToLoc(h),
                f = p.map((function(e, n) {
                    return e + t[n]
                }));
            l.set.apply(l, [c.get.apply(c, T(f))].concat(T(p)))
        }
        return "string" === a ? ioe(l.values) : l.values
    }

    function sbe(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs,
            a = t.x,
            i = r.begin,
            o = r.size;
        sge(a, "slice");
        var s = S(Yae(a, i, o), 2),
            u = s[0],
            c = s[1];
        zae(a, u, c);
        var l = obe(n.data.get(a.dataId).values, u, c, a.shape, a.dtype);
        return n.makeTensorInfo(c, a.dtype, l)
    }
    var ube = {
        kernelName: Z2,
        backendName: "cpu",
        kernelFunc: sbe
    };

    function cbe(e, t, n, r, a, i, o) {
        var s = t[0],
            u = i[0],
            c = new Array(u),
            l = new Array(s),
            h = t[1];
        if (0 === u) {
            if (0 !== s) throw new Error(Gie(s));
            return [K$(n, 0), [0, h], K$(a, 0), c, l]
        }
        for (var p = !0, f = 0, d = new Array(u).fill(0), v = 0; v < s; ++v) {
            var m = e[v * h];
            if (m < 0) throw new Error(jie(v, m));
            if (m >= u) throw new Error(Hie(v, m, u));
            ++d[m], p = p && m >= f, f = m
        }
        for (var g = !0, y = 0; y < u; ++y) {
            var b = 0 === d[y];
            c[y] = b, g = g && !b, d[y] = Math.max(d[y], 1), y > 0 && (d[y] += d[y - 1])
        }
        if (g && p) {
            for (var x = e, k = r, w = 0; w < s; ++w) l[w] = w;
            return [x, [s, h], k, c, l]
        }
        for (var I = d[u - 1], N = K$(n, I * h), S = K$(a, I), T = new Array(u).fill(0), E = 0; E < s; ++E) {
            var C = e[E * h],
                A = T[C],
                R = (0 === C ? 0 : d[C - 1]) + A;
            T[C]++;
            for (var _ = 0; _ < h; ++_) N[R * h + _] = e[E * h + _];
            S[R] = r[E], l[E] = R
        }
        for (var O = 0; O < u; ++O) {
            if (0 === T[O]) {
                var F = 0 === O ? 0 : d[O - 1];
                N[F * h + 0] = O;
                for (var D = 1; D < h; ++D) N[F * h + D] = 0;
                S[F] = o
            }
        }
        return [N, [I, h], S, c, l]
    }

    function lbe(e, t, n, r, a) {
        for (var i = L$(r), o = t[0], s = a.length, u = [], c = 1, l = -1, h = 0; h < s; ++h) {
            var p = a[h];
            if (-1 === p) {
                if (-1 !== l) throw new Error(qie(l, h));
                l = h, u.push(1)
            } else {
                if (p < 0) throw new Error(Kie(h, p));
                c *= p, u.push(p)
            }
        }
        if (-1 !== l) {
            if (c <= 0) throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");
            var f = Math.trunc(i / c);
            if (c * f !== i) throw new Error(Yie(r, u));
            u[l] = f
        }
        if (L$(u) !== i) throw new Error(Jie(r, u));
        var d = r.length,
            v = [];
        if (d > 0) {
            v[d - 1] = 1;
            for (var m = d - 2; m >= 0; --m) v[m] = v[m + 1] * r[m + 1]
        }
        var g = [];
        if (s > 0) {
            g[s - 1] = 1;
            for (var y = s - 2; y >= 0; --y) g[y] = g[y + 1] * u[y + 1]
        }
        for (var b = K$(n, o * s), x = 0; x < o; ++x) {
            for (var k = 0, w = 0; w < d; ++w) k += e[x * d + w] * v[w];
            for (var I = 0; I < s; ++I) b[x * s + I] = Math.trunc(k / g[I]), k %= g[I]
        }
        return [b, [o, s], u]
    }

    function hbe(e, t, n, r, a) {
        var i = arguments.length > 5 && void 0 !== arguments[5] && arguments[5],
            o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0,
            s = r.length,
            u = [t[0], e.length / t[0]],
            c = u[1],
            l = s > 0 ? a[s - 1] + 1 : 0,
            h = l;
        if (h < 0) throw new Error("segment ids must be >= 0");
        var p = t.slice();
        p[0] = h;
        var f = p.reduce((function(e, t) {
                return e * t
            }), 1),
            d = K$(n, f);
        if (0 === s) return h > 0 && d.fill(o), [d, p];
        if (h <= 0) throw new Error("segment ids must be >= 0");
        for (var v = 0, m = 1, g = 0, y = a[v];;) {
            var b = 0;
            if (m < s) {
                if (y === (b = a[m])) {
                    ++m;
                    continue
                }
                if (y >= b) throw new Error("segment ids are not increasing")
            }
            if (y < 0 || y >= h) throw new Error($ie(y, h));
            y > g && d.fill(o, g * c, y * c);
            for (var x = v; x < m; ++x) {
                var k = r[x];
                if (k < 0 || k >= u[0]) throw new Error(eoe(x, r[x], u[0]));
                for (var w = 0; w < c; w++) d[y * c + w] += e[k * c + w]
            }
            if (i)
                for (var I = 0; I < c; I++) d[y * c + I] /= m - v;
            if (v = m, g = y + 1, y = b, ++m > s) break
        }
        return g < h && d.fill(o, g * c, h * c), [d, p]
    }
    var pbe = Dge((function(e) {
            return Math.sqrt(e)
        })),
        fbe = Mge(r3, (function(e) {
            return Math.sqrt(e)
        })),
        dbe = {
            kernelName: r3,
            backendName: "cpu",
            kernelFunc: fbe
        },
        vbe = pge((function(e, t) {
            var n = e - t;
            return n * n
        })),
        mbe = Ige(f3, vbe),
        gbe = {
            kernelName: f3,
            backendName: "cpu",
            kernelFunc: mbe
        },
        ybe = Dge((function(e, t) {
            var n = t.pattern,
                r = t.replaceGlobal,
                a = t.rewrite;
            return e.replace(new RegExp(n, r ? "g" : ""), a)
        })),
        bbe = Lge(v3, ybe),
        xbe = {
            kernelName: v3,
            backendName: "cpu",
            kernelFunc: bbe
        };

    function kbe(e, t, n, r) {
        for (var a = l8(e, t.dtype), i = 0; i < a.size; i++) {
            for (var o = a.indexToLoc(i), s = new Array(o.length), u = 0; u < s.length; u++) s[u] = o[u] * n[u] + r[u];
            a.set.apply(a, [t.get.apply(t, s)].concat(T(o)))
        }
        return a
    }
    var wbe = function() {
        function e(t, n, r, a, i, o) {
            l(this, e), this.separator = B4(t), this.nGramWidths = n, this.leftPad = B4(r), this.rightPad = B4(a), this.padWidth = i, this.preserveShort = o
        }
        return p(e, [{
            key: "getPadWidth",
            value: function(e) {
                return Math.min(this.padWidth < 0 ? e - 1 : this.padWidth, e - 1)
            }
        }, {
            key: "getNumNGrams",
            value: function(e, t) {
                var n = this.getPadWidth(t);
                return Math.max(0, e + 2 * n - t + 1)
            }
        }, {
            key: "createNGrams",
            value: function(e, t, n, r, a, i) {
                for (var o = this, s = function() {
                        var s = o.getPadWidth(i),
                            c = Math.max(0, s - u),
                            l = Math.max(0, s - (a - (u + 1))),
                            h = i - (c + l),
                            p = t + (c > 0 ? 0 : u - s),
                            f = 0;
                        f += c * o.leftPad.length;
                        for (var d = 0; d < h; ++d) f += e[p + d].length;
                        f += l * o.rightPad.length, f += (c + l + h - 1) * o.separator.length, n[r + u] = new Uint8Array(f);
                        for (var v = n[r + u], m = 0, g = function(e) {
                                return e.forEach((function(e) {
                                    return v[m++] = e
                                }))
                            }, y = 0; y < c; ++y) g(o.leftPad), g(o.separator);
                        for (var b = 0; b < h - 1; ++b) g(e[p + b]), g(o.separator);
                        if (h > 0) {
                            g(e[p + h - 1]);
                            for (var x = 0; x < l; ++x) g(o.separator), g(o.rightPad)
                        } else {
                            for (var k = 0; k < l - 1; ++k) g(o.rightPad), g(o.separator);
                            g(o.rightPad)
                        }
                    }, u = 0; u < a; ++u) s()
            }
        }, {
            key: "compute",
            value: function(e, t) {
                var n = this,
                    r = e.length,
                    a = t.length;
                if (a > 0) {
                    var i = t[0];
                    if (0 !== i) throw new Error("First split value must be 0, got ".concat(i));
                    for (var o = 1; o < a; ++o) {
                        var s = t[o] >= i;
                        if (!(s = s && t[o] <= r)) throw new Error("Invalid split value ".concat(t[o], ", must be in [").concat(i, ", ").concat(r, "]"));
                        i = t[o]
                    }
                    if (i !== r) throw new Error("Last split value must be data size. Expected ".concat(r, ", got ").concat(i))
                }
                var u = a - 1,
                    c = K$("int32", a);
                if (0 === r || 0 === a) {
                    for (var l = new Array(r), h = 0; h <= u; ++h) c[h] = 0;
                    return [l, c]
                }
                c[0] = 0;
                for (var p = function() {
                        var e = t[f] - t[f - 1],
                            r = 0;
                        n.nGramWidths.forEach((function(t) {
                            r += n.getNumNGrams(e, t)
                        })), n.preserveShort && e > 0 && 0 === r && (r = 1), c[f] = c[f - 1] + r
                    }, f = 1; f <= u; ++f) p();
                for (var d = new Array(c[u]), v = function(r) {
                        var a = t[r],
                            i = c[r];
                        if (n.nGramWidths.forEach((function(o) {
                                var s = t[r + 1] - t[r],
                                    u = n.getNumNGrams(s, o);
                                n.createNGrams(e, a, d, i, u, o), i += u
                            })), n.preserveShort && i === c[r]) {
                            var o = t[r + 1] - t[r];
                            if (0 === o) return "continue";
                            var s = o + 2 * n.padWidth;
                            n.createNGrams(e, a, d, i, 1, s)
                        }
                    }, m = 0; m < u; ++m) v(m);
                return [d, c]
            }
        }]), e
    }();

    function Ibe(e, t, n, r, a, i, o, s) {
        return new wbe(n, r, a, i, o, s).compute(e, t)
    }

    function Nbe(e, t, n, r) {
        if (e.length)
            if (0 !== t.length)
                if (1 !== t.length) {
                    for (var a = 0, i = 0; i < e.length + 1; i++)
                        if (i === e.length || -1 !== t.indexOf(e[i])) {
                            var o = e.subarray(a, i);
                            n && 0 === o.length || r.push(o), a = i + 1
                        }
                } else {
                    for (var s = t[0], u = e.indexOf(s); - 1 !== u;) {
                        var c = e.subarray(0, u);
                        n && 0 === c.length || r.push(c), u = (e = e.subarray(u + 1)).indexOf(s)
                    }
                    n && 0 === e.length || r.push(e)
                } else
            for (var l = 0; l < e.length; ++l) r.push(e.subarray(l, l + 1))
    }

    function Sbe(e, t, n) {
        for (var r = e.length, a = [], i = 0, o = 0, s = new Array(r), u = 0; u < r; ++u) {
            var c = a.length;
            Nbe(e[u], t, n, a);
            var l = a.length - c;
            s[u] = l, i += l, o = Math.max(o, l)
        }
        for (var h = K$("int32", 2 * i), p = new Array(i), f = [r, o], d = 0, v = 0; v < r; ++v)
            for (var m = 0; m < s[v]; ++m) h[2 * d] = v, h[2 * d + 1] = m, p[d] = a[d], ++d;
        return [h, p, f]
    }

    function Tbe(e, t) {
        for (var n = K$("int32", e.length), r = 0; r < e.length; ++r) n[r] = D4(e[r]).modulo(t).getLowBitsUnsigned();
        return n
    }
    var Ebe = pge((function(e, t) {
            return e - t
        })),
        Cbe = Nge((function(e, t, n, r) {
            return {
                real: e - n,
                imag: t - r
            }
        })),
        Abe = Ige(x3, Ebe, Cbe),
        Rbe = {
            kernelName: x3,
            backendName: "cpu",
            kernelFunc: Abe
        };

    function _be(e, t) {
        for (var n = new Array(e.rank), r = 0; r < n.length; r++) n[r] = e.shape[r] * t[r];
        for (var a = l8(n, e.dtype), i = 0; i < a.values.length; ++i) {
            for (var o = a.indexToLoc(i), s = new Array(e.rank), u = 0; u < s.length; u++) s[u] = o[u] % e.shape[u];
            var c = e.locToIndex(s);
            a.values[i] = e.values[c]
        }
        return a
    }
    var Obe = function(e, t) {
        var n = t.value - e.value;
        return 0 === n ? e.index - t.index : n
    };

    function Fbe(e, t) {
        for (var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e.length - 1; r > n;) {
            if (r - n > 600) {
                var a = r - n + 1,
                    i = t - n + 1,
                    o = Math.log(a),
                    s = .5 * Math.exp(2 * o / 3),
                    u = .5 * Math.sqrt(o * s * (a - s) / a) * Math.sign(i - a / 2),
                    c = Math.max(n, Math.floor(t - i * s / a + u)),
                    l = Math.min(r, Math.floor(t + (a - i) * s / a + u));
                Fbe(e, t, c, l)
            }
            var h = e[t],
                p = n,
                f = r;
            for (_$(e, n, t), Obe(e[r], h) > 0 && _$(e, n, r); p < f;) {
                for (_$(e, p, f), p++, f--; Obe(e[p], h) < 0;) p += 1;
                for (; Obe(e[f], h) > 0;) f -= 1
            }
            0 === Obe(e[n], h) ? _$(e, n, f) : _$(e, f += 1, r), f <= t && (n = f + 1), t <= f && (r = f - 1)
        }
    }

    function Dbe(e, t, n, r, a) {
        for (var i = t[t.length - 1], o = e.length / i, s = i, u = q$(n, o * r), c = q$("int32", o * r), l = function() {
                var t = h * s,
                    n = e.subarray(t, t + s),
                    i = new Array(n.length);
                n.forEach((function(e, t) {
                    return i[t] = {
                        value: e,
                        index: t
                    }
                })), r < i.length && (Fbe(i, r), i = i.slice(0, r)), a && i.sort(Obe);
                for (var o = h * r, l = u.subarray(o, o + r), p = c.subarray(o, o + r), f = 0; f < r; f++) l[f] = i[f].value, p[f] = i[f].index
            }, h = 0; h < o; h++) l();
        var p = t.slice();
        return p[p.length - 1] = r, [l8(p, n, u), l8(p, "int32", c)]
    }

    function Mbe(e, t, n, r) {
        for (var a = j$(t, n)[0], i = [1, n[0], 1], o = 0; o < a; o++) i[0] *= n[o];
        i[1] = n[a];
        for (var s = a + 1; s < n.length; s++) i[2] *= n[s];
        for (var u = new Map, c = new Int32Array(n[a]), l = new $4(i, r, e), h = [], p = 1 === i[0] && 1 === i[2], f = 0; f < n[a]; f++) {
            var d = void 0;
            if (p) d = e[f].toString();
            else {
                for (var v = [], m = 0; m < i[0]; m++)
                    for (var g = 0; g < i[2]; g++) v.push(l.get(m, f, g));
                d = v.join(",")
            }
            var y = u.get(d);
            if (null != y) c[f] = y;
            else {
                var b = u.size;
                u.set(d, b), c[f] = b, h.push(f)
            }
        }
        var x = i.slice();
        x[1] = u.size;
        var k = new $4(x, r);
        h.forEach((function(e, t) {
            for (var n = 0; n < i[0]; n++)
                for (var r = 0; r < i[2]; r++) k.set(l.get(n, e, r), n, t, r)
        }));
        var w = n.slice();
        return w[a] = x[1], {
            outputValues: k.values,
            outputShape: w,
            indices: c
        }
    }
    var Lbe = {
            __proto__: null,
            addImpl: Sge,
            bincountImpl: Age,
            bincountReduceImpl: Rge,
            bitwiseAndImpl: _ge,
            castImpl: xge,
            ceilImpl: zge,
            concatImpl: Wge,
            equalImpl: Uge,
            expImpl: jge,
            expm1Impl: Kge,
            floorDivImpl: $ge,
            floorImpl: Jge,
            gatherNdImpl: nye,
            gatherV2Impl: rye,
            greaterEqualImpl: sye,
            greaterImpl: aye,
            lessEqualImpl: fye,
            lessImpl: lye,
            linSpaceImpl: mye,
            logImpl: gye,
            maxImpl: xye,
            maximumImpl: kye,
            minimumImpl: Nye,
            multiplyImpl: Eye,
            negImpl: _ye,
            notEqualImpl: Fye,
            prodImpl: Bye,
            raggedGatherImpl: jye,
            raggedRangeImpl: qye,
            raggedTensorToTensorImpl: Zye,
            rangeImpl: Qye,
            rsqrtImpl: $ye,
            scatterImpl: nbe,
            sigmoidImpl: rbe,
            simpleAbsImpl: lge,
            sliceImpl: obe,
            sparseFillEmptyRowsImpl: cbe,
            sparseReshapeImpl: lbe,
            sparseSegmentReductionImpl: hbe,
            sqrtImpl: pbe,
            squaredDifferenceImpl: vbe,
            staticRegexReplaceImpl: ybe,
            stridedSliceImpl: kbe,
            stringNGramsImpl: Ibe,
            stringSplitImpl: Sbe,
            stringToHashBucketFastImpl: Tbe,
            subImpl: Ebe,
            tileImpl: _be,
            topKImpl: Dbe,
            transposeImpl: Lye,
            uniqueImpl: Mbe
        },
        zbe = "4.22.0";
    $5("cpu", (function() {
        return new cge
    }), 1);
    var Pbe = Mge(I1, (function(e) {
            return e >= 0 ? e : Math.exp(e) - 1
        })),
        Bbe = {
            kernelName: I1,
            backendName: "cpu",
            kernelFunc: Pbe
        };

    function Wbe(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs,
            a = t.x,
            i = r.alpha;
        sge([a], "leakyRelu");
        for (var o = L$(a.shape), s = n.data.get(a.dataId).values, u = q$("float32", o), c = 0; c < s.length; c++) u[c] = s[c] < 0 ? i * s[c] : s[c];
        return n.makeTensorInfo(a.shape, "float32", u)
    }
    var Ube = {
            kernelName: q1,
            backendName: "cpu",
            kernelFunc: Wbe
        },
        Vbe = pge((function(e, t) {
            return e < 0 ? t * e : e
        }));

    function Gbe(e) {
        var t = e.inputs,
            n = e.backend,
            r = t.x,
            a = t.alpha;
        sge([r, a], "prelu");
        var i = n.data.get(r.dataId).values,
            o = n.data.get(a.dataId).values,
            s = S(Vbe(r.shape, a.shape, i, o, "float32"), 2),
            u = s[0],
            c = s[1];
        return n.makeTensorInfo(c, "float32", u)
    }
    var jbe = {
            kernelName: C2,
            backendName: "cpu",
            kernelFunc: Gbe
        },
        Hbe = Mge(L2, (function(e) {
            return Math.max(0, e)
        })),
        qbe = {
            kernelName: L2,
            backendName: "cpu",
            kernelFunc: Hbe
        },
        Kbe = Mge(V2, (function(e) {
            return Math.min(Math.max(0, e), 6)
        })),
        Xbe = {
            kernelName: V2,
            backendName: "cpu",
            kernelFunc: Kbe
        };

    function Ybe(e, t, n, r, a) {
        if ("linear" === n) return mge({
            inputs: {
                x: t
            },
            backend: e
        });
        if ("relu" === n) return Hbe({
            inputs: {
                x: t
            },
            backend: e
        });
        if ("elu" === n) return Pbe({
            inputs: {
                x: t
            },
            backend: e
        });
        if ("relu6" === n) return Kbe({
            inputs: {
                x: t
            },
            backend: e
        });
        if ("prelu" === n) return Gbe({
            inputs: {
                x: t,
                alpha: r
            },
            backend: e
        });
        if ("leakyrelu" === n) return Wbe({
            inputs: {
                x: t
            },
            backend: e,
            attrs: {
                alpha: a
            }
        });
        if ("sigmoid" === n) return abe({
            inputs: {
                x: t
            },
            backend: e
        });
        throw new Error("Activation ".concat(n, " has not been implemented for the CPU backend."))
    }

    function Jbe(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs,
            a = t.x,
            i = r.shape,
            o = L$(a.shape),
            s = G$(i, o),
            u = L$(s);
        F$(o === u, (function() {
            return "The new shape (".concat(s, ") has ").concat(u, " elements and the old ") + "shape (".concat(a.shape, ") has ").concat(o, " elements. The new shape and old ") + "shape must have the same number of elements."
        })), n.incRef(a.dataId);
        var c = n.data.get(a.dataId);
        if (null != c.complexTensorInfos) {
            var l = c.complexTensorInfos.real,
                h = c.complexTensorInfos.imag;
            l.shape = s, h.shape = s
        }
        return {
            dataId: a.dataId,
            shape: s,
            dtype: a.dtype
        }
    }
    var Zbe = {
        kernelName: z2,
        backendName: "cpu",
        kernelFunc: Jbe
    };

    function Qbe(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs,
            a = t.a,
            i = t.b,
            o = r.transposeA,
            s = r.transposeB;
        sge([a, i], "matMul");
        var u = a.shape.length,
            c = i.shape.length,
            l = o ? a.shape[u - 2] : a.shape[u - 1],
            h = s ? i.shape[c - 1] : i.shape[c - 2],
            p = o ? a.shape[u - 1] : a.shape[u - 2],
            f = s ? i.shape[c - 2] : i.shape[c - 1],
            d = a.shape.slice(0, -2),
            v = i.shape.slice(0, -2),
            m = L$(d),
            g = L$(v),
            y = z7(a.shape.slice(0, -2), i.shape.slice(0, -2)).concat([p, f]);
        F$(l === h, (function() {
            return "Error in matMul: inner shapes (".concat(l, ") and (") + "".concat(h, ") of Tensors with shapes ").concat(a.shape, " and ") + "".concat(i.shape, " and transposeA=").concat(o) + " and transposeB=".concat(s, " must match.")
        }));
        for (var b = s ? [g, f, h] : [g, h, f], x = Jbe({
                inputs: {
                    x: a
                },
                backend: n,
                attrs: {
                    shape: o ? [m, l, p] : [m, p, l]
                }
            }), k = Jbe({
                inputs: {
                    x: i
                },
                backend: n,
                attrs: {
                    shape: b
                }
            }), w = o ? x.shape[1] : x.shape[2], I = o ? x.shape[2] : x.shape[1], N = s ? k.shape[1] : k.shape[2], T = Math.max(m, g), E = n.data.get(x.dataId).values, C = n.data.get(k.dataId).values, A = i0(x.shape), R = i0(k.shape), _ = S(o ? [A[0], 1, A[1]] : [A[0], A[1], 1], 3), O = _[0], F = _[1], D = _[2], M = S(s ? [1, R[1], R[0]] : [R[1], 1, R[0]], 3), L = M[0], z = M[1], P = M[2], B = I * N, W = l8([T, I, N], x.dtype), U = W.values, V = n.blockSize, G = 0; G < T; G++)
            for (var j = G % m, H = G % g, q = 0; q < I; q += V)
                for (var K = Math.min(q + V, I), X = 0; X < N; X += V)
                    for (var Y = Math.min(X + V, N), J = 0; J < w; J += V)
                        for (var Z = Math.min(J + V, w), Q = q; Q < K; Q++)
                            for (var $ = X; $ < Y; $++) {
                                for (var ee = 0, te = J; te < Z; te++) {
                                    ee += E[j * O + Q * F + te * D] * C[te * L + $ * z + H * P]
                                }
                                U[G * B + (Q * N + $)] += ee
                            }
        return n.disposeIntermediateTensorInfo(x), n.disposeIntermediateTensorInfo(k), n.makeTensorInfo(y, W.dtype, W.values)
    }
    var $be = {
        kernelName: V0,
        backendName: "cpu",
        kernelFunc: Qbe
    };
    var exe = {
            kernelName: D3,
            backendName: "cpu",
            kernelFunc: function(e) {
                var t, n, r, a = e.inputs,
                    i = e.backend,
                    o = e.attrs,
                    s = a.a,
                    u = a.b,
                    c = a.bias,
                    l = a.preluActivationWeights,
                    h = o.transposeA,
                    p = o.transposeB,
                    f = o.activation,
                    d = o.leakyreluAlpha,
                    v = [];
                t = Qbe({
                    inputs: {
                        a: s,
                        b: u
                    },
                    attrs: {
                        transposeA: h,
                        transposeB: p
                    },
                    backend: i
                }), c && (n = Ege({
                    inputs: {
                        a: t,
                        b: c
                    },
                    backend: i
                }), v.push(t), t = n), f && (r = Ybe(i, t, f, l, d), v.push(t), t = r);
                for (var m = 0, g = v; m < g.length; m++) {
                    var y = g[m];
                    i.disposeIntermediateTensorInfo(y)
                }
                return t
            }
        },
        txe = Mge(S0, (function(e) {
            return Math.acos(e)
        })),
        nxe = {
            kernelName: S0,
            backendName: "cpu",
            kernelFunc: txe
        },
        rxe = Mge(T0, (function(e) {
            return Math.acosh(e)
        })),
        axe = {
            kernelName: T0,
            backendName: "cpu",
            kernelFunc: rxe
        };
    var ixe = {
        kernelName: C0,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = t;
            sge(t, "addN");
            for (var a = r.map((function(e) {
                    return n.data.get(e.dataId).values
                })), i = l8(r[0].shape, r[0].dtype), o = i.values, s = 0; s < r.length; s++)
                for (var u = a[s], c = 0; c < o.length; c++) o[c] += u[c];
            return n.makeTensorInfo(i.shape, i.dtype, i.values)
        }
    };
    var oxe = {
        kernelName: A0,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = r.axis,
                o = r.keepDims;
            sge(a, "all");
            var s = j$(i, a.shape),
                u = s,
                c = $7(u, a.shape.length),
                l = a;
            null != c && (l = zye({
                inputs: {
                    x: a
                },
                backend: n,
                attrs: {
                    perm: c
                }
            }), u = t9(u.length, a.shape.length)), Q7("all", u, l.shape.length);
            for (var h = S(J7(l.shape, u), 2), p = h[0], f = L$(h[1]), d = l0(L$(p), l.dtype), v = n.data.get(l.dataId).values, m = 0; m < d.length; ++m) {
                for (var g = m * f, y = v[g], b = 0; b < f; ++b) {
                    var x = v[g + b];
                    y = y && x
                }
                d[m] = y
            }
            null != c && n.disposeIntermediateTensorInfo(l);
            var k = n.makeTensorInfo(p, l.dtype, d);
            if (o) {
                var w = Jbe({
                    inputs: {
                        x: k
                    },
                    backend: n,
                    attrs: {
                        shape: Z7(p, s)
                    }
                });
                return n.disposeIntermediateTensorInfo(k), w
            }
            return k
        }
    };
    var sxe = {
        kernelName: R0,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = r.axis,
                o = r.keepDims;
            sge(a, "any");
            var s = j$(i, a.shape),
                u = s,
                c = $7(u, a.shape.length),
                l = a;
            null != c && (l = zye({
                inputs: {
                    x: a
                },
                backend: n,
                attrs: {
                    perm: c
                }
            }), u = t9(u.length, a.shape.length)), Q7("any", u, l.shape.length);
            for (var h = S(J7(l.shape, u), 2), p = h[0], f = L$(h[1]), d = l0(L$(p), l.dtype), v = n.data.get(l.dataId).values, m = 0; m < d.length; ++m) {
                for (var g = m * f, y = v[g], b = 0; b < f; ++b) {
                    var x = v[g + b];
                    y = y || x
                }
                d[m] = y
            }
            null != c && n.disposeIntermediateTensorInfo(l);
            var k = n.makeTensorInfo(p, l.dtype, d);
            if (o) {
                var w = Jbe({
                    inputs: {
                        x: k
                    },
                    backend: n,
                    attrs: {
                        shape: Z7(p, s)
                    }
                });
                return n.disposeIntermediateTensorInfo(k), w
            }
            return k
        }
    };
    var uxe = {
        kernelName: _0,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = r.axis;
            sge(a, "argMax");
            var o = j$(i, a.shape),
                s = $7(o, a.shape.length),
                u = a,
                c = [];
            null != s && (u = zye({
                inputs: {
                    x: a
                },
                backend: n,
                attrs: {
                    perm: s
                }
            }), c.push(u), o = t9(o.length, u.shape.length)), Q7("argMax", o = [o[0]], u.shape.length);
            for (var l = S(J7(u.shape, o), 2), h = l[0], p = l[1], f = l0(L$(h), "int32"), d = L$(p), v = n.data.get(u.dataId).values, m = 0; m < f.length; ++m) {
                for (var g = m * d, y = v[g], b = 0, x = 0; x < d; ++x) {
                    var k = v[g + x];
                    k > y && (y = k, b = x)
                }
                f[m] = b
            }
            return c.forEach((function(e) {
                return n.disposeIntermediateTensorInfo(e)
            })), n.makeTensorInfo(h, "int32", f)
        }
    };
    var cxe = {
            kernelName: O0,
            backendName: "cpu",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.axis;
                sge(a, "argMin");
                var o = j$(i, a.shape),
                    s = $7(o, a.shape.length),
                    u = a,
                    c = [];
                null != s && (u = zye({
                    inputs: {
                        x: a
                    },
                    backend: n,
                    attrs: {
                        perm: s
                    }
                }), c.push(u), o = t9(o.length, u.shape.length)), Q7("argMin", o = [o[0]], u.shape.length);
                for (var l = S(J7(u.shape, o), 2), h = l[0], p = l[1], f = l0(L$(h), "int32"), d = L$(p), v = n.data.get(u.dataId).values, m = 0; m < f.length; ++m) {
                    for (var g = m * d, y = v[g], b = 0, x = 0; x < d; ++x) {
                        var k = v[g + x];
                        k < y && (y = k, b = x)
                    }
                    f[m] = b
                }
                return c.forEach((function(e) {
                    return n.disposeIntermediateTensorInfo(e)
                })), n.makeTensorInfo(h, "int32", f)
            }
        },
        lxe = Mge(F0, (function(e) {
            return Math.asin(e)
        })),
        hxe = {
            kernelName: F0,
            backendName: "cpu",
            kernelFunc: lxe
        },
        pxe = Mge(D0, (function(e) {
            return Math.asinh(e)
        })),
        fxe = {
            kernelName: D0,
            backendName: "cpu",
            kernelFunc: pxe
        },
        dxe = Mge(M0, (function(e) {
            return Math.atan(e)
        })),
        vxe = {
            kernelName: M0,
            backendName: "cpu",
            kernelFunc: dxe
        },
        mxe = pge((function(e, t) {
            return Math.atan2(e, t)
        })),
        gxe = Ige(z0, mxe),
        yxe = {
            kernelName: z0,
            backendName: "cpu",
            kernelFunc: gxe
        },
        bxe = Mge(L0, (function(e) {
            return Math.atanh(e)
        })),
        xxe = {
            kernelName: L0,
            backendName: "cpu",
            kernelFunc: bxe
        };

    function kxe(e, t, n, r, a, i) {
        for (var o = a.strideHeight, s = a.strideWidth, u = a.dilationHeight, c = a.dilationWidth, l = a.effectiveFilterHeight, h = a.effectiveFilterWidth, p = a.padInfo.top, f = a.padInfo.left, d = "max" === i ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, v = l8(a.outShape, n), m = v.values, g = a.outShape[1] * a.outShape[2] * a.outShape[3], y = a.outShape[2] * a.outShape[3], b = a.outShape[3], x = 0; x < a.batchSize; ++x)
            for (var k = x * g, w = x * r[0], I = 0; I < a.inChannels; ++I)
                for (var N = 0; N < a.outHeight; ++N)
                    for (var S = N * o - p, T = Math.max(0, S), E = Math.min(a.inHeight, l + S), C = k + N * y, A = 0; A < a.outWidth; ++A) {
                        for (var R = A * s - f, _ = Math.max(0, R), O = Math.min(a.inWidth, h + R), F = d, D = 0, M = 0, L = T; L < E; L += u) {
                            for (var z = w + L * r[1], P = _; P < O; P += c) {
                                var B = e[z + P * r[2] + I];
                                "max" === i && B > F ? F = B : "avg" === i && (D += B, M++)
                            }
                            if (isNaN(F)) break
                        }
                        m[C + A * b + I] = "avg" === i ? D / M : F
                    }
        return v
    }

    function wxe(e, t, n, r) {
        for (var a = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], i = arguments.length > 5 && void 0 !== arguments[5] && arguments[5], o = l8(r.outShape, "int32"), s = r.strideHeight, u = r.strideWidth, c = r.dilationHeight, l = r.dilationWidth, h = r.effectiveFilterHeight, p = r.effectiveFilterWidth, f = r.padInfo.top, d = r.padInfo.left, v = l8(t, n, e), m = 0; m < r.batchSize; ++m)
            for (var g = 0; g < r.inChannels; ++g)
                for (var y = 0; y < r.outHeight; ++y) {
                    for (var b = y * s - f, x = b; x < 0;) x += c;
                    for (var k = Math.min(r.inHeight, h + b), w = 0; w < r.outWidth; ++w) {
                        for (var I = w * u - d, N = I; N < 0;) N += l;
                        for (var S = Math.min(r.inWidth, p + I), T = Number.NEGATIVE_INFINITY, E = -1, C = x; C < k; C += c)
                            for (var A = C - b, R = N; R < S; R += l) {
                                var _ = R - I,
                                    O = v.get(m, C, R, g);
                                O > T && (T = O, E = a ? i ? ((m * r.inHeight + C) * r.inWidth + R) * r.inChannels + g : (C * r.inWidth + R) * r.inChannels + g : A * p + _)
                            }
                        o.set(E, m, y, w, g)
                    }
                }
        return o
    }

    function Ixe(e, t, n, r, a, i) {
        for (var o = a.strideDepth, s = a.strideHeight, u = a.strideWidth, c = a.dilationDepth, l = a.dilationHeight, h = a.dilationWidth, p = a.effectiveFilterDepth, f = a.effectiveFilterHeight, d = a.effectiveFilterWidth, v = a.padInfo.front, m = a.padInfo.top, g = a.padInfo.left, y = "max" === i ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, b = l8(a.outShape, n), x = b.values, k = a.outShape[1] * a.outShape[2] * a.outShape[3] * a.outShape[4], w = a.outShape[2] * a.outShape[3] * a.outShape[4], I = a.outShape[3] * a.outShape[4], N = a.outShape[4], S = 0; S < a.batchSize; ++S)
            for (var T = S * k, E = S * r[0], C = 0; C < a.inChannels; ++C)
                for (var A = 0; A < a.outDepth; ++A) {
                    for (var R = A * o - v, _ = R; _ < 0;) _ += c;
                    for (var O = Math.min(a.inDepth, p + R), F = T + A * w, D = 0; D < a.outHeight; ++D) {
                        for (var M = D * s - m, L = M; L < 0;) L += l;
                        for (var z = Math.min(a.inHeight, f + M), P = F + D * I, B = 0; B < a.outWidth; ++B) {
                            for (var W = B * u - g, U = W; U < 0;) U += h;
                            for (var V = Math.min(a.inWidth, d + W), G = P + B * N, j = y, H = 0, q = 0, K = _; K < O; K += c) {
                                for (var X = E + K * r[1], Y = L; Y < z; Y += l) {
                                    for (var J = X + Y * r[2], Z = U; Z < V; Z += h) {
                                        var Q = e[J + Z * r[3] + C];
                                        if ("max" === i && Q > j ? j = Q : "avg" === i && (H += Q, q++), isNaN(j)) break
                                    }
                                    if (isNaN(j)) break
                                }
                                if (isNaN(j)) break
                            }
                            x[G + C] = "avg" === i ? H / Math.max(q, 1) : j
                        }
                    }
                }
        return b
    }
    var Nxe = {
        kernelName: P0,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x;
            sge(a, "avgPool");
            var i = r.filterSize,
                o = r.strides,
                s = r.pad,
                u = r.dimRoundingMode;
            F$(j8(o, 1), (function() {
                return "Error in avgPool: Either strides or dilations must be 1. " + "Got strides ".concat(o, " and dilations '").concat(1, "'")
            }));
            var c, l = O8(a.shape, i, o, 1, s, u);
            if (1 === l.filterWidth && 1 === l.filterHeight && P$(l.inShape, l.outShape)) c = mge({
                inputs: {
                    x: a
                },
                backend: n
            });
            else {
                var h = n.data.get(a.dataId).values,
                    p = i0(a.shape),
                    f = kxe(h, a.shape, a.dtype, p, l, "avg");
                c = n.makeTensorInfo(l.outShape, a.dtype, f.values)
            }
            return c
        }
    };
    var Sxe = {
        kernelName: W0,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = r.filterSize,
                o = r.strides,
                s = r.pad,
                u = r.dimRoundingMode,
                c = r.dataFormat;
            sge(a, "avgPool3d");
            var l = F8(a.shape, i, o, 1, s, u, c),
                h = Ixe(n.data.get(a.dataId).values, a.shape, a.dtype, i0(a.shape), l, "avg");
            return n.makeTensorInfo(h.shape, "float32", h.values)
        }
    };
    var Txe = {
        kernelName: U0,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.dy,
                i = t.input,
                o = r.filterSize,
                s = r.strides,
                u = r.pad,
                c = r.dimRoundingMode;
            sge([a, i], "avgPool3DGrad");
            for (var l = F8(i.shape, o, s, 1, u, c), h = l.strideDepth, p = l.strideHeight, f = l.strideWidth, d = l.filterDepth, v = l.filterHeight, m = l.filterWidth, g = l.dilationDepth, y = l.dilationHeight, b = l.dilationWidth, x = l.effectiveFilterDepth, k = l.effectiveFilterHeight, w = l.effectiveFilterWidth, I = x - 1 - l.padInfo.front, N = w - 1 - l.padInfo.left, S = k - 1 - l.padInfo.top, T = l8(i.shape, "float32"), E = 1 / (d * v * m), C = n.bufferSync(a), A = 0; A < l.batchSize; ++A)
                for (var R = 0; R < l.inChannels; ++R)
                    for (var _ = 0; _ < l.inDepth; ++_)
                        for (var O = 0; O < l.inHeight; ++O)
                            for (var F = 0; F < l.inWidth; ++F) {
                                for (var D = _ - I, M = O - S, L = F - N, z = 0, P = 0; P < x; P += g) {
                                    var B = (D + P) / h;
                                    if (!(B < 0 || B >= l.outDepth || Math.floor(B) !== B))
                                        for (var W = 0; W < k; W += y) {
                                            var U = (M + W) / p;
                                            if (!(U < 0 || U >= l.outHeight || Math.floor(U) !== U))
                                                for (var V = 0; V < w; V += b) {
                                                    var G = (L + V) / f;
                                                    if (!(G < 0 || G >= l.outWidth || Math.floor(G) !== G)) z += C.get(A, B, U, G, R)
                                                }
                                        }
                                }
                                T.set(z * E, A, _, O, F, R)
                            }
            return n.makeTensorInfo(T.shape, T.dtype, T.values)
        }
    };
    var Exe = {
        kernelName: B0,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.dy,
                i = t.input,
                o = i;
            sge([a, i], "avgPoolGrad");
            for (var s = r.filterSize, u = r.strides, c = r.pad, l = O8(o.shape, s, u, 1, c), h = l.strideHeight, p = l.strideWidth, f = l.filterHeight, d = l.filterWidth, v = l.dilationHeight, m = l.dilationWidth, g = l.effectiveFilterHeight, y = l.effectiveFilterWidth, b = y - 1 - l.padInfo.left, x = g - 1 - l.padInfo.top, k = l8(o.shape, "float32"), w = 1 / (f * d), I = n.data.get(a.dataId).values, N = l8(a.shape, "float32", I), S = 0; S < l.batchSize; ++S)
                for (var T = 0; T < l.inChannels; ++T)
                    for (var E = 0; E < l.inHeight; ++E)
                        for (var C = 0; C < l.inWidth; ++C) {
                            for (var A = E - x, R = C - b, _ = 0, O = 0; O < g; O += v) {
                                var F = (A + O) / h;
                                if (!(F < 0 || F >= l.outHeight || Math.floor(F) !== F))
                                    for (var D = 0; D < y; D += m) {
                                        var M = (R + D) / p;
                                        if (!(M < 0 || M >= l.outWidth || Math.floor(M) !== M)) _ += N.get(S, F, M, T)
                                    }
                            }
                            k.set(_ * w, S, E, C, T)
                        }
            return n.makeTensorInfo(k.shape, k.dtype, k.values)
        }
    };
    var Cxe = {
        kernelName: M1,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = t.scale,
                o = t.offset,
                s = t.mean,
                u = t.variance;
            F$(s.shape.length === u.shape.length, (function() {
                return "Batch normalization gradient requires mean and variance to have equal ranks."
            })), F$(null == o || s.shape.length === o.shape.length, (function() {
                return "Batch normalization gradient requires mean and offset to have equal ranks."
            })), F$(null == i || s.shape.length === i.shape.length, (function() {
                return "Batch normalization gradient requires mean and scale to have equal ranks."
            })), sge([a, s, u, i, o], "batchNorm");
            var c = r.varianceEpsilon;
            null == c && (c = .001);
            for (var l = n.data.get(a.dataId).values, h = n.data.get(s.dataId).values, p = n.data.get(u.dataId).values, f = i ? n.data.get(i.dataId).values : new Float32Array([1]), d = o ? n.data.get(o.dataId).values : new Float32Array([0]), v = new Float32Array(l.length), m = d.length, g = f.length, y = p.length, b = h.length, x = 0, k = 0, w = 0, I = 0, N = 0; N < l.length; ++N) v[N] = d[x++] + (l[N] - h[k++]) * f[w++] / Math.sqrt(p[I++] + c), x >= m && (x = 0), k >= b && (k = 0), w >= g && (w = 0), I >= y && (I = 0);
            return n.makeTensorInfo(a.shape, a.dtype, v)
        }
    };
    var Axe = {
        kernelName: G0,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = r.blockShape,
                o = r.crops;
            sge([a], "batchToSpaceND");
            var s = i.reduce((function(e, t) {
                    return e * t
                })),
                u = fie(a.shape, i, s),
                c = die(u.length, i.length),
                l = vie(a.shape, i, s),
                h = mie(o, i.length),
                p = gie(l, o, i.length),
                f = Jbe({
                    inputs: {
                        x: a
                    },
                    backend: n,
                    attrs: {
                        shape: u
                    }
                }),
                d = zye({
                    inputs: {
                        x: f
                    },
                    backend: n,
                    attrs: {
                        perm: c
                    }
                }),
                v = Jbe({
                    inputs: {
                        x: d
                    },
                    backend: n,
                    attrs: {
                        shape: l
                    }
                }),
                m = sbe({
                    inputs: {
                        x: v
                    },
                    backend: n,
                    attrs: {
                        begin: h,
                        size: p
                    }
                });
            return n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(v), m
        }
    };
    var Rxe = {
        kernelName: j0,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = t.weights,
                o = r.size,
                s = Age(n.data.get(a.dataId).values, n.data.get(i.dataId).values, i.dtype, i.shape, o);
            return n.makeTensorInfo([o], i.dtype, s)
        }
    };
    var _xe = {
            kernelName: K0,
            backendName: "cpu",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = t.s0,
                    a = t.s1,
                    i = n.data.get(r.dataId).values,
                    o = n.data.get(a.dataId).values,
                    s = z7(Array.from(i), Array.from(o));
                return n.makeTensorInfo([s.length], "int32", Int32Array.from(s))
            }
        },
        Oxe = Mge(J0, (function(e, t) {
            var n = t;
            return e > n.clipValueMax ? n.clipValueMax : e < n.clipValueMin ? n.clipValueMin : e
        })),
        Fxe = {
            kernelName: J0,
            backendName: "cpu",
            kernelFunc: Oxe
        },
        Dxe = {
            kernelName: Q0,
            backendName: "cpu",
            kernelFunc: function(e) {
                for (var t = e.inputs.x, n = e.backend, r = new Float32Array(L$(t.shape)), a = n.data.get(t.dataId), i = a.complexTensorInfos.real, o = a.complexTensorInfos.imag, s = n.data.get(i.dataId).values, u = n.data.get(o.dataId).values, c = 0; c < s.length; c++) {
                    var l = s[c],
                        h = u[c];
                    r[c] = Math.hypot(l, h)
                }
                return n.makeOutput(r, t.shape, "float32")
            }
        };

    function Mxe(e) {
        var t = e.inputs,
            n = e.backend,
            r = t.input,
            a = n.data.get(r.dataId).complexTensorInfos.imag,
            i = n.data.get(a.dataId).values;
        return n.makeTensorInfo(a.shape, a.dtype, i)
    }
    var Lxe = {
        kernelName: V1,
        backendName: "cpu",
        kernelFunc: Mxe
    };

    function zxe(e) {
        var t = e.inputs,
            n = e.backend,
            r = j$(e.attrs.axis, t[0].shape)[0];
        iie(t.map((function(e) {
            return e.shape
        })), r);
        var a = oie(t.map((function(e) {
            return e.shape
        })), r);
        if (0 === L$(a)) return n.makeTensorInfo(a, t[0].dtype, []);
        var i = t.filter((function(e) {
            return L$(e.shape) > 0
        }));
        if (1 === i.length) return mge({
            inputs: {
                x: i[0]
            },
            backend: n
        });
        if ("complex64" === i[0].dtype) {
            var o = i.map((function(e) {
                    return yge({
                        inputs: {
                            input: e
                        },
                        backend: n
                    })
                })),
                s = i.map((function(e) {
                    return Mxe({
                        inputs: {
                            input: e
                        },
                        backend: n
                    })
                })),
                u = zxe({
                    inputs: o,
                    backend: n,
                    attrs: {
                        axis: r
                    }
                }),
                c = zxe({
                    inputs: s,
                    backend: n,
                    attrs: {
                        axis: r
                    }
                }),
                l = fge({
                    inputs: {
                        real: u,
                        imag: c
                    },
                    backend: n
                });
            return o.forEach((function(e) {
                return n.disposeIntermediateTensorInfo(e)
            })), s.forEach((function(e) {
                return n.disposeIntermediateTensorInfo(e)
            })), n.disposeIntermediateTensorInfo(u), n.disposeIntermediateTensorInfo(c), l
        }
        var h = i.map((function(e) {
                var t = L$(e.shape.slice(r));
                return Jbe({
                    inputs: {
                        x: e
                    },
                    backend: n,
                    attrs: {
                        shape: [-1, t]
                    }
                })
            })),
            p = h.map((function(e) {
                return {
                    vals: n.data.get(e.dataId).values,
                    shape: e.shape
                }
            }));
        a = oie(h.map((function(e) {
            return e.shape
        })), 1);
        var f = 1 === h[0].shape[0],
            d = Wge(p, a, t[0].dtype, f),
            v = oie(i.map((function(e) {
                return e.shape
            })), r),
            m = n.makeTensorInfo(v, t[0].dtype, d);
        return h.forEach((function(e) {
            return n.disposeIntermediateTensorInfo(e)
        })), m
    }
    var Pxe = {
        kernelName: $0,
        backendName: "cpu",
        kernelFunc: zxe
    };

    function Bxe(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs,
            a = t.x,
            i = t.filter,
            o = r.strides,
            s = r.pad,
            u = r.dataFormat,
            c = r.dilations,
            l = r.dimRoundingMode;
        sge([a, i], "conv2d");
        for (var h = q8(u), p = D8(a.shape, i.shape, o, c, s, l, !1, h), f = p.filterHeight, d = p.filterWidth, v = p.dilationHeight, m = p.dilationWidth, g = p.padInfo.left, y = p.padInfo.top, b = "channelsLast" === p.dataFormat, x = new $4(p.outShape, a.dtype), k = i0(a.shape), w = i0(i.shape), I = k[0], N = b ? k[1] : k[2], S = b ? k[2] : 1, T = b ? 1 : k[1], E = x.strides[0], C = b ? x.strides[1] : x.strides[2], A = b ? x.strides[2] : 1, R = b ? 1 : x.strides[1], _ = n.data.get(a.dataId).values, O = n.data.get(i.dataId).values, F = x.values, D = 0; D < p.batchSize; ++D)
            for (var M = D * I, L = D * E, z = 0; z < p.outHeight; ++z)
                for (var P = L + z * C, B = z * p.strideHeight - y, W = 0; W < f; ++W) {
                    var U = B + W * v;
                    if (!(U < 0 || U >= p.inHeight))
                        for (var V = W * w[0], G = M + U * N, j = 0; j < p.outWidth; ++j)
                            for (var H = P + j * A, q = j * p.strideWidth - g, K = 0; K < d; ++K) {
                                var X = q + K * m;
                                if (!(X < 0 || X >= p.inWidth))
                                    for (var Y = G + X * S, J = V + K * w[1], Z = 0; Z < p.inChannels; ++Z) {
                                        for (var Q = _[Y + Z * T], $ = 0; $ < p.outChannels; ++$) F[H + $ * R] += Q * O[J + $];
                                        J += p.outChannels
                                    }
                            }
                }
        return n.makeTensorInfo(x.shape, x.dtype, F)
    }
    var Wxe = {
        kernelName: e1,
        backendName: "cpu",
        kernelFunc: Bxe
    };
    var Uxe = {
        kernelName: t1,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = t.dy,
                o = r.strides,
                s = r.pad,
                u = r.dataFormat,
                c = r.dimRoundingMode,
                l = r.filterShape;
            sge([a, i], "conv2dBackpropFilter");
            for (var h = q8(u), p = D8(a.shape, l, o, 1, s, c, !1, h), f = p.strideHeight, d = p.strideWidth, v = p.filterHeight, m = p.filterWidth, g = "channelsLast" === p.dataFormat, y = new $4(p.filterShape, "float32"), b = p.padInfo.left, x = p.padInfo.top, k = n.data.get(a.dataId).values, w = n.data.get(i.dataId).values, I = new $4(a.shape, a.dtype, k), N = new $4(i.shape, i.dtype, w), S = 0; S < v; ++S)
                for (var T = Math.max(0, Math.ceil((x - S) / f)), E = Math.min(p.outHeight, (p.inHeight + x - S) / f), C = 0; C < m; ++C)
                    for (var A = Math.max(0, Math.ceil((b - C) / d)), R = Math.min(p.outWidth, (p.inWidth + b - C) / d), _ = 0; _ < p.inChannels; ++_)
                        for (var O = 0; O < p.outChannels; ++O) {
                            for (var F = 0, D = 0; D < p.batchSize; ++D)
                                for (var M = T; M < E; ++M)
                                    for (var L = S + M * f - x, z = A; z < R; ++z) {
                                        var P = C + z * d - b;
                                        F += g ? I.get(D, L, P, _) * N.get(D, M, z, O) : I.get(D, _, L, P) * N.get(D, O, M, z)
                                    }
                            y.set(F, S, C, _, O)
                        }
            return n.makeTensorInfo(y.shape, y.dtype, y.values)
        }
    };
    var Vxe = {
        kernelName: n1,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.dy,
                i = t.filter,
                o = r.inputShape,
                s = r.strides,
                u = r.pad,
                c = r.dataFormat,
                l = r.dimRoundingMode;
            sge([a, i], "conv2dBackpropInput");
            var h = i0(i.shape),
                p = i0(a.shape),
                f = q8(c),
                d = D8(o, i.shape, s, 1, u, l, !1, f),
                v = new $4(d.inShape, "float32"),
                m = v.values,
                g = n.data.get(a.dataId).values,
                y = n.data.get(i.dataId).values,
                b = S(h, 3),
                x = b[0],
                k = b[1],
                w = b[2],
                I = d.batchSize,
                N = d.filterHeight,
                T = d.filterWidth,
                E = d.inChannels,
                C = d.inHeight,
                A = d.inWidth,
                R = d.outChannels,
                _ = d.outHeight,
                O = d.outWidth,
                F = d.strideHeight,
                D = d.strideWidth;
            f = d.dataFormat;
            for (var M = N - 1 - d.padInfo.top, L = T - 1 - d.padInfo.left, z = "channelsLast" === f, P = v.strides[0], B = z ? v.strides[1] : v.strides[2], W = z ? v.strides[2] : 1, U = z ? 1 : v.strides[1], V = p[0], G = z ? p[1] : p[2], j = z ? p[2] : 1, H = z ? 1 : p[1], q = 0; q < I; ++q)
                for (var K = 0; K < E; ++K)
                    for (var X = 0; X < C; ++X)
                        for (var Y = X - M, J = Math.max(0, Math.ceil(Y / F)), Z = Math.min(_, (N + Y) / F), Q = 0; Q < A; ++Q) {
                            for (var $ = Q - L, ee = Math.max(0, Math.ceil($ / D)), te = Math.min(O, (T + $) / D), ne = 0, re = J; re < Z; ++re)
                                for (var ae = re * F - Y, ie = ee; ie < te; ++ie)
                                    for (var oe = V * q + G * re + j * ie, se = x * (N - 1 - ae) + k * (T - 1 - (ie * D - $)) + w * K, ue = 0; ue < R; ++ue) {
                                        ne += g[oe + H * ue] * y[se + ue]
                                    }
                            m[P * q + B * X + W * Q + U * K] = ne
                        }
            return n.makeTensorInfo(v.shape, v.dtype, v.values)
        }
    };
    var Gxe = {
        kernelName: r1,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = t.filter,
                o = r.strides,
                s = r.pad,
                u = r.dilations;
            sge([a, i], "conv3d");
            for (var c = M8(a.shape, i.shape, o, u, s), l = c.filterDepth, h = c.filterHeight, p = c.filterWidth, f = c.dilationDepth, d = c.dilationHeight, v = c.dilationWidth, m = c.padInfo, g = m.front, y = m.left, b = m.top, x = new $4(c.outShape, a.dtype), k = n.data.get(a.dataId).values, w = n.data.get(i.dataId).values, I = x.values, N = i0(a.shape), S = i0(i.shape), T = 0; T < c.batchSize; ++T)
                for (var E = T * N[0], C = T * x.strides[0], A = 0; A < c.outDepth; ++A)
                    for (var R = C + A * x.strides[1], _ = A * c.strideDepth - g, O = 0; O < l; ++O) {
                        var F = _ + O * f;
                        if (!(F < 0 || F >= c.inDepth))
                            for (var D = O * S[0], M = E + F * N[1], L = 0; L < c.outHeight; ++L)
                                for (var z = R + L * x.strides[2], P = L * c.strideHeight - b, B = 0; B < h; ++B) {
                                    var W = P + B * d;
                                    if (!(W < 0 || W >= c.inHeight))
                                        for (var U = D + B * S[1], V = M + W * N[2], G = 0; G < c.outWidth; ++G)
                                            for (var j = z + G * c.outChannels, H = G * c.strideWidth - y, q = 0; q < p; ++q) {
                                                var K = H + q * v;
                                                if (!(K < 0 || K >= c.inWidth))
                                                    for (var X = U + q * S[2], Y = V + K * c.inChannels, J = X, Z = 0; Z < c.inChannels; ++Z) {
                                                        for (var Q = k[Y + Z], $ = 0; $ < c.outChannels; ++$) I[j + $] += Q * w[J + $];
                                                        J += c.outChannels
                                                    }
                                            }
                                }
                    }
            return n.makeTensorInfo(x.shape, x.dtype, x.values)
        }
    };
    var jxe = {
        kernelName: a1,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = t.dy,
                o = r.strides,
                s = r.pad,
                u = r.filterShape;
            sge([a, i], "conv3dBackpropFilterV2");
            for (var c = i0(a.shape), l = i0(i.shape), h = M8(a.shape, u, o, 1, s), p = h.strideDepth, f = h.strideHeight, d = h.strideWidth, v = h.filterDepth, m = h.filterHeight, g = h.filterWidth, y = new $4(h.filterShape, "float32"), b = y.values, x = S(y.strides, 4), k = x[0], w = x[1], I = x[2], N = x[3], T = n.data.get(i.dataId).values, E = S(l, 4), C = E[0], A = E[1], R = E[2], _ = E[3], O = n.data.get(a.dataId).values, F = S(c, 4), D = F[0], M = F[1], L = F[2], z = F[3], P = h.padInfo.front, B = h.padInfo.left, W = h.padInfo.top, U = 0; U < v; ++U)
                for (var V = Math.max(0, Math.ceil((P - U) / p)), G = Math.min(h.outDepth, (h.inDepth + P - U) / p), j = U * k, H = 0; H < m; ++H)
                    for (var q = Math.max(0, Math.ceil((W - H) / f)), K = Math.min(h.outHeight, (h.inHeight + W - H) / f), X = H * w + j, Y = 0; Y < g; ++Y)
                        for (var J = Math.max(0, Math.ceil((B - Y) / d)), Z = Math.min(h.outWidth, (h.inWidth + B - Y) / d), Q = Y * I + X, $ = 0; $ < h.inChannels; ++$)
                            for (var ee = $ * N + Q, te = 0; te < h.outChannels; ++te) {
                                for (var ne = 0, re = 0; re < h.batchSize; ++re)
                                    for (var ae = re * D, ie = re * C, oe = V; oe < G; ++oe)
                                        for (var se = (U + oe * p - P) * M + ae, ue = oe * A + ie, ce = q; ce < K; ++ce)
                                            for (var le = (H + ce * f - W) * L + se, he = ce * R + ue, pe = J; pe < Z; ++pe) {
                                                var fe = pe * _ + he;
                                                ne += O[(Y + pe * d - B) * z + le + $] * T[fe + te]
                                            }
                                b[ee + te] = ne
                            }
            return n.makeTensorInfo(y.shape, y.dtype, y.values)
        }
    };
    var Hxe = {
            kernelName: i1,
            backendName: "cpu",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.dy,
                    i = t.filter,
                    o = r.pad,
                    s = r.strides,
                    u = r.inputShape;
                sge([a], "conv3dBackpropInputV2");
                for (var c = i0(a.shape), l = i0(i.shape), h = M8(u, i.shape, s, 1, o), p = new $4(h.inShape, "float32"), f = p.values, d = S(p.strides, 4), v = d[0], m = d[1], g = d[2], y = d[3], b = n.data.get(a.dataId).values, x = S(c, 4), k = x[0], w = x[1], I = x[2], N = x[3], T = n.data.get(i.dataId).values, E = S(l, 4), C = E[0], A = E[1], R = E[2], _ = E[3], O = h.batchSize, F = h.filterDepth, D = h.filterHeight, M = h.filterWidth, L = h.inChannels, z = h.inDepth, P = h.inHeight, B = h.inWidth, W = h.outChannels, U = h.outDepth, V = h.outHeight, G = h.outWidth, j = h.strideDepth, H = h.strideHeight, q = h.strideWidth, K = F - 1 - h.padInfo.front, X = D - 1 - h.padInfo.top, Y = M - 1 - h.padInfo.left, J = 0; J < O; ++J)
                    for (var Z = 0; Z < L; ++Z)
                        for (var Q = 0; Q < z; ++Q)
                            for (var $ = Q - K, ee = Math.max(0, Math.ceil($ / j)), te = Math.min(U, (F + $) / j), ne = 0; ne < P; ++ne)
                                for (var re = ne - X, ae = Math.max(0, Math.ceil(re / H)), ie = Math.min(V, (D + re) / H), oe = 0; oe < B; ++oe) {
                                    for (var se = oe - Y, ue = Math.max(0, Math.ceil(se / q)), ce = Math.min(G, (M + se) / q), le = 0, he = ee; he < te; ++he)
                                        for (var pe = he * j - $, fe = ae; fe < ie; ++fe)
                                            for (var de = fe * H - re, ve = ue; ve < ce; ++ve)
                                                for (var me = k * J + w * he + I * fe + N * ve, ge = C * (F - 1 - pe) + A * (D - 1 - de) + R * (M - 1 - (ve * q - se)) + _ * Z, ye = 0; ye < W; ++ye) {
                                                    le += b[me + ye] * T[ge + ye]
                                                }
                                    f[v * J + m * Q + g * ne + y * oe + Z] = le
                                }
                return n.makeTensorInfo(p.shape, p.dtype, p.values)
            }
        },
        qxe = Mge(o1, (function(e) {
            return Math.cos(e)
        })),
        Kxe = {
            kernelName: o1,
            backendName: "cpu",
            kernelFunc: qxe
        },
        Xxe = Mge(s1, (function(e) {
            return Math.cosh(e)
        })),
        Yxe = {
            kernelName: s1,
            backendName: "cpu",
            kernelFunc: Xxe
        };
    var Jxe = {
        kernelName: l1,
        backendName: "cpu",
        kernelFunc: function(e) {
            for (var t = e.inputs, n = e.backend, r = e.attrs, a = t.image, i = t.boxes, o = t.boxInd, s = r.cropSize, u = r.method, c = r.extrapolationValue, l = S(a.shape, 4), h = l[0], p = l[1], f = l[2], d = l[3], v = i.shape[0], m = S(s, 2), g = m[0], y = m[1], b = l8([v, g, y, d], "float32"), x = n.data.get(i.dataId).values, k = n.data.get(o.dataId).values, w = n.data.get(a.dataId).values, I = i0(a.shape), N = i0(b.shape), T = 0; T < v; T++) {
                var E = 4 * T,
                    C = x[E],
                    A = x[E + 1],
                    R = x[E + 2],
                    _ = x[E + 3],
                    O = k[T];
                if (!(O >= h))
                    for (var F = g > 1 ? (R - C) * (p - 1) / (g - 1) : 0, D = y > 1 ? (_ - A) * (f - 1) / (y - 1) : 0, M = 0; M < g; M++) {
                        var L = g > 1 ? C * (p - 1) + M * F : .5 * (C + R) * (p - 1);
                        if (L < 0 || L > p - 1)
                            for (var z = 0; z < y; z++)
                                for (var P = 0; P < d; P++) {
                                    var B = P + z * N[2] + M * N[1] + T * N[0];
                                    b.values[B] = c
                                } else if ("bilinear" === u)
                                    for (var W = Math.floor(L), U = Math.ceil(L), V = L - W, G = 0; G < y; G++) {
                                        var j = y > 1 ? A * (f - 1) + G * D : .5 * (A + _) * (f - 1);
                                        if (j < 0 || j > f - 1)
                                            for (var H = 0; H < d; H++) {
                                                var q = H + G * N[2] + M * N[1] + T * N[0];
                                                b.values[q] = c
                                            } else
                                                for (var K = Math.floor(j), X = Math.ceil(j), Y = j - K, J = 0; J < d; J++) {
                                                    var Z = J + K * I[2] + W * I[1] + O * I[0],
                                                        Q = w[Z],
                                                        $ = w[Z = J + X * I[2] + W * I[1] + O * I[0]],
                                                        ee = w[Z = J + K * I[2] + U * I[1] + O * I[0]],
                                                        te = Q + ($ - Q) * Y,
                                                        ne = ee + (w[Z = J + X * I[2] + U * I[1] + O * I[0]] - ee) * Y;
                                                    Z = J + G * N[2] + M * N[1] + T * N[0], b.values[Z] = te + (ne - te) * V
                                                }
                                    } else
                                        for (var re = 0; re < y; ++re) {
                                            var ae = y > 1 ? A * (f - 1) + re * D : .5 * (A + _) * (f - 1);
                                            if (ae < 0 || ae > f - 1)
                                                for (var ie = 0; ie < d; ie++) {
                                                    var oe = ie + re * N[2] + M * N[1] + T * N[0];
                                                    b.values[oe] = c
                                                } else
                                                    for (var se = Math.round(ae), ue = Math.round(L), ce = 0; ce < d; ce++) {
                                                        var le = ce + se * I[2] + ue * I[1] + O * I[0],
                                                            he = ce + re * N[2] + M * N[1] + T * N[0];
                                                        b.values[he] = w[le]
                                                    }
                                        }
                    }
            }
            return n.makeTensorInfo(b.shape, b.dtype, b.values)
        }
    };
    var Zxe = {
        kernelName: u1,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = r.axis,
                o = r.exclusive,
                s = r.reverse;
            sge(a, "cumprod");
            var u = $7([i], a.shape.length),
                c = a;
            null != u && (c = zye({
                inputs: {
                    x: a
                },
                backend: n,
                attrs: {
                    perm: u
                }
            }));
            var l = t9(1, a.shape.length)[0];
            if (l !== c.shape.length - 1) throw new Error("backend.cumprod in CPU expects an inner-most " + "axis=".concat(c.shape.length - 1, " but got axis=").concat(l));
            for (var h = h5(c.dtype, "int32"), p = c0(L$(c.shape), h), f = n.data.get(c.dataId).values, d = c.shape[c.shape.length - 1], v = s ? function(e, t) {
                    return e + d - t - 1
                } : function(e, t) {
                    return e + t
                }, m = 0; m < f.length; m += d)
                for (var g = 0; g < d; g++) {
                    var y = v(m, g);
                    if (0 === g) p[y] = o ? 1 : f[y];
                    else {
                        var b = v(m, g - 1);
                        p[y] = o ? f[b] * p[b] : f[y] * p[b]
                    }
                }
            var x = n.makeTensorInfo(c.shape, h, p);
            if (null != u) {
                var k = zye({
                    inputs: {
                        x: x
                    },
                    backend: n,
                    attrs: {
                        perm: e9(u)
                    }
                });
                return n.disposeIntermediateTensorInfo(x), n.disposeIntermediateTensorInfo(c), k
            }
            return x
        }
    };
    var Qxe = {
        kernelName: c1,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = r.axis,
                o = r.exclusive,
                s = r.reverse;
            sge(a, "cumsum");
            var u = $7([i], a.shape.length),
                c = a;
            null != u && (c = zye({
                inputs: {
                    x: a
                },
                backend: n,
                attrs: {
                    perm: u
                }
            }));
            var l = t9(1, a.shape.length)[0];
            if (l !== c.shape.length - 1) throw new Error("backend.cumsum in CPU expects an inner-most " + "axis=".concat(c.shape.length - 1, " but got axis=").concat(l));
            for (var h = h5(c.dtype, "int32"), p = l0(L$(c.shape), h), f = n.data.get(c.dataId).values, d = c.shape[c.shape.length - 1], v = s ? function(e, t) {
                    return e + d - t - 1
                } : function(e, t) {
                    return e + t
                }, m = 0; m < f.length; m += d)
                for (var g = 0; g < d; g++) {
                    var y = v(m, g);
                    if (0 === g) p[y] = o ? 0 : f[y];
                    else {
                        var b = v(m, g - 1);
                        p[y] = o ? f[b] + p[b] : f[y] + p[b]
                    }
                }
            var x = n.makeTensorInfo(c.shape, h, p);
            if (null != u) {
                var k = zye({
                    inputs: {
                        x: x
                    },
                    backend: n,
                    attrs: {
                        perm: e9(u)
                    }
                });
                return n.disposeIntermediateTensorInfo(x), n.disposeIntermediateTensorInfo(c), k
            }
            return x
        }
    };
    var $xe = {
        kernelName: h1,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = t.weights,
                o = r.size,
                s = r.binaryOutput;
            if (1 === a.shape.length) {
                var u = Age(n.data.get(a.dataId).values, n.data.get(i.dataId).values, i.dtype, i.shape, o);
                return n.makeTensorInfo([o], i.dtype, u)
            }
            if (2 === a.shape.length) {
                var c = Rge(n.bufferSync(a), n.bufferSync(i), o, s);
                return n.makeTensorInfo(c.shape, i.dtype, c.values)
            }
            throw new Error("Error in denseBincount: input must be at most rank 2, but got rank" + "".concat(a.shape.length, "."))
        }
    };
    var eke = {
        kernelName: p1,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = r.blockSize,
                o = r.dataFormat;
            F$("NHWC" === o, (function() {
                return "Only NHWC dataFormat supported on CPU for depthToSpace. Got ".concat(o)
            }));
            for (var s = a.shape[0], u = a.shape[1], c = a.shape[2], l = a.shape[3], h = u * i, p = c * i, f = l / (i * i), d = n.data.get(a.dataId).values, v = new Float32Array(s * h * p * f), m = 0, g = 0; g < s; ++g)
                for (var y = 0; y < h; ++y)
                    for (var b = Math.floor(y / i), x = y % i, k = 0; k < p; ++k)
                        for (var w = Math.floor(k / i), I = (x * i + k % i) * f, N = 0; N < f; ++N) {
                            var S = N + I + l * (w + c * (b + u * g));
                            v[m++] = d[S]
                        }
            return n.makeTensorInfo([s, h, p, f], a.dtype, v)
        }
    };

    function tke(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs,
            a = t.x,
            i = t.filter,
            o = r.strides,
            s = r.pad,
            u = r.dilations,
            c = r.dimRoundingMode;
        sge([a, i], "depthwiseConv2DNative");
        var l = i0(a.shape),
            h = i0(i.shape),
            p = u;
        null == p && (p = [1, 1]), F$(j8(o, p), (function() {
            return "Error in depthwiseConv2d: Either strides or dilations must be " + "1. Got strides ".concat(o, " and dilations '").concat(p, "'")
        }));
        for (var f = D8(a.shape, i.shape, o, p, s, c, !0), d = f.filterHeight, v = f.filterWidth, m = f.dilationHeight, g = f.dilationWidth, y = f.padInfo, b = y.left, x = y.top, k = f.outChannels / f.inChannels, w = new $4(f.outShape, a.dtype), I = n.data.get(a.dataId).values, N = n.data.get(i.dataId).values, S = w.values, T = 0; T < f.batchSize; ++T)
            for (var E = T * l[0], C = T * w.strides[0], A = 0; A < f.outHeight; ++A)
                for (var R = C + A * w.strides[1], _ = A * f.strideHeight - x, O = 0; O < d; ++O) {
                    var F = _ + O * m;
                    if (!(F < 0 || F >= f.inHeight))
                        for (var D = O * h[0], M = E + F * l[1], L = 0; L < f.outWidth; ++L)
                            for (var z = R + L * w.strides[2], P = L * f.strideWidth - b, B = 0; B < v; ++B) {
                                var W = P + B * g;
                                if (!(W < 0 || W >= f.inWidth))
                                    for (var U = D + B * h[1], V = M + W * f.inChannels, G = z, j = U, H = 0; H < f.inChannels; ++H) {
                                        for (var q = I[V + H], K = 0; K < k; ++K) S[G + K] += q * N[j + K];
                                        G += k, j += k
                                    }
                            }
                }
        return n.makeTensorInfo(w.shape, w.dtype, w.values)
    }
    var nke = {
        kernelName: f1,
        backendName: "cpu",
        kernelFunc: tke
    };
    var rke = {
        kernelName: d1,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = t.dy,
                o = r.strides,
                s = r.dilations,
                u = r.pad,
                c = r.dimRoundingMode,
                l = r.filterShape;
            sge([a, i], "depthwiseConv2dNativeBackpropFilter");
            for (var h = D8(a.shape, l, o, s, u, c, !0), p = h.strideHeight, f = h.strideWidth, d = h.filterHeight, v = h.filterWidth, m = new $4(h.filterShape, "float32"), g = h.padInfo.left, y = h.padInfo.top, b = h.outChannels / h.inChannels, x = n.data.get(a.dataId).values, k = new $4(a.shape, a.dtype, x), w = n.data.get(i.dataId).values, I = new $4(i.shape, i.dtype, w), N = 0; N < d; ++N)
                for (var S = Math.max(0, Math.ceil((y - N) / p)), T = Math.min(h.outHeight, (h.inHeight + y - N) / p), E = 0; E < v; ++E)
                    for (var C = Math.max(0, Math.ceil((g - E) / f)), A = Math.min(h.outWidth, (h.inWidth + g - E) / f), R = 0; R < h.outChannels; ++R) {
                        for (var _ = Math.trunc(R / b), O = R % b, F = 0, D = 0; D < h.batchSize; ++D)
                            for (var M = S; M < T; ++M)
                                for (var L = N + M * p - y, z = C; z < A; ++z) {
                                    var P = E + z * f - g;
                                    F += k.get(D, L, P, _) * I.get(D, M, z, R)
                                }
                        m.set(F, N, E, _, O)
                    }
            return n.makeTensorInfo(m.shape, m.dtype, m.values)
        }
    };
    var ake = {
        kernelName: v1,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.dy,
                i = t.filter,
                o = r.strides,
                s = r.dilations,
                u = r.pad,
                c = r.dimRoundingMode,
                l = r.inputShape;
            sge([a, i], "depthwiseConv2DNativeBackpropInput");
            for (var h = i0(a.shape), p = i0(i.shape), f = D8(l, i.shape, o, s, u, c, !0), d = new $4(f.inShape, "float32"), v = d.values, m = S(d.strides, 3), g = m[0], y = m[1], b = m[2], x = n.data.get(a.dataId).values, k = S(h, 3), w = k[0], I = k[1], N = k[2], T = n.data.get(i.dataId).values, E = S(p, 3), C = E[0], A = E[1], R = E[2], _ = f.batchSize, O = f.filterHeight, F = f.filterWidth, D = f.inChannels, M = f.inHeight, L = f.inWidth, z = f.outChannels, P = f.outHeight, B = f.outWidth, W = f.strideHeight, U = f.strideWidth, V = O - 1 - f.padInfo.top, G = F - 1 - f.padInfo.left, j = z / D, H = 0; H < _; ++H)
                for (var q = 0; q < D; ++q)
                    for (var K = 0; K < M; ++K)
                        for (var X = K - V, Y = Math.max(0, Math.ceil(X / W)), J = Math.min(P, (O + X) / W), Z = 0; Z < L; ++Z) {
                            for (var Q = Z - G, $ = Math.max(0, Math.ceil(Q / U)), ee = Math.min(B, (F + Q) / U), te = 0, ne = Y; ne < J; ++ne)
                                for (var re = ne * W - X, ae = $; ae < ee; ++ae)
                                    for (var ie = w * H + I * ne + N * ae, oe = C * (O - 1 - re) + A * (F - 1 - (ae * U - Q)) + R * q, se = 0; se < j; ++se) {
                                        te += x[ie + (q * j + se)] * T[oe + se]
                                    }
                            v[g * H + y * K + b * Z + q] = te
                        }
            return n.makeTensorInfo(d.shape, d.dtype, d.values)
        }
    };
    var ike = {
            kernelName: m1,
            backendName: "cpu",
            kernelFunc: function(e) {
                for (var t = e.inputs, n = e.backend, r = t.x, a = L$(r.shape), i = n.data.get(r.dataId).values, o = l8([a, a], r.dtype), s = o.values, u = 0; u < i.length; u++) s[u * a + u] = i[u];
                var c = [].concat(T(r.shape), T(r.shape));
                return n.makeTensorInfo(c, o.dtype, o.values)
            }
        },
        oke = {
            kernelName: g1,
            backendName: "cpu",
            kernelFunc: function(e) {
                for (var t = e.inputs, n = e.backend, r = e.attrs, a = t.x, i = t.filter, o = r.strides, s = r.pad, u = r.dilations, c = n, l = c.data.get(a.dataId).values, h = a.shape.length, p = c.data.get(i.dataId).values, f = i.shape.length, d = _8(a.shape, i.shape, o, s, "NHWC", u), v = d.batchSize, m = d.inHeight, g = d.inWidth, y = d.inChannels, b = d.outHeight, x = d.outWidth, k = d.padInfo, w = d.strideHeight, I = d.strideWidth, N = d.filterHeight, S = d.filterWidth, T = d.dilationHeight, E = d.dilationWidth, C = d.outShape, A = L$(C), R = C.length, _ = K$(a.dtype, A), O = 0; O < v; ++O)
                    for (var F = 0; F < b; ++F)
                        for (var D = F * w - k.top, M = 0; M < x; ++M)
                            for (var L = M * I - k.left, z = 0; z < y; ++z) {
                                for (var P = Number.MIN_SAFE_INTEGER, B = 0; B < N; ++B) {
                                    var W = D + B * T;
                                    if (W >= 0 && W < m)
                                        for (var U = 0; U < S; ++U) {
                                            var V = L + U * E;
                                            if (V >= 0 && V < g) {
                                                var G = f0([O, W, V, z], h, i0(a.shape)),
                                                    j = f0([B, U, z], f, i0(i.shape)),
                                                    H = l[G] + p[j];
                                                H > P && (P = H)
                                            }
                                        }
                                }
                                _[f0([O, F, M, z], R, i0(C))] = P
                            }
                return {
                    dataId: c.write(L4(_, a.dtype), C, a.dtype),
                    shape: C,
                    dtype: a.dtype
                }
            }
        },
        ske = {
            kernelName: b1,
            backendName: "cpu",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.filter,
                    o = t.dy,
                    s = r.strides,
                    u = r.pad,
                    c = r.dilations,
                    l = n,
                    h = s0(a.shape, l.data.get(a.dataId).values),
                    p = s0(i.shape, l.data.get(i.dataId).values),
                    f = _8(a.shape, i.shape, s, u, "NHWC", c),
                    d = f.batchSize,
                    v = f.inHeight,
                    m = f.inWidth,
                    g = f.inChannels,
                    y = f.outHeight,
                    b = f.outWidth,
                    x = f.padInfo,
                    k = f.strideHeight,
                    w = f.strideWidth,
                    I = f.filterHeight,
                    N = f.filterWidth,
                    S = f.dilationHeight,
                    T = f.dilationWidth,
                    E = f.outShape;
                F$(o.rank === E.length, (function() {
                    return "Error in ".concat(b1, ", dy ") + "must have the same rank as output ".concat(E.length, ", but got ") + "".concat(o.rank)
                }));
                for (var C = s0(E, l.data.get(o.dataId).values), A = h0(i.shape, i.dtype), R = 0; R < d; ++R)
                    for (var _ = 0; _ < y; ++_)
                        for (var O = _ * k - x.top, F = 0; F < b; ++F)
                            for (var D = F * w - x.left, M = 0; M < g; ++M) {
                                for (var L = Number.MIN_SAFE_INTEGER, z = 0, P = 0, B = 0; B < I; ++B) {
                                    var W = O + B * S;
                                    if (W >= 0 && W < v)
                                        for (var U = 0; U < N; ++U) {
                                            var V = D + U * T;
                                            if (V >= 0 && V < m) {
                                                var G = h[R][W][V][M] + p[B][U][M];
                                                G > L && (L = G, z = B, P = U)
                                            }
                                        }
                                }
                                A[z][P][M] += C[R][_][F][M]
                            }
                return {
                    dataId: l.write(L4(A, a.dtype), i.shape, i.dtype),
                    shape: i.shape,
                    dtype: i.dtype
                }
            }
        },
        uke = {
            kernelName: y1,
            backendName: "cpu",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.filter,
                    o = t.dy,
                    s = r.strides,
                    u = r.pad,
                    c = r.dilations,
                    l = n,
                    h = s0(a.shape, l.data.get(a.dataId).values),
                    p = s0(i.shape, l.data.get(i.dataId).values),
                    f = _8(a.shape, i.shape, s, u, "NHWC", c),
                    d = f.batchSize,
                    v = f.inHeight,
                    m = f.inWidth,
                    g = f.inChannels,
                    y = f.outHeight,
                    b = f.outWidth,
                    x = f.padInfo,
                    k = f.strideHeight,
                    w = f.strideWidth,
                    I = f.filterHeight,
                    N = f.filterWidth,
                    S = f.dilationHeight,
                    T = f.dilationWidth,
                    E = f.outShape;
                F$(o.rank === E.length, (function() {
                    return "Error in ".concat(y1, ", dy ") + "must have the same rank as output ".concat(E.length, ", but got ") + "".concat(o.rank)
                }));
                for (var C = s0(E, l.data.get(o.dataId).values), A = h0(a.shape, a.dtype), R = 0; R < d; ++R)
                    for (var _ = 0; _ < y; ++_)
                        for (var O = _ * k - x.top, F = 0; F < b; ++F)
                            for (var D = F * w - x.left, M = 0; M < g; ++M) {
                                for (var L = Number.MIN_SAFE_INTEGER, z = O < 0 ? 0 : O, P = D < 0 ? 0 : D, B = 0; B < I; ++B) {
                                    var W = O + B * S;
                                    if (W >= 0 && W < v)
                                        for (var U = 0; U < N; ++U) {
                                            var V = D + U * T;
                                            if (V >= 0 && V < m) {
                                                var G = h[R][W][V][M] + p[B][U][M];
                                                G > L && (L = G, z = W, P = V)
                                            }
                                        }
                                }
                                A[R][z][P][M] += C[R][_][F][M]
                            }
                return {
                    dataId: l.write(L4(A, a.dtype), a.shape, a.dtype),
                    shape: a.shape,
                    dtype: a.dtype
                }
            }
        };
    var cke = {
        kernelName: x1,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.image,
                i = r.canvas,
                o = r.options || {},
                s = o.contextOptions,
                u = o.imageOptions,
                c = (null == u ? void 0 : u.alpha) || 1,
                l = (null == s ? void 0 : s.contextType) || "2d";
            if ("2d" !== l) throw new Error("Context type ".concat(s.contextType, " is not supported by the CPU backend."));
            var h = i.getContext(l, (null == s ? void 0 : s.contextAttributes) || {});
            if (null == h) throw new Error("Could not get the context with ".concat(l, " type."));
            for (var p = S(a.shape.slice(0, 2), 2), f = p[0], d = p[1], v = 2 === a.shape.length ? 1 : a.shape[2], m = n.data.get(a.dataId).values, g = "float32" === a.dtype ? 255 : 1, y = new Uint8ClampedArray(d * f * 4), b = 0; b < f * d; ++b) {
                for (var x = [0, 0, 0, 255 * c], k = 0; k < v; k++) {
                    var w = m[b * v + k];
                    if ("float32" === a.dtype) {
                        if (w < 0 || w > 1) throw new Error("Tensor values for a float32 Tensor must be in the " + "range [0 - 1] but encountered ".concat(w, "."))
                    } else if ("int32" === a.dtype && (w < 0 || w > 255)) throw new Error("Tensor values for a int32 Tensor must be in the " + "range [0 - 255] but encountered ".concat(w, "."));
                    1 === v ? (x[0] = w * g, x[1] = w * g, x[2] = w * g) : x[k] = w * g
                }
                var I = 4 * b;
                y[I + 0] = Math.round(x[0]), y[I + 1] = Math.round(x[1]), y[I + 2] = Math.round(x[2]), y[I + 3] = Math.round(x[3])
            }
            i.width = d, i.height = f;
            var N = new ImageData(y, d, f);
            return h.putImageData(N, 0, 0), a
        }
    };

    function lke(e) {
        var t, n = e.inputs,
            r = e.backend,
            a = e.attrs,
            i = n.x,
            o = a.axis,
            s = a.keepDims;
        sge(i, "sum");
        var u = (t = "bool" === i.dtype ? kge({
                inputs: {
                    x: i
                },
                backend: r,
                attrs: {
                    dtype: "int32"
                }
            }) : mge({
                inputs: {
                    x: i
                },
                backend: r
            })).shape.length,
            c = j$(o, t.shape),
            l = $7(c, u),
            h = c,
            p = t;
        null != l && (p = zye({
            inputs: {
                x: t
            },
            backend: r,
            attrs: {
                perm: l
            }
        }), h = t9(h.length, u)), Q7("sum", h, p.shape.length);
        for (var f = S(J7(p.shape, h), 2), d = f[0], v = f[1], m = vge(r, d, h5(p.dtype, "int32")), g = L$(v), y = r.data.get(m.dataId).values, b = r.data.get(p.dataId).values, x = 0; x < y.length; ++x) {
            for (var k = x * g, w = 0, I = 0; I < g; ++I) w += b[k + I];
            y[x] = w
        }
        if (s) {
            var N = m;
            m = Jbe({
                inputs: {
                    x: m
                },
                backend: r,
                attrs: {
                    shape: Z7(m.shape, c)
                }
            }), r.disposeIntermediateTensorInfo(N)
        }
        return r.disposeIntermediateTensorInfo(t), null != l && r.disposeIntermediateTensorInfo(p), m
    }
    var hke = {
        kernelName: a3,
        backendName: "cpu",
        kernelFunc: lke
    };
    var pke = {
        kernelName: w1,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = t,
                a = Lie(e.attrs.equation, r.length),
                i = a.allDims,
                o = a.summedDims,
                s = a.idDims;
            Pie(i.length, s, r);
            for (var u = Bie(o, s), c = u.path, l = u.steps, h = l.length, p = null, f = i.length, d = [], v = 0; v < h; ++v) {
                var m, g = O(l[v]);
                try {
                    for (g.s(); !(m = g.n()).done;) {
                        var y = m.value,
                            b = zie(f, s[y]),
                            x = b.permutationIndices,
                            k = b.expandDims,
                            w = void 0;
                        Wie(x) ? w = r[y] : (w = zye({
                            inputs: {
                                x: r[y]
                            },
                            backend: n,
                            attrs: {
                                perm: x
                            }
                        }), d.push(w));
                        for (var I = w.shape.slice(), N = 0; N < k.length; ++N) I.splice(k[N], 0, 1);
                        P$(w.shape, I) || (w = Jbe({
                            inputs: {
                                x: w
                            },
                            backend: n,
                            attrs: {
                                shape: I
                            }
                        }), d.push(w)), null === p ? p = w : (p = Aye({
                            inputs: {
                                a: w,
                                b: p
                            },
                            backend: n
                        }), d.push(p))
                    }
                } catch (e) {
                    g.e(e)
                } finally {
                    g.f()
                }
                v < h - 1 && (c[v] >= 0 && (p = lke({
                    inputs: {
                        x: p
                    },
                    backend: n,
                    attrs: {
                        axis: c[v] - (i.length - f),
                        keepDims: !1
                    }
                }), d.push(p)), f--)
            }
            for (var S = 0, T = d; S < T.length; S++) {
                var E = T[S];
                E !== p && n.disposeIntermediateTensorInfo(E)
            }
            return p
        }
    };
    var fke = {
            kernelName: N1,
            backendName: "cpu",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = t.dy,
                    a = t.y;
                sge([r, a], "eluGrad");
                for (var i = new Float32Array(L$(a.shape)), o = n.data.get(a.dataId).values, s = n.data.get(r.dataId).values, u = 0; u < o.length; ++u) {
                    var c = o[u];
                    i[u] = c >= 0 ? s[u] : s[u] * (c + 1)
                }
                return n.makeTensorInfo(a.shape, "float32", i)
            }
        },
        dke = Mge(S1, (function(e) {
            var t = Math.sign(e),
                n = Math.abs(e),
                r = 1 / (1 + .3275911 * n);
            return t * (1 - ((((1.061405429 * r - 1.453152027) * r + 1.421413741) * r - .284496736) * r + .254829592) * r * Math.exp(-n * n))
        })),
        vke = {
            kernelName: S1,
            backendName: "cpu",
            kernelFunc: dke
        };

    function mke(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs,
            a = t.input,
            i = r.dim,
            o = a.shape.length,
            s = a.shape.slice(),
            u = i;
        return i < 0 && (F$(-(o + 1) <= i, (function() {
            return "Axis must be in the interval [".concat(-(o + 1), ", ").concat(o, "]")
        })), u = o + i + 1), s.splice(u, 0, 1), Jbe({
            inputs: {
                x: a
            },
            backend: n,
            attrs: {
                shape: s
            }
        })
    }
    var gke = {
            kernelName: C1,
            backendName: "cpu",
            kernelFunc: mke
        },
        yke = pge((function(e, t) {
            return e / t
        })),
        bke = Ige(k1, yke),
        xke = {
            kernelName: k1,
            backendName: "cpu",
            kernelFunc: bke
        };

    function kke(e, t, n) {
        for (var r = e.shape, a = r[0], i = r[1], o = n.data.get(e.dataId), s = o.complexTensorInfos.real, u = o.complexTensorInfos.imag, c = [a, i], l = L$(c), h = q$("float32", l), p = q$("float32", l), f = 0; f < a; f++) {
            for (var d = sbe({
                    inputs: {
                        x: s
                    },
                    backend: n,
                    attrs: {
                        begin: [f, 0],
                        size: [1, i]
                    }
                }), v = sbe({
                    inputs: {
                        x: u
                    },
                    backend: n,
                    attrs: {
                        begin: [f, 0],
                        size: [1, i]
                    }
                }), m = fge({
                    inputs: {
                        real: d,
                        imag: v
                    },
                    backend: n
                }), g = wke(m, t, n), y = Tie(g.real, g.imag), b = 0; b < i; b++) {
                var x = Rie(y, b);
                h[f * i + b] = x.real, p[f * i + b] = x.imag
            }
            n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(v), n.disposeIntermediateTensorInfo(m)
        }
        var k = n.makeTensorInfo(c, "float32", h),
            w = n.makeTensorInfo(c, "float32", p),
            I = fge({
                inputs: {
                    real: k,
                    imag: w
                },
                backend: n
            });
        return n.disposeIntermediateTensorInfo(k), n.disposeIntermediateTensorInfo(w), I
    }

    function wke(e, t, n) {
        var r = L$(e.shape),
            a = n.data.get(e.dataId),
            i = n.data.get(a.complexTensorInfos.real.dataId).values,
            o = n.data.get(a.complexTensorInfos.imag.dataId).values;
        if (0 == ((g = r) & g - 1)) {
            var s = Ike(i, o, r, t, n),
                u = [e.shape[0], e.shape[1]];
            if (t) {
                var c = n.makeTensorInfo(u, "float32", s.real),
                    l = n.makeTensorInfo(u, "float32", s.imag),
                    h = n.makeTensorInfo([], "float32", M4(r, "float32")),
                    p = mge({
                        inputs: {
                            x: h
                        },
                        backend: n
                    }),
                    f = xke.kernelFunc({
                        inputs: {
                            a: c,
                            b: h
                        },
                        backend: n
                    }),
                    d = xke.kernelFunc({
                        inputs: {
                            a: l,
                            b: p
                        },
                        backend: n
                    }),
                    v = n.data.get(f.dataId).values,
                    m = n.data.get(d.dataId).values;
                return n.disposeIntermediateTensorInfo(c), n.disposeIntermediateTensorInfo(l), n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(d), {
                    real: v,
                    imag: m
                }
            }
            return s
        }
        var g, y = function(e, t, n) {
            for (var r = new Float32Array(2 * t), a = 0; a < t; a++) {
                for (var i = 0, o = 0, s = 0; s < t; s++) {
                    var u = Fie(a * s, t, n),
                        c = Rie(e, s);
                    i += c.real * u.real - c.imag * u.imag, o += c.real * u.imag + c.imag * u.real
                }
                n && (i /= t, o /= t), _ie(r, i, o, a)
            }
            return r
        }(Tie(i, o), r, t);
        return Eie(y)
    }

    function Ike(e, t, n, r, a) {
        if (1 === n) return {
            real: e,
            imag: t
        };
        var i = Tie(e, t),
            o = n / 2,
            s = Cie(i),
            u = s.real,
            c = s.imag,
            l = [u.length],
            h = a.makeTensorInfo(l, "float32", u),
            p = a.makeTensorInfo(l, "float32", c),
            f = fge({
                inputs: {
                    real: h,
                    imag: p
                },
                backend: a
            }),
            d = Aie(i),
            v = d.real,
            m = d.imag,
            g = [v.length],
            y = a.makeTensorInfo(g, "float32", v),
            b = a.makeTensorInfo(g, "float32", m),
            x = fge({
                inputs: {
                    real: y,
                    imag: b
                },
                backend: a
            }),
            k = Ike(u, c, o, r, a),
            w = k.real,
            I = k.imag,
            N = [w.length],
            S = a.makeTensorInfo(N, "float32", w),
            T = a.makeTensorInfo(N, "float32", I),
            E = fge({
                inputs: {
                    real: S,
                    imag: T
                },
                backend: a
            }),
            C = Ike(v, m, o, r, a),
            A = C.real,
            R = C.imag,
            _ = [A.length],
            O = a.makeTensorInfo(_, "float32", A),
            F = a.makeTensorInfo(_, "float32", R),
            D = fge({
                inputs: {
                    real: O,
                    imag: F
                },
                backend: a
            }),
            M = Oie(n, r),
            L = [M.real.length],
            z = a.makeTensorInfo(L, "float32", M.real),
            P = a.makeTensorInfo(L, "float32", M.imag),
            B = fge({
                inputs: {
                    real: z,
                    imag: P
                },
                backend: a
            }),
            W = Aye({
                inputs: {
                    a: B,
                    b: D
                },
                backend: a
            }),
            U = Ege({
                inputs: {
                    a: E,
                    b: W
                },
                backend: a
            }),
            V = Abe({
                inputs: {
                    a: E,
                    b: W
                },
                backend: a
            }),
            G = yge({
                inputs: {
                    input: U
                },
                backend: a
            }),
            j = yge({
                inputs: {
                    input: V
                },
                backend: a
            }),
            H = Mxe({
                inputs: {
                    input: U
                },
                backend: a
            }),
            q = Mxe({
                inputs: {
                    input: V
                },
                backend: a
            }),
            K = zxe({
                inputs: [G, j],
                backend: a,
                attrs: {
                    axis: 0
                }
            }),
            X = zxe({
                inputs: [H, q],
                backend: a,
                attrs: {
                    axis: 0
                }
            }),
            Y = a.data.get(K.dataId).values,
            J = a.data.get(X.dataId).values;
        return a.disposeIntermediateTensorInfo(h), a.disposeIntermediateTensorInfo(p), a.disposeIntermediateTensorInfo(f), a.disposeIntermediateTensorInfo(y), a.disposeIntermediateTensorInfo(b), a.disposeIntermediateTensorInfo(x), a.disposeIntermediateTensorInfo(S), a.disposeIntermediateTensorInfo(T), a.disposeIntermediateTensorInfo(E), a.disposeIntermediateTensorInfo(O), a.disposeIntermediateTensorInfo(F), a.disposeIntermediateTensorInfo(D), a.disposeIntermediateTensorInfo(z), a.disposeIntermediateTensorInfo(P), a.disposeIntermediateTensorInfo(B), a.disposeIntermediateTensorInfo(W), a.disposeIntermediateTensorInfo(U), a.disposeIntermediateTensorInfo(V), a.disposeIntermediateTensorInfo(G), a.disposeIntermediateTensorInfo(H), a.disposeIntermediateTensorInfo(j), a.disposeIntermediateTensorInfo(q), a.disposeIntermediateTensorInfo(K), a.disposeIntermediateTensorInfo(X), {
            real: Y,
            imag: J
        }
    }
    var Nke = {
        kernelName: R1,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = t.input,
                a = L$(r.shape),
                i = r.shape[r.shape.length - 1],
                o = Jbe({
                    inputs: {
                        x: r
                    },
                    backend: n,
                    attrs: {
                        shape: [a / i, i]
                    }
                }),
                s = kke(o, !1, n),
                u = Jbe({
                    inputs: {
                        x: s
                    },
                    backend: n,
                    attrs: {
                        shape: r.shape
                    }
                });
            return n.disposeIntermediateTensorInfo(o), n.disposeIntermediateTensorInfo(s), u
        }
    };

    function Ske(e) {
        var t = e.backend,
            n = e.attrs,
            r = n.shape,
            a = n.value,
            i = n.dtype || n0(a),
            o = K$(i, L$(r));
        return function(e, t, n) {
            e.fill(t)
        }(o, a), t.makeTensorInfo(r, i, o)
    }
    var Tke = {
        kernelName: _1,
        backendName: "cpu",
        kernelFunc: Ske
    };
    var Eke = {
        kernelName: O1,
        backendName: "cpu",
        kernelFunc: function(e) {
            for (var t = e.inputs, n = (e.attrs, e.backend), r = t.image, a = n, i = q$(r.dtype, L$(r.shape)), o = S(r.shape, 4), s = o[0], u = o[1], c = o[2], l = o[3], h = a.data.get(r.dataId).values, p = 0; p < s; p++)
                for (var f = p * c * u * l, d = 0; d < u; d++)
                    for (var v = d * (c * l), m = 0; m < c; m++)
                        for (var g = m * l, y = 0; y < l; y++) {
                            var b = Math.round(c - m - 1),
                                x = f + v + g + y,
                                k = h[x];
                            if (b >= 0 && b < c) k = h[f + v + b * l + y];
                            i[x] = k
                        }
            return {
                dataId: a.write(i, r.shape, r.dtype),
                shape: r.shape,
                dtype: r.dtype
            }
        }
    };
    var Cke = {
        kernelName: M3,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = t.filter,
                o = t.bias,
                s = t.preluActivationWeights,
                u = r.strides,
                c = r.pad,
                l = r.dataFormat,
                h = r.dilations,
                p = r.dimRoundingMode,
                f = r.activation,
                d = r.leakyreluAlpha,
                v = Bxe({
                    inputs: {
                        x: a,
                        filter: i
                    },
                    backend: n,
                    attrs: {
                        strides: u,
                        pad: c,
                        dataFormat: l,
                        dilations: h,
                        dimRoundingMode: p
                    }
                });
            if (o) {
                var m = v;
                if ("NCHW" === l && 1 === o.shape.length && 1 !== o.shape[0]) {
                    var g = Jbe({
                        inputs: {
                            x: o
                        },
                        backend: n,
                        attrs: {
                            shape: [o.shape[0], 1, 1]
                        }
                    });
                    v = Ege({
                        inputs: {
                            a: v,
                            b: g
                        },
                        backend: n
                    }), n.disposeIntermediateTensorInfo(g)
                } else v = Ege({
                    inputs: {
                        a: v,
                        b: o
                    },
                    backend: n
                });
                n.disposeIntermediateTensorInfo(m)
            }
            if (f) {
                var y = v;
                if ("NCHW" === l && "prelu" === f && 1 === s.shape.length && 1 !== s.shape[0]) {
                    var b = Jbe({
                        inputs: {
                            x: s
                        },
                        backend: n,
                        attrs: {
                            shape: [s.shape[0], 1, 1]
                        }
                    });
                    v = Ybe(n, v, f, b, d), n.disposeIntermediateTensorInfo(b)
                } else v = Ybe(n, v, f, s, d);
                n.disposeIntermediateTensorInfo(y)
            }
            return v
        }
    };
    var Ake = {
        kernelName: L3,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = t.filter,
                o = t.bias,
                s = t.preluActivationWeights,
                u = r.strides,
                c = r.pad,
                l = r.dataFormat,
                h = r.dilations,
                p = r.dimRoundingMode,
                f = r.activation,
                d = r.leakyreluAlpha,
                v = tke({
                    inputs: {
                        x: a,
                        filter: i
                    },
                    backend: n,
                    attrs: {
                        strides: u,
                        pad: c,
                        dataFormat: l,
                        dilations: h,
                        dimRoundingMode: p
                    }
                });
            if (o) {
                var m = v;
                v = Ege({
                    inputs: {
                        a: v,
                        b: o
                    },
                    backend: n
                }), n.disposeIntermediateTensorInfo(m)
            }
            if (f) {
                var g = v;
                v = Ybe(n, v, f, s, d), n.disposeIntermediateTensorInfo(g)
            }
            return v
        }
    };
    var Rke = {
        kernelName: z1,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = t.params,
                a = t.indices,
                i = L$(r.shape),
                o = a.shape,
                s = o[o.length - 1],
                u = S(Mae(r, a), 4),
                c = u[0],
                l = u[1],
                h = u[2],
                p = u[3];
            if (0 === l) return n.makeTensorInfo(c, r.dtype, []);
            var f = nye(n.data.get(a.dataId).values, n.bufferSync(r), r.dtype, l, s, h, p, r.shape, i);
            return n.makeTensorInfo(c, r.dtype, f.values)
        }
    };
    var _ke = {
        kernelName: L1,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = t.indices,
                o = r.axis,
                s = r.batchDims;
            sge([a, i], "gatherV2");
            for (var u = j$(o, a.shape)[0], c = n.data.get(i.dataId).values, l = a.shape[u], h = function() {
                    var e = c[p];
                    F$(e <= l - 1 && e >= 0, (function() {
                        return "GatherV2: the index value ".concat(e, " is not in [0, ").concat(l - 1, "]")
                    }))
                }, p = 0; p < c.length; ++p) h();
            var f = s;
            null == s && (f = 0);
            var d = L$(i.shape),
                v = roe(a, i, u, f),
                m = Jbe({
                    inputs: {
                        x: a
                    },
                    backend: n,
                    attrs: {
                        shape: [v.batchSize, v.outerSize, v.dimSize, v.sliceSize]
                    }
                }),
                g = Jbe({
                    inputs: {
                        x: i
                    },
                    backend: n,
                    attrs: {
                        shape: [v.batchSize, d / v.batchSize]
                    }
                }),
                y = [v.batchSize, v.outerSize, d / v.batchSize, v.sliceSize],
                b = n.bufferSync(g),
                x = rye(n.bufferSync(m), b, y);
            return n.disposeIntermediateTensorInfo(m), n.disposeIntermediateTensorInfo(g), n.makeTensorInfo(v.outputShape, x.dtype, x.values)
        }
    };
    var Oke = {
            kernelName: U1,
            backendName: "cpu",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = t.input,
                    a = L$(r.shape),
                    i = r.shape[r.shape.length - 1],
                    o = Jbe({
                        inputs: {
                            x: r
                        },
                        backend: n,
                        attrs: {
                            shape: [a / i, i]
                        }
                    }),
                    s = kke(o, !0, n),
                    u = Jbe({
                        inputs: {
                            x: s
                        },
                        backend: n,
                        attrs: {
                            shape: r.shape
                        }
                    });
                return n.disposeIntermediateTensorInfo(o), n.disposeIntermediateTensorInfo(s), u
            }
        },
        Fke = Mge(G1, (function(e) {
            return Number.isFinite(e) ? 1 : 0
        }), "bool"),
        Dke = {
            kernelName: G1,
            backendName: "cpu",
            kernelFunc: Fke
        },
        Mke = Mge(j1, (function(e) {
            return Math.abs(e) === 1 / 0 ? 1 : 0
        }), "bool"),
        Lke = {
            kernelName: j1,
            backendName: "cpu",
            kernelFunc: Mke
        },
        zke = Mge(H1, (function(e) {
            return Number.isNaN(e) ? 1 : 0
        }), "bool"),
        Pke = {
            kernelName: H1,
            backendName: "cpu",
            kernelFunc: zke
        };
    var Bke = {
            kernelName: Y1,
            backendName: "cpu",
            kernelFunc: function(e) {
                var t = e.backend,
                    n = e.attrs,
                    r = mye(n.start, n.stop, n.num);
                return t.makeTensorInfo([r.length], "float32", r)
            }
        },
        Wke = Mge(Z1, (function(e) {
            return Math.log1p(e)
        })),
        Uke = {
            kernelName: Z1,
            backendName: "cpu",
            kernelFunc: Wke
        },
        Vke = pge((function(e, t) {
            return e && t
        })),
        Gke = Ige(Q1, Vke, null, "bool"),
        jke = {
            kernelName: Q1,
            backendName: "cpu",
            kernelFunc: Gke
        },
        Hke = Mge($1, (function(e) {
            return e ? 0 : 1
        }), "bool"),
        qke = {
            kernelName: $1,
            backendName: "cpu",
            kernelFunc: Hke
        },
        Kke = pge((function(e, t) {
            return e || t
        })),
        Xke = Ige(e2, Kke, null, "bool"),
        Yke = {
            kernelName: e2,
            backendName: "cpu",
            kernelFunc: Xke
        };
    var Jke = {
        kernelName: n2,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = r.depthRadius,
                o = r.bias,
                s = r.alpha,
                u = r.beta;
            sge(a, "LRN");
            var c = a.shape[3],
                l = c - 1,
                h = n.data.get(a.dataId).values,
                p = L$(a.shape),
                f = new Float32Array(p);

            function d(e) {
                for (var t = e % c, n = e - t + Math.max(0, t - i), r = e - t + Math.min(t + i, l), a = 0; n <= r; n++) {
                    var o = h[n];
                    a += o * o
                }
                return a
            }
            for (var v = 0; v < p; v++) {
                var m = d(v),
                    g = h[v] * Math.pow(o + s * m, -u);
                f[v] = g
            }
            return n.makeTensorInfo(a.shape, a.dtype, f)
        }
    };
    var Zke = {
        kernelName: r2,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = t.y,
                o = t.dy,
                s = r.depthRadius,
                u = r.bias,
                c = r.alpha,
                l = r.beta;
            sge(o, "LRNGrad");
            for (var h = L$(o.shape), p = o.shape[3], f = n.data.get(o.dataId).values, d = n.data.get(a.dataId).values, v = n.data.get(i.dataId).values, m = new Float32Array(h), g = h, y = 0; y < g; y++) {
                for (var b = y % p, x = y - b + Math.max(0, b - s), k = y - b + Math.min(p, b + s + 1), w = 0, I = x; I < k; I++) w += Math.pow(d[I], 2);
                w = c * w + u;
                for (var N = x; N < k; N++) {
                    var S = -2 * c * l * d[N] * v[y] / w;
                    y === N && (S += Math.pow(w, -l)), S *= f[y], m[N] += S
                }
            }
            return n.makeTensorInfo(o.shape, a.dtype, m)
        }
    };

    function Qke(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs,
            a = t.x,
            i = r.reductionIndices,
            o = r.keepDims,
            s = n,
            u = a.shape,
            c = u.length,
            l = j$(i, u),
            h = l,
            p = $7(h, c),
            f = s.data.get(a.dataId).values;
        if (null != p) {
            for (var d = new Array(c), v = 0; v < d.length; v++) d[v] = u[p[v]];
            f = Lye(f, u, a.dtype, p, d), h = t9(h.length, c), u = d
        }
        sge(a, "max"), Q7("max", h, c);
        var m = S(J7(u, h), 2),
            g = m[0],
            y = xye(f, L$(m[1]), g, a.dtype),
            b = s.write(y, g, a.dtype),
            x = g;
        o && (x = Z7(g, l));
        return {
            dataId: b,
            shape: x,
            dtype: a.dtype
        }
    }
    var $ke = {
        kernelName: a2,
        backendName: "cpu",
        kernelFunc: Qke
    };
    var ewe = {
        kernelName: o2,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x;
            sge(a, "maxPool");
            var i = r.filterSize,
                o = r.strides,
                s = r.pad,
                u = r.dimRoundingMode;
            F$(j8(o, 1), (function() {
                return "Error in maxPool: Either strides or dilations must be 1. " + "Got strides ".concat(o, " and dilations '").concat(1, "'")
            }));
            var c, l = O8(a.shape, i, o, 1, s, u);
            if (1 === l.filterWidth && 1 === l.filterHeight && P$(l.inShape, l.outShape)) c = mge({
                inputs: {
                    x: a
                },
                backend: n
            });
            else {
                var h = n.data.get(a.dataId).values,
                    p = i0(a.shape),
                    f = kxe(h, a.shape, a.dtype, p, l, "max");
                c = n.makeTensorInfo(l.outShape, a.dtype, f.values)
            }
            return c
        }
    };
    var twe = {
        kernelName: u2,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = r.filterSize,
                o = r.strides,
                s = r.pad,
                u = r.dimRoundingMode,
                c = r.dataFormat;
            sge(a, "maxPool3d");
            var l = F8(a.shape, i, o, 1, s, u, c),
                h = Ixe(n.data.get(a.dataId).values, a.shape, a.dtype, i0(a.shape), l, "max");
            return n.makeTensorInfo(h.shape, "float32", h.values)
        }
    };
    var nwe = {
        kernelName: c2,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.dy,
                i = t.input,
                o = r.filterSize,
                s = r.strides,
                u = r.pad,
                c = r.dimRoundingMode;
            sge([a, i], "maxPool3DGrad");
            for (var l = F8(i.shape, o, s, 1, u, c), h = function(e, t) {
                    for (var n = l8(t.outShape, "int32"), r = t.strideDepth, a = t.strideHeight, i = t.strideWidth, o = t.dilationDepth, s = t.dilationHeight, u = t.dilationWidth, c = t.effectiveFilterDepth, l = t.effectiveFilterHeight, h = t.effectiveFilterWidth, p = t.padInfo.front, f = t.padInfo.top, d = t.padInfo.left, v = 0; v < t.batchSize; ++v)
                        for (var m = 0; m < t.inChannels; ++m)
                            for (var g = 0; g < t.outDepth; ++g) {
                                for (var y = g * r - p, b = y; b < 0;) b += o;
                                for (var x = Math.min(t.inDepth, c + y), k = 0; k < t.outHeight; ++k) {
                                    for (var w = k * a - f, I = w; I < 0;) I += s;
                                    for (var N = Math.min(t.inHeight, l + w), S = 0; S < t.outWidth; ++S) {
                                        for (var T = S * i - d, E = T; E < 0;) E += u;
                                        for (var C = Math.min(t.inWidth, h + T), A = Number.NEGATIVE_INFINITY, R = -1, _ = b; _ < x; _ += o)
                                            for (var O = _ - y, F = I; F < N; F += s)
                                                for (var D = F - w, M = E; M < C; M += u) {
                                                    var L = M - T,
                                                        z = e.get(v, _, F, M, m);
                                                    z >= A && (A = z, R = O * l * h + D * l + L)
                                                }
                                        n.set(R, v, g, k, S, m)
                                    }
                                }
                            }
                    return n
                }(n.bufferSync(i), l), p = l.strideDepth, f = l.strideHeight, d = l.strideWidth, v = l.dilationDepth, m = l.dilationHeight, g = l.dilationWidth, y = l.effectiveFilterDepth, b = l.effectiveFilterHeight, x = l.effectiveFilterWidth, k = y - 1 - l.padInfo.front, w = x - 1 - l.padInfo.left, I = b - 1 - l.padInfo.top, N = l8(i.shape, "float32"), S = n.bufferSync(a), T = 0; T < l.batchSize; ++T)
                for (var E = 0; E < l.inChannels; ++E)
                    for (var C = 0; C < l.inDepth; ++C)
                        for (var A = 0; A < l.inHeight; ++A)
                            for (var R = 0; R < l.inWidth; ++R) {
                                for (var _ = C - k, O = A - I, F = R - w, D = 0, M = 0; M < y; M += v) {
                                    var L = (_ + M) / p;
                                    if (!(L < 0 || L >= l.outDepth || Math.floor(L) !== L))
                                        for (var z = 0; z < b; z += m) {
                                            var P = (O + z) / f;
                                            if (!(P < 0 || P >= l.outHeight || Math.floor(P) !== P))
                                                for (var B = 0; B < x; B += g) {
                                                    var W = (F + B) / d;
                                                    if (!(W < 0 || W >= l.outWidth || Math.floor(W) !== W)) {
                                                        var U = y * b * x - 1 - h.get(T, L, P, W, E) === M * b * x + z * x + B ? 1 : 0;
                                                        if (0 !== U) D += S.get(T, L, P, W, E) * U
                                                    }
                                                }
                                        }
                                }
                                N.set(D, T, C, A, R, E)
                            }
            return n.makeTensorInfo(N.shape, N.dtype, N.values)
        }
    };
    var rwe = {
        kernelName: s2,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.dy,
                i = t.input,
                o = i;
            sge([i, t.output], "maxPoolGrad");
            for (var s = r.filterSize, u = r.strides, c = r.pad, l = r.dimRoundingMode, h = O8(o.shape, s, u, 1, c, l), p = n.data.get(o.dataId).values, f = l8(h.outShape, o.dtype, wxe(p, o.shape, o.dtype, h).values), d = h.strideHeight, v = h.strideWidth, m = h.dilationHeight, g = h.dilationWidth, y = h.effectiveFilterHeight, b = h.effectiveFilterWidth, x = b - 1 - h.padInfo.left, k = y - 1 - h.padInfo.top, w = l8(o.shape, "float32"), I = n.data.get(a.dataId).values, N = l8(a.shape, "float32", I), S = 0; S < h.batchSize; ++S)
                for (var T = 0; T < h.inChannels; ++T)
                    for (var E = 0; E < h.inHeight; ++E)
                        for (var C = 0; C < h.inWidth; ++C) {
                            for (var A = E - k, R = C - x, _ = 0, O = 0; O < y; O += m) {
                                var F = (A + O) / d;
                                if (!(F < 0 || F >= h.outHeight || Math.floor(F) !== F))
                                    for (var D = 0; D < b; D += g) {
                                        var M = (R + D) / v;
                                        if (!(M < 0 || M >= h.outWidth || Math.floor(M) !== M)) {
                                            var L = y * b - 1 - f.get(S, F, M, T) === O * b + D ? 1 : 0;
                                            if (0 !== L) _ += N.get(S, F, M, T) * L
                                        }
                                    }
                            }
                            w.set(_, S, E, C, T)
                        }
            return n.makeTensorInfo(w.shape, w.dtype, w.values)
        }
    };
    var awe = {
        kernelName: l2,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.attrs,
                r = e.backend,
                a = t.x,
                i = n.filterSize,
                o = n.strides,
                s = n.pad,
                u = n.includeBatchInIndex,
                c = r;
            sge(a, "MaxPoolWithArgmax");
            var l = c.data.get(a.dataId).values,
                h = O8(a.shape, i, o, [1, 1], s),
                p = function(e, t, n, r, a) {
                    var i = kxe(e, 0, n, i0(t), a, "max"),
                        o = wxe(e, t, n, a, !0, r);
                    return [i.values, o.values]
                }(l, a.shape, a.dtype, u, h),
                f = S(p, 2),
                d = f[0],
                v = f[1],
                m = c.write(d, h.outShape, a.dtype),
                g = c.write(v, h.outShape, a.dtype);
            return [{
                dataId: m,
                shape: h.outShape,
                dtype: a.dtype
            }, {
                dataId: g,
                shape: h.outShape,
                dtype: "int32"
            }]
        }
    };
    var iwe = {
        kernelName: h2,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = r.axis,
                o = r.keepDims,
                s = j$(i, a.shape),
                u = L$(J7(a.shape, s)[1]),
                c = [],
                l = n.makeTensorInfo([], "float32", new Float32Array([u]));
            c.push(l);
            var h = kge({
                inputs: {
                    x: a
                },
                backend: n,
                attrs: {
                    dtype: "float32"
                }
            });
            c.push(h);
            var p = bke({
                inputs: {
                    a: h,
                    b: l
                },
                backend: n
            });
            c.push(p);
            var f = lke({
                inputs: {
                    x: p
                },
                backend: n,
                attrs: {
                    axis: i,
                    keepDims: o
                }
            });
            return c.forEach((function(e) {
                return n.disposeIntermediateTensorInfo(e)
            })), f
        }
    };
    var owe = {
        kernelName: p2,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = r.axis,
                o = r.keepDims;
            sge(a, "min");
            var s = j$(i, a.shape),
                u = s,
                c = $7(u, a.shape.length),
                l = a;
            null != c && (l = zye({
                inputs: {
                    x: a
                },
                backend: n,
                attrs: {
                    perm: c
                }
            }), u = t9(u.length, a.shape.length)), Q7("min", u, l.shape.length);
            for (var h = S(J7(l.shape, u), 2), p = h[0], f = L$(h[1]), d = l0(L$(p), l.dtype), v = n.data.get(l.dataId).values, m = 0; m < d.length; ++m) {
                for (var g = m * f, y = v[g], b = 0; b < f; ++b) {
                    var x = v[g + b];
                    (Number.isNaN(x) || x < y) && (y = x)
                }
                d[m] = y
            }
            null != c && n.disposeIntermediateTensorInfo(l);
            var k = n.makeTensorInfo(p, l.dtype, d);
            if (o) {
                var w = Jbe({
                    inputs: {
                        x: k
                    },
                    backend: n,
                    attrs: {
                        shape: Z7(p, s)
                    }
                });
                return n.disposeIntermediateTensorInfo(k), w
            }
            return k
        }
    };
    var swe = {
            kernelName: d2,
            backendName: "cpu",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.paddings,
                    o = r.mode;
                sge(a, "mirrorPad");
                for (var s = i.map((function(e, t) {
                        return e[0] + a.shape[t] + e[1]
                    })), u = i.map((function(e) {
                        return e[0]
                    })), c = i.map((function(e, t) {
                        return e[0] + a.shape[t]
                    })), l = "reflect" === o ? 0 : 1, h = n.data.get(a.dataId).values, p = a.shape.length, f = i0(a.shape), d = L$(s), v = s.length, m = i0(s), g = q$(a.dtype, d), y = 0; y < d; y++) {
                    for (var b = d0(y, v, m), x = 0; x < v; x++) b[x] < u[x] ? b[x] = 2 * u[x] - b[x] - l : b[x] >= c[x] && (b[x] = 2 * (c[x] - 1) - b[x] + l);
                    b = b.map((function(e, t) {
                        return e - u[t]
                    }));
                    var k = f0(b, p, f);
                    g[y] = h[k]
                }
                return {
                    dataId: n.write(g, s, a.dtype),
                    shape: s,
                    dtype: a.dtype
                }
            }
        },
        uwe = pge((function(e, t) {
            var n = e % t;
            return e < 0 && t < 0 || e >= 0 && t >= 0 ? n : (n + t) % t
        })),
        cwe = Ige(v2, uwe),
        lwe = {
            kernelName: v2,
            backendName: "cpu",
            kernelFunc: cwe
        };

    function hwe(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs,
            a = t.logits,
            i = r.dim,
            o = a.shape.length,
            s = i;
        if (-1 === s && (s = o - 1), s !== o - 1) throw Error("Softmax along a non-last dimension is not yet supported. " + "Logits was rank ".concat(o, " and dim was ").concat(s));
        var u = j$([s], a.shape),
            c = Qke({
                inputs: {
                    x: a
                },
                backend: n,
                attrs: {
                    reductionIndices: u,
                    keepDims: !1
                }
            }),
            l = Z7(c.shape, u),
            h = Jbe({
                inputs: {
                    x: c
                },
                backend: n,
                attrs: {
                    shape: l
                }
            }),
            p = Abe({
                inputs: {
                    a: a,
                    b: h
                },
                backend: n
            }),
            f = Hge({
                inputs: {
                    x: p
                },
                backend: n
            }),
            d = lke({
                inputs: {
                    x: f
                },
                backend: n,
                attrs: {
                    axis: u,
                    keepDims: !1
                }
            }),
            v = Jbe({
                inputs: {
                    x: d
                },
                backend: n,
                attrs: {
                    shape: l
                }
            }),
            m = bke({
                inputs: {
                    a: f,
                    b: v
                },
                backend: n
            });
        return n.disposeIntermediateTensorInfo(c), n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(p), n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(v), m
    }
    var pwe = {
        kernelName: s3,
        backendName: "cpu",
        kernelFunc: hwe
    };
    var fwe = {
            kernelName: m2,
            backendName: "cpu",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.logits,
                    i = r.numSamples,
                    o = r.seed,
                    s = r.normalized;
                sge(a, "multinomial");
                for (var u = s ? a : hwe({
                        inputs: {
                            logits: a
                        },
                        backend: n,
                        attrs: {
                            dim: -1
                        }
                    }), c = u.shape[0], l = u.shape[1], h = n.data.get(u.dataId).values, p = [c, i], f = l0(L$(p), "int32"), d = 0; d < c; ++d) {
                    var v = d * l,
                        m = new Float32Array(l - 1);
                    m[0] = h[v];
                    for (var g = 1; g < m.length; ++g) m[g] = m[g - 1] + h[v + g];
                    for (var y = qee.alea(o.toString()), b = d * i, x = 0; x < i; ++x) {
                        var k = y();
                        f[b + x] = m.length;
                        for (var w = 0; w < m.length; w++)
                            if (k < m[w]) {
                                f[b + x] = w;
                                break
                            }
                    }
                }
                return s || n.disposeIntermediateTensorInfo(u), n.makeTensorInfo(p, "int32", f)
            }
        },
        dwe = qne;
    var vwe = {
            kernelName: x2,
            backendName: "cpu",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.boxes,
                    i = t.scores,
                    o = r.maxOutputSize,
                    s = r.iouThreshold,
                    u = r.scoreThreshold;
                sge(a, "NonMaxSuppression");
                var c = n.data.get(a.dataId).values,
                    l = n.data.get(i.dataId).values,
                    h = dwe(c, l, o, s, u).selectedIndices;
                return n.makeTensorInfo([h.length], "int32", new Int32Array(h))
            }
        },
        mwe = Kne;
    var gwe = {
            kernelName: k2,
            backendName: "cpu",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.boxes,
                    i = t.scores,
                    o = r.maxOutputSize,
                    s = r.iouThreshold,
                    u = r.scoreThreshold,
                    c = r.padToMaxOutputSize;
                sge(a, "NonMaxSuppressionPadded");
                var l = n.data.get(a.dataId).values,
                    h = n.data.get(i.dataId).values,
                    p = mwe(l, h, o, s, u, c),
                    f = p.selectedIndices,
                    d = p.validOutputs;
                return [n.makeTensorInfo([f.length], "int32", new Int32Array(f)), n.makeTensorInfo([], "int32", new Int32Array([d]))]
            }
        },
        ywe = Xne;
    var bwe = {
        kernelName: w2,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.boxes,
                i = t.scores,
                o = r.maxOutputSize,
                s = r.iouThreshold,
                u = r.scoreThreshold,
                c = r.softNmsSigma;
            sge(a, "NonMaxSuppressionWithScore");
            var l = n.data.get(a.dataId).values,
                h = n.data.get(i.dataId).values,
                p = ywe(l, h, o, s, u, c),
                f = p.selectedIndices,
                d = p.selectedScores;
            return [n.makeTensorInfo([f.length], "int32", new Int32Array(f)), n.makeTensorInfo([d.length], "float32", new Float32Array(d))]
        }
    };
    var xwe = {
        kernelName: N2,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.indices,
                i = r.dtype,
                o = r.depth,
                s = r.onValue,
                u = r.offValue;
            sge(a, "oneHot");
            var c = L$(a.shape),
                l = new Float32Array(c * o);
            l.fill(u);
            for (var h = n.data.get(a.dataId).values, p = 0; p < c; ++p) h[p] >= 0 && h[p] < o && (l[p * o + h[p]] = s);
            return n.makeTensorInfo([].concat(T(a.shape), [o]), i, l)
        }
    };

    function kwe(e) {
        var t = e.inputs,
            n = e.backend,
            r = t.x;
        if ("string" === r.dtype) throw new Error("zerosLike is not supported for string tensors");
        if ("complex64" === r.dtype) {
            var a = yge({
                    inputs: {
                        input: r
                    },
                    backend: n
                }),
                i = kwe({
                    inputs: {
                        x: a
                    },
                    backend: n
                }),
                o = Mxe({
                    inputs: {
                        input: r
                    },
                    backend: n
                }),
                s = kwe({
                    inputs: {
                        x: o
                    },
                    backend: n
                }),
                u = fge({
                    inputs: {
                        real: i,
                        imag: s
                    },
                    backend: n
                });
            return n.disposeIntermediateTensorInfo(a), n.disposeIntermediateTensorInfo(i), n.disposeIntermediateTensorInfo(o), n.disposeIntermediateTensorInfo(s), u
        }
        return Ske({
            backend: n,
            attrs: {
                shape: r.shape,
                value: 0,
                dtype: r.dtype
            }
        })
    }
    var wwe = {
        kernelName: R3,
        backendName: "cpu",
        kernelFunc: kwe
    };
    var Iwe = {
        kernelName: I2,
        backendName: "cpu",
        kernelFunc: function e(t) {
            var n = t.inputs,
                r = t.backend,
                a = n.x;
            if ("string" === a.dtype) throw new Error("onesLike is not supported for string tensors");
            if ("complex64" === a.dtype) {
                var i = yge({
                        inputs: {
                            input: a
                        },
                        backend: r
                    }),
                    o = e({
                        inputs: {
                            x: i
                        },
                        backend: r
                    }),
                    s = Mxe({
                        inputs: {
                            input: a
                        },
                        backend: r
                    }),
                    u = kwe({
                        inputs: {
                            x: s
                        },
                        backend: r
                    }),
                    c = fge({
                        inputs: {
                            real: o,
                            imag: u
                        },
                        backend: r
                    });
                return r.disposeIntermediateTensorInfo(i), r.disposeIntermediateTensorInfo(o), r.disposeIntermediateTensorInfo(s), r.disposeIntermediateTensorInfo(u), c
            }
            return Ske({
                backend: r,
                attrs: {
                    shape: a.shape,
                    value: 1,
                    dtype: a.dtype
                }
            })
        }
    };

    function Nwe(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs.axis;
        if (1 === t.length) return mke({
            inputs: {
                input: t[0]
            },
            backend: n,
            attrs: {
                dim: r
            }
        });
        var a = t[0].shape,
            i = t[0].dtype;
        t.forEach((function(e) {
            D$(a, e.shape, "All tensors passed to stack must have matching shapes"), F$(i === e.dtype, (function() {
                return "All tensors passed to stack must have matching dtypes"
            }))
        }));
        var o = [],
            s = zxe({
                inputs: t.map((function(e) {
                    var t = mke({
                        inputs: {
                            input: e
                        },
                        backend: n,
                        attrs: {
                            dim: r
                        }
                    });
                    return o.push(t), t
                })),
                backend: n,
                attrs: {
                    axis: r
                }
            });
        return o.forEach((function(e) {
            return n.disposeIntermediateTensorInfo(e)
        })), s
    }
    var Swe = {
        kernelName: S2,
        backendName: "cpu",
        kernelFunc: Nwe
    };
    var Twe = {
            kernelName: T2,
            backendName: "cpu",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.paddings,
                    o = r.constantValue;
                sge(a, "pad");
                var s = i.map((function(e, t) {
                        return e[0] + a.shape[t] + e[1]
                    })),
                    u = i.map((function(e) {
                        return e[0]
                    })),
                    c = n.data.get(a.dataId).values,
                    l = L$(a.shape),
                    h = a.shape.length,
                    p = i0(a.shape),
                    f = L$(s),
                    d = s.length,
                    v = i0(s),
                    m = q$(a.dtype, f);
                0 !== o && m.fill(o);
                for (var g = 0; g < l; g++) {
                    m[f0(d0(g, h, p).map((function(e, t) {
                        return e + u[t]
                    })), d, v)] = c[g]
                }
                return {
                    dataId: n.write(m, s, a.dtype),
                    shape: s,
                    dtype: a.dtype
                }
            }
        },
        Ewe = pge((function(e, t) {
            return Math.pow(e, t)
        })),
        Cwe = Ige(E2, Ewe),
        Awe = {
            kernelName: E2,
            backendName: "cpu",
            kernelFunc: Cwe
        };
    var Rwe = {
        kernelName: R2,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.paramsNestedSplits,
                i = t.paramsDenseValues,
                o = t.indices,
                s = (r.outputRaggedRank, a.map((function(e) {
                    return n.data.get(e.dataId).values
                }))),
                u = a.map((function(e) {
                    return e.shape
                })),
                c = n.data.get(i.dataId).values,
                l = n.data.get(o.dataId).values,
                h = S(jye(s, u, c, i.shape, i.dtype, l, o.shape), 3),
                p = h[0],
                f = h[1],
                d = h[2],
                v = p.map((function(e) {
                    return n.makeTensorInfo([e.length], "int32", e)
                })),
                m = n.makeTensorInfo(d, i.dtype, f);
            return v.concat([m])
        }
    };
    var _we = {
        kernelName: _2,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = t.starts,
                a = t.limits,
                i = t.deltas,
                o = n.data.get(r.dataId).values,
                s = n.data.get(a.dataId).values,
                u = n.data.get(i.dataId).values,
                c = S(qye(o, r.shape, r.dtype, s, a.shape, u, i.shape), 2),
                l = c[0],
                h = c[1];
            return [n.makeTensorInfo([l.length], "int32", l), n.makeTensorInfo([h.length], r.dtype, h)]
        }
    };
    var Owe = {
        kernelName: O2,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.shape,
                i = t.values,
                o = t.defaultValue,
                s = t.rowPartitionTensors,
                u = r.rowPartitionTypes,
                c = n.data.get(a.dataId).values,
                l = n.data.get(i.dataId).values,
                h = n.data.get(o.dataId).values,
                p = s.map((function(e) {
                    return n.data.get(e.dataId).values
                })),
                f = s.map((function(e) {
                    return e.shape
                })),
                d = S(Zye(c, a.shape, l, i.shape, i.dtype, h, o.shape, p, f, u), 2),
                v = d[0],
                m = d[1];
            return n.makeTensorInfo(v, i.dtype, m)
        }
    };
    var Fwe = {
            kernelName: F2,
            backendName: "cpu",
            kernelFunc: function(e) {
                var t = e.backend,
                    n = e.attrs,
                    r = n.start,
                    a = n.stop,
                    i = n.dtype,
                    o = Qye(r, a, n.step, i);
                return t.makeTensorInfo([o.length], i, o)
            }
        },
        Dwe = Mge(M2, (function(e) {
            return 1 / e
        })),
        Mwe = {
            kernelName: M2,
            backendName: "cpu",
            kernelFunc: Dwe
        };
    var Lwe = {
        kernelName: W2,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.images,
                i = r.alignCorners,
                o = r.halfPixelCenters,
                s = r.size;
            sge(a, "resizeBilinear");
            for (var u = i0(a.shape), c = S(s, 2), l = c[0], h = c[1], p = S(a.shape, 4), f = p[0], d = p[1], v = p[2], m = p[3], g = n.data.get(a.dataId).values, y = new Float32Array(L$([f, l, h, m])), b = [i && l > 1 ? d - 1 : d, i && h > 1 ? v - 1 : v], x = [i && l > 1 ? l - 1 : l, i && h > 1 ? h - 1 : h], k = 0, w = b[0] / x[0], I = b[1] / x[1], N = 0; N < f; N++)
                for (var T = 0; T < l; T++) {
                    var E = void 0;
                    E = o ? w * (T + .5) - .5 : w * T;
                    for (var C = Math.max(0, Math.floor(E)), A = E - C, R = Math.min(d - 1, Math.ceil(E)), _ = N * u[0] + C * u[1], O = N * u[0] + R * u[1], F = 0; F < h; F++) {
                        var D = void 0;
                        D = o ? I * (F + .5) - .5 : I * F;
                        for (var M = Math.max(0, Math.floor(D)), L = D - M, z = Math.min(v - 1, Math.ceil(D)), P = _ + M * u[2], B = O + M * u[2], W = _ + z * u[2], U = O + z * u[2], V = 0; V < m; V++) {
                            var G = g[P + V],
                                j = g[B + V],
                                H = G + (g[W + V] - G) * L,
                                q = H + (j + (g[U + V] - j) * L - H) * A;
                            y[k++] = q
                        }
                    }
                }
            return n.makeTensorInfo([f, l, h, m], "float32", y)
        }
    };
    var zwe = {
        kernelName: U2,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.images,
                i = t.dy,
                o = r.alignCorners;
            sge([i, a], "resizeBilinearGrad");
            for (var s = i0(a.shape), u = S(a.shape, 4), c = u[0], l = u[1], h = u[2], p = u[3], f = S(i.shape, 3), d = f[1], v = f[2], m = new Float32Array(c * l * h * p), g = [o && d > 1 ? l - 1 : l, o && v > 1 ? h - 1 : h], y = [o && d > 1 ? d - 1 : d, o && v > 1 ? v - 1 : v], b = g[0] / y[0], x = g[1] / y[1], k = n.data.get(i.dataId).values, w = 0, I = 0; I < c; I++)
                for (var N = I * s[0], T = 0; T < d; T++)
                    for (var E = T * b, C = Math.floor(E), A = Math.min(Math.ceil(E), l - 1), R = N + C * s[1], _ = N + A * s[1], O = E - C, F = 1 - O, D = 0; D < v; D++)
                        for (var M = D * x, L = Math.floor(M), z = Math.min(Math.ceil(M), h - 1), P = M - L, B = 1 - P, W = R + L * s[2], U = R + z * s[2], V = _ + L * s[2], G = _ + z * s[2], j = F * B, H = F * P, q = O * B, K = O * P, X = 0; X < p; X++) {
                            var Y = k[w++];
                            m[W + X] += Y * j, m[U + X] += Y * H, m[V + X] += Y * q, m[G + X] += Y * K
                        }
            return n.makeTensorInfo([c, h, l, p], "float32", m)
        }
    };
    var Pwe = {
        kernelName: P2,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.images,
                i = r.alignCorners,
                o = r.halfPixelCenters,
                s = r.size;
            sge(a, "resizeNearestNeighbor");
            for (var u = i0(a.shape), c = S(s, 2), l = c[0], h = c[1], p = S(a.shape, 4), f = p[0], d = p[1], v = p[2], m = p[3], g = n.data.get(a.dataId).values, y = new Float32Array(f * l * h * m), b = [i && l > 1 ? d - 1 : d, i && h > 1 ? v - 1 : v], x = [i && l > 1 ? l - 1 : l, i && h > 1 ? h - 1 : h], k = b[0] / x[0], w = b[1] / x[1], I = 0, N = 0; N < f; N++)
                for (var T = N * u[0], E = 0; E < l; E++) {
                    var C = o ? k * (E + .5) : k * E,
                        A = Math.min(d - 1, i ? Math.round(C) : Math.floor(C));
                    o && (A = Math.max(0, A));
                    for (var R = T + A * u[1], _ = 0; _ < h; _++) {
                        var O = o ? w * (_ + .5) : w * _,
                            F = Math.min(v - 1, i ? Math.round(O) : Math.floor(O));
                        o && (F = Math.max(0, F));
                        for (var D = R + F * u[2], M = 0; M < m; M++) {
                            var L = g[D + M];
                            y[I++] = L
                        }
                    }
                }
            return n.makeTensorInfo([f, l, h, m], a.dtype, y)
        }
    };
    var Bwe = {
        kernelName: B2,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.images,
                i = t.dy,
                o = r.alignCorners;
            sge([i, a], "resizeNearestNeighborGrad");
            for (var s = i0(a.shape), u = i0(i.shape), c = S(a.shape, 4), l = c[0], h = c[1], p = c[2], f = c[3], d = S(i.shape, 3), v = d[1], m = d[2], g = new Float32Array(l * h * p * f), y = n.data.get(i.dataId).values, b = [o && v > 1 ? h - 1 : h, o && m > 1 ? p - 1 : p], x = [o && v > 1 ? v - 1 : v, o && m > 1 ? m - 1 : m], k = b[0] / x[0], w = b[1] / x[1], I = 1 / k, N = 1 / w, T = 2 * Math.ceil(I) + 2, E = 2 * Math.ceil(N) + 2, C = 0; C < l; C++)
                for (var A = C * s[0], R = 0; R < h; R++)
                    for (var _ = A + R * s[1], O = Math.floor(R * I), F = Math.floor(O - T / 2), D = 0; D < p; D++)
                        for (var M = _ + D * s[2], L = Math.floor(D * N), z = Math.floor(L - E / 2), P = 0; P < f; P++) {
                            for (var B = 0, W = 0; W < T; W++) {
                                var U = W + F;
                                if (!(U < 0 || U >= v)) {
                                    var V = A + U * u[1],
                                        G = U * k;
                                    if (R === Math.min(h - 1, o ? Math.round(G) : Math.floor(G)))
                                        for (var j = 0; j < E; j++) {
                                            var H = j + z;
                                            if (!(H < 0 || H >= m)) {
                                                var q = V + H * u[2],
                                                    K = H * w;
                                                D === Math.min(p - 1, o ? Math.round(K) : Math.floor(K)) && (B += y[q + P])
                                            }
                                        }
                                }
                            }
                            g[M + P] = B
                        }
            return n.makeTensorInfo(a.shape, a.dtype, g)
        }
    };
    var Wwe = {
            kernelName: G2,
            backendName: "cpu",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.dims;
                sge(a, "reverse");
                var o = a.shape.length,
                    s = j$(i, a.shape);
                if (0 === o) return mge({
                    inputs: {
                        x: a
                    },
                    backend: n
                });
                for (var u = new $4(a.shape, a.dtype), c = n.bufferSync(a), l = function() {
                        var e = u.indexToLoc(h),
                            t = e.slice();
                        s.forEach((function(e) {
                            return t[e] = a.shape[e] - 1 - t[e]
                        })), u.set.apply(u, [c.get.apply(c, T(t))].concat(T(e)))
                    }, h = 0; h < u.size; h++) l();
                return n.makeTensorInfo(u.shape, u.dtype, u.values)
            }
        },
        Uwe = {
            kernelName: F3,
            backendName: "cpu",
            kernelFunc: function(e) {
                for (var t = e.inputs, n = e.attrs, r = e.backend, a = t.image, i = n.radians, o = n.fillValue, s = n.center, u = r, c = q$(a.dtype, L$(a.shape)), l = S(a.shape, 4), h = l[0], p = l[1], f = l[2], d = l[3], v = S(pie(s, p, f), 2), m = v[0], g = v[1], y = Math.sin(i), b = Math.cos(i), x = u.data.get(a.dataId).values, k = 0; k < h; k++)
                    for (var w = k * f * p * d, I = 0; I < p; I++)
                        for (var N = I * (f * d), T = 0; T < f; T++)
                            for (var E = T * d, C = 0; C < d; C++) {
                                var A = [h, I, T, C],
                                    R = A[2],
                                    _ = A[1],
                                    O = (R - m) * b - (_ - g) * y,
                                    F = (R - m) * y + (_ - g) * b;
                                O = Math.round(O + m), F = Math.round(F + g);
                                var D = o;
                                if ("number" != typeof o && (D = 3 === C ? 255 : o[C]), O >= 0 && O < f && F >= 0 && F < p) D = x[w + F * (f * d) + O * d + C];
                                c[w + N + E + C] = D
                            }
                return {
                    dataId: u.write(c, a.shape, a.dtype),
                    shape: a.shape,
                    dtype: a.dtype
                }
            }
        },
        Vwe = Mge(j2, (function(e) {
            var t = Math.floor(e);
            return e - t < .5 ? Math.floor(e) : e - t > .5 ? Math.ceil(e) : t % 2 == 0 ? t : t + 1
        })),
        Gwe = {
            kernelName: j2,
            backendName: "cpu",
            kernelFunc: Vwe
        };
    var jwe = {
        kernelName: q2,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.indices,
                i = t.updates,
                o = r.shape,
                s = Jte(0, a, o),
                u = s.sliceRank,
                c = s.numUpdates,
                l = s.sliceSize,
                h = s.strides,
                p = s.outputSize,
                f = nbe(n.bufferSync(a), n.bufferSync(i), o, p, l, c, u, h, 0, !0);
            return n.makeTensorInfo(o, f.dtype, f.values)
        }
    };

    function Hwe(e, t) {
        for (var n = 0, r = e.length, a = 0; n < r;) e[a = Math.floor((n + r) / 2)] < t ? n = a + 1 : r = a;
        return r
    }

    function qwe(e, t) {
        for (var n = 0, r = e.length, a = 0; n < r;) e[a = Math.floor((n + r) / 2)] <= t ? n = a + 1 : r = a;
        return r
    }
    var Kwe = {
        kernelName: X2,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.sortedSequence,
                i = t.values,
                o = r.side,
                s = function(e, t, n, r, a, i) {
                    for (var o = K$("int32", n * a), s = 0; s < n; ++s)
                        for (var u = e.slice(s * r, (s + 1) * r), c = s * a, l = 0; l < a; ++l) o[c + l] = "left" === i ? Hwe(u, t[l + c]) : qwe(u, t[l + c]);
                    return o
                }(n.data.get(a.dataId).values, n.data.get(i.dataId).values, a.shape[0], a.shape[1], i.shape[1], o);
            return n.makeTensorInfo(i.shape, "int32", s)
        }
    };
    var Xwe = {
            kernelName: Y2,
            backendName: "cpu",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = t.condition,
                    a = t.t,
                    i = t.e;
                sge([r, a, i], "select");
                for (var o = r.shape.length, s = n.data.get(r.dataId).values, u = n.data.get(a.dataId).values, c = n.data.get(i.dataId).values, l = h5(a.dtype, i.dtype), h = l0(L$(a.shape), l), p = 0, f = 0 === o || o > 1 || 1 === a.shape.length ? 1 : L$(a.shape.slice(1)), d = 0; d < s.length; d++)
                    for (var v = 0; v < f; v++) 1 === s[d] ? h[p++] = u[d] : h[p++] = c[d];
                return n.makeTensorInfo(a.shape, l, h)
            }
        },
        Ywe = Mge(J2, (function(e) {
            return e >= 0 ? 1.0507009873554805 * e : 1.7580993408473768 * (Math.exp(e) - 1)
        })),
        Jwe = {
            kernelName: J2,
            backendName: "cpu",
            kernelFunc: Ywe
        },
        Zwe = Mge(e3, (function(e) {
            return e < 0 ? -1 : e > 0 ? 1 : 0
        })),
        Qwe = {
            kernelName: e3,
            backendName: "cpu",
            kernelFunc: Zwe
        },
        $we = Mge(Q2, (function(e) {
            return Math.sin(e)
        })),
        eIe = {
            kernelName: Q2,
            backendName: "cpu",
            kernelFunc: $we
        },
        tIe = Mge($2, (function(e) {
            return Math.sinh(e)
        })),
        nIe = {
            kernelName: $2,
            backendName: "cpu",
            kernelFunc: tIe
        },
        rIe = Math.log(1.1920928955078125e-7) + 2,
        aIe = Mge(n3, (function(e) {
            var t = e > -rIe,
                n = e < rIe,
                r = Math.exp(e);
            return n ? r : t ? e : Math.log(1 + r)
        })),
        iIe = {
            kernelName: n3,
            backendName: "cpu",
            kernelFunc: aIe
        };
    var oIe = {
        kernelName: i3,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = r.blockShape,
                o = r.paddings;
            sge([a], "spaceToBatchND");
            var s = L$(i),
                u = [
                    [0, 0]
                ];
            u.push.apply(u, T(o));
            for (var c = 1 + i.length; c < a.shape.length; ++c) u.push([0, 0]);
            var l = Twe.kernelFunc({
                    inputs: {
                        x: a
                    },
                    backend: n,
                    attrs: {
                        paddings: u,
                        constantValue: 0
                    }
                }),
                h = fie(l.shape, i, s, !1),
                p = die(h.length, i.length, !1),
                f = vie(l.shape, i, s, !1),
                d = Jbe({
                    inputs: {
                        x: l
                    },
                    backend: n,
                    attrs: {
                        shape: h
                    }
                }),
                v = zye({
                    inputs: {
                        x: d
                    },
                    backend: n,
                    attrs: {
                        perm: p
                    }
                }),
                m = Jbe({
                    inputs: {
                        x: v
                    },
                    backend: n,
                    attrs: {
                        shape: f
                    }
                });
            return n.disposeIntermediateTensorInfo(l), n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(v), m
        }
    };
    var sIe = {
        kernelName: u3,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = t.indices,
                a = t.values,
                i = t.denseShape,
                o = t.defaultValue;
            if (1 !== i.shape.length) throw new Error("Dense shape must be a vector, saw:\n        ".concat(i.shape));
            if (2 !== r.shape.length) throw new Error("Indices must be a matrix, saw:\n        ".concat(r.shape));
            if (1 !== a.shape.length) throw new Error("Values must be a vector, saw:\n        ".concat(a.shape));
            if (0 !== o.shape.length) throw new Error("Default value must be a scalar, saw:\n        ".concat(o.shape));
            var s = n.data.get(r.dataId).values,
                u = n.data.get(a.dataId).values,
                c = n.data.get(i.dataId).values,
                l = n.data.get(o.dataId).values[0],
                h = S(cbe(s, r.shape, r.dtype, u, a.dtype, c, l), 5),
                p = h[0],
                f = h[1],
                d = h[2],
                v = h[3],
                m = h[4];
            return [n.makeTensorInfo(f, r.dtype, p), n.makeTensorInfo([f[0]], a.dtype, d), n.makeTensorInfo([v.length], "bool", new Uint8Array(v.map((function(e) {
                return Number(e)
            })))), n.makeTensorInfo([m.length], r.dtype, new Int32Array(m))]
        }
    };
    var uIe = {
        kernelName: c3,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = t.inputIndices,
                a = t.inputShape,
                i = t.newShape;
            if (2 !== r.shape.length) throw new Error("Input indices should be a matrix but received shape\n        ".concat(r.shape));
            if (1 !== a.shape.length) throw new Error("Input shape should be a vector but received shape\n        ".concat(a.shape));
            if (1 !== i.shape.length) throw new Error("Target shape should be a vector but received shape ".concat(i.shape));
            var o = Array.from(n.data.get(a.dataId).values),
                s = n.data.get(r.dataId).values,
                u = Array.from(n.data.get(i.dataId).values),
                c = S(lbe(s, r.shape, r.dtype, o, u), 3),
                l = c[0],
                h = c[1],
                p = c[2];
            return [n.makeTensorInfo(h, r.dtype, l), n.makeTensorInfo([p.length], i.dtype, new Int32Array(p))]
        }
    };
    var cIe = {
        kernelName: l3,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = t.data,
                a = t.indices,
                i = t.segmentIds;
            if (r.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
            if (1 !== a.shape.length) throw new Error("Indices should be a vector but received shape\n          ".concat(a.shape));
            if (1 !== i.shape.length) throw new Error("Segment ids should be a vector but received shape\n          ".concat(i.shape));
            if (a.shape[0] !== i.shape[0]) throw new Error("segmentIds and indices should have same size.");
            var o = n.data.get(r.dataId).values,
                s = n.data.get(a.dataId).values,
                u = n.data.get(i.dataId).values,
                c = S(hbe(o, r.shape, r.dtype, s, u, !0), 2),
                l = c[0],
                h = c[1];
            return n.makeTensorInfo(h, r.dtype, l)
        }
    };
    var lIe = {
        kernelName: h3,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = t.data,
                a = t.indices,
                i = t.segmentIds;
            if (r.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
            if (1 !== a.shape.length) throw new Error("Indices should be a vector but received shape\n         ".concat(a.shape));
            if (1 !== i.shape.length) throw new Error("Segment ids should be a vector but received shape\n         ".concat(i.shape));
            if (a.shape[0] !== i.shape[0]) throw new Error("segmentIds and indices should have same size.");
            var o = n.data.get(r.dataId).values,
                s = n.data.get(a.dataId).values,
                u = n.data.get(i.dataId).values,
                c = S(hbe(o, r.shape, r.dtype, s, u), 2),
                l = c[0],
                h = c[1];
            return n.makeTensorInfo(h, r.dtype, l)
        }
    };
    var hIe = {
        kernelName: p3,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t, n = e.inputs,
                r = e.backend,
                a = e.attrs,
                i = n.sparseIndices,
                o = n.sparseValues,
                s = n.defaultValue,
                u = a.outputShape,
                c = Jte(0, i, u),
                l = c.sliceRank,
                h = c.numUpdates,
                p = c.sliceSize,
                f = c.strides,
                d = c.outputSize,
                v = !1,
                m = r.bufferSync(i);
            switch (o.dtype) {
                case "bool":
                    t = nbe(m, r.bufferSync(o), u, d, p, h, l, f, Boolean(r.data.get(s.dataId).values[0]), v);
                    break;
                case "float32":
                    t = nbe(m, r.bufferSync(o), u, d, p, h, l, f, r.data.get(s.dataId).values[0], v);
                    break;
                case "int32":
                    t = nbe(m, r.bufferSync(o), u, d, p, h, l, f, r.data.get(s.dataId).values[0], v);
                    break;
                case "string":
                    t = nbe(m, r.bufferSync(o), u, d, p, h, l, f, W4(r.data.get(s.dataId).values[0]), v);
                    break;
                default:
                    throw new Error("Unsupported type ".concat(o.dtype))
            }
            return r.makeTensorInfo(u, t.dtype, t.values)
        }
    };
    var pIe = {
            kernelName: o3,
            backendName: "cpu",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.numOrSizeSplits,
                    o = j$(r.axis, a.shape)[0],
                    s = Vie(a, i, o),
                    u = new Array(a.shape.length).fill(0),
                    c = a.shape.slice();
                return s.map((function(e) {
                    var t = T(c);
                    t[o] = e;
                    var r = sbe({
                        inputs: {
                            x: a
                        },
                        backend: n,
                        attrs: {
                            begin: u,
                            size: t
                        }
                    });
                    return u[o] += e, r
                }))
            }
        },
        fIe = {
            kernelName: d3,
            backendName: "cpu",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = t.x,
                    a = n;
                sge(r, "square");
                for (var i = a.data.get(r.dataId).values, o = new Float32Array(i.length), s = 0; s < i.length; ++s) {
                    var u = i[s];
                    o[s] = u * u
                }
                return {
                    dataId: a.write(o, r.shape, r.dtype),
                    shape: r.shape,
                    dtype: r.dtype
                }
            }
        },
        dIe = Mge(_3, (function(e, t) {
            var n = t;
            return isNaN(e) ? NaN : e > 0 ? 1 : n.alpha
        })),
        vIe = {
            kernelName: _3,
            backendName: "cpu",
            kernelFunc: dIe
        };
    var mIe = {
        kernelName: m3,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = r.begin,
                o = r.end,
                s = r.strides,
                u = r.beginMask,
                c = r.endMask,
                l = r.ellipsisMask,
                h = r.newAxisMask,
                p = r.shrinkAxisMask;
            sge(a, "stridedSlice");
            var f, d = Jae(a.shape, i, o, s, u, c, l, h, p),
                v = d.finalShapeSparse,
                m = d.finalShape,
                g = d.isIdentity,
                y = d.sliceDim0,
                b = d.isSimpleSlice,
                x = d.begin,
                k = d.end,
                w = d.strides;
            if (g) f = Jbe({
                inputs: {
                    x: a
                },
                backend: n,
                attrs: {
                    shape: m
                }
            });
            else if (y || b) {
                F$(a.shape.length >= 1, (function() {
                    return "Input must have rank at least 1, got: ".concat(a.shape.length)
                }));
                var I = Pae(x, k, w),
                    N = sbe({
                        inputs: {
                            x: a
                        },
                        backend: n,
                        attrs: {
                            begin: x,
                            size: I
                        }
                    });
                f = Jbe({
                    inputs: {
                        x: N
                    },
                    backend: n,
                    attrs: {
                        shape: m
                    }
                }), n.disposeIntermediateTensorInfo(N)
            } else {
                var S = kbe(v, n.bufferSync(a), w, x);
                f = n.makeTensorInfo(m, S.dtype, S.values)
            }
            return f
        }
    };
    var gIe = {
        kernelName: g3,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = r.separator,
                i = r.nGramWidths,
                o = r.leftPad,
                s = r.rightPad,
                u = r.padWidth,
                c = r.preserveShortSequences,
                l = t.data,
                h = t.dataSplits,
                p = S(Ibe(n.data.get(l.dataId).values, n.data.get(h.dataId).values, a, i, o, s, u, c), 2),
                f = p[0],
                d = p[1];
            return [n.makeTensorInfo([f.length], "string", f), n.makeTensorInfo(h.shape, "int32", d)]
        }
    };
    var yIe = {
        kernelName: y3,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs.skipEmpty,
                a = t.input,
                i = t.delimiter;
            if ("string" !== a.dtype) throw new Error("Input must be of datatype string");
            if (1 !== a.shape.length) throw new Error("Input must be a vector, got shape: ".concat(a.shape));
            if (0 !== i.shape.length) throw new Error("Delimiter must be a scalar, got shape: ".concat(i.shape));
            var o = S(Sbe(n.data.get(a.dataId).values, n.data.get(i.dataId).values[0], r), 3),
                s = o[0],
                u = o[1],
                c = o[2],
                l = u.length;
            return [n.makeTensorInfo([l, 2], "int32", s), n.makeTensorInfo([l], "string", u), n.makeTensorInfo([2], "int32", new Int32Array(c))]
        }
    };
    var bIe = {
            kernelName: b3,
            backendName: "cpu",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs.numBuckets,
                    a = t.input;
                if ("string" !== a.dtype) throw new Error("Input must be of datatype string");
                if (r <= 0) throw new Error("Number of buckets must be at least 1");
                var i = Tbe(n.data.get(a.dataId).values, r);
                return n.makeTensorInfo(a.shape, "int32", i)
            }
        },
        xIe = Mge(k3, (function(e) {
            return Math.tan(e)
        })),
        kIe = {
            kernelName: k3,
            backendName: "cpu",
            kernelFunc: xIe
        },
        wIe = Mge(w3, (function(e) {
            return Math.tanh(e)
        }));
    var IIe = {
        kernelName: K2,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = t.tensor,
                a = t.indices,
                i = t.updates,
                o = Jte(0, a, r.shape),
                s = o.sliceRank,
                u = o.numUpdates,
                c = o.sliceSize,
                l = o.strides,
                h = o.outputSize,
                p = n.bufferSync(a),
                f = n.bufferSync(i),
                d = n.bufferSync(r),
                v = nbe(p, f, r.shape, h, c, u, s, l, d, !1);
            return n.makeTensorInfo(r.shape, v.dtype, v.values)
        }
    };
    var NIe = {
        kernelName: I3,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = r.reps;
            sge(a, "tile");
            var o = _be(n.bufferSync(a), i);
            return n.makeTensorInfo(o.shape, o.dtype, o.values)
        }
    };
    var SIe = {
        kernelName: N3,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = r.k,
                o = r.sorted;
            sge(a, "topk");
            var s = S(Dbe(n.data.get(a.dataId).values, a.shape, a.dtype, i, o), 2),
                u = s[0],
                c = s[1];
            return [n.makeTensorInfo(u.shape, u.dtype, u.values), n.makeTensorInfo(c.shape, c.dtype, c.values)]
        }
    };
    var TIe = {
        kernelName: S3,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.attrs,
                r = e.backend,
                a = t.image,
                i = t.transforms,
                o = n.interpolation,
                s = n.fillMode,
                u = n.fillValue,
                c = n.outputShape,
                l = S(a.shape, 4),
                h = l[0],
                p = l[1],
                f = l[2],
                d = l[3],
                v = S(null != c ? c : [p, f], 2),
                m = v[0],
                g = v[1],
                y = [h, m, g, d],
                b = i0(a.shape),
                x = b[0],
                k = b[1],
                w = b[2],
                I = i0(y),
                N = I[0],
                T = I[1],
                E = I[2],
                C = q$(a.dtype, L$(y));
            C.fill(u);
            for (var A = r.data.get(a.dataId).values, R = r.data.get(i.dataId).values, _ = 0; _ < h; ++_) {
                for (var O = 1 === i.shape[0] ? R : R.subarray(8 * _, 8 * _ + 8), F = 0; F < m; ++F)
                    for (var D = 0; D < g; ++D)
                        for (var M = 0; M < d; ++M) {
                            var L = void 0,
                                z = O[6] * D + O[7] * F + 1;
                            if (0 !== z) {
                                var P = (O[0] * D + O[1] * F + O[2]) / z,
                                    B = (O[3] * D + O[4] * F + O[5]) / z,
                                    W = EIe(P, f, s),
                                    U = EIe(B, p, s);
                                switch (o) {
                                    case "nearest":
                                        L = AIe(A, p, f, x, k, w, _, U, W, M, u);
                                        break;
                                    case "bilinear":
                                        L = RIe(A, p, f, x, k, w, _, U, W, M, u);
                                        break;
                                    default:
                                        throw new Error("Error in Transform: Expect 'nearest' or " + "'bilinear', but got ".concat(o))
                                }
                                C[_ * N + F * T + D * E + M] = L
                            }
                        }
                return r.makeTensorInfo(y, a.dtype, C)
            }
            return {
                dataId: r.write(C, y, a.dtype),
                shape: a.shape,
                dtype: a.dtype
            }
        }
    };

    function EIe(e, t, n) {
        switch (n) {
            case "reflect":
                return function(e, t) {
                    var n = e;
                    if (n < 0)
                        if (t <= 1) n = 0;
                        else {
                            var r = 2 * t;
                            n < r && (n = r * Math.trunc(-n / r) + n), n = n < -t ? n + r : -n - 1
                        } else if (n > t - 1)
                        if (t <= 1) n = 0;
                        else {
                            var a = 2 * t;
                            (n -= a * Math.trunc(n / a)) >= t && (n = a - n - 1)
                        }
                    return A$(0, n, t - 1)
                }(e, t);
            case "wrap":
                return function(e, t) {
                    var n = e;
                    if (n < 0)
                        if (t <= 1) n = 0;
                        else {
                            var r = t - 1;
                            n += t * (Math.trunc(-n / r) + 1)
                        } else if (n > t - 1)
                        if (t <= 1) n = 0;
                        else {
                            var a = t - 1;
                            n -= t * Math.trunc(n / a)
                        }
                    return A$(0, n, t - 1)
                }(e, t);
            case "nearest":
                return function(e, t) {
                    return A$(0, e, t - 1)
                }(e, t);
            default:
                return function(e, t) {
                    return e
                }(e)
        }
    }

    function CIe(e, t, n, r, a, i, o, s, u, c, l) {
        return 0 <= s && s < t && 0 <= u && u < n ? e[o * r + s * a + u * i + c] : l
    }

    function AIe(e, t, n, r, a, i, o, s, u, c, l) {
        return CIe(e, t, n, r, a, i, o, Math.round(s), Math.round(u), c, l)
    }

    function RIe(e, t, n, r, a, i, o, s, u, c, l) {
        var h = Math.floor(s),
            p = Math.floor(u),
            f = h + 1,
            d = p + 1;
        return (f - s) * ((d - u) * CIe(e, t, n, r, a, i, o, h, p, c, l) + (u - p) * CIe(e, t, n, r, a, i, o, h, d, c, l)) + (s - h) * ((d - u) * CIe(e, t, n, r, a, i, o, f, p, c, l) + (u - p) * CIe(e, t, n, r, a, i, o, f, d, c, l))
    }
    var _Ie = {
        kernelName: E3,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.attrs,
                r = e.backend,
                a = n.axis,
                i = t.x;
            sge(i, "unique");
            var o = Mbe(r.data.get(i.dataId).values, a, i.shape, i.dtype),
                s = o.outputValues,
                u = o.outputShape,
                c = o.indices;
            return [r.makeTensorInfo(u, i.dtype, s), r.makeTensorInfo([c.length], "int32", c)]
        }
    };
    var OIe = {
        kernelName: C3,
        backendName: "cpu",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.value,
                i = r.axis;
            i < 0 && (i += a.shape.length);
            for (var o = a.shape.length, s = a.shape[i], u = new Array(o - 1), c = 0, l = 0; l < o; l++) l !== i && (u[c++] = a.shape[l]);
            var h = new Array(o).fill(0),
                p = a.shape.slice();
            p[i] = 1;
            for (var f = new Array(s), d = 0; d < f.length; d++) {
                h[i] = d;
                var v = sbe({
                    inputs: {
                        x: a
                    },
                    backend: n,
                    attrs: {
                        begin: h,
                        size: p
                    }
                });
                f[d] = Jbe({
                    inputs: {
                        x: v
                    },
                    backend: n,
                    attrs: {
                        shape: u
                    }
                }), n.disposeIntermediateTensorInfo(v)
            }
            return f
        }
    };
    for (var FIe = {
            kernelName: A3,
            backendName: "cpu",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.segmentIds,
                    o = r.numSegments;
                sge(a, "unsortedSegmentSum");
                for (var s = [], u = [], c = a.shape.length - i.shape.length, l = i, h = 0; h < c; ++h) {
                    var p = mke({
                        inputs: {
                            input: l
                        },
                        backend: n,
                        attrs: {
                            dim: h + 1
                        }
                    });
                    l = p, u.push(p)
                }
                for (var f = 0; f < o; ++f) {
                    var d = M4(f, "int32"),
                        v = n.makeTensorInfo([], "int32", d),
                        m = Vge({
                            inputs: {
                                a: v,
                                b: l
                            },
                            backend: n
                        }),
                        g = kge({
                            inputs: {
                                x: m
                            },
                            backend: n,
                            attrs: {
                                dtype: "float32"
                            }
                        }),
                        y = Aye({
                            inputs: {
                                a: g,
                                b: a
                            },
                            backend: n
                        }),
                        b = lke({
                            inputs: {
                                x: y
                            },
                            backend: n,
                            attrs: {
                                axis: 0,
                                keepDims: !1
                            }
                        });
                    s.push(b), u.push(v), u.push(m), u.push(g), u.push(y), u.push(b)
                }
                var x = Nwe({
                    inputs: s,
                    backend: n,
                    attrs: {
                        axis: 0
                    }
                });
                return u.forEach((function(e) {
                    return n.disposeIntermediateTensorInfo(e)
                })), x
            }
        }, DIe = 0, MIe = [exe, hge, nxe, axe, Cge, ixe, oxe, sxe, uxe, cxe, hxe, fxe, vxe, yxe, xxe, Nxe, Sxe, Txe, Exe, $be, Cxe, Axe, Rxe, Fge, _xe, wge, Bge, Fxe, dge, Dxe, Pxe, Wxe, Uxe, Vxe, Gxe, jxe, Hxe, Kxe, Yxe, Jxe, Zxe, Qxe, $xe, eke, nke, rke, ake, ike, oke, ske, uke, cke, pke, Bbe, fke, Gge, vke, qge, gke, Yge, Nke, Tke, Eke, Qge, tye, Cke, Ake, Rke, _ke, oye, cye, gge, Oke, Lxe, Dke, Lke, Pke, Ube, pye, vye, Bke, bye, Uke, jke, qke, Yke, Jke, Zke, $ke, Iye, ewe, twe, nwe, rwe, awe, iwe, owe, Tye, swe, lwe, fwe, Rye, Oye, vwe, gwe, bwe, Mye, xwe, Iwe, Swe, Twe, Awe, jbe, Wye, Rwe, _we, Owe, Fwe, bge, xke, Mwe, qbe, Xbe, Zbe, Lwe, zwe, Pwe, Bwe, Wwe, Uwe, Gwe, tbe, jwe, Kwe, Xwe, Jwe, ibe, Qwe, eIe, nIe, ube, pwe, iIe, oIe, sIe, uIe, cIe, lIe, hIe, pIe, dbe, fIe, gbe, xbe, vIe, mIe, gIe, yIe, bIe, Rbe, hke, kIe, {
            kernelName: w3,
            backendName: "cpu",
            kernelFunc: wIe
        }, IIe, NIe, SIe, TIe, Pye, _Ie, OIe, FIe, wwe]; DIe < MIe.length; DIe++) {
        G3(MIe[DIe])
    }
    var LIe, zIe, PIe, BIe = {},
        WIe = {
            alpha: !1,
            antialias: !1,
            premultipliedAlpha: !1,
            preserveDrawingBuffer: !1,
            depth: !1,
            stencil: !1,
            failIfMajorPerformanceCaveat: !0
        };

    function UIe(e, t) {
        BIe[e] = t
    }

    function VIe(e, t) {
        if (!(e in BIe) || null != t) {
            var n = function(e, t) {
                if (1 !== e && 2 !== e) throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
                var n = null == t ? function(e) {
                    if (k0().getBool("IS_SAFARI") || "undefined" == typeof OffscreenCanvas || 2 !== e) {
                        if ("undefined" != typeof document) return document.createElement("canvas");
                        throw new Error("Cannot create a canvas in this context")
                    }
                    return new OffscreenCanvas(300, 150)
                }(e) : t;
                n.addEventListener("webglcontextlost", (function(t) {
                    t.preventDefault(), delete BIe[e]
                }), !1), k0().getBool("SOFTWARE_WEBGL_ENABLED") && (WIe.failIfMajorPerformanceCaveat = !1);
                if (1 === e) return n.getContext("webgl", WIe) || n.getContext("experimental-webgl", WIe);
                return n.getContext("webgl2", WIe)
            }(e, t);
            if (null === n) return console.log("Could not get context for WebGL version", e), null;
            BIe[e] = n
        }
        var r = BIe[e];
        return null == r || r.isContextLost() ? (delete BIe[e], VIe(e)) : (r.disable(r.DEPTH_TEST), r.disable(r.STENCIL_TEST), r.disable(r.BLEND), r.disable(r.DITHER), r.disable(r.POLYGON_OFFSET_FILL), r.disable(r.SAMPLE_COVERAGE), r.enable(r.SCISSOR_TEST), r.enable(r.CULL_FACE), r.cullFace(r.BACK), BIe[e])
    }

    function GIe(e, t) {
        return [t, e]
    }

    function jIe(e) {
        var t = L$(e);
        return W$(Math.ceil(t / 4))
    }

    function HIe(e, t) {
        return [Math.max(1, Math.ceil(t / 2)), Math.max(1, Math.ceil(e / 2))]
    }

    function qIe(e, t) {
        var n, r, a, i, o, s, u, c, l, h, p = e;
        return 2 === k0().getNumber("WEBGL_VERSION") ? (n = p.R32F, r = p.R16F, a = p.RGBA16F, i = p.RGBA32F, o = p.RED, u = 4, c = 1, l = p.HALF_FLOAT, h = p.FLOAT, s = p.RGBA8) : (n = e.RGBA, r = e.RGBA, a = e.RGBA, i = p.RGBA, o = e.RGBA, u = 4, c = 4, l = null != t ? t.HALF_FLOAT_OES : null, h = e.FLOAT, s = e.RGBA), {
            internalFormatFloat: n,
            internalFormatHalfFloat: r,
            internalFormatPackedHalfFloat: a,
            internalFormatPackedFloat: i,
            textureFormatFloat: o,
            downloadTextureFormat: s,
            downloadUnpackNumChannels: u,
            defaultNumChannels: c,
            textureTypeHalfFloat: l,
            textureTypeFloat: h
        }
    }

    function KIe(e, t) {
        var n = t();
        return k0().getBool("DEBUG") && function(e) {
            var t = e.getError();
            if (t !== e.NO_ERROR) throw new Error("WebGL Error: " + YIe(e, t))
        }(e), n
    }! function(e) {
        e[e.DENSE = 0] = "DENSE", e[e.SHARED_BATCH = 1] = "SHARED_BATCH"
    }(LIe || (LIe = {})),
    function(e) {
        e[e.RENDER = 0] = "RENDER", e[e.UPLOAD = 1] = "UPLOAD", e[e.PIXELS = 2] = "PIXELS", e[e.DOWNLOAD = 3] = "DOWNLOAD"
    }(zIe || (zIe = {})),
    function(e) {
        e[e.UNPACKED_FLOAT16 = 0] = "UNPACKED_FLOAT16", e[e.UNPACKED_FLOAT32 = 1] = "UNPACKED_FLOAT32", e[e.PACKED_4X1_UNSIGNED_BYTE = 2] = "PACKED_4X1_UNSIGNED_BYTE", e[e.PACKED_2X2_FLOAT32 = 3] = "PACKED_2X2_FLOAT32", e[e.PACKED_2X2_FLOAT16 = 4] = "PACKED_2X2_FLOAT16"
    }(PIe || (PIe = {}));

    function XIe(e) {
        return !!(k0().getBool("WEBGL_RENDER_FLOAT32_ENABLED") || 0 === e || 5.96e-8 < Math.abs(e) && Math.abs(e) < 65504)
    }

    function YIe(e, t) {
        switch (t) {
            case e.NO_ERROR:
                return "NO_ERROR";
            case e.INVALID_ENUM:
                return "INVALID_ENUM";
            case e.INVALID_VALUE:
                return "INVALID_VALUE";
            case e.INVALID_OPERATION:
                return "INVALID_OPERATION";
            case e.INVALID_FRAMEBUFFER_OPERATION:
                return "INVALID_FRAMEBUFFER_OPERATION";
            case e.OUT_OF_MEMORY:
                return "OUT_OF_MEMORY";
            case e.CONTEXT_LOST_WEBGL:
                return "CONTEXT_LOST_WEBGL";
            default:
                return "Unknown error code ".concat(t)
        }
    }

    function JIe(e, t) {
        return xNe(e, (function() {
            return e.getExtension(t)
        }), 'Extension "' + t + '" not supported on this browser.')
    }

    function ZIe(e, t) {
        var n = xNe(e, (function() {
            return e.createShader(e.VERTEX_SHADER)
        }), "Unable to create vertex WebGLShader.");
        if (KIe(e, (function() {
                return e.shaderSource(n, t)
            })), KIe(e, (function() {
                return e.compileShader(n)
            })), !1 === e.getShaderParameter(n, e.COMPILE_STATUS)) throw console.log(e.getShaderInfoLog(n)), new Error("Failed to compile vertex shader.");
        return n
    }

    function QIe(e, t) {
        var n = xNe(e, (function() {
            return e.createShader(e.FRAGMENT_SHADER)
        }), "Unable to create fragment WebGLShader.");
        if (KIe(e, (function() {
                return e.shaderSource(n, t)
            })), KIe(e, (function() {
                return e.compileShader(n)
            })), k0().get("ENGINE_COMPILE_ONLY")) return n;
        if (!1 === e.getShaderParameter(n, e.COMPILE_STATUS)) throw nNe(t, e.getShaderInfoLog(n)), new Error("Failed to compile fragment shader.");
        return n
    }
    var $Ie, eNe, tNe = /ERROR: [0-9]+:([0-9]+):/g;

    function nNe(e, t) {
        var n = tNe.exec(t);
        if (null == n) return console.log("Couldn't parse line number in error: ".concat(t)), void console.log(e);
        for (var r = +n[1], a = e.split("\n"), i = a.length.toString().length + 2, o = a.map((function(e, t) {
                return U$((t + 1).toString(), i) + e
            })), s = 0, u = 0; u < o.length; u++) s = Math.max(o[u].length, s);
        var c = o.slice(0, r - 1),
            l = o.slice(r - 1, r),
            h = o.slice(r);
        console.log(c.join("\n")), console.log(t.split("\n")[0]), console.log("%c ".concat(U$(l[0], s)), "border:1px solid red; background-color:#e3d2d2; color:#a61717"), console.log(h.join("\n"))
    }

    function rNe(e) {
        return xNe(e, (function() {
            return e.createProgram()
        }), "Unable to create WebGLProgram.")
    }

    function aNe(e, t) {
        if (KIe(e, (function() {
                return e.linkProgram(t)
            })), !k0().get("ENGINE_COMPILE_ONLY") && !1 === e.getProgramParameter(t, e.LINK_STATUS)) throw console.log(e.getProgramInfoLog(t)), new Error("Failed to link vertex and fragment shaders.")
    }

    function iNe(e, t) {
        if (KIe(e, (function() {
                return e.validateProgram(t)
            })), !1 === e.getProgramParameter(t, e.VALIDATE_STATUS)) throw console.log(e.getProgramInfoLog(t)), new Error("Shader program validation failed.")
    }

    function oNe(e, t) {
        var n = xNe(e, (function() {
            return e.createBuffer()
        }), "Unable to create WebGLBuffer");
        return KIe(e, (function() {
            return e.bindBuffer(e.ARRAY_BUFFER, n)
        })), KIe(e, (function() {
            return e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW)
        })), n
    }

    function sNe(e, t) {
        var n = xNe(e, (function() {
            return e.createBuffer()
        }), "Unable to create WebGLBuffer");
        return KIe(e, (function() {
            return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, n)
        })), KIe(e, (function() {
            return e.bufferData(e.ELEMENT_ARRAY_BUFFER, t, e.STATIC_DRAW)
        })), n
    }

    function uNe(e) {
        return xNe(e, (function() {
            return e.createTexture()
        }), "Unable to create WebGLTexture.")
    }

    function cNe(e, t) {
        var n = k0().getNumber("WEBGL_MAX_TEXTURE_SIZE");
        if (e <= 0 || t <= 0) {
            var r = "[".concat(e, "x").concat(t, "]");
            throw new Error("Requested texture size " + r + " is invalid.")
        }
        if (e > n || t > n) {
            var a = "[".concat(e, "x").concat(t, "]"),
                i = "[".concat(n, "x").concat(n, "]");
            throw new Error("Requested texture size " + a + " greater than WebGL maximum on this browser / GPU " + i + ".")
        }
    }

    function lNe(e) {
        return xNe(e, (function() {
            return e.createFramebuffer()
        }), "Unable to create WebGLFramebuffer.")
    }

    function hNe(e, t, n, r, a, i, o) {
        var s = e.getAttribLocation(t, n);
        return -1 !== s && (KIe(e, (function() {
            return e.bindBuffer(e.ARRAY_BUFFER, r)
        })), KIe(e, (function() {
            return e.vertexAttribPointer(s, a, e.FLOAT, !1, i, o)
        })), KIe(e, (function() {
            return e.enableVertexAttribArray(s)
        })), !0)
    }

    function pNe(e, t, n) {
        kNe(e, n), KIe(e, (function() {
            return e.activeTexture(e.TEXTURE0 + n)
        })), KIe(e, (function() {
            return e.bindTexture(e.TEXTURE_2D, t)
        }))
    }

    function fNe(e, t, n) {
        return xNe(e, (function() {
            return e.getUniformLocation(t, n)
        }), 'uniform "' + n + '" not present in program.')
    }

    function dNe(e, t, n) {
        return e.getUniformLocation(t, n)
    }

    function vNe(e, t, n, r) {
        KIe(e, (function() {
            return pNe(e, t, r)
        })), KIe(e, (function() {
            return e.uniform1i(n, r)
        }))
    }

    function mNe(e, t, n) {
        KIe(e, (function() {
            return e.bindFramebuffer(e.FRAMEBUFFER, n)
        })), KIe(e, (function() {
            return e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0)
        }))
    }

    function gNe(e, t) {
        KIe(e, (function() {
            return e.bindFramebuffer(e.FRAMEBUFFER, t)
        })), KIe(e, (function() {
            return e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, null, 0)
        }))
    }

    function yNe(e) {
        var t = e.checkFramebufferStatus(e.FRAMEBUFFER);
        if (t !== e.FRAMEBUFFER_COMPLETE) throw new Error("Error binding framebuffer: " + bNe(e, t))
    }

    function bNe(e, t) {
        switch (t) {
            case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
            case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
            case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
            case e.FRAMEBUFFER_UNSUPPORTED:
                return "FRAMEBUFFER_UNSUPPORTED";
            default:
                return "unknown error ".concat(t)
        }
    }

    function xNe(e, t, n) {
        var r = KIe(e, (function() {
            return t()
        }));
        if (null == r) throw new Error(n);
        return r
    }

    function kNe(e, t) {
        var n = e.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1,
            r = t + e.TEXTURE0;
        if (r < e.TEXTURE0 || r > n) {
            var a = "[gl.TEXTURE0, gl.TEXTURE".concat(n, "]");
            throw new Error("textureUnit must be in ".concat(a, "."))
        }
    }

    function wNe(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2;
        return L$(e.slice(0, e.length - t))
    }

    function INe(e) {
        if (0 === e.length) throw Error("Cannot get rows and columns of an empty shape array.");
        return [e.length > 1 ? e[e.length - 2] : 1, e[e.length - 1]]
    }

    function NNe(e) {
        var t = [1, 1, 1];
        return 0 === e.length || 1 === e.length && 1 === e[0] || (t = [wNe(e)].concat(T(INe(e)))), t
    }

    function SNe(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
            n = k0().getNumber("WEBGL_MAX_TEXTURE_SIZE"),
            r = k0().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");
        if (r === 1 / 0 && k0().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE") && (r = n / 2), t && (n *= 2, r *= 2, 1 === (e = e.map((function(t, n) {
                return n >= e.length - 2 ? R$(e[n]) : e[n]
            }))).length && (e = [2, e[0]])), 2 !== e.length) {
            var a = H$(e);
            e = a.newShape
        }
        var i = L$(e),
            o = null;
        e.length <= 1 && i <= n ? o = [1, i] : 2 === e.length && e[0] <= n && e[1] <= n ? o = e : 3 === e.length && e[0] * e[1] <= n && e[2] <= n ? o = [e[0] * e[1], e[2]] : 3 === e.length && e[0] <= n && e[1] * e[2] <= n ? o = [e[0], e[1] * e[2]] : 4 === e.length && e[0] * e[1] * e[2] <= n && e[3] <= n ? o = [e[0] * e[1] * e[2], e[3]] : 4 === e.length && e[0] <= n && e[1] * e[2] * e[3] <= n && (o = [e[0], e[1] * e[2] * e[3]]);
        var s = null != o && Math.max.apply(Math, T(o)) > r && Math.min.apply(Math, T(o)) <= (t ? 2 : 1) && Math.min.apply(Math, T(o)) > 0;
        if (null == o || s)
            if (t) {
                var u = wNe(e),
                    c = 2,
                    l = 2;
                if (e.length) {
                    var h = INe(e),
                        p = S(h, 2);
                    c = p[0], l = p[1]
                }
                o = W$(i = u * (c / 2) * (l / 2)).map((function(e) {
                    return 2 * e
                }))
            } else o = W$(i);
        return o
    }

    function TNe(e) {
        return e % 2 == 0
    }

    function ENe(e, t) {
        if (P$(e = e.slice(-2), t = t.slice(-2))) return !0;
        if (!e.length || !t.length) return !0;
        if (0 === e[0] || 0 === e[1] || 0 === t[0] || 0 === t[1]) return !0;
        if (e.length !== t.length) {
            var n = e[e.length - 1],
                r = t[t.length - 1];
            if (n === r) return !0;
            if (TNe(n) && TNe(r) && (1 === e[0] || 1 === t[0])) return !0
        }
        return e[1] === t[1] && TNe(e[0]) && TNe(t[0])
    }

    function CNe(e) {
        if (null == $Ie) {
            var t = VIe(e);
            $Ie = t.getParameter(t.MAX_TEXTURE_SIZE)
        }
        return $Ie
    }

    function ANe(e) {
        if (null == eNe) {
            var t = VIe(e);
            eNe = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)
        }
        return Math.min(16, eNe)
    }

    function RNe(e) {
        if (0 === e) return 0;
        var t = VIe(e);
        return _Ne(t, "EXT_disjoint_timer_query_webgl2") && 2 === e ? 2 : _Ne(t, "EXT_disjoint_timer_query") ? 1 : 0
    }

    function _Ne(e, t) {
        return null != e.getExtension(t)
    }

    function ONe(e) {
        try {
            if (null != VIe(e)) return !0
        } catch (e) {
            return console.log("Error when getting WebGL context: ", e), !1
        }
        return !1
    }

    function FNe(e) {
        if (0 === e) return !1;
        var t = VIe(e);
        if (1 === e) {
            if (!_Ne(t, "OES_texture_float")) return !1
        } else if (!_Ne(t, "EXT_color_buffer_float")) return !1;
        return MNe(t)
    }

    function DNe(e) {
        if (0 === e) return !1;
        var t = VIe(e);
        if (1 !== e) {
            if (_Ne(t, "EXT_color_buffer_float")) return MNe(t);
            var n = "EXT_color_buffer_half_float";
            if (_Ne(t, n)) {
                var r = t.getExtension(n);
                return function(e, t) {
                    var n = qIe(e, t),
                        r = e.createTexture();
                    e.bindTexture(e.TEXTURE_2D, r);
                    var a = 1,
                        i = 1;
                    e.texImage2D(e.TEXTURE_2D, 0, n.internalFormatHalfFloat, a, i, 0, n.textureFormatFloat, n.textureTypeHalfFloat, null);
                    var o = e.createFramebuffer();
                    e.bindFramebuffer(e.FRAMEBUFFER, o), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, r, 0);
                    var s = e.checkFramebufferStatus(e.FRAMEBUFFER) === e.FRAMEBUFFER_COMPLETE;
                    return e.bindTexture(e.TEXTURE_2D, null), e.bindFramebuffer(e.FRAMEBUFFER, null), e.deleteTexture(r), e.deleteFramebuffer(o), s
                }(t, r)
            }
            return !1
        }
        return !!_Ne(t, "OES_texture_float") && (!!_Ne(t, "WEBGL_color_buffer_float") && MNe(t))
    }

    function MNe(e) {
        var t = qIe(e),
            n = e.createTexture();
        e.bindTexture(e.TEXTURE_2D, n);
        e.texImage2D(e.TEXTURE_2D, 0, t.internalFormatFloat, 1, 1, 0, t.textureFormatFloat, t.textureTypeFloat, null);
        var r = e.createFramebuffer();
        e.bindFramebuffer(e.FRAMEBUFFER, r), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, n, 0);
        var a = e.checkFramebufferStatus(e.FRAMEBUFFER) === e.FRAMEBUFFER_COMPLETE;
        return e.bindTexture(e.TEXTURE_2D, null), e.bindFramebuffer(e.FRAMEBUFFER, null), e.deleteTexture(n), e.deleteFramebuffer(r), a
    }

    function LNe(e) {
        return 2 === e && null != VIe(e).fenceSync
    }

    function zNe(e, t) {
        Array.isArray(e) || (e = [e]), e.forEach((function(e) {
            null != e && F$("complex64" !== e.dtype, (function() {
                return "".concat(t, " does not support complex64 tensors ") + "in the WebGL backend."
            }))
        }))
    }
    var PNe = {
            __proto__: null,
            assertNotComplex: zNe,
            bindCanvasToFramebuffer: function(e) {
                KIe(e, (function() {
                    return e.bindFramebuffer(e.FRAMEBUFFER, null)
                })), KIe(e, (function() {
                    return e.viewport(0, 0, e.canvas.width, e.canvas.height)
                })), KIe(e, (function() {
                    return e.scissor(0, 0, e.canvas.width, e.canvas.height)
                }))
            },
            bindColorTextureToFramebuffer: mNe,
            bindTextureToProgramUniformSampler: vNe,
            bindTextureUnit: pNe,
            bindVertexBufferToProgramAttribute: hNe,
            callAndCheck: KIe,
            canBeRepresented: XIe,
            createFragmentShader: QIe,
            createFramebuffer: lNe,
            createProgram: rNe,
            createStaticIndexBuffer: sNe,
            createStaticVertexBuffer: oNe,
            createTexture: uNe,
            createVertexShader: ZIe,
            getBatchDim: wNe,
            getExtensionOrThrow: JIe,
            getFramebufferErrorMessage: bNe,
            getMaxTexturesInShader: ANe,
            getNumChannels: function() {
                return 2 === k0().getNumber("WEBGL_VERSION") ? 1 : 4
            },
            getProgramUniformLocation: dNe,
            getProgramUniformLocationOrThrow: fNe,
            getRowsCols: INe,
            getShapeAs3D: NNe,
            getTextureShapeFromLogicalShape: SNe,
            getWebGLDisjointQueryTimerVersion: RNe,
            getWebGLErrorMessage: YIe,
            getWebGLMaxTextureSize: CNe,
            hasExtension: _Ne,
            isCapableOfRenderingToFloatTexture: FNe,
            isDownloadFloatTextureEnabled: DNe,
            isReshapeFree: ENe,
            isWebGLFenceEnabled: LNe,
            isWebGLVersionEnabled: ONe,
            linkProgram: aNe,
            logShaderSourceAndInfoLog: nNe,
            resetMaxTextureSize: function() {
                $Ie = null
            },
            resetMaxTexturesInShader: function() {
                eNe = null
            },
            unbindColorTextureFromFramebuffer: gNe,
            unbindTextureUnit: function(e, t) {
                kNe(e, t), KIe(e, (function() {
                    return e.activeTexture(e.TEXTURE0 + t)
                })), KIe(e, (function() {
                    return e.bindTexture(e.TEXTURE_2D, null)
                }))
            },
            validateFramebuffer: yNe,
            validateProgram: iNe,
            validateTextureSize: cNe
        },
        BNe = k0();

    function WNe() {
        var e, t, n, r, a, i, o, s, u, c;
        return 2 === k0().getNumber("WEBGL_VERSION") ? (e = "#version 300 es", t = "in", n = "out", r = "in", a = "texture", i = "outputColor", o = "out vec4 outputColor;", s = k0().getBool("WEBGL2_ISNAN_CUSTOM") ? "\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    " : "", u = "", c = "\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    ") : (e = "", t = "attribute", n = "varying", r = "varying", a = "texture2D", i = "gl_FragColor", o = "", s = "\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ", u = "\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ", c = "\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "), {
            version: e,
            attribute: t,
            varyingVs: n,
            varyingFs: r,
            texture2D: a,
            output: i,
            defineOutput: o,
            defineSpecialNaN: s,
            defineSpecialInf: u,
            defineRound: c
        }
    }

    function UNe(e, t) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "index",
            r = i0(t);
        return r.map((function(t, a) {
            var i = "int ".concat(e[a], " = ").concat(n, " / ").concat(t),
                o = a === r.length - 1 ? "int ".concat(e[a + 1], " = ").concat(n, " - ").concat(e[a], " * ").concat(t) : "index -= ".concat(e[a], " * ").concat(t);
            return "".concat(i, "; ").concat(o, ";")
        })).join("")
    }

    function VNe(e, t) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "index",
            r = i0(t);
        return r.map((function(t, a) {
            var i = "int ".concat(e[a], " = ").concat(n, " / outShapeStrides[").concat(a, "]"),
                o = a === r.length - 1 ? "int ".concat(e[a + 1], " = ").concat(n, " - ").concat(e[a], " * outShapeStrides[").concat(a, "]") : "index -= ".concat(e[a], " * outShapeStrides[").concat(a, "]");
            return "".concat(i, "; ").concat(o, ";")
        })).join("")
    }

    function GNe(e, t) {
        var n = e.length,
            r = e.map((function(e) {
                return "".concat(t, "[").concat(e, "]")
            })),
            a = new Array(n - 1);
        a[n - 2] = r[n - 1];
        for (var i = n - 3; i >= 0; --i) a[i] = "(".concat(a[i + 1], " * ").concat(r[i + 1], ")");
        return a
    }

    function jNe(e) {
        var t = i0(e).map((function(e) {
            return e.toString()
        }));
        return "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ".concat(t[0], " + coords.y * ").concat(t[1], " + coords.z;\n  }\n")
    }
    BNe.registerFlag("HAS_WEBGL", (function() {
        return BNe.getNumber("WEBGL_VERSION") > 0
    })), BNe.registerFlag("WEBGL_VERSION", (function() {
        return ONe(2) ? 2 : ONe(1) ? 1 : 0
    })), BNe.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS", (function() {
        return !1
    })), BNe.registerFlag("WEBGL_BUFFER_SUPPORTED", (function() {
        return 2 === BNe.get("WEBGL_VERSION")
    })), BNe.registerFlag("WEBGL_CPU_FORWARD", (function() {
        return !0
    })), BNe.registerFlag("WEBGL_FORCE_F16_TEXTURES", (function() {
        return !1
    })), BNe.registerFlag("WEBGL_PACK", (function() {
        return BNe.getBool("HAS_WEBGL")
    })), BNe.registerFlag("WEBGL_PACK_NORMALIZATION", (function() {
        return BNe.getBool("WEBGL_PACK")
    })), BNe.registerFlag("WEBGL_PACK_CLIP", (function() {
        return BNe.getBool("WEBGL_PACK")
    })), BNe.registerFlag("WEBGL_PACK_DEPTHWISECONV", (function() {
        return BNe.getBool("WEBGL_PACK")
    })), BNe.registerFlag("WEBGL_PACK_BINARY_OPERATIONS", (function() {
        return BNe.getBool("WEBGL_PACK")
    })), BNe.registerFlag("WEBGL_PACK_UNARY_OPERATIONS", (function() {
        return BNe.getBool("WEBGL_PACK")
    })), BNe.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS", (function() {
        return BNe.getBool("WEBGL_PACK")
    })), BNe.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS", (function() {
        return BNe.getBool("WEBGL_PACK")
    })), BNe.registerFlag("WEBGL_PACK_REDUCE", (function() {
        return BNe.getBool("WEBGL_PACK")
    })), BNe.registerFlag("WEBGL_LAZILY_UNPACK", (function() {
        return BNe.getBool("WEBGL_PACK")
    })), BNe.registerFlag("WEBGL_CONV_IM2COL", (function() {
        return BNe.getBool("WEBGL_PACK")
    })), BNe.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE", (function() {
        return BNe.getBool("WEBGL_PACK")
    })), BNe.registerFlag("WEBGL_MAX_TEXTURE_SIZE", (function() {
        return CNe(BNe.getNumber("WEBGL_VERSION"))
    })), BNe.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER", (function() {
        return ANe(BNe.getNumber("WEBGL_VERSION"))
    })), BNe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", (function() {
        var e = BNe.getNumber("WEBGL_VERSION");
        return 0 === e ? 0 : RNe(e)
    })), BNe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", (function() {
        return BNe.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && !A5()
    })), BNe.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE", (function() {
        return FNe(BNe.getNumber("WEBGL_VERSION"))
    })), BNe.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED", (function() {
        return !BNe.getBool("WEBGL_FORCE_F16_TEXTURES") && BNe.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")
    })), BNe.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED", (function() {
        return DNe(BNe.getNumber("WEBGL_VERSION"))
    })), BNe.registerFlag("WEBGL_FENCE_API_ENABLED", (function() {
        return LNe(BNe.getNumber("WEBGL_VERSION"))
    })), BNe.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM", (function() {
        return BNe.getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0
    })), BNe.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD", (function() {
        return -1
    }), (function(e) {
        if ("number" != typeof e) throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but " + "got ".concat(e, "."));
        if (e < 0 && -1 !== e) throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never " + "delete) or at least 0, but got ".concat(e, "."))
    })), BNe.registerFlag("WEBGL_FLUSH_THRESHOLD", (function() {
        return A5() ? 1 : -1
    }), (function(e) {
        if ("number" != typeof e) throw new Error("WEBGL_FLUSH_THRESHOLD must be a number but got " + "".concat(e, "."));
        if (e < 0 && -1 !== e) throw new Error("WEBGL_FLUSH_THRESHOLD must be -1 (indicating never " + "manual flush) or at least 0, but got ".concat(e, "."))
    })), BNe.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD", (function() {
        return 128
    })), BNe.registerFlag("WEBGL_USE_SHAPES_UNIFORMS", (function() {
        return !1
    })), BNe.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD", (function() {
        return 1e5
    })), BNe.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD", (function() {
        return 128
    })), BNe.registerFlag("WEBGL_EXP_CONV", (function() {
        return !1
    })), BNe.registerFlag("SOFTWARE_WEBGL_ENABLED", (function() {
        return BNe.getBool("IS_TEST")
    })), BNe.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE", (function() {
        return 1 / 0
    })), BNe.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE", (function() {
        return !1
    })), BNe.registerFlag("WEBGL2_ISNAN_CUSTOM", (function() {
        return !1
    })), BNe.registerFlag("ENGINE_COMPILE_ONLY", (function() {
        return !1
    }));
    var HNe = "\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",
        qNe = M7;

    function KNe(e, t, n) {
        var r = [];
        if (e.forEach((function(e) {
                var t = L$(e.shapeInfo.logicalShape);
                if (e.shapeInfo.isUniform ? r.push("uniform float ".concat(e.name).concat(t > 1 ? "[".concat(t, "]") : "", ";")) : (r.push("uniform sampler2D ".concat(e.name, ";")), r.push("uniform int offset".concat(e.name, ";"))), n.enableShapeUniforms) {
                    switch (pSe(n.packedInputs, e.shapeInfo.logicalShape, e.shapeInfo.texShape).uniformShape.length) {
                        case 1:
                            r.push("uniform int ".concat(e.name, "Shape;"));
                            break;
                        case 2:
                            r.push("uniform ivec2 ".concat(e.name, "Shape;"));
                            break;
                        case 3:
                            r.push("uniform ivec3 ".concat(e.name, "Shape;"));
                            break;
                        case 4:
                            r.push("uniform ivec4 ".concat(e.name, "Shape;"))
                    }
                    r.push("uniform ivec2 ".concat(e.name, "TexShape;"))
                }
            })), n.enableShapeUniforms) {
            switch (t.logicalShape.length) {
                case 1:
                    r.push("uniform int outShape;");
                    break;
                case 2:
                    r.push("uniform ivec2 outShape;"), r.push("uniform int outShapeStrides;");
                    break;
                case 3:
                    r.push("uniform ivec3 outShape;"), r.push("uniform ivec2 outShapeStrides;");
                    break;
                case 4:
                    r.push("uniform ivec4 outShape;"), r.push("uniform ivec3 outShapeStrides;")
            }
            r.push("uniform ivec2 outTexShape;")
        }
        n.customUniforms && n.customUniforms.forEach((function(e) {
            r.push("uniform ".concat(e.type, " ").concat(e.name).concat(e.arrayIndex ? "[".concat(e.arrayIndex, "]") : "", ";"))
        }));
        var a, i, o = r.join("\n"),
            s = e.map((function(e) {
                return function(e, t) {
                    var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                        r = arguments.length > 3 ? arguments[3] : void 0,
                        a = "";
                    a += n ? YNe(e, r) : XNe(e, r);
                    var i = e.shapeInfo.logicalShape,
                        o = t.logicalShape;
                    i.length <= o.length && (a += n ? cSe(e, t) : lSe(e, t));
                    return a
                }(e, t, n.packedInputs, n.enableShapeUniforms)
            })).join("\n"),
            u = t.texShape,
            c = WNe(),
            l = function(e) {
                return "\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ".concat(e.texture2D, "(textureSampler, uv).r;\n    }\n  ")
            }(c),
            h = function(e) {
                return "".concat(e.version, "\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ").concat(e.varyingFs, " vec2 resultUV;\n    ").concat(e.defineOutput, "\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ").concat(e.defineSpecialNaN, "\n    ").concat(e.defineSpecialInf, "\n    ").concat(e.defineRound, "\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ").concat(JNe, "\n    ").concat(ZNe, "\n    ").concat(QNe, "\n  ")
            }(c);
        return t.isPacked ? (a = function(e, t, n) {
            switch (e.length) {
                case 0:
                    return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
                case 1:
                    return function(e, t, n) {
                        var r = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)];
                        if (1 === r[0]) return n ? "\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    " : "\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ".concat(r[1], ".0);\n      }\n    ");
                        if (1 === r[1]) return n ? "\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    " : "\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ".concat(r[0], ".0);\n      }\n    ");
                        if (n) return "\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";
                        return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(r[0], ", ").concat(r[1], "));\n      return 2 * (resTexRC.x * ").concat(r[1], " + resTexRC.y);\n    }\n  ")
                    }(0, t, n);
                case 2:
                    return function(e, t, n) {
                        var r = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)];
                        if (P$(e, t)) return n ? "\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    " : "\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(".concat(r[0], ", ").concat(r[1], "));\n      }\n    ");
                        var a = Math.ceil(e[1] / 2);
                        if (n) return "\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";
                        return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(r[0], ", ").concat(r[1], "));\n\n      int index = resTexRC.x * ").concat(r[1], " + resTexRC.y;\n      int r = 2 * (index / ").concat(a, ");\n      int c = imod(index, ").concat(a, ") * 2;\n\n      return ivec2(r, c);\n    }\n  ")
                    }(e, t, n);
                case 3:
                    return function(e, t, n) {
                        if (n) return "\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";
                        var r = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)],
                            a = Math.ceil(e[2] / 2),
                            i = a * Math.ceil(e[1] / 2);
                        return "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(r[0], ", ").concat(r[1], "));\n      int index = resTexRC.x * ").concat(r[1], " + resTexRC.y;\n\n      int b = index / ").concat(i, ";\n      index -= b * ").concat(i, ";\n\n      int r = 2 * (index / ").concat(a, ");\n      int c = imod(index, ").concat(a, ") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ")
                    }(e, t, n);
                default:
                    return function(e, t, n) {
                        if (n) return "\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";
                        for (var r = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)], a = Math.ceil(e[e.length - 1] / 2), i = a * Math.ceil(e[e.length - 2] / 2), o = i, s = "", u = "b, r, c", c = 2; c < e.length - 1; c++) o *= e[e.length - c - 1], s = "\n      int b".concat(c, " = index / ").concat(o, ";\n      index -= b").concat(c, " * ").concat(o, ";\n    ") + s, u = "b".concat(c, ", ") + u;
                        return "\n    ivec".concat(e.length, " getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(").concat(r[0], ", ").concat(r[1], "));\n      int index = resTexRC.x * ").concat(r[1], " + resTexRC.y;\n\n      ").concat(s, "\n\n      int b = index / ").concat(i, ";\n      index -= b * ").concat(i, ";\n\n      int r = 2 * (index / ").concat(a, ");\n      int c = imod(index, ").concat(a, ") * 2;\n\n      return ivec").concat(e.length, "(").concat(u, ");\n    }\n  ")
                    }(e, t, n)
            }
        }(t.logicalShape, u, n.enableShapeUniforms), i = function(e) {
            return "\n    void setOutput(vec4 val) {\n      ".concat(e.output, " = val;\n    }\n  ")
        }(c)) : (a = function(e, t, n) {
            switch (e.length) {
                case 0:
                    return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
                case 1:
                    return function(e, t, n) {
                        if (1 === t[0]) return n ? "\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    " : "\n      int getOutputCoords() {\n        return int(resultUV.x * ".concat(t[1], ".0);\n      }\n    ");
                        if (1 === t[1]) return n ? "\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    " : "\n      int getOutputCoords() {\n        return int(resultUV.y * ".concat(t[0], ".0);\n      }\n    ");
                        if (n) return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";
                        return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0], ", ").concat(t[1], "));\n      return resTexRC.x * ").concat(t[1], " + resTexRC.y;\n    }\n  ")
                    }(0, t, n);
                case 2:
                    return function(e, t, n) {
                        if (P$(e, t)) return n ? "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    " : "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(".concat(t[0], ", ").concat(t[1], "));\n      }\n    ");
                        if (1 === e[1]) return n ? "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    " : "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0], ", ").concat(t[1], "));\n        int index = resTexRC.x * ").concat(t[1], " + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ");
                        if (1 === e[0]) return n ? "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    " : "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0], ", ").concat(t[1], "));\n        int index = resTexRC.x * ").concat(t[1], " + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ");
                        if (n) return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";
                        return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0], ", ").concat(t[1], "));\n      int index = resTexRC.x * ").concat(t[1], " + resTexRC.y;\n      int r = index / ").concat(e[1], ";\n      int c = index - r * ").concat(e[1], ";\n      return ivec2(r, c);\n    }\n  ")
                    }(e, t, n);
                case 3:
                    return function(e, t, n) {
                        if (n) {
                            var r = VNe(["r", "c", "d"], e);
                            return "\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ".concat(r, "\n    return ivec3(r, c, d);\n  }\n")
                        }
                        var a = UNe(["r", "c", "d"], e);
                        return "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0], ", ").concat(t[1], "));\n      int index = resTexRC.x * ").concat(t[1], " + resTexRC.y;\n      ").concat(a, "\n      return ivec3(r, c, d);\n    }\n  ")
                    }(e, t, n);
                case 4:
                    return function(e, t, n) {
                        if (n) {
                            var r = VNe(["r", "c", "d", "d2"], e);
                            return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ".concat(r, "\n      return ivec4(r, c, d, d2);\n    }\n  ")
                        }
                        var a = UNe(["r", "c", "d", "d2"], e);
                        return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0], ", ").concat(t[1], "));\n      int index = resTexRC.x * ").concat(t[1], " + resTexRC.y;\n      ").concat(a, "\n      return ivec4(r, c, d, d2);\n    }\n  ")
                    }(e, t, n);
                case 5:
                    return r = t, a = UNe(["r", "c", "d", "d2", "d3"], e), "\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(".concat(r[0], ",\n                             ").concat(r[1], "));\n\n      int index = resTexRC.x * ").concat(r[1], " + resTexRC.y;\n\n      ").concat(a, "\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ");
                case 6:
                    return function(e, t) {
                        var n = UNe(["r", "c", "d", "d2", "d3", "d4"], e);
                        return "\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0], ", ").concat(t[1], "));\n      int index = resTexRC.x * ").concat(t[1], " + resTexRC.y;\n\n      ").concat(n, "\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ")
                    }(e, t);
                default:
                    throw new Error("".concat(e.length, "-D output sampling is not yet supported"))
            }
            var r, a
        }(t.logicalShape, u, n.enableShapeUniforms), i = function(e) {
            return "\n    void setOutput(float val) {\n      ".concat(e.output, " = vec4(val, 0, 0, 0);\n    }\n  ")
        }(c)), n.packedInputs && (h += $Ne), [h, l, i, o, a, s, n.userCode].join("\n")
    }

    function XNe(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
            n = e.shapeInfo.logicalShape;
        switch (n.length) {
            case 0:
                return tSe(e, t);
            case 1:
                return nSe(e, t);
            case 2:
                return rSe(e, t);
            case 3:
                return aSe(e, t);
            case 4:
                return iSe(e, t);
            case 5:
                return oSe(e);
            case 6:
                return sSe(e);
            default:
                throw new Error("".concat(n.length, "-D input sampling") + " is not yet supported")
        }
    }

    function YNe(e, t) {
        var n, r, a;
        switch (e.shapeInfo.logicalShape.length) {
            case 0:
                return n = e.name, r = "get" + n.charAt(0).toUpperCase() + n.slice(1), a = WNe(), "\n    vec4 ".concat(r, "() {\n      return ").concat(a.texture2D, "(").concat(n, ", halfCR);\n    }\n  ");
            case 1:
                return function(e, t) {
                    var n = e.name,
                        r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
                        a = e.shapeInfo.texShape,
                        i = WNe();
                    if (t) return "\n    vec4 ".concat(r, "(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n, "TexShape[0]) / 2.0), ceil(float(").concat(n, "TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ").concat(i.texture2D, "(").concat(n, ", uv);\n    }\n  ");
                    var o = [Math.ceil(a[0] / 2), Math.ceil(a[1] / 2)];
                    return "\n    vec4 ".concat(r, "(int index) {\n      vec2 uv = packedUVfrom1D(\n        ").concat(o[0], ", ").concat(o[1], ", index);\n      return ").concat(i.texture2D, "(").concat(n, ", uv);\n    }\n  ")
                }(e, t);
            case 2:
                return function(e, t) {
                    var n = e.shapeInfo.logicalShape,
                        r = e.name,
                        a = "get" + r.charAt(0).toUpperCase() + r.slice(1),
                        i = e.shapeInfo.texShape,
                        o = i[0],
                        s = i[1],
                        u = WNe();
                    if (null != i && P$(n, i)) return t ? "\n      vec4 ".concat(a, "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(r, "TexShape[1], ").concat(r, "TexShape[0]);\n\n        return ").concat(u.texture2D, "(").concat(r, ", uv);\n      }\n    ") : "\n      vec4 ".concat(a, "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(s, ".0, ").concat(o, ".0);\n\n        return ").concat(u.texture2D, "(").concat(r, ", uv);\n      }\n    ");
                    if (t) return "\n    vec4 ".concat(a, "(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(r, "TexShape[0]) / 2.0), ceil(float(").concat(r, "TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(r, "Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ").concat(u.texture2D, "(").concat(r, ", uv);\n    }\n  ");
                    var c = [Math.ceil(i[0] / 2), Math.ceil(i[1] / 2)],
                        l = Math.ceil(n[1] / 2);
                    return "\n    vec4 ".concat(a, "(int row, int col) {\n      vec2 uv = packedUVfrom2D(").concat(l, ", ").concat(c[0], ", ").concat(c[1], ", row, col);\n      return ").concat(u.texture2D, "(").concat(r, ", uv);\n    }\n  ")
                }(e, t);
            case 3:
                return function(e, t) {
                    var n = e.shapeInfo.logicalShape,
                        r = e.name,
                        a = "get" + r.charAt(0).toUpperCase() + r.slice(1),
                        i = e.shapeInfo.texShape,
                        o = [Math.ceil(i[0] / 2), Math.ceil(i[1] / 2)];
                    if (1 === n[0]) {
                        var s = [1, 2],
                            u = fSe(e, n.slice(1)),
                            c = ["b", "row", "col"];
                        return "\n        ".concat(YNe(u, t), "\n        vec4 ").concat(a, "(int b, int row, int col) {\n          return ").concat(a, "(").concat(dSe(c, s), ");\n        }\n      ")
                    }
                    var l = WNe();
                    if (t) return "\n    vec4 ".concat(a, "(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(r, "TexShape[0]) / 2.0), ceil(float(").concat(r, "TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(r, "Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(r, "Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ").concat(l.texture2D, "(").concat(r, ", uv);\n    }\n  ");
                    var h = o[0],
                        p = o[1],
                        f = Math.ceil(n[2] / 2),
                        d = f * Math.ceil(n[1] / 2);
                    return "\n    vec4 ".concat(a, "(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ").concat(h, ", ").concat(p, ", ").concat(d, ", ").concat(f, ", b, row, col);\n      return ").concat(l.texture2D, "(").concat(r, ", uv);\n    }\n  ")
                }(e, t);
            default:
                return function(e, t) {
                    var n = e.name,
                        r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
                        a = WNe();
                    if (t) return "\n    vec4 ".concat(r, "(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(").concat(n, "Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(n, "Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ").concat(n, "Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n, "TexShape[0]) / 2.0), ceil(float(").concat(n, "TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ").concat(a.texture2D, "(").concat(n, ", uv);\n    }\n  ");
                    for (var i = e.shapeInfo.logicalShape, o = i.length, s = e.shapeInfo.texShape, u = [Math.ceil(s[0] / 2), Math.ceil(s[1] / 2)], c = u[0], l = u[1], h = Math.ceil(i[o - 1] / 2), p = h * Math.ceil(i[o - 2] / 2), f = "int b, int row, int col", d = "b * ".concat(p, " + (row / 2) * ").concat(h, " + (col / 2)"), v = 2; v < o - 1; v++) f = "int b".concat(v, ", ") + f, p *= i[o - v - 1], d = "b".concat(v, " * ").concat(p, " + ") + d;
                    return "\n    vec4 ".concat(r, "(").concat(f, ") {\n      int index = ").concat(d, ";\n      int texR = index / ").concat(l, ";\n      int texC = index - texR * ").concat(l, ";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(l, ", ").concat(c, ");\n      return ").concat(a.texture2D, "(").concat(n, ", uv);\n    }\n  ")
                }(e, t)
        }
    }
    var JNe = "\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
        ZNe = "\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
        QNe = "\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",
        $Ne = "\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";

    function eSe(e) {
        return "offset".concat(e)
    }

    function tSe(e, t) {
        var n = e.name,
            r = "get" + n.charAt(0).toUpperCase() + n.slice(1);
        if (e.shapeInfo.isUniform) return "float ".concat(r, "() {return ").concat(n, ";}");
        var a = S(e.shapeInfo.texShape, 2),
            i = a[0],
            o = a[1];
        if (1 === i && 1 === o) return "\n      float ".concat(r, "() {\n        return sampleTexture(").concat(n, ", halfCR);\n      }\n    ");
        var s = eSe(n);
        if (t) return "\n    float ".concat(r, "() {\n      vec2 uv = uvFromFlat(").concat(n, "TexShape[0], ").concat(n, "TexShape[1], ").concat(s, ");\n      return sampleTexture(").concat(n, ", uv);\n    }\n  ");
        var u = S(e.shapeInfo.texShape, 2),
            c = u[0],
            l = u[1];
        return "\n    float ".concat(r, "() {\n      vec2 uv = uvFromFlat(").concat(c, ", ").concat(l, ", ").concat(s, ");\n      return sampleTexture(").concat(n, ", uv);\n    }\n  ")
    }

    function nSe(e, t) {
        var n = e.name,
            r = "get" + n.charAt(0).toUpperCase() + n.slice(1);
        if (e.shapeInfo.isUniform) return "\n      float ".concat(r, "(int index) {\n        ").concat(uSe(e), "\n      }\n    ");
        var a = e.shapeInfo.texShape,
            i = a[0],
            o = a[1];
        if (1 === o && 1 === i) return "\n      float ".concat(r, "(int index) {\n        return sampleTexture(").concat(n, ", halfCR);\n      }\n    ");
        var s = eSe(n);
        return 1 === o ? t ? "\n      float ".concat(r, "(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(s, ") + 0.5) / float(").concat(n, "TexShape[0]));\n        return sampleTexture(").concat(n, ", uv);\n      }\n    ") : "\n      float ".concat(r, "(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(s, ") + 0.5) / ").concat(i, ".0);\n        return sampleTexture(").concat(n, ", uv);\n      }\n    ") : 1 === i ? t ? "\n      float ".concat(r, "(int index) {\n        vec2 uv = vec2((float(index + ").concat(s, ") + 0.5) / float(").concat(n, "TexShape[1]), 0.5);\n        return sampleTexture(").concat(n, ", uv);\n      }\n    ") : "\n      float ".concat(r, "(int index) {\n        vec2 uv = vec2((float(index + ").concat(s, ") + 0.5) / ").concat(o, ".0, 0.5);\n        return sampleTexture(").concat(n, ", uv);\n      }\n    ") : t ? "\n    float ".concat(r, "(int index) {\n      vec2 uv = uvFromFlat(").concat(n, "TexShape[0], ").concat(n, "TexShape[1], index + ").concat(s, ");\n      return sampleTexture(").concat(n, ", uv);\n    }\n  ") : "\n    float ".concat(r, "(int index) {\n      vec2 uv = uvFromFlat(").concat(i, ", ").concat(o, ", index + ").concat(s, ");\n      return sampleTexture(").concat(n, ", uv);\n    }\n  ")
    }

    function rSe(e, t) {
        var n = e.shapeInfo.logicalShape,
            r = e.name,
            a = "get" + r.charAt(0).toUpperCase() + r.slice(1),
            i = e.shapeInfo.texShape;
        if (null != i && P$(n, i)) {
            if (t) return "\n      float ".concat(a, "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(r, "TexShape[1], ").concat(r, "TexShape[0]);\n        return sampleTexture(").concat(r, ", uv);\n      }\n    ");
            var o = i[0],
                s = i[1];
            return "\n    float ".concat(a, "(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(s, ".0, ").concat(o, ".0);\n      return sampleTexture(").concat(r, ", uv);\n    }\n  ")
        }
        var u = H$(n),
            c = u.newShape,
            l = u.keptDims,
            h = c;
        if (h.length < n.length) {
            var p = fSe(e, h);
            return "\n      ".concat(XNe(p, t), "\n      float ").concat(a, "(int row, int col) {\n        return ").concat(a, "(").concat(dSe(["row", "col"], l), ");\n      }\n    ")
        }
        if (e.shapeInfo.isUniform) return "\n      float ".concat(a, "(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(").concat(n[1], ", 1)));\n        ").concat(uSe(e), "\n      }\n    ");
        var f = i[0],
            d = i[1],
            v = eSe(r);
        return 1 === d ? t ? "\n      float ".concat(a, "(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(v, "), vec3(").concat(r, "Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(").concat(r, "TexShape[0]));\n        return sampleTexture(").concat(r, ", uv);\n      }\n    ") : "\n    float ".concat(a, "(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(v, "), vec3(").concat(n[1], ", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ").concat(f, ".0);\n      return sampleTexture(").concat(r, ", uv);\n    }\n  ") : 1 === f ? t ? "\n      float ".concat(a, "(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(v, "), vec3(").concat(r, "Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(").concat(r, "TexShape[1]), 0.5);\n        return sampleTexture(").concat(r, ", uv);\n      }\n    ") : "\n    float ".concat(a, "(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(v, "), vec3(").concat(n[1], ", 1, 1));\n      vec2 uv = vec2((index + 0.5) / ").concat(d, ".0, 0.5);\n      return sampleTexture(").concat(r, ", uv);\n    }\n  ") : t ? "\n      float ".concat(a, "(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(r, "Shape[1] + col + ").concat(v, ";\n        vec2 uv = uvFromFlat(").concat(r, "TexShape[0], ").concat(r, "TexShape[1], index);\n        return sampleTexture(").concat(r, ", uv);\n      }\n    ") : "\n  float ".concat(a, "(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ").concat(n[1], " + col + ").concat(v, ";\n    vec2 uv = uvFromFlat(").concat(f, ", ").concat(d, ", index);\n    return sampleTexture(").concat(r, ", uv);\n  }\n")
    }

    function aSe(e, t) {
        var n = e.shapeInfo.logicalShape,
            r = e.name,
            a = "get" + r.charAt(0).toUpperCase() + r.slice(1),
            i = n[1] * n[2],
            o = n[2],
            s = H$(n),
            u = s.newShape,
            c = s.keptDims,
            l = u;
        if (l.length < n.length) {
            var h = fSe(e, l);
            return "\n        ".concat(XNe(h, t), "\n        float ").concat(a, "(int row, int col, int depth) {\n          return ").concat(a, "(").concat(dSe(["row", "col", "depth"], c), ");\n        }\n      ")
        }
        if (e.shapeInfo.isUniform) return "\n      float ".concat(a, "(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(").concat(i, ", ").concat(o, ", 1)));\n        ").concat(uSe(e), "\n      }\n    ");
        var p = e.shapeInfo.texShape,
            f = p[0],
            d = p[1],
            v = e.shapeInfo.flatOffset;
        if (d === i && null == v) return t ? "\n      float ".concat(a, "(int row, int col, int depth) {\n        int stride1 = ").concat(r, "Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(r, "TexShape[1], ").concat(r, "TexShape[0]);\n        return sampleTexture(").concat(r, ", uv);\n      }\n    ") : "\n        float ".concat(a, "(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(").concat(o, ", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(").concat(d, ".0, ").concat(f, ".0);\n          return sampleTexture(").concat(r, ", uv);\n        }\n      ");
        if (d === o && null == v) return t ? "\n      float ".concat(a, "(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(").concat(r, "Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(r, "TexShape[1], ").concat(r, "TexShape[0]);\n        return sampleTexture(").concat(r, ", uv);\n      }\n    ") : "\n    float ".concat(a, "(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(").concat(n[1], ", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(d, ".0, ").concat(f, ".0);\n      return sampleTexture(").concat(r, ", uv);\n    }\n  ");
        var m = eSe(r);
        return t ? "\n    float ".concat(a, "(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ").concat(r, "Shape[1] * ").concat(r, "Shape[2];\n      int stride1 = ").concat(r, "Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ").concat(m, ";\n      vec2 uv = uvFromFlat(").concat(r, "TexShape[0], ").concat(r, "TexShape[1], index);\n      return sampleTexture(").concat(r, ", uv);\n    }\n    ") : "\n      float ".concat(a, "(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(i, " + col * ").concat(o, " + depth + ").concat(m, ";\n        vec2 uv = uvFromFlat(").concat(f, ", ").concat(d, ", index);\n        return sampleTexture(").concat(r, ", uv);\n      }\n  ")
    }

    function iSe(e, t) {
        var n = e.shapeInfo.logicalShape,
            r = e.name,
            a = "get" + r.charAt(0).toUpperCase() + r.slice(1),
            i = n[3],
            o = n[2] * i,
            s = n[1] * o,
            u = H$(n),
            c = u.newShape,
            l = u.keptDims;
        if (c.length < n.length) {
            var h = fSe(e, c);
            return "\n      ".concat(XNe(h, t), "\n      float ").concat(a, "(int row, int col, int depth, int depth2) {\n        return ").concat(a, "(").concat(dSe(["row", "col", "depth", "depth2"], l), ");\n      }\n    ")
        }
        if (e.shapeInfo.isUniform) return "\n      float ".concat(a, "(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(").concat(s, ", ").concat(o, ", ").concat(i, ", 1)));\n        ").concat(uSe(e), "\n      }\n    ");
        var p = e.shapeInfo.flatOffset,
            f = e.shapeInfo.texShape,
            d = f[0],
            v = f[1],
            m = "int stride2 = ".concat(r, "Shape[3];"),
            g = "int stride1 = ".concat(r, "Shape[2] * stride2;"),
            y = "int stride0 = ".concat(r, "Shape[1] * stride1;");
        if (v === s && null == p) return t ? "\n      float ".concat(a, "(int row, int col, int depth, int depth2) {\n        ").concat(m, "\n        ").concat(g, "\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(r, "TexShape[1], ").concat(r, "TexShape[0]);\n        return sampleTexture(").concat(r, ", uv);\n      }\n    ") : "\n      float ".concat(a, "(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(").concat(o, ", ").concat(i, ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(v, ".0, ").concat(d, ".0);\n        return sampleTexture(").concat(r, ", uv);\n      }\n    ");
        if (v === i && null == p) return t ? "\n      float ".concat(a, "(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(r, "Shape[1] * ").concat(r, "Shape[2], ").concat(r, "Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(r, "TexShape[1], ").concat(r, "TexShape[0]);\n        return sampleTexture(").concat(r, ", uv);\n      }\n    ") : "\n      float ".concat(a, "(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(n[1] * n[2], ", ").concat(n[2], ", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(v, ".0, ").concat(d, ".0);\n        return sampleTexture(").concat(r, ", uv);\n      }\n    ");
        var b = eSe(r);
        return t ? "\n    float ".concat(a, "(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ").concat(m, "\n      ").concat(g, "\n      ").concat(y, "\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(").concat(r, "TexShape[0], ").concat(r, "TexShape[1], index + ").concat(b, ");\n      return sampleTexture(").concat(r, ", uv);\n    }\n  ") : "\n    float ".concat(a, "(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(s, " + col * ").concat(o, " +\n          depth * ").concat(i, " + depth2;\n      vec2 uv = uvFromFlat(").concat(d, ", ").concat(v, ", index + ").concat(b, ");\n      return sampleTexture(").concat(r, ", uv);\n    }\n  ")
    }

    function oSe(e) {
        var t = e.shapeInfo.logicalShape,
            n = e.name,
            r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            a = t[4],
            i = t[3] * a,
            o = t[2] * i,
            s = t[1] * o,
            u = H$(t),
            c = u.newShape,
            l = u.keptDims;
        if (c.length < t.length) {
            var h = fSe(e, c);
            return "\n      ".concat(XNe(h), "\n      float ").concat(r, "(int row, int col, int depth, int depth2, int depth3) {\n        return ").concat(r, "(").concat(dSe(["row", "col", "depth", "depth2", "depth3"], l), ");\n      }\n    ")
        }
        if (e.shapeInfo.isUniform) return "\n      float ".concat(r, "(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(s, ", ").concat(o, ", ").concat(i, ", ").concat(a, ")) +\n          depth3;\n        ").concat(uSe(e), "\n      }\n    ");
        var p = e.shapeInfo.flatOffset,
            f = e.shapeInfo.texShape,
            d = f[0],
            v = f[1];
        if (v === s && null == p) return "\n      float ".concat(r, "(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(").concat(o, ", ").concat(i, ", ").concat(a, ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(v, ".0, ").concat(d, ".0);\n        return sampleTexture(").concat(n, ", uv);\n      }\n    ");
        if (v === a && null == p) return "\n      float ".concat(r, "(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(t[1] * t[2] * t[3], ",\n               ").concat(t[2] * t[3], ", ").concat(t[3], ", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(v, ".0, ").concat(d, ".0);\n        return sampleTexture(").concat(n, ", uv);\n      }\n    ");
        var m = eSe(n);
        return "\n    float ".concat(r, "(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(s, " + col * ").concat(o, " + depth * ").concat(i, " +\n          depth2 * ").concat(a, " + depth3 + ").concat(m, ";\n      vec2 uv = uvFromFlat(").concat(d, ", ").concat(v, ", index);\n      return sampleTexture(").concat(n, ", uv);\n    }\n  ")
    }

    function sSe(e) {
        var t = e.shapeInfo.logicalShape,
            n = e.name,
            r = "get" + n.charAt(0).toUpperCase() + n.slice(1),
            a = H$(t),
            i = a.newShape,
            o = a.keptDims;
        if (i.length < t.length) {
            var s = fSe(e, i);
            return "\n      ".concat(XNe(s), "\n      float ").concat(r, "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ").concat(r, "(").concat(dSe(["row", "col", "depth", "depth2", "depth3", "depth4"], o), ");\n      }\n    ")
        }
        var u = t[5],
            c = t[4] * u,
            l = t[3] * c,
            h = t[2] * l,
            p = t[1] * h;
        if (e.shapeInfo.isUniform) return "\n      float ".concat(r, "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(p, ", ").concat(h, ", ").concat(l, ", ").concat(c, ")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(").concat(u, ", 1)));\n        ").concat(uSe(e), "\n      }\n    ");
        var f = e.shapeInfo.flatOffset,
            d = e.shapeInfo.texShape,
            v = d[0],
            m = d[1];
        if (m === p && null == f) return "\n      float ".concat(r, "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(").concat(h, ", ").concat(l, ", ").concat(c, ", ").concat(u, ")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(m, ".0, ").concat(v, ".0);\n        return sampleTexture(").concat(n, ", uv);\n      }\n    ");
        if (m === u && null == f) return "\n      float ".concat(r, "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(").concat(t[1] * t[2] * t[3] * t[4], ",\n               ").concat(t[2] * t[3] * t[4], ",\n               ").concat(t[3] * t[4], ",\n               ").concat(t[4], ")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(m, ".0, ").concat(v, ".0);\n        return sampleTexture(").concat(n, ", uv);\n      }\n    ");
        var g = eSe(n);
        return "\n    float ".concat(r, "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(p, " + col * ").concat(h, " + depth * ").concat(l, " +\n          depth2 * ").concat(c, " + depth3 * ").concat(u, " + depth4 + ").concat(g, ";\n      vec2 uv = uvFromFlat(").concat(v, ", ").concat(m, ", index);\n      return sampleTexture(").concat(n, ", uv);\n    }\n  ")
    }

    function uSe(e) {
        var t = e.name,
            n = L$(e.shapeInfo.logicalShape);
        return n < 2 ? "return ".concat(t, ";") : "\n    for (int i = 0; i < ".concat(n, "; i++) {\n      if (i == index) {\n        return ").concat(t, "[i];\n      }\n    }\n  ")
    }

    function cSe(e, t) {
        var n, r = e.name,
            a = r.charAt(0).toUpperCase() + r.slice(1),
            i = "get" + a + "AtOutCoords",
            o = e.shapeInfo.logicalShape.length,
            s = t.logicalShape.length,
            u = qNe(e.shapeInfo.logicalShape, t.logicalShape),
            c = hSe(s),
            l = s - o,
            h = ["x", "y", "z", "w", "u", "v"];
        n = 0 === o ? "" : s < 2 && u.length >= 1 ? "coords = 0;" : u.map((function(e) {
            return "coords.".concat(h[e + l], " = 0;")
        })).join("\n");
        var p = "";
        p = s < 2 && o > 0 ? "coords" : e.shapeInfo.logicalShape.map((function(e, t) {
            return "coords.".concat(h[t + l])
        })).join(", ");
        var f = "return outputValue;",
            d = 1 === L$(e.shapeInfo.logicalShape),
            v = 1 === L$(t.logicalShape);
        if (1 !== o || d || v) {
            if (d && !v) f = 1 === s ? "\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      " : "\n        return vec4(outputValue.x);\n      ";
            else if (u.length) {
                var m = o - 2,
                    g = o - 1;
                u.indexOf(m) > -1 && u.indexOf(g) > -1 ? f = "return vec4(outputValue.x);" : u.indexOf(m) > -1 ? f = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : u.indexOf(g) > -1 && (f = "return vec4(outputValue.xx, outputValue.zz);")
            }
        } else f = "\n      return vec4(outputValue.xy, outputValue.xy);\n    ";
        return "\n    vec4 ".concat(i, "() {\n      ").concat(c, " coords = getOutputCoords();\n      ").concat(n, "\n      vec4 outputValue = get").concat(a, "(").concat(p, ");\n      ").concat(f, "\n    }\n  ")
    }

    function lSe(e, t) {
        var n = e.name,
            r = n.charAt(0).toUpperCase() + n.slice(1),
            a = "get" + r + "AtOutCoords",
            i = t.texShape,
            o = e.shapeInfo.texShape,
            s = e.shapeInfo.logicalShape.length,
            u = t.logicalShape.length;
        if (!e.shapeInfo.isUniform && s === u && null == e.shapeInfo.flatOffset && P$(o, i)) return "\n      float ".concat(a, "() {\n        return sampleTexture(").concat(n, ", resultUV);\n      }\n    ");
        var c, l = hSe(u),
            h = qNe(e.shapeInfo.logicalShape, t.logicalShape),
            p = u - s,
            f = ["x", "y", "z", "w", "u", "v"];
        c = 0 === s ? "" : u < 2 && h.length >= 1 ? "coords = 0;" : h.map((function(e) {
            return "coords.".concat(f[e + p], " = 0;")
        })).join("\n");
        var d = "";
        return d = u < 2 && s > 0 ? "coords" : e.shapeInfo.logicalShape.map((function(e, t) {
            return "coords.".concat(f[t + p])
        })).join(", "), "\n    float ".concat(a, "() {\n      ").concat(l, " coords = getOutputCoords();\n      ").concat(c, "\n      return get").concat(r, "(").concat(d, ");\n    }\n  ")
    }

    function hSe(e) {
        if (e <= 1) return "int";
        if (2 === e) return "ivec2";
        if (3 === e) return "ivec3";
        if (4 === e) return "ivec4";
        if (5 === e) return "ivec5";
        if (6 === e) return "ivec6";
        throw Error("GPU for rank ".concat(e, " is not yet supported"))
    }

    function pSe(e, t, n) {
        var r = H$(t),
            a = r.newShape,
            i = r.keptDims,
            o = t.length,
            s = e && 3 === o && 1 === t[0],
            u = s ? t.slice(1) : a,
            c = !e && o > 1 && !P$(t, n) && a.length < o || s;
        return {
            useSqueezeShape: c,
            uniformShape: c ? u : t,
            keptDims: i
        }
    }

    function fSe(e, t) {
        var n = JSON.parse(JSON.stringify(e));
        return n.shapeInfo.logicalShape = t, n
    }

    function dSe(e, t) {
        return t.map((function(t) {
            return e[t]
        })).join(", ")
    }

    function vSe(e, t, n, r) {
        var a = n.map((function(e, n) {
                var r = {
                    logicalShape: e.shape,
                    texShape: e.isUniform ? null : e.texData.texShape,
                    isUniform: e.isUniform,
                    isPacked: !e.isUniform && e.texData.isPacked,
                    flatOffset: null
                };
                return null != e.texData && null != e.texData.slice && e.texData.slice.flatOffset > 0 && (r.flatOffset = e.texData.slice.flatOffset), {
                    name: t.variableNames[n],
                    shapeInfo: r
                }
            })),
            i = a.map((function(e) {
                return e.shapeInfo
            })),
            o = {
                logicalShape: r.shape,
                texShape: r.texData.texShape,
                isUniform: !1,
                isPacked: r.texData.isPacked,
                flatOffset: null
            },
            s = KNe(a, o, t),
            u = QIe(e.gl, s),
            c = e.createProgram(u);
        return k0().get("ENGINE_COMPILE_ONLY") ? {
            program: t,
            fragmentShader: u,
            source: s,
            webGLProgram: c,
            inShapeInfos: i,
            outShapeInfo: o,
            variablesLocations: null,
            customUniformLocations: null,
            infLoc: null,
            nanLoc: null,
            outShapeLocation: null,
            outShapeStridesLocation: null,
            outTexShapeLocation: null
        } : (e.buildVao(c), Object.assign({
            program: t,
            fragmentShader: u,
            source: s,
            webGLProgram: c,
            inShapeInfos: i,
            outShapeInfo: o
        }, mSe(e, t, c)))
    }

    function mSe(e, t, n) {
        var r, a, i, o, s = [],
            u = [],
            c = null;
        o = e.getUniformLocation(n, "NAN", !1), 1 === k0().getNumber("WEBGL_VERSION") && (c = e.getUniformLocation(n, "INFINITY", !1));
        var l, h = !1,
            p = O(t.variableNames);
        try {
            for (p.s(); !(l = p.n()).done;) {
                var f = l.value,
                    d = {
                        name: f,
                        uniform: e.getUniformLocation(n, f, h),
                        offset: e.getUniformLocation(n, "offset".concat(f), h)
                    };
                t.enableShapeUniforms && (d.shape = e.getUniformLocation(n, "".concat(f, "Shape"), h), d.texShape = e.getUniformLocation(n, "".concat(f, "TexShape"), h)), s.push(d)
            }
        } catch (e) {
            p.e(e)
        } finally {
            p.f()
        }
        if (t.enableShapeUniforms && (r = e.getUniformLocation(n, "outShape", h), i = e.getUniformLocation(n, "outShapeStrides", h), a = e.getUniformLocation(n, "outTexShape", h)), t.customUniforms) {
            var v, m = O(t.customUniforms);
            try {
                for (m.s(); !(v = m.n()).done;) {
                    var g = v.value;
                    u.push(e.getUniformLocation(n, g.name, h))
                }
            } catch (e) {
                m.e(e)
            } finally {
                m.f()
            }
        }
        return {
            variablesLocations: s,
            customUniformLocations: u,
            infLoc: c,
            nanLoc: o,
            outShapeLocation: r,
            outShapeStridesLocation: i,
            outTexShapeLocation: a
        }
    }

    function gSe(e, t) {
        if (e.length !== t.length) throw Error("Binary was compiled with ".concat(e.length, " inputs, but ") + "was executed with ".concat(t.length, " inputs"));
        e.forEach((function(e, n) {
            var r = e.logicalShape,
                a = t[n],
                i = a.shape;
            if (!P$(r, i)) throw Error("Binary was compiled with different shapes than " + "the current args. Shapes ".concat(r, " and ").concat(i, " must match"));
            if (!e.isUniform || !a.isUniform) {
                var o = e.texShape,
                    s = a.isUniform ? null : a.texData.texShape;
                if (!P$(o, s)) throw Error("Binary was compiled with different texture shapes than the" + " current args. Shape ".concat(o, " and ").concat(s, " must match"))
            }
        }))
    }

    function ySe(e, t, n, r, a) {
        t.program.enableShapeUniforms || (gSe(t.inShapeInfos, n), gSe([t.outShapeInfo], [r]));
        var i = r.texData.texture,
            o = r.texData.texShape;
        r.texData.isPacked ? e.setOutputPackedMatrixTexture(i.texture, o[0], o[1]) : e.setOutputMatrixTexture(i.texture, o[0], o[1]), e.setProgram(t.webGLProgram), e.bindVertexArray(t.webGLProgram.vao), 1 === k0().getNumber("WEBGL_VERSION") && null !== t.infLoc && e.gl.uniform1f(t.infLoc, 1 / 0), null !== t.nanLoc && e.gl.uniform1f(t.nanLoc, NaN);
        for (var s = 0; s < n.length; ++s) {
            var u = n[s],
                c = t.variablesLocations[s],
                l = c.uniform,
                h = c.offset,
                p = c.shape,
                f = c.texShape;
            if (p) {
                var d = pSe(t.program.packedInputs, u.shape, u.texData.texShape).uniformShape;
                switch (d.length) {
                    case 1:
                        e.gl.uniform1iv(p, new Int32Array(d));
                        break;
                    case 2:
                        e.gl.uniform2iv(p, new Int32Array(d));
                        break;
                    case 3:
                        e.gl.uniform3iv(p, new Int32Array(d));
                        break;
                    case 4:
                        e.gl.uniform4iv(p, new Int32Array(d))
                }
            }
            if (f && e.gl.uniform2i(f, u.texData.texShape[0], u.texData.texShape[1]), null != l)
                if (u.isUniform)
                    if (L$(u.shape) < 2) e.gl.uniform1f(l, u.uniformValues[0]);
                    else {
                        var v = u.uniformValues;
                        v instanceof Float32Array || (v = new Float32Array(v)), e.gl.uniform1fv(l, v)
                    } else null != u.texData.slice && null != h && e.gl.uniform1i(h, u.texData.slice.flatOffset), e.setInputMatrixTexture(u.texData.texture.texture, l, s)
        }
        var m = t.outShapeLocation;
        if (m) switch (r.shape.length) {
            case 1:
                e.gl.uniform1iv(m, new Int32Array(r.shape));
                break;
            case 2:
                e.gl.uniform2iv(m, new Int32Array(r.shape));
                break;
            case 3:
                e.gl.uniform3iv(m, new Int32Array(r.shape));
                break;
            case 4:
                e.gl.uniform4iv(m, new Int32Array(r.shape))
        }
        if (t.outShapeStridesLocation) {
            var g = i0(r.shape);
            switch (r.shape.length) {
                case 2:
                    e.gl.uniform1iv(t.outShapeStridesLocation, new Int32Array(g));
                    break;
                case 3:
                    e.gl.uniform2iv(t.outShapeStridesLocation, new Int32Array(g));
                    break;
                case 4:
                    e.gl.uniform3iv(t.outShapeStridesLocation, new Int32Array(g))
            }
        }
        if (t.outTexShapeLocation && e.gl.uniform2i(t.outTexShapeLocation, r.texData.texShape[0], r.texData.texShape[1]), t.program.customUniforms && a)
            for (var y = 0; y < t.program.customUniforms.length; ++y) {
                var b = t.program.customUniforms[y],
                    x = t.customUniformLocations[y],
                    k = a[y];
                if ("float" === b.type) e.gl.uniform1fv(x, k);
                else if ("vec2" === b.type) e.gl.uniform2fv(x, k);
                else if ("vec3" === b.type) e.gl.uniform3fv(x, k);
                else if ("vec4" === b.type) e.gl.uniform4fv(x, k);
                else if ("int" === b.type) e.gl.uniform1iv(x, k);
                else if ("ivec2" === b.type) e.gl.uniform2iv(x, k);
                else if ("ivec3" === b.type) e.gl.uniform3iv(x, k);
                else {
                    if ("ivec4" !== b.type) throw Error("uniform type ".concat(b.type, " is not supported yet."));
                    e.gl.uniform4iv(x, k)
                }
            }
        e.executeProgram()
    }

    function bSe(e, t, n) {
        var r = "";
        t.concat(n).forEach((function(t) {
            var a = null != t.texData && null != t.texData.slice && t.texData.slice.flatOffset > 0;
            if (e.enableShapeUniforms && !t.isUniform) {
                var i = t.texData.texShape,
                    o = pSe(e.packedInputs, t.shape, i),
                    s = o.useSqueezeShape,
                    u = o.uniformShape,
                    c = o.keptDims,
                    l = "",
                    h = "",
                    p = "";
                if (1 === u.length && e.packedInputs) {
                    var f = [Math.ceil(i[0] / 2), Math.ceil(i[1] / 2)];
                    l = "".concat(f[0] > 1, "_").concat(f[1] > 1)
                } else if (2 !== u.length || e.packedInputs) {
                    if (u.length > 2 && !e.packedInputs) {
                        var d = i0(u);
                        p = "".concat(d[0] === i[1], "_").concat(d[d.length - 1] === i[1])
                    }
                } else h = "".concat(u[0] > 1, "_").concat(u[1] > 1);
                var v = t.shape.length,
                    m = 2 === u.length && P$(t.shape, i),
                    g = 1 === L$(t.shape),
                    y = M7(t.shape, n.shape),
                    b = !e.packedInputs && v === n.shape.length && P$(i, n.texData.texShape),
                    x = e.packedInputs || u.length > 2 ? "" : "".concat(i[0] > 1, "_").concat(i[1] > 1);
                r += "".concat(v, "_").concat(b, "_").concat(s ? c : "", "_").concat(u.length, "_").concat(g, "_").concat(y, "_").concat(m, "_").concat(l, "_").concat(h, "_").concat(p, "_").concat(x, "_").concat(a)
            } else {
                var k = t.isUniform ? "uniform" : t.texData.texShape;
                r += "".concat(t.shape, "_").concat(k, "_").concat(a)
            }
        }));
        var a = e.userCode,
            i = e.constructor.name;
        return i += "_" + r + "_" + a + "".concat(k0().getNumber("WEBGL_VERSION"))
    }

    function xSe(e) {
        return k0().getBool("WEBGL_USE_SHAPES_UNIFORMS") && e <= 4
    }
    var kSe = p((function e(t) {
            l(this, e), this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.outPackingScheme = LIe.DENSE, this.customUniforms = [{
                name: "texShape",
                type: "ivec2"
            }];
            var n = WNe();
            this.outputShape = t, this.enableShapeUniforms = xSe(this.outputShape.length), this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms ? VNe(["r", "c", "d"], t) : UNe(["r", "c", "d"], t), "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ").concat(n.output, " = result;\n      }\n    ")
        })),
        wSe = p((function e(t) {
            l(this, e), this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outPackingScheme = LIe.DENSE, this.customUniforms = [{
                name: "texShape",
                type: "ivec2"
            }];
            var n = WNe();
            this.outputShape = t, this.enableShapeUniforms = xSe(this.outputShape.length), this.userCode = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms ? VNe(["r", "c", "d"], t) : UNe(["r", "c", "d"], t), "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ").concat(n.output, " = result;\n      }\n    ")
        })),
        ISe = p((function e(t) {
            l(this, e), this.variableNames = ["A"], this.outTexUsage = zIe.DOWNLOAD;
            var n = WNe();
            this.outputShape = t, this.userCode = "\n      ".concat(HNe, "\n\n      void main() {\n        float x = getAAtOutCoords();\n        ").concat(n.output, " = encode_float(x);\n      }\n    ")
        })),
        NSe = p((function e(t) {
            l(this, e), this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !1, this.outTexUsage = zIe.DOWNLOAD;
            var n = WNe();
            this.outputShape = t, this.userCode = "\n      ".concat(HNe, "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ").concat(n.output, " = encode_float(x);\n      }\n    ")
        })),
        SSe = {
            R: 0,
            G: 1,
            B: 2,
            A: 3
        },
        TSe = p((function e(t) {
            var n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "RGBA";
            l(this, e), this.variableNames = ["A"], this.customUniforms = [{
                name: "texShape",
                type: "ivec2"
            }];
            var a = WNe();
            this.outputShape = t, this.enableShapeUniforms = xSe(this.outputShape.length);
            var i = "result";
            n && (i = "floor(result * 255. + 0.5)");
            for (var o = "", s = 0; s < r.length; s++) {
                var u = r[s];
                o += "\n          if(offset == ".concat(s, ") {\n            result = values[").concat(SSe[u], "];\n          }")
            }
            this.userCode = "\n      ".concat(this.enableShapeUniforms ? "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n" : jNe(t), "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ").concat(r.length, ");\n\n        flatIndex = idiv(flatIndex, ").concat(r.length, ", 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ").concat(a.texture2D, "(A, uv);\n          ").concat(o, "\n        }\n        ").concat(a.output, " = vec4(").concat(i, ", 0., 0., 0.);\n      }\n    ")
        })),
        ESe = p((function e(t) {
            var n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            l(this, e), this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.customUniforms = [{
                name: "texShape",
                type: "ivec2"
            }];
            var r = WNe();
            this.outputShape = t, this.enableShapeUniforms = xSe(this.outputShape.length);
            var a = "",
                i = "result";
            n && (i = "floor(result * 255. + 0.5)");
            for (var o = 0; o <= 1; o++)
                for (var s = 0; s <= 1; s++) {
                    var u = 2 * o + s;
                    a += "\n          localCoords = coords;\n          if(localCoords[2] + ".concat(s, " < ").concat(this.enableShapeUniforms ? "outShape[2]" : "".concat(t[2]), ") {\n          localCoords[2] += ").concat(s, ";\n          if (localCoords[1] + ").concat(o, " < ").concat(this.enableShapeUniforms ? "outShape[1]" : "".concat(t[1]), ") {\n            localCoords[1] += ").concat(o, ";\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ").concat(r.texture2D, "(A, uv);\n\n            if (offset == 0) {\n              result[").concat(u, "] = values[0];\n            } else if (offset == 1) {\n              result[").concat(u, "] = values[1];\n            } else if (offset == 2) {\n              result[").concat(u, "] = values[2];\n            } else {\n              result[").concat(u, "] = values[3];\n            }\n          }\n        }\n        ")
                }
            this.userCode = "\n        ".concat(this.enableShapeUniforms ? "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n" : jNe(t), "\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ").concat(a, "\n\n          ").concat(r.output, " = ").concat(i, ";\n        }\n    ")
        }));

    function CSe(e) {
        var t = WNe();
        return ZIe(e, "".concat(t.version, "\n    precision highp float;\n    ").concat(t.attribute, " vec3 clipSpacePos;\n    ").concat(t.attribute, " vec2 uv;\n    ").concat(t.varyingVs, " vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }"))
    }

    function ASe(e) {
        return oNe(e, new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]))
    }

    function RSe(e) {
        return sNe(e, new Uint16Array([0, 1, 2, 2, 1, 3]))
    }

    function _Se(e, t, n, r, a, i) {
        cNe(t, n);
        var o = uNe(e),
            s = e.TEXTURE_2D;
        return KIe(e, (function() {
            return e.bindTexture(s, o)
        })), KIe(e, (function() {
            return e.texParameteri(s, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE)
        })), KIe(e, (function() {
            return e.texParameteri(s, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE)
        })), KIe(e, (function() {
            return e.texParameteri(s, e.TEXTURE_MIN_FILTER, e.NEAREST)
        })), KIe(e, (function() {
            return e.texParameteri(s, e.TEXTURE_MAG_FILTER, e.NEAREST)
        })), 1 === k0().getNumber("WEBGL_VERSION") ? KIe(e, (function() {
            return e.texImage2D(s, 0, r, t, n, 0, a, i, null)
        })) : KIe(e, (function() {
            return e.texStorage2D(s, 1, r, t, n)
        })), KIe(e, (function() {
            return e.bindTexture(e.TEXTURE_2D, null)
        })), {
            texture: o,
            texShape: [n, t]
        }
    }

    function OSe(e) {
        return e.internalFormatFloat
    }

    function FSe(e, t, n, r) {
        var a = S(GIe(t, n), 2);
        return _Se(e, a[0], a[1], OSe(r), r.textureFormatFloat, e.FLOAT)
    }

    function DSe(e) {
        return e.internalFormatHalfFloat
    }

    function MSe(e, t, n, r) {
        var a = S(GIe(t, n), 2);
        return _Se(e, a[0], a[1], DSe(r), r.textureFormatFloat, r.textureTypeHalfFloat)
    }

    function LSe(e) {
        return e.downloadTextureFormat
    }

    function zSe(e, t, n, r) {
        var a = S(GIe(t, n), 2);
        return _Se(e, a[0], a[1], LSe(r), e.RGBA, e.UNSIGNED_BYTE)
    }

    function PSe(e) {
        return e.internalFormatPackedFloat
    }

    function BSe(e, t, n, r) {
        var a = S(HIe(t, n), 2);
        return _Se(e, a[0], a[1], PSe(r), e.RGBA, e.FLOAT)
    }

    function WSe(e) {
        return e.internalFormatPackedHalfFloat
    }

    function USe(e, t, n, r) {
        var a = S(HIe(t, n), 2);
        return _Se(e, a[0], a[1], WSe(r), e.RGBA, r.textureTypeHalfFloat)
    }

    function VSe(e, t, n) {
        return KIe(e, (function() {
            return e.bindBuffer(e.ARRAY_BUFFER, n)
        })), hNe(e, t, "clipSpacePos", n, 3, 20, 0) && hNe(e, t, "uv", n, 2, 20, 12)
    }

    function GSe(e, t, n, r, a, i) {
        var o, s, u;
        KIe(e, (function() {
            return e.bindTexture(e.TEXTURE_2D, t)
        })), a instanceof Uint8Array ? (o = new Uint8Array(n * r * 4), s = e.UNSIGNED_BYTE, u = e.RGBA) : (o = new Float32Array(n * r * 4), s = e.FLOAT, u = i.internalFormatPackedFloat), o.set(a), 2 === k0().getNumber("WEBGL_VERSION") ? KIe(e, (function() {
            return e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, n, r, e.RGBA, s, o)
        })) : KIe(e, (function() {
            return e.texImage2D(e.TEXTURE_2D, 0, u, n, r, 0, e.RGBA, s, o)
        })), KIe(e, (function() {
            return e.bindTexture(e.TEXTURE_2D, null)
        }))
    }

    function jSe(e, t, n) {
        KIe(e, (function() {
            return e.bindTexture(e.TEXTURE_2D, t)
        })), n.data instanceof Uint8Array ? 2 === k0().getNumber("WEBGL_VERSION") ? KIe(e, (function() {
            return e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, n.width, n.height, e.RGBA, e.UNSIGNED_BYTE, n.data)
        })) : KIe(e, (function() {
            return e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, n.width, n.height, 0, e.RGBA, e.UNSIGNED_BYTE, n.data)
        })) : 2 === k0().getNumber("WEBGL_VERSION") ? KIe(e, (function() {
            return e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, e.RGBA, e.UNSIGNED_BYTE, n)
        })) : KIe(e, (function() {
            return e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, n)
        })), KIe(e, (function() {
            return e.bindTexture(e.TEXTURE_2D, null)
        }))
    }

    function HSe(e, t, n, r) {
        var a = e.createBuffer();
        KIe(e, (function() {
            return e.bindBuffer(e.PIXEL_PACK_BUFFER, a)
        }));
        var i = 16 * t * n;
        return KIe(e, (function() {
            return e.bufferData(e.PIXEL_PACK_BUFFER, i, e.STREAM_READ)
        })), KIe(e, (function() {
            return e.readPixels(0, 0, n, t, e.RGBA, e.FLOAT, 0)
        })), KIe(e, (function() {
            return e.bindBuffer(e.PIXEL_PACK_BUFFER, null)
        })), a
    }

    function qSe(e, t, n) {
        var r = e,
            a = new Float32Array(n);
        return r.bindBuffer(r.PIXEL_PACK_BUFFER, t), r.getBufferSubData(r.PIXEL_PACK_BUFFER, 0, a), r.bindBuffer(r.PIXEL_PACK_BUFFER, null), a
    }

    function KSe(e, t, n, r) {
        var a = S(GIe(t, n), 2),
            i = a[0],
            o = a[1],
            s = new Uint8Array(t * n * 4);
        return KIe(e, (function() {
            return e.readPixels(0, 0, i, o, r.downloadTextureFormat, e.UNSIGNED_BYTE, s)
        })), new Float32Array(s.buffer)
    }

    function XSe(e, t, n, r, a, i, o, s) {
        var u = e,
            c = new Float32Array(function(e, t) {
                var n = S(HIe(e, t), 2);
                return n[0] * n[1] * 4
            }(i, o));
        return u.bindBuffer(u.PIXEL_PACK_BUFFER, t), u.getBufferSubData(u.PIXEL_PACK_BUFFER, 0, c), u.bindBuffer(u.PIXEL_PACK_BUFFER, null), c
    }

    function YSe(e, t, n) {
        var r = new Float32Array(t * n * 4);
        return KIe(e, (function() {
            return e.readPixels(0, 0, n, t, e.RGBA, e.FLOAT, r)
        })), r
    }
    var JSe = {
            __proto__: null,
            bindVertexProgramAttributeStreams: VSe,
            createBufferFromOutputTexture: HSe,
            createFloat16MatrixTexture: MSe,
            createFloat16PackedMatrixTexture: USe,
            createFloat32MatrixTexture: FSe,
            createIndexBuffer: RSe,
            createPackedMatrixTexture: BSe,
            createUnsignedBytesMatrixTexture: zSe,
            createVertexBuffer: ASe,
            createVertexShader: CSe,
            downloadByteEncodedFloatMatrixFromOutputTexture: KSe,
            downloadFloat32MatrixFromBuffer: qSe,
            downloadMatrixFromPackedOutputTexture: YSe,
            downloadPackedMatrixFromBuffer: XSe,
            getInternalFormatForFloat16MatrixTexture: DSe,
            getInternalFormatForFloat16PackedMatrixTexture: WSe,
            getInternalFormatForFloat32MatrixTexture: OSe,
            getInternalFormatForPackedMatrixTexture: PSe,
            getInternalFormatForUnsignedBytesMatrixTexture: LSe,
            uploadDenseMatrixToTexture: GSe,
            uploadPixelDataToTexture: jSe
        },
        ZSe = function() {
            function e(t) {
                l(this, e), this.outputTexture = null, this.program = null, this.disposed = !1, this.itemsToPoll = [];
                var n = k0().getNumber("WEBGL_VERSION");
                if (null != t ? (this.gl = t, UIe(n, t)) : this.gl = VIe(n), t = this.gl, 2 === k0().getNumber("WEBGL_VERSION")) {
                    var r = t;
                    this.createVertexArray = function() {
                        return KIe(r, (function() {
                            return r.createVertexArray()
                        }))
                    }, this.bindVertexArray = function(e) {
                        return KIe(r, (function() {
                            return r.bindVertexArray(e)
                        }))
                    }, this.deleteVertexArray = function(e) {
                        return KIe(r, (function() {
                            return r.deleteVertexArray(e)
                        }))
                    }, this.getVertexArray = function() {
                        return KIe(r, (function() {
                            return r.getParameter(r.VERTEX_ARRAY_BINDING)
                        }))
                    }
                } else if (null != t) {
                    var a = t.getExtension("OES_vertex_array_object");
                    if (null == a) throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");
                    this.createVertexArray = function() {
                        return KIe(t, (function() {
                            return a.createVertexArrayOES()
                        }))
                    }, this.bindVertexArray = function(e) {
                        return KIe(t, (function() {
                            return a.bindVertexArrayOES(e)
                        }))
                    }, this.deleteVertexArray = function(e) {
                        return KIe(t, (function() {
                            return a.deleteVertexArrayOES(e)
                        }))
                    }, this.getVertexArray = function() {
                        return KIe(t, (function() {
                            return t.getParameter(a.VERTEX_ARRAY_BINDING_OES)
                        }))
                    }
                }
                var i = "WEBGL_color_buffer_float",
                    o = "EXT_color_buffer_half_float";
                if (this.parallelCompilationExtension = this.gl.getExtension("KHR_parallel_shader_compile"), 1 === k0().getNumber("WEBGL_VERSION")) {
                    var s = "OES_texture_half_float";
                    if (this.textureFloatExtension = JIe(this.gl, "OES_texture_float"), _Ne(this.gl, s)) this.textureHalfFloatExtension = JIe(this.gl, s);
                    else if (k0().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
                    if (this.colorBufferFloatExtension = this.gl.getExtension(i), _Ne(this.gl, o)) this.colorBufferHalfFloatExtension = JIe(this.gl, o);
                    else if (k0().get("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")
                } else if (i = "EXT_color_buffer_float", _Ne(this.gl, i)) this.colorBufferFloatExtension = this.gl.getExtension(i);
                else {
                    if (!_Ne(this.gl, o)) throw new Error("GL context does not support color renderable floats");
                    this.colorBufferHalfFloatExtension = this.gl.getExtension(o)
                }
                this.vertexBuffer = ASe(this.gl), this.indexBuffer = RSe(this.gl), this.framebuffer = lNe(this.gl), this.textureConfig = qIe(this.gl, this.textureHalfFloatExtension)
            }
            var t;
            return p(e, [{
                key: "debug",
                get: function() {
                    return k0().getBool("DEBUG")
                }
            }, {
                key: "dispose",
                value: function() {
                    var e = this;
                    if (!this.disposed) {
                        null != this.program && console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."), null != this.outputTexture && console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
                        var t = this.gl;
                        KIe(t, (function() {
                            return t.finish()
                        })), KIe(t, (function() {
                            return t.bindFramebuffer(t.FRAMEBUFFER, null)
                        })), KIe(t, (function() {
                            return t.deleteFramebuffer(e.framebuffer)
                        })), KIe(t, (function() {
                            return t.bindBuffer(t.ARRAY_BUFFER, null)
                        })), KIe(t, (function() {
                            return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, null)
                        })), KIe(t, (function() {
                            return t.deleteBuffer(e.indexBuffer)
                        })), this.disposed = !0
                    }
                }
            }, {
                key: "createFloat32MatrixTexture",
                value: function(e, t) {
                    return this.throwIfDisposed(), FSe(this.gl, e, t, this.textureConfig)
                }
            }, {
                key: "createFloat16MatrixTexture",
                value: function(e, t) {
                    return this.throwIfDisposed(), MSe(this.gl, e, t, this.textureConfig)
                }
            }, {
                key: "createUnsignedBytesMatrixTexture",
                value: function(e, t) {
                    return this.throwIfDisposed(), zSe(this.gl, e, t, this.textureConfig)
                }
            }, {
                key: "uploadPixelDataToTexture",
                value: function(e, t) {
                    this.throwIfDisposed(), jSe(this.gl, e, t)
                }
            }, {
                key: "uploadDenseMatrixToTexture",
                value: function(e, t, n, r) {
                    this.throwIfDisposed(), GSe(this.gl, e, t, n, r, this.textureConfig)
                }
            }, {
                key: "createFloat16PackedMatrixTexture",
                value: function(e, t) {
                    return this.throwIfDisposed(), USe(this.gl, e, t, this.textureConfig)
                }
            }, {
                key: "createPackedMatrixTexture",
                value: function(e, t) {
                    return this.throwIfDisposed(), BSe(this.gl, e, t, this.textureConfig)
                }
            }, {
                key: "deleteMatrixTexture",
                value: function(e) {
                    var t = this;
                    this.throwIfDisposed(), this.outputTexture === e && (gNe(this.gl, this.framebuffer), this.outputTexture = null), KIe(this.gl, (function() {
                        return t.gl.deleteTexture(e)
                    }))
                }
            }, {
                key: "downloadByteEncodedFloatMatrixFromOutputTexture",
                value: function(e, t, n) {
                    var r = this;
                    return this.downloadMatrixDriver(e, (function() {
                        return KSe(r.gl, t, n, r.textureConfig)
                    }))
                }
            }, {
                key: "downloadPackedMatrixFromBuffer",
                value: function(e, t, n, r, a, i) {
                    return XSe(this.gl, e, 0, 0, 0, a, i, this.textureConfig)
                }
            }, {
                key: "downloadFloat32MatrixFromBuffer",
                value: function(e, t) {
                    return qSe(this.gl, e, t)
                }
            }, {
                key: "createBufferFromTexture",
                value: function(e, t, n) {
                    this.bindTextureToFrameBuffer(e);
                    var r = HSe(this.gl, t, n, this.textureConfig);
                    return this.unbindTextureToFrameBuffer(), r
                }
            }, {
                key: "createAndWaitForFence",
                value: function() {
                    var e = this.createFence(this.gl);
                    return this.pollFence(e)
                }
            }, {
                key: "createFence",
                value: function(e) {
                    var t, n, r = this;
                    if (k0().getBool("WEBGL_FENCE_API_ENABLED")) {
                        var a = e,
                            i = a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE, 0);
                        e.flush(), n = function() {
                            var e = a.clientWaitSync(i, 0, 0);
                            return e === a.ALREADY_SIGNALED || e === a.CONDITION_SATISFIED
                        }, t = i
                    } else k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (t = this.beginQuery(), this.endQuery(), n = function() {
                        return r.isQueryAvailable(t, k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))
                    }) : n = function() {
                        return !0
                    };
                    return {
                        query: t,
                        isFencePassed: n
                    }
                }
            }, {
                key: "downloadMatrixFromPackedTexture",
                value: function(e, t, n) {
                    var r = this;
                    return this.downloadMatrixDriver(e, (function() {
                        return YSe(r.gl, t, n)
                    }))
                }
            }, {
                key: "createProgram",
                value: function(e) {
                    var t = this;
                    this.throwIfDisposed();
                    var n = this.gl;
                    null == this.vertexShader && (this.vertexShader = CSe(n));
                    var r = rNe(n);
                    KIe(n, (function() {
                        return n.attachShader(r, t.vertexShader)
                    })), KIe(n, (function() {
                        return n.attachShader(r, e)
                    })), aNe(n, r);
                    var a = Object.assign(r, {
                        vao: this.createVertexArray()
                    });
                    return this.debug && iNe(n, a), a
                }
            }, {
                key: "buildVao",
                value: function(e) {
                    var t = this;
                    this.setProgram(e), this.bindVertexArray(e.vao);
                    var n = this.gl;
                    KIe(n, (function() {
                        return n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t.indexBuffer)
                    })), VSe(n, e, this.vertexBuffer)
                }
            }, {
                key: "deleteProgram",
                value: function(e) {
                    var t = this;
                    this.throwIfDisposed(), e === this.program && (this.program = null), null != e && (KIe(this.gl, (function() {
                        return t.gl.deleteProgram(e)
                    })), this.deleteVertexArray(e.vao))
                }
            }, {
                key: "setProgram",
                value: function(e) {
                    var t = this;
                    this.throwIfDisposed(), this.program = e, null != this.program && this.debug && iNe(this.gl, this.program), KIe(this.gl, (function() {
                        return t.gl.useProgram(e)
                    }))
                }
            }, {
                key: "getUniformLocation",
                value: function(e, t) {
                    var n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                    return this.throwIfDisposed(), n ? fNe(this.gl, e, t) : dNe(this.gl, e, t)
                }
            }, {
                key: "getAttributeLocation",
                value: function(e, t) {
                    var n = this;
                    return this.throwIfDisposed(), KIe(this.gl, (function() {
                        return n.gl.getAttribLocation(e, t)
                    }))
                }
            }, {
                key: "getUniformLocationNoThrow",
                value: function(e, t) {
                    return this.throwIfDisposed(), this.gl.getUniformLocation(e, t)
                }
            }, {
                key: "setInputMatrixTexture",
                value: function(e, t, n) {
                    this.throwIfDisposed(), this.throwIfNoProgram(), vNe(this.gl, e, t, n)
                }
            }, {
                key: "setOutputMatrixTexture",
                value: function(e, t, n) {
                    this.setOutputMatrixTextureDriver(e, n, t)
                }
            }, {
                key: "setOutputPackedMatrixTexture",
                value: function(e, t, n) {
                    this.throwIfDisposed();
                    var r = S(HIe(t, n), 2),
                        a = r[0],
                        i = r[1];
                    this.setOutputMatrixTextureDriver(e, a, i)
                }
            }, {
                key: "setOutputMatrixWriteRegion",
                value: function(e, t, n, r) {
                    this.setOutputMatrixWriteRegionDriver(n, e, r, t)
                }
            }, {
                key: "setOutputPackedMatrixWriteRegion",
                value: function(e, t, n, r) {
                    throw new Error("setOutputPackedMatrixWriteRegion not implemented.")
                }
            }, {
                key: "debugValidate",
                value: function() {
                    null != this.program && iNe(this.gl, this.program), yNe(this.gl)
                }
            }, {
                key: "executeProgram",
                value: function() {
                    this.throwIfDisposed(), this.throwIfNoProgram();
                    var e = this.gl;
                    if (this.debug) {
                        var t = this.getVertexArray();
                        console.assert(t === this.program.vao, "VAO changed between setProgram and executeProgram!"), this.debugValidate()
                    }
                    KIe(e, (function() {
                        return e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0)
                    }))
                }
            }, {
                key: "blockUntilAllProgramsCompleted",
                value: function() {
                    var e = this;
                    this.throwIfDisposed(), KIe(this.gl, (function() {
                        return e.gl.finish()
                    }))
                }
            }, {
                key: "getQueryTimerExtension",
                value: function() {
                    return null == this.disjointQueryTimerExtension && (this.disjointQueryTimerExtension = JIe(this.gl, 2 === k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")), this.disjointQueryTimerExtension
                }
            }, {
                key: "getQueryTimerExtensionWebGL2",
                value: function() {
                    return this.getQueryTimerExtension()
                }
            }, {
                key: "getQueryTimerExtensionWebGL1",
                value: function() {
                    return this.getQueryTimerExtension()
                }
            }, {
                key: "beginQuery",
                value: function() {
                    if (2 === k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
                        var e = this.gl,
                            t = this.getQueryTimerExtensionWebGL2(),
                            n = e.createQuery();
                        return e.beginQuery(t.TIME_ELAPSED_EXT, n), n
                    }
                    var r = this.getQueryTimerExtensionWebGL1(),
                        a = r.createQueryEXT();
                    return r.beginQueryEXT(r.TIME_ELAPSED_EXT, a), a
                }
            }, {
                key: "endQuery",
                value: function() {
                    if (2 !== k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")) {
                        var e = this.getQueryTimerExtensionWebGL1();
                        e.endQueryEXT(e.TIME_ELAPSED_EXT)
                    } else {
                        var t = this.gl,
                            n = this.getQueryTimerExtensionWebGL2();
                        t.endQuery(n.TIME_ELAPSED_EXT)
                    }
                }
            }, {
                key: "waitForQueryAndGetTime",
                value: (t = c(o().mark((function e(t) {
                    var n = this;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                return e.next = 2, V$((function() {
                                    return n.disposed || n.isQueryAvailable(t, k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))
                                }));
                            case 2:
                                return e.abrupt("return", this.getQueryTime(t, k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")));
                            case 3:
                            case "end":
                                return e.stop()
                        }
                    }), e, this)
                }))), function(e) {
                    return t.apply(this, arguments)
                })
            }, {
                key: "getQueryTime",
                value: function(e, t) {
                    if (0 === t) return null;
                    if (2 === t) {
                        var n = this.gl;
                        return n.getQueryParameter(e, n.QUERY_RESULT) / 1e6
                    }
                    var r = this.getQueryTimerExtensionWebGL1();
                    return r.getQueryObjectEXT(e, r.QUERY_RESULT_EXT) / 1e6
                }
            }, {
                key: "isQueryAvailable",
                value: function(e, t) {
                    if (0 === t) return !0;
                    if (2 === t) {
                        var n = this.gl,
                            r = this.getQueryTimerExtensionWebGL2(),
                            a = n.getQueryParameter(e, n.QUERY_RESULT_AVAILABLE);
                        return null == this.disjoint && (this.disjoint = this.gl.getParameter(r.GPU_DISJOINT_EXT)), a && !this.disjoint
                    }
                    var i = this.getQueryTimerExtensionWebGL1(),
                        o = i.getQueryObjectEXT(e, i.QUERY_RESULT_AVAILABLE_EXT);
                    return null == this.disjoint && (this.disjoint = this.gl.getParameter(i.GPU_DISJOINT_EXT)), o && !this.disjoint
                }
            }, {
                key: "pollFence",
                value: function(e) {
                    var t = this;
                    return new Promise((function(n) {
                        t.addItemToPoll((function() {
                            return e.isFencePassed()
                        }), (function() {
                            return n()
                        }))
                    }))
                }
            }, {
                key: "pollItems",
                value: function() {
                    for (var e = function(e) {
                            for (var t = 0; t < e.length; ++t) {
                                if (!e[t]()) break
                            }
                            return t - 1
                        }(this.itemsToPoll.map((function(e) {
                            return e.isDoneFn
                        }))), t = 0; t <= e; ++t) {
                        (0, this.itemsToPoll[t].resolveFn)()
                    }
                    this.itemsToPoll = this.itemsToPoll.slice(e + 1)
                }
            }, {
                key: "addItemToPoll",
                value: function(e, t) {
                    var n = this;
                    if (this.itemsToPoll.push({
                            isDoneFn: e,
                            resolveFn: t
                        }), !(this.itemsToPoll.length > 1)) {
                        var r = void 0;
                        "setTimeoutCustom" in k0().platform && (r = k0().platform.setTimeoutCustom.bind(k0().platform)), V$((function() {
                            return n.pollItems(), 0 === n.itemsToPoll.length
                        }), (function() {
                            return 0
                        }), null, r)
                    }
                }
            }, {
                key: "bindTextureToFrameBuffer",
                value: function(e) {
                    this.throwIfDisposed(), mNe(this.gl, e, this.framebuffer), this.debug && yNe(this.gl)
                }
            }, {
                key: "unbindTextureToFrameBuffer",
                value: function() {
                    null != this.outputTexture ? (mNe(this.gl, this.outputTexture, this.framebuffer), this.debug && yNe(this.gl)) : gNe(this.gl, this.framebuffer)
                }
            }, {
                key: "downloadMatrixDriver",
                value: function(e, t) {
                    this.bindTextureToFrameBuffer(e);
                    var n = t();
                    return this.unbindTextureToFrameBuffer(), n
                }
            }, {
                key: "setOutputMatrixTextureDriver",
                value: function(e, t, n) {
                    this.throwIfDisposed();
                    var r = this.gl;
                    mNe(r, e, this.framebuffer), this.debug && yNe(r), this.outputTexture = e, KIe(r, (function() {
                        return r.viewport(0, 0, t, n)
                    })), KIe(r, (function() {
                        return r.scissor(0, 0, t, n)
                    }))
                }
            }, {
                key: "setOutputMatrixWriteRegionDriver",
                value: function(e, t, n, r) {
                    var a = this;
                    this.throwIfDisposed(), KIe(this.gl, (function() {
                        return a.gl.scissor(e, t, n, r)
                    }))
                }
            }, {
                key: "throwIfDisposed",
                value: function() {
                    if (this.disposed) throw new Error("Attempted to use disposed GPGPUContext.")
                }
            }, {
                key: "throwIfNoProgram",
                value: function() {
                    if (null == this.program) throw new Error("No GPU program is currently set.")
                }
            }]), e
        }();
    var QSe = Sge,
        $Se = Age,
        eTe = Rge,
        tTe = _ge,
        nTe = xge,
        rTe = zge,
        aTe = Wge,
        iTe = Uge,
        oTe = jge,
        sTe = Kge,
        uTe = Jge,
        cTe = nye,
        lTe = rye,
        hTe = aye,
        pTe = sye,
        fTe = lye,
        dTe = fye,
        vTe = mye,
        mTe = gye,
        gTe = xye,
        yTe = kye,
        bTe = Nye,
        xTe = Eye,
        kTe = _ye,
        wTe = Fye,
        ITe = Bye,
        NTe = jye,
        STe = qye,
        TTe = Zye,
        ETe = Qye,
        CTe = $ye,
        ATe = nbe,
        RTe = rbe,
        _Te = lge,
        OTe = obe,
        FTe = cbe,
        DTe = lbe,
        MTe = hbe,
        LTe = pbe,
        zTe = ybe,
        PTe = kbe,
        BTe = Ibe,
        WTe = Sbe,
        UTe = Tbe,
        VTe = Ebe,
        GTe = _be,
        jTe = Dbe,
        HTe = Lye,
        qTe = Mbe;

    function KTe(e, t) {
        return ["x", "y", "z", "w", "u", "v"].slice(0, t).map((function(t) {
            return "".concat(e, ".").concat(t)
        }))
    }

    function XTe(e, t) {
        return 1 === t ? [e] : KTe(e, t)
    }
    var YTe = function() {
            function e(t) {
                if (l(this, e), this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0, this.outputShape = t, this.rank = t.length, this.enableShapeUniforms = xSe(this.outputShape.length), 0 === this.rank) this.userCode = "\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";
                else {
                    var n = XTe("rc", this.rank),
                        r = hSe(this.rank),
                        a = this.getOutOfBoundsCondition(n),
                        i = this.getSetup(n),
                        o = this.getOutput(n);
                    this.userCode = "\n        void main() {\n          ".concat(r, " rc = getOutputCoords();\n\n          if(").concat(a, ") {\n            setOutput(vec4(0));\n          } else {\n            ").concat(i, "\n\n            setOutput(vec4(").concat(o, "));\n          }\n        }\n      ")
                }
            }
            return p(e, [{
                key: "getSourceCoordsArr",
                value: function(e) {
                    for (var t = [], n = 0; n <= 1; n++)
                        for (var r = 0; r <= 1; r++) {
                            for (var a = "".concat(0 === n ? "r" : "rp1", ", ").concat(0 === r ? "c" : "cp1"), i = 2; i < this.rank; i++) a = "".concat(e[e.length - 1 - i], ",") + a;
                            t.push(a)
                        }
                    return t
                }
            }, {
                key: "getOutOfBoundsCondition",
                value: function(e) {
                    if (1 === this.rank) return "rc > ".concat(this.enableShapeUniforms ? "outShape" : this.outputShape[0]);
                    for (var t = "", n = this.rank - 2; n < this.rank; n++) t += "".concat(e[n], " >= ").concat(this.enableShapeUniforms ? "outShape[".concat(n, "]") : this.outputShape[n]), n < this.rank - 1 && (t += "||");
                    return t
                }
            }, {
                key: "getSetup",
                value: function(e) {
                    if (1 === this.rank) return "";
                    var t = e.slice(-2),
                        n = this.enableShapeUniforms ? "outShape[".concat(this.rank, " - 1]") : this.outputShape[this.rank - 1],
                        r = this.enableShapeUniforms ? "outShape[".concat(this.rank, " - 2]") : this.outputShape[this.rank - 2];
                    return "\n      int r = ".concat(t[0], ";\n      int c = ").concat(t[1], ";\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ").concat(n, ";\n      bool rEdge = rp1 >= ").concat(r, ";\n    ")
                }
            }, {
                key: "getOutput",
                value: function(e) {
                    var t = this.getSourceCoordsArr(e);
                    if (1 === this.rank) {
                        var n = this.enableShapeUniforms ? "outShape" : this.outputShape[0];
                        return "getA(rc), (rc + 1 >= ".concat(n, " ? 0. : getA(rc + 1)), 0, 0")
                    }
                    return "getA(".concat(t[0], "),\n            cEdge ? 0. : getA(").concat(t[1], "),\n            rEdge ? 0. : getA(").concat(t[2], "),\n            rEdge || cEdge ? 0. : getA(").concat(t[3], ")")
                }
            }]), e
        }(),
        JTe = p((function e(t, n) {
            l(this, e), this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.customUniforms = [{
                name: "inputShape",
                type: "ivec3"
            }], this.outputShape = t, this.enableShapeUniforms = xSe(this.outputShape.length);
            for (var r, a, i, o = "", s = 0; s < 4; s++) {
                var u = "thisRC = rc;";
                s % 2 == 1 && (u += "thisRC.z += 1;"), s > 1 && (u += "thisRC.y += 1;"), o += "\n        ".concat(u, "\n        ").concat(s > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : "", "\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[").concat(s, "] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ").concat(s > 0 ? "}" : "", "\n      ")
            }
            this.userCode = "\n      ".concat((r = n, a = this.enableShapeUniforms, i = a ? function(e, t) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "index",
                    r = e.map((function(e, t) {
                        return t
                    })),
                    a = GNe(r, t);
                return a.map((function(t, r) {
                    var i = "int ".concat(e[r], " = ").concat(n, " / ").concat(a[r]),
                        o = r === a.length - 1 ? "int ".concat(e[r + 1], " = ").concat(n, " - ").concat(e[r], " * ").concat(a[r]) : "index -= ".concat(e[r], " * ").concat(a[r]);
                    return "".concat(i, "; ").concat(o, ";")
                })).join("")
            }(["r", "c", "d"], "inputShape") : UNe(["r", "c", "d"], r), "\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ".concat(i, "\n      return ivec3(r, c, d);\n    }\n  ")), "\n      ").concat(this.enableShapeUniforms ? "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n" : jNe(t), "\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ").concat(this.enableShapeUniforms ? "outShape[1]" : t[1], ";\n        int cols = ").concat(this.enableShapeUniforms ? "outShape[2]" : t[2], ";\n\n        ").concat(o, "\n\n        setOutput(result);\n      }\n    ")
        }));
    var ZTe = function() {
        function e(t) {
            l(this, e), this.gpgpu = t, this.numUsedTextures = 0, this.numFreeTextures = 0, this._numBytesAllocated = 0, this._numBytesFree = 0, this.freeTextures = {}, this.usedTextures = {}, this.logEnabled = !1
        }
        return p(e, [{
            key: "acquireTexture",
            value: function(e, t, n) {
                var r = $Te(t, n),
                    a = eEe(e, r, n);
                a in this.freeTextures || (this.freeTextures[a] = []), a in this.usedTextures || (this.usedTextures[a] = []);
                var i, o = QTe(e, r, this.gpgpu.gl, this.gpgpu.textureConfig, n);
                if (this.freeTextures[a].length > 0) {
                    this.numFreeTextures--, this.numUsedTextures++, this._numBytesFree -= o, this.log();
                    var s = this.freeTextures[a].pop();
                    return this.usedTextures[a].push(s), s
                }
                return r === PIe.PACKED_2X2_FLOAT32 ? i = this.gpgpu.createPackedMatrixTexture(e[0], e[1]) : r === PIe.PACKED_2X2_FLOAT16 ? i = this.gpgpu.createFloat16PackedMatrixTexture(e[0], e[1]) : r === PIe.UNPACKED_FLOAT32 ? i = this.gpgpu.createFloat32MatrixTexture(e[0], e[1]) : r === PIe.UNPACKED_FLOAT16 ? i = this.gpgpu.createFloat16MatrixTexture(e[0], e[1]) : r === PIe.PACKED_4X1_UNSIGNED_BYTE && (i = this.gpgpu.createUnsignedBytesMatrixTexture(e[0], e[1])), this.usedTextures[a].push(i), this.numUsedTextures++, this._numBytesAllocated += o, this.log(), i
            }
        }, {
            key: "releaseTexture",
            value: function(e, t, n, r) {
                if (null != this.freeTextures) {
                    var a = $Te(n, r),
                        i = eEe(t, a, r);
                    i in this.freeTextures || (this.freeTextures[i] = []);
                    var o = QTe(t, a, this.gpgpu.gl, this.gpgpu.textureConfig, r),
                        s = k0().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD"); - 1 !== s && this._numBytesAllocated > s ? (this.gpgpu.deleteMatrixTexture(e.texture), this._numBytesAllocated -= o) : (this.freeTextures[i].push(e), this.numFreeTextures++, this._numBytesFree += o), this.numUsedTextures--;
                    var u = this.usedTextures[i],
                        c = u && u.indexOf(e);
                    if (null == c || c < 0) throw new Error("Cannot release a texture that was never provided by this texture manager");
                    u[c] = u[u.length - 1], u.pop(), this.log()
                }
            }
        }, {
            key: "log",
            value: function() {
                if (this.logEnabled) {
                    var e = this.numFreeTextures + this.numUsedTextures;
                    console.log("Free/Used", "".concat(this.numFreeTextures, " / ").concat(this.numUsedTextures), "(".concat(e, ")"));
                    var t = this._numBytesFree / this._numBytesAllocated;
                    console.log("Bytes allocated: ".concat(this._numBytesAllocated)), console.log("Bytes unused: ".concat(this._numBytesFree, " (").concat(Math.round(100 * t), "%)"))
                }
            }
        }, {
            key: "numBytesAllocated",
            get: function() {
                return this._numBytesAllocated
            }
        }, {
            key: "numBytesFree",
            get: function() {
                return this._numBytesFree
            }
        }, {
            key: "getNumUsedTextures",
            value: function() {
                return this.numUsedTextures
            }
        }, {
            key: "getNumFreeTextures",
            value: function() {
                return this.numFreeTextures
            }
        }, {
            key: "dispose",
            value: function() {
                var e = this;
                if (null != this.freeTextures) {
                    for (var t in this.freeTextures) this.freeTextures[t].forEach((function(t) {
                        e.gpgpu.deleteMatrixTexture(t.texture)
                    }));
                    for (var n in this.usedTextures) this.usedTextures[n].forEach((function(t) {
                        e.gpgpu.deleteMatrixTexture(t.texture)
                    }));
                    this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0, this._numBytesAllocated = 0, this._numBytesFree = 0
                }
            }
        }]), e
    }();

    function QTe(e, t, n, r, a) {
        var i, o = function(e, t) {
            switch (e) {
                case PIe.PACKED_2X2_FLOAT32:
                    return PSe(t);
                case PIe.PACKED_2X2_FLOAT16:
                    return WSe(t);
                case PIe.UNPACKED_FLOAT32:
                    return OSe(t);
                case PIe.UNPACKED_FLOAT16:
                    return DSe(t);
                case PIe.PACKED_4X1_UNSIGNED_BYTE:
                    return LSe(t);
                default:
                    throw new Error("Unknown physical texture type ".concat(e))
            }
        }(t, r);
        if (a) {
            var s = S(HIe(e[0], e[1]), 2);
            i = s[0] * s[1]
        } else {
            var u = S(GIe(e[0], e[1]), 2);
            i = u[0] * u[1]
        }
        var c = function(e, t) {
            var n = e;
            if (t === n.R32F) return 4;
            if (t === n.R16F) return 2;
            if (t === n.RGBA32F) return 16;
            if (t === e.RGBA) return 16;
            if (t === n.RGBA16F) return 8;
            if (t === n.RGBA8) return 4;
            throw new Error("Unknown internal format ".concat(t))
        }(n, o);
        return i * c
    }

    function $Te(e, t) {
        if (e === zIe.UPLOAD) return PIe.PACKED_2X2_FLOAT32;
        if (e === zIe.RENDER || null == e) return function(e) {
            return k0().getBool("WEBGL_RENDER_FLOAT32_ENABLED") ? e ? PIe.PACKED_2X2_FLOAT32 : PIe.UNPACKED_FLOAT32 : e ? PIe.PACKED_2X2_FLOAT16 : PIe.UNPACKED_FLOAT16
        }(t);
        if (e === zIe.DOWNLOAD || e === zIe.PIXELS) return PIe.PACKED_4X1_UNSIGNED_BYTE;
        throw new Error("Unknown logical texture type ".concat(e))
    }

    function eEe(e, t, n) {
        return "".concat(e[0], "_").concat(e[1], "_").concat(t, "_").concat(n)
    }
    var tEe = p((function e(t, n) {
            l(this, e), this.variableNames = ["A"], this.outputShape = t, this.enableShapeUniforms = xSe(this.outputShape.length), this.userCode = "\n      float unaryOperation(float x) {\n        ".concat(n, "\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")
        })),
        nEe = "if (isnan(x)) return x;",
        rEe = "return x;",
        aEe = "return abs(x);";
    var iEe = "return (x >= 0.0) ? x : (exp(x) - 1.0);",
        oEe = nEe + "\n  return (x < 0.0) ? 0.0 : x;\n",
        sEe = nEe + "\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",
        uEe = "return x;",
        cEe = "return 1.0 / (1.0 + exp(-1.0 * x));",
        lEe = "return x;",
        hEe = "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",
        pEe = "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",
        fEe = "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",
        dEe = "return 1.0 / (1.0 + exp(-1.0 * x));",
        vEe = p((function e(t, n) {
            l(this, e), this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.enableShapeUniforms = xSe(this.outputShape.length), this.userCode = "\n      vec4 unaryOperation(vec4 x) {\n        ".concat(n, "\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")
        })),
        mEe = p((function e(t) {
            l(this, e), this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !1, this.outputShape = t, this.enableShapeUniforms = xSe(this.outputShape.length);
            var n = t.length,
                r = XTe("rc", n),
                a = hSe(n),
                i = function(e, t) {
                    if (1 === e) return "rc";
                    for (var n = "", r = 0; r < e; r++) n += t[r], r < e - 1 && (n += ",");
                    return n
                }(n, r),
                o = r.slice(-2),
                s = n <= 1 ? "rc" : "vec2(".concat(o.join(","), ")");
            this.userCode = "\n      void main() {\n        ".concat(a, " rc = getOutputCoords();\n        vec4 packedInput = getA(").concat(i, ");\n\n        setOutput(getChannel(packedInput, ").concat(s, "));\n      }\n    ")
        })),
        gEe = one,
        yEe = {};
    var bEe = k0().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");
    var xEe = function(e) {
        d(s, e);
        var t, n, r, a, i = w(s);

        function s(e) {
            var t, n, r;
            if (l(this, s), (t = i.call(this)).pendingRead = new WeakMap, t.pendingDisposal = new WeakSet, t.dataRefCount = new WeakMap, t.numBytesInGPU = 0, t.uploadWaitMs = 0, t.downloadWaitMs = 0, t.lastGlFlushTime = 0, t.warnedAboutMemory = !1, t.pendingDeletes = 0, t.disposed = !1, !k0().getBool("HAS_WEBGL")) throw new Error("WebGL is not supported on this device");
            if (null != e) {
                if (e instanceof ZSe) n = e;
                else {
                    var a = VIe(k0().getNumber("WEBGL_VERSION"), e);
                    n = new ZSe(a)
                }
                t.binaryCache = {}, t.gpgpuCreatedLocally = !1
            } else {
                var o = VIe(k0().getNumber("WEBGL_VERSION"));
                n = new ZSe(o), t.binaryCache = ((r = k0().getNumber("WEBGL_VERSION")) in yEe || (yEe[r] = {}), yEe[r]), t.gpgpuCreatedLocally = !0
            }
            return t.gpgpu = n, t.canvas = t.gpgpu.gl.canvas, t.textureManager = new ZTe(t.gpgpu), t.numMBBeforeWarning = null == k0().global.screen ? 1024 : k0().global.screen.height * k0().global.screen.width * window.devicePixelRatio * 600 / 1024 / 1024, t.texData = new S$(x(t), q5()), t
        }
        return p(s, [{
            key: "nextDataId",
            value: function() {
                return s.nextDataId++
            }
        }, {
            key: "numDataIds",
            value: function() {
                return this.texData.numDataIds() - this.pendingDeletes
            }
        }, {
            key: "writeTexture",
            value: function(e, t, n, r, a, i) {
                var o = this.makeTensorInfo(t, n),
                    s = this.texData.get(o.dataId);
                s.isPacked = !1, s.texture = {
                    texture: e,
                    texShape: [r, a]
                }, s.texShape = [r, a];
                var u = NNe(t),
                    c = new TSe(u, !1, i),
                    l = this.runWebGLProgram(c, [o], n, [
                        [r, a]
                    ]);
                return l.shape = t, s.texture = null, this.disposeIntermediateTensorInfo(o), l.dataId
            }
        }, {
            key: "write",
            value: function(e, t, n) {
                if ((k0().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS") || k0().getBool("DEBUG")) && this.checkNumericalProblems(e), "complex64" === n && null != e) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
                var r = {
                    id: this.nextDataId()
                };
                return this.texData.set(r, {
                    shape: t,
                    dtype: n,
                    values: e,
                    usage: zIe.UPLOAD,
                    refCount: 1
                }), r
            }
        }, {
            key: "refCount",
            value: function(e) {
                return this.texData.has(e) ? this.texData.get(e).refCount : 0
            }
        }, {
            key: "incRef",
            value: function(e) {
                this.texData.get(e).refCount++
            }
        }, {
            key: "decRef",
            value: function(e) {
                this.texData.has(e) && this.texData.get(e).refCount--
            }
        }, {
            key: "move",
            value: function(e, t, n, r, a) {
                if (k0().getBool("DEBUG") && this.checkNumericalProblems(t), "complex64" === r) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
                this.texData.set(e, {
                    shape: n,
                    dtype: r,
                    values: t,
                    usage: zIe.UPLOAD,
                    refCount: a
                })
            }
        }, {
            key: "disposeIntermediateTensorInfo",
            value: function(e) {
                this.disposeData(e.dataId)
            }
        }, {
            key: "readSync",
            value: function(e) {
                var t = this.texData.get(e),
                    n = t.values,
                    r = t.dtype,
                    a = t.complexTensorInfos,
                    i = t.slice,
                    o = t.shape,
                    s = t.isPacked;
                if (null != i) {
                    var u;
                    u = s ? new vEe(o, uEe) : new tEe(o, uEe);
                    var c = this.runWebGLProgram(u, [{
                            dataId: e,
                            shape: o,
                            dtype: r
                        }], r),
                        l = this.readSync(c.dataId);
                    return this.disposeIntermediateTensorInfo(c), l
                }
                if (null != n) return this.convertAndCacheOnCPU(e);
                if ("string" === r) return n;
                var h, p, f = null != this.activeTimers;
                (f && (h = z4()), "complex64" === r) ? p = Tie(this.readSync(a.real.dataId), this.readSync(a.imag.dataId)): p = this.getValuesFromTexture(e);
                return f && (this.downloadWaitMs += z4() - h), this.convertAndCacheOnCPU(e, p)
            }
        }, {
            key: "read",
            value: (a = c(o().mark((function e(t) {
                var n, r, a, i, s, u, c, l, h, p, f, d, v, m, g, y, b, x, k, w, I, N, S;
                return o().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if (!this.pendingRead.has(t)) {
                                e.next = 3;
                                break
                            }
                            return n = this.pendingRead.get(t), e.abrupt("return", new Promise((function(e) {
                                return n.push(e)
                            })));
                        case 3:
                            if (r = this.texData.get(t), a = r.values, i = r.shape, s = r.slice, u = r.dtype, c = r.complexTensorInfos, l = r.isPacked, null == s) {
                                e.next = 11;
                                break
                            }
                            return h = l ? new vEe(i, uEe) : new tEe(i, uEe), p = this.runWebGLProgram(h, [{
                                dataId: t,
                                shape: i,
                                dtype: u
                            }], u), f = this.read(p.dataId), this.disposeIntermediateTensorInfo(p), e.abrupt("return", f);
                        case 11:
                            if (null == a) {
                                e.next = 13;
                                break
                            }
                            return e.abrupt("return", this.convertAndCacheOnCPU(t));
                        case 13:
                            if (!k0().getBool("DEBUG")) {
                                e.next = 16;
                                break
                            }
                            if (k0().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED") || 2 !== k0().getNumber("WEBGL_VERSION")) {
                                e.next = 16;
                                break
                            }
                            throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");
                        case 16:
                            if (d = null, "complex64" !== u && k0().get("WEBGL_BUFFER_SUPPORTED") && (v = this.decode(t), g = this.texData.get(v.dataId), d = (m = this.gpgpu).createBufferFromTexture.apply(m, [g.texture.texture].concat(T(jIe(i))))), this.pendingRead.set(t, []), "complex64" === u) {
                                e.next = 22;
                                break
                            }
                            return e.next = 22, this.gpgpu.createAndWaitForFence();
                        case 22:
                            if ("complex64" !== u) {
                                e.next = 31;
                                break
                            }
                            return e.next = 25, Promise.all([this.read(c.real.dataId), this.read(c.imag.dataId)]);
                        case 25:
                            b = e.sent, x = b[0], k = b[1], y = Tie(x, k), e.next = 32;
                            break;
                        case 31:
                            null == d ? y = this.getValuesFromTexture(t) : (w = L$(i), y = this.gpgpu.downloadFloat32MatrixFromBuffer(d, w));
                        case 32:
                            return null != v && this.disposeIntermediateTensorInfo(v), null != d && KIe(I = this.gpgpu.gl, (function() {
                                return I.deleteBuffer(d)
                            })), N = this.convertAndCacheOnCPU(t, y), S = this.pendingRead.get(t), this.pendingRead.delete(t), S.forEach((function(e) {
                                return e(N)
                            })), this.pendingDisposal.has(t) && (this.pendingDisposal.delete(t), this.disposeData(t) && q5().removeDataId(t, this), this.pendingDeletes--), e.abrupt("return", N);
                        case 40:
                        case "end":
                            return e.stop()
                    }
                }), e, this)
            }))), function(e) {
                return a.apply(this, arguments)
            })
        }, {
            key: "readToGPU",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    n = this.texData.get(e),
                    r = n.values,
                    a = n.shape,
                    i = n.slice,
                    o = n.dtype,
                    s = n.isPacked,
                    u = n.texture;
                if ("complex64" === o) throw new Error("Does not support reading texture for complex64 dtype.");
                if (null != i) {
                    var c;
                    c = s ? new vEe(a, uEe) : new tEe(a, uEe);
                    var l = this.runWebGLProgram(c, [{
                            dataId: e,
                            shape: a,
                            dtype: o
                        }], o),
                        h = this.readToGPU(l, t);
                    return this.disposeIntermediateTensorInfo(l), h
                }
                if (null == u) throw null != r ? new Error("Data is not on GPU but on CPU.") : new Error("There is no data on GPU or CPU.");
                var p = this.decode(e, t.customTexShape),
                    f = q5().makeTensorFromTensorInfo(p),
                    d = this.texData.get(p.dataId);
                return Object.assign({
                    tensorRef: f
                }, d.texture)
            }
        }, {
            key: "bufferSync",
            value: function(e) {
                var t = this.readSync(e.dataId);
                if ("string" === e.dtype) try {
                    var n = t.map((function(e) {
                        return W4(e)
                    }));
                    return l8(e.shape, e.dtype, n)
                } catch (e) {
                    throw new Error("Failed to decode encoded string bytes into utf-8")
                }
                return l8(e.shape, e.dtype, t)
            }
        }, {
            key: "checkNumericalProblems",
            value: function(e) {
                if (null != e)
                    for (var t = 0; t < e.length; t++) {
                        var n = e[t];
                        if (!XIe(n)) {
                            if (k0().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")) throw Error("The value ".concat(n, " cannot be represented with your ") + "current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");
                            throw Error("The value ".concat(n, " cannot be represented on this device."))
                        }
                    }
            }
        }, {
            key: "getValuesFromTexture",
            value: function(e) {
                var t = this.texData.get(e),
                    n = t.shape,
                    r = t.dtype,
                    a = t.isPacked,
                    i = L$(n);
                if (k0().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
                    var o, s = this.decode(e),
                        u = this.texData.get(s.dataId),
                        c = (o = this.gpgpu).downloadMatrixFromPackedTexture.apply(o, [u.texture.texture].concat(T(jIe(n)))).subarray(0, i);
                    return this.disposeIntermediateTensorInfo(s), c
                }
                var l = k0().getBool("WEBGL_PACK") && !0 === a,
                    h = l ? NNe(n) : n,
                    p = l ? new NSe(h) : new ISe(h),
                    f = this.runWebGLProgram(p, [{
                        shape: h,
                        dtype: r,
                        dataId: e
                    }], "float32"),
                    d = this.texData.get(f.dataId),
                    v = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture.texture, d.texShape[0], d.texShape[1]).subarray(0, i);
                return this.disposeIntermediateTensorInfo(f), v
            }
        }, {
            key: "timerAvailable",
            value: function() {
                return k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0
            }
        }, {
            key: "time",
            value: function(e) {
                var t = this,
                    n = this.activeTimers,
                    r = [],
                    a = !1;
                null == this.programTimersStack ? (this.programTimersStack = r, a = !0) : this.activeTimers.push(r), this.activeTimers = r, e();
                var i = V4(this.activeTimers.map((function(e) {
                        return e.query
                    }))).filter((function(e) {
                        return null != e
                    })),
                    s = V4(this.activeTimers.map((function(e) {
                        return e.name
                    }))).filter((function(e) {
                        return null != e
                    }));
                this.activeTimers = n, a && (this.programTimersStack = null);
                var u = {
                    uploadWaitMs: this.uploadWaitMs,
                    downloadWaitMs: this.downloadWaitMs,
                    kernelMs: null,
                    wallMs: null
                };
                return c(o().mark((function e() {
                    var n;
                    return o().wrap((function(e) {
                        for (;;) switch (e.prev = e.next) {
                            case 0:
                                if (!(k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0)) {
                                    e.next = 8;
                                    break
                                }
                                return e.next = 3, Promise.all(i);
                            case 3:
                                n = e.sent, u.kernelMs = O$(n), u.getExtraProfileInfo = function() {
                                    return n.map((function(e, t) {
                                        return {
                                            name: s[t],
                                            ms: e
                                        }
                                    })).map((function(e) {
                                        return "".concat(e.name, ": ").concat(e.ms)
                                    })).join(", ")
                                }, e.next = 9;
                                break;
                            case 8:
                                u.kernelMs = {
                                    error: "WebGL query timers are not supported in this environment."
                                };
                            case 9:
                                return t.uploadWaitMs = 0, t.downloadWaitMs = 0, e.abrupt("return", u);
                            case 12:
                            case "end":
                                return e.stop()
                        }
                    }), e)
                })))()
            }
        }, {
            key: "memory",
            value: function() {
                return {
                    unreliable: !1,
                    numBytesInGPU: this.numBytesInGPU,
                    numBytesInGPUAllocated: this.textureManager.numBytesAllocated,
                    numBytesInGPUFree: this.textureManager.numBytesFree
                }
            }
        }, {
            key: "startTimer",
            value: function() {
                return k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? this.gpgpu.beginQuery() : {
                    startMs: z4(),
                    endMs: null
                }
            }
        }, {
            key: "endTimer",
            value: function(e) {
                return k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? (this.gpgpu.endQuery(), e) : (e.endMs = z4(), e)
            }
        }, {
            key: "getQueryTime",
            value: (r = c(o().mark((function e(t) {
                var n;
                return o().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if (!(k0().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0)) {
                                e.next = 2;
                                break
                            }
                            return e.abrupt("return", this.gpgpu.waitForQueryAndGetTime(t));
                        case 2:
                            return n = t, e.abrupt("return", n.endMs - n.startMs);
                        case 4:
                        case "end":
                            return e.stop()
                    }
                }), e, this)
            }))), function(e) {
                return r.apply(this, arguments)
            })
        }, {
            key: "disposeData",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                if (this.pendingDisposal.has(e)) return !1;
                if (!this.texData.has(e)) return !0;
                if (t ? this.texData.get(e).refCount = 0 : this.texData.get(e).refCount--, !t && this.texData.get(e).refCount > 0) return !1;
                if (this.pendingRead.has(e)) return this.pendingDisposal.add(e), this.pendingDeletes++, !1;
                this.releaseGPUData(e);
                var n = this.texData.get(e),
                    r = n.complexTensorInfos;
                return null != r && (this.disposeData(r.real.dataId, t), this.disposeData(r.imag.dataId, t)), this.texData.delete(e), !0
            }
        }, {
            key: "releaseGPUData",
            value: function(e) {
                var t = this.texData.get(e),
                    n = t.texture,
                    r = t.dtype,
                    a = t.texShape,
                    i = t.usage,
                    o = t.isPacked,
                    s = t.slice,
                    u = s && s.origDataId || e,
                    c = this.dataRefCount.get(u);
                c > 1 ? this.dataRefCount.set(u, c - 1) : (this.dataRefCount.delete(u), null != n && (this.numBytesInGPU -= this.computeBytes(a, r), this.textureManager.releaseTexture(n, a, i, o)));
                var l = this.texData.get(e);
                l.texture = null, l.texShape = null, l.isPacked = !1, l.slice = null
            }
        }, {
            key: "getTexture",
            value: function(e) {
                return this.uploadToGPU(e), this.texData.get(e).texture.texture
            }
        }, {
            key: "getDataInfo",
            value: function(e) {
                return this.texData.get(e)
            }
        }, {
            key: "shouldExecuteOnCPU",
            value: function(e) {
                var t = this,
                    n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : bEe;
                return k0().getBool("WEBGL_CPU_FORWARD") && e.every((function(e) {
                    return null == t.texData.get(e.dataId).texture && L$(e.shape) < n
                }))
            }
        }, {
            key: "getGPGPUContext",
            value: function() {
                return this.gpgpu
            }
        }, {
            key: "where",
            value: function(e) {
                z3("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
                var t = e.dataSync();
                return gEe(e.shape, t)
            }
        }, {
            key: "packedUnaryOp",
            value: function(e, t, n) {
                var r = new vEe(e.shape, t),
                    a = this.compileAndRun(r, [e], n);
                return q5().makeTensorFromTensorInfo(a)
            }
        }, {
            key: "abs",
            value: function(e) {
                if (this.shouldExecuteOnCPU([e]) && "complex64" !== e.dtype) {
                    var t = _Te(this.texData.get(e.dataId).values);
                    return this.makeOutput(e.shape, e.dtype, t)
                }
                if (k0().getBool("WEBGL_PACK_UNARY_OPERATIONS")) return this.packedUnaryOp(e, aEe, e.dtype);
                var n = new tEe(e.shape, aEe),
                    r = this.compileAndRun(n, [e]);
                return q5().makeTensorFromTensorInfo(r)
            }
        }, {
            key: "makeTensorInfo",
            value: function(e, t, n) {
                var r;
                if ("string" === t && null != n && n.length > 0 && $$(n[0])) {
                    var a = n.map((function(e) {
                        return B4(e)
                    }));
                    r = this.write(a, e, t)
                } else r = this.write(n, e, t);
                return this.texData.get(r).usage = null, {
                    dataId: r,
                    shape: e,
                    dtype: t
                }
            }
        }, {
            key: "makeOutput",
            value: function(e, t, n) {
                return q5().makeTensorFromTensorInfo(this.makeTensorInfo(e, t, n), this)
            }
        }, {
            key: "unpackTensor",
            value: function(e) {
                var t = new mEe(e.shape);
                return this.runWebGLProgram(t, [e], e.dtype)
            }
        }, {
            key: "packTensor",
            value: function(e) {
                var t = new YTe(e.shape);
                return this.runWebGLProgram(t, [e], e.dtype, null, !0)
            }
        }, {
            key: "packedReshape",
            value: function(e, t) {
                var n = [wNe(e.shape)].concat(T(INe(e.shape))),
                    r = {
                        dtype: e.dtype,
                        shape: n,
                        dataId: e.dataId
                    },
                    a = [wNe(t)].concat(T(INe(t))),
                    i = new JTe(a, n),
                    o = [n],
                    s = this.runWebGLProgram(i, [r], e.dtype, o, !0);
                return {
                    dataId: s.dataId,
                    shape: t,
                    dtype: s.dtype
                }
            }
        }, {
            key: "decode",
            value: function(e, t) {
                var n = this.texData.get(e),
                    r = n.isPacked,
                    a = n.shape,
                    i = n.dtype;
                null != t && F$(L$(a) <= t[0] * t[1] * 4, (function() {
                    return "customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."
                }));
                var o, s = NNe(a);
                o = r ? new wSe(s) : new kSe(s);
                var u = [null != t ? t : jIe(s)];
                return {
                    dtype: i,
                    shape: a,
                    dataId: this.runWebGLProgram(o, [{
                        shape: s,
                        dtype: i,
                        dataId: e
                    }], i, u, !0, t).dataId
                }
            }
        }, {
            key: "runWebGLProgram",
            value: function(e, t, n, r) {
                var a = this,
                    i = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
                    o = arguments.length > 5 ? arguments[5] : void 0,
                    s = this.makeTensorInfo(e.outputShape, n),
                    u = this.texData.get(s.dataId);
                if (e.packedOutput && (u.isPacked = !0), e.outPackingScheme === LIe.DENSE) {
                    var c = null != o ? o : jIe(e.outputShape);
                    u.texShape = c.map((function(e) {
                        return 2 * e
                    }))
                }
                if (null != e.outTexUsage && (u.usage = e.outTexUsage), 0 === L$(s.shape)) return u.values = q$(s.dtype, 0), s;
                var l = [],
                    h = t.map((function(t) {
                        if ("complex64" === t.dtype) throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
                        var n = a.texData.get(t.dataId);
                        if (null == n.texture) {
                            if (!e.packedInputs && L$(t.shape) <= k0().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM")) return {
                                shape: t.shape,
                                texData: null,
                                isUniform: !0,
                                uniformValues: n.values
                            };
                            e.packedInputs && (n.isPacked = !0, n.shape = t.shape)
                        }
                        if (a.uploadToGPU(t.dataId), !!n.isPacked != !!e.packedInputs) t = n.isPacked ? a.unpackTensor(t) : a.packTensor(t), l.push(t), n = a.texData.get(t.dataId);
                        else if (n.isPacked && !ENe(n.shape, t.shape)) {
                            var r = t,
                                i = t.shape;
                            t.shape = n.shape, t = a.packedReshape(t, i), l.push(t), n = a.texData.get(t.dataId), r.shape = i
                        }
                        return {
                            shape: t.shape,
                            texData: n,
                            isUniform: !1
                        }
                    }));
                this.uploadToGPU(s.dataId);
                var p, f = {
                        shape: s.shape,
                        texData: u,
                        isUniform: !1
                    },
                    d = bSe(e, h, f),
                    v = this.getAndSaveBinary(d, (function() {
                        return vSe(a.gpgpu, e, h, f)
                    })),
                    m = null != this.activeTimers;
                m && (p = this.startTimer()), k0().get("ENGINE_COMPILE_ONLY") || ySe(this.gpgpu, v, h, f, r), l.forEach((function(e) {
                    return a.disposeIntermediateTensorInfo(e)
                })), m && (p = this.endTimer(p), this.activeTimers.push({
                    name: e.constructor.name,
                    query: this.getQueryTime(p)
                }));
                var g = k0().getNumber("WEBGL_FLUSH_THRESHOLD");
                if (g > 0) {
                    var y = z4();
                    y - this.lastGlFlushTime > g && (this.gpgpu.gl.flush(), this.lastGlFlushTime = y)
                }
                if (!k0().getBool("WEBGL_LAZILY_UNPACK") && u.isPacked && !1 === i) {
                    var b = this.unpackTensor(s);
                    return this.disposeIntermediateTensorInfo(s), b
                }
                return s
            }
        }, {
            key: "compileAndRun",
            value: function(e, t, n, r) {
                var a = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
                n = n || t[0].dtype;
                var i = this.runWebGLProgram(e, t, n, r, a);
                return i
            }
        }, {
            key: "getAndSaveBinary",
            value: function(e, t) {
                return e in this.binaryCache || (this.binaryCache[e] = t()), this.binaryCache[e]
            }
        }, {
            key: "getTextureManager",
            value: function() {
                return this.textureManager
            }
        }, {
            key: "dispose",
            value: function() {
                var e = this;
                if (!this.disposed) {
                    if (!k0().getBool("IS_TEST")) Object.keys(this.binaryCache).forEach((function(t) {
                        e.gpgpu.deleteProgram(e.binaryCache[t].webGLProgram), delete e.binaryCache[t]
                    }));
                    this.textureManager.dispose(), null != this.canvas && "undefined" != typeof HTMLCanvasElement && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), this.disposed = !0
                }
            }
        }, {
            key: "floatPrecision",
            value: function() {
                var e = this;
                return null == this.floatPrecisionValue && (this.floatPrecisionValue = X5((function() {
                    if (!k0().get("WEBGL_RENDER_FLOAT32_ENABLED")) {
                        var t = k0().getBool("DEBUG");
                        k0().set("DEBUG", !1);
                        var n = e.abs(i9(1e-8)).dataSync()[0];
                        if (k0().set("DEBUG", t), n > 0) return 32
                    }
                    return 16
                }))), this.floatPrecisionValue
            }
        }, {
            key: "epsilon",
            value: function() {
                return 32 === this.floatPrecision() ? 1e-7 : 1e-4
            }
        }, {
            key: "uploadToGPU",
            value: function(e) {
                var t = this.texData.get(e),
                    n = t.shape,
                    r = t.dtype,
                    a = t.values,
                    i = t.texture,
                    o = t.usage,
                    s = t.isPacked;
                if (null == i) {
                    var u, c = null != this.activeTimers;
                    c && (u = z4());
                    var l = t.texShape;
                    if (null == l && (l = SNe(n, s), t.texShape = l), null != a) {
                        var h, p = NNe(n),
                            f = l[1],
                            d = l[0],
                            v = a instanceof Uint8Array || a instanceof Uint8ClampedArray;
                        if (s || !v) {
                            var m = S(HIe(l[0], l[1]), 2);
                            f = m[0], d = m[1]
                        }
                        h = s ? new ESe(p, v) : new TSe(p, v);
                        var g = v ? [d, f] : l,
                            y = this.makeTensorInfo(g, r),
                            b = this.texData.get(y.dataId);
                        b.usage = v ? zIe.PIXELS : zIe.UPLOAD, b.texShape = g, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(y.dataId), f, d, a);
                        var x = [
                                [d, f]
                            ],
                            k = this.runWebGLProgram(h, [y], r, x, !0),
                            w = this.texData.get(k.dataId);
                        t.texShape = w.texShape, t.isPacked = w.isPacked, t.usage = w.usage, k0().get("ENGINE_COMPILE_ONLY") ? this.disposeData(k.dataId) : (t.texture = w.texture, t.values = null, this.texData.delete(k.dataId)), this.disposeIntermediateTensorInfo(y), c && (this.uploadWaitMs += z4() - u)
                    } else {
                        var I = this.acquireTexture(l, o, r, s);
                        t.texture = I
                    }
                }
            }
        }, {
            key: "convertAndCacheOnCPU",
            value: function(e, t) {
                var n = this.texData.get(e),
                    r = n.dtype;
                return null != t && (n.values = function(e, t) {
                    if ("float32" === t || "complex64" === t) return e;
                    if ("int32" === t || "bool" === t) {
                        for (var n = "int32" === t ? new Int32Array(e.length) : new Uint8Array(e.length), r = 0; r < n.length; ++r) n[r] = Math.round(e[r]);
                        return n
                    }
                    throw new Error("Unknown dtype ".concat(t))
                }(t, r)), n.values
            }
        }, {
            key: "acquireTexture",
            value: function(e, t, n, r) {
                if (this.numBytesInGPU += this.computeBytes(e, n), !this.warnedAboutMemory && this.numBytesInGPU > 1024 * this.numMBBeforeWarning * 1024) {
                    var a = (this.numBytesInGPU / 1024 / 1024).toFixed(2);
                    this.warnedAboutMemory = !0, console.warn("High memory usage in GPU: ".concat(a, " MB, ") + "most likely due to a memory leak")
                }
                return this.textureManager.acquireTexture(e, t, r)
            }
        }, {
            key: "computeBytes",
            value: function(e, t) {
                return e[0] * e[1] * Z$(t)
            }
        }, {
            key: "checkCompileCompletion",
            value: function() {
                for (var e = 0, t = Object.entries(this.binaryCache); e < t.length; e++) {
                    var n = S(t[e], 2)[1];
                    this.checkCompletion_(n)
                }
            }
        }, {
            key: "checkCompileCompletionAsync",
            value: (n = c(o().mark((function e() {
                var t, n, r, a, i, s, u, c, l = this;
                return o().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if (t = [], !this.gpgpu.parallelCompilationExtension) {
                                e.next = 6;
                                break
                            }
                            for (n = 0, r = Object.entries(this.binaryCache); n < r.length; n++) a = S(r[n], 2), i = a[1], t.push(this.checkCompletionAsync_(i));
                            return e.abrupt("return", Promise.all(t));
                        case 6:
                            s = o().mark((function e() {
                                var n, r, a;
                                return o().wrap((function(e) {
                                    for (;;) switch (e.prev = e.next) {
                                        case 0:
                                            n = S(c[u], 2), r = n[1], a = new Promise((function(e) {
                                                try {
                                                    l.checkCompletion_(r), e(!0)
                                                } catch (e) {
                                                    throw e
                                                }
                                            })), t.push(a);
                                        case 3:
                                        case "end":
                                            return e.stop()
                                    }
                                }), e)
                            })), u = 0, c = Object.entries(this.binaryCache);
                        case 8:
                            if (!(u < c.length)) {
                                e.next = 13;
                                break
                            }
                            return e.delegateYield(s(), "t0", 10);
                        case 10:
                            u++, e.next = 8;
                            break;
                        case 13:
                            return e.abrupt("return", Promise.all(t));
                        case 14:
                        case "end":
                            return e.stop()
                    }
                }), e, this)
            }))), function() {
                return n.apply(this, arguments)
            })
        }, {
            key: "checkCompletionAsync_",
            value: (t = c(o().mark((function e(t) {
                return o().wrap((function(e) {
                    for (;;) switch (e.prev = e.next) {
                        case 0:
                            if (!this.gpgpu.gl.getProgramParameter(t.webGLProgram, this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)) {
                                e.next = 4;
                                break
                            }
                            return e.abrupt("return", this.checkCompletion_(t));
                        case 4:
                            return e.next = 6, aie();
                        case 6:
                            return e.abrupt("return", this.checkCompletionAsync_(t));
                        case 7:
                        case "end":
                            return e.stop()
                    }
                }), e, this)
            }))), function(e) {
                return t.apply(this, arguments)
            })
        }, {
            key: "checkCompletion_",
            value: function(e) {
                if (!1 === this.gpgpu.gl.getProgramParameter(e.webGLProgram, this.gpgpu.gl.LINK_STATUS)) {
                    if (console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)), !1 === this.gpgpu.gl.getShaderParameter(e.fragmentShader, this.gpgpu.gl.COMPILE_STATUS)) throw nNe(e.source, this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)), new Error("Failed to compile fragment shader.");
                    throw new Error("Failed to link vertex and fragment shaders.")
                }
                return !0
            }
        }, {
            key: "getUniformLocations",
            value: function() {
                for (var e = 0, t = Object.values(this.binaryCache); e < t.length; e++) {
                    var n = t[e];
                    this.gpgpu.buildVao(n.webGLProgram);
                    var r = mSe(this.gpgpu, n.program, n.webGLProgram),
                        a = r.variablesLocations,
                        i = r.customUniformLocations,
                        o = r.infLoc,
                        s = r.nanLoc,
                        u = r.outShapeLocation,
                        c = r.outShapeStridesLocation,
                        l = r.outTexShapeLocation;
                    n.variablesLocations = a, n.customUniformLocations = i, n.infLoc = o, n.nanLoc = s, n.outShapeLocation = u, n.outShapeStridesLocation = c, n.outTexShapeLocation = l
                }
            }
        }, {
            key: "createTensorFromGPUData",
            value: function(e, t, n) {
                e.channels = e.channels || "RGBA";
                var r = e.texture,
                    a = e.height,
                    i = e.width,
                    o = e.channels,
                    s = q5().backend;
                if (!s.gpgpu.gl.isTexture(r)) throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");
                var u = s.writeTexture(r, t, n, a, i, o);
                return q5().makeTensorFromDataId(u, t, n, s)
            }
        }]), s
    }(T$);
    xEe.nextDataId = 0;
    var kEe = "4.22.0";

    function wEe() {
        k0().set("WEBGL_FORCE_F16_TEXTURES", !0)
    }
    R5() && $5("webgl", (function() {
        return new xEe
    }), 2);
    var IEe = {
            forceHalfFloat: wEe
        },
        NEe = p((function e(t, n, r) {
            l(this, e), this.variableNames = ["A", "B"], this.outputShape = z7(n, r), this.enableShapeUniforms = xSe(this.outputShape.length), this.userCode = "\n      float binaryOperation(float a, float b) {\n        ".concat(t, "\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ")
        })),
        SEe = "\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n",
        TEe = p((function e(t, n, r) {
            var a = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
            l(this, e), this.variableNames = ["A", "B"], this.supportsBroadcasting = !0, this.packedInputs = !0, this.packedOutput = !0, this.outputShape = z7(n, r);
            var i = this.outputShape.length;
            this.enableShapeUniforms = xSe(i);
            var o = "";
            if (a)
                if (0 === i || 1 === L$(this.outputShape)) o = "\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";
                else {
                    var s = hSe(i);
                    if (o = "\n          ".concat(s, " coords = getOutputCoords();\n        "), 1 === i) this.enableShapeUniforms ? o += "\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          " : o += "\n            result.y = (coords + 1) >= ".concat(this.outputShape[0], " ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ");
                    else {
                        var u = XTe("coords", i);
                        this.enableShapeUniforms ? o += "\n            bool nextRowOutOfBounds =\n              (".concat(u[i - 2], " + 1) >= outShape[").concat(i, " - 2];\n            bool nextColOutOfBounds =\n              (").concat(u[i - 1], " + 1) >= outShape[").concat(i, " - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ") : o += "\n            bool nextRowOutOfBounds =\n              (".concat(u[i - 2], " + 1) >= ").concat(this.outputShape[i - 2], ";\n            bool nextColOutOfBounds =\n              (").concat(u[i - 1], " + 1) >= ").concat(this.outputShape[i - 1], ";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ")
                    }
                }
            this.userCode = "\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ".concat(t, "\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ").concat(o, "\n\n        setOutput(result);\n      }\n    ")
        }));

    function EEe(e) {
        var t = e.inputs,
            n = e.backend,
            r = t.x;
        return n.incRef(r.dataId), {
            dataId: r.dataId,
            shape: r.shape,
            dtype: r.dtype
        }
    }
    var CEe = {
        kernelName: W1,
        backendName: "webgl",
        kernelFunc: EEe
    };

    function AEe(e) {
        var t = e.inputs,
            n = e.backend,
            r = t.real,
            a = t.imag,
            i = n.makeTensorInfo(r.shape, "complex64"),
            o = n.texData.get(i.dataId),
            s = EEe({
                inputs: {
                    x: r
                },
                backend: n
            }),
            u = EEe({
                inputs: {
                    x: a
                },
                backend: n
            });
        return o.complexTensorInfos = {
            real: s,
            imag: u
        }, i
    }
    var REe = {
            kernelName: Z0,
            backendName: "webgl",
            kernelFunc: AEe
        },
        _Ee = "return (a < 0.) ? b * a : a;",
        OEe = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";
    var FEe = {
            kernelName: q1,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.alpha,
                    o = n.makeTensorInfo([], "float32", M4(i, "float32")),
                    s = k0().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new TEe(OEe, a.shape, o.shape) : new NEe(_Ee, a.shape, o.shape),
                    u = n.runWebGLProgram(s, [a, o], "float32");
                return n.disposeIntermediateTensorInfo(o), u
            }
        },
        DEe = "return (a < 0.) ? b * a : a;",
        MEe = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";
    var LEe = {
        kernelName: C2,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = t.x,
                a = t.alpha,
                i = k0().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new TEe(MEe, r.shape, a.shape) : new NEe(DEe, r.shape, a.shape);
            return n.runWebGLProgram(i, [r, a], "float32")
        }
    };

    function zEe(e) {
        var t = e.opSnippet,
            n = e.packedOpSnippet,
            r = e.cpuKernelImpl,
            a = e.dtype;
        return function(e) {
            var i, o = e.inputs,
                s = e.backend,
                u = o.x,
                c = s,
                l = a || u.dtype;
            if (c.shouldExecuteOnCPU([u]) && null != r) {
                var h = c.texData.get(u.dataId),
                    p = r(h.values, l);
                return c.makeTensorInfo(u.shape, l, p)
            }
            return i = k0().getBool("WEBGL_PACK_UNARY_OPERATIONS") && null != n ? new vEe(u.shape, n) : new tEe(u.shape, t), c.runWebGLProgram(i, [u], l)
        }
    }

    function PEe(e) {
        var t = e.opSnippet,
            n = e.packedOpSnippet,
            r = e.checkOutOfBounds,
            a = void 0 !== r && r,
            i = e.supportsComplex,
            o = void 0 !== i && i,
            s = e.cpuKernelImpl,
            u = e.dtype;
        return function(e) {
            var r = e.inputs,
                i = e.backend,
                c = r.a,
                l = r.b,
                h = i;
            if (o && "complex64" === c.dtype) {
                var p = h.texData.get(c.dataId),
                    f = h.texData.get(l.dataId),
                    d = [
                        [p.complexTensorInfos.real, f.complexTensorInfos.real],
                        [p.complexTensorInfos.imag, f.complexTensorInfos.imag]
                    ].map((function(e) {
                        var n = S(e, 2),
                            r = n[0],
                            a = n[1],
                            i = {
                                dataId: r.dataId,
                                dtype: r.dtype,
                                shape: c.shape
                            },
                            o = {
                                dataId: a.dataId,
                                dtype: a.dtype,
                                shape: l.shape
                            },
                            s = new NEe(t, c.shape, l.shape);
                        return h.runWebGLProgram(s, [i, o], h5(r.dtype, a.dtype))
                    })),
                    v = S(d, 2),
                    m = v[0],
                    g = v[1],
                    y = AEe({
                        inputs: {
                            real: m,
                            imag: g
                        },
                        backend: h
                    });
                return h.disposeIntermediateTensorInfo(m), h.disposeIntermediateTensorInfo(g), y
            }
            var b, x = u || h5(c.dtype, l.dtype);
            if (("string" === c.dtype || "string" === l.dtype || h.shouldExecuteOnCPU([c, l])) && null != s) {
                var k = h.texData.get(c.dataId).values,
                    w = h.texData.get(l.dataId).values,
                    I = "string" === c.dtype ? aoe(k) : k,
                    N = "string" === c.dtype ? aoe(w) : w,
                    T = S(s(c.shape, l.shape, I, N, x), 2),
                    E = T[0],
                    C = T[1],
                    A = h.makeTensorInfo(C, x);
                return h.texData.get(A.dataId).values = E, A
            }
            return b = k0().getBool("WEBGL_PACK_BINARY_OPERATIONS") && null != n ? new TEe(n, c.shape, l.shape, a) : new NEe(t, c.shape, l.shape), h.runWebGLProgram(b, [c, l], x)
        }
    }

    function BEe(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        if ("linear" === e) return t ? lEe : rEe;
        if ("relu" === e) return t ? pEe : oEe;
        if ("elu" === e) return t ? hEe : iEe;
        if ("relu6" === e) return t ? fEe : sEe;
        if ("prelu" === e) return t ? MEe : DEe;
        if ("leakyrelu" === e) return t ? OEe : _Ee;
        if ("sigmoid" === e) return t ? dEe : cEe;
        throw new Error("Activation ".concat(e, " has not been implemented for the WebGL backend."))
    }
    var WEe = p((function e(t, n, r) {
            var a = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
                i = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
                o = arguments.length > 5 && void 0 !== arguments[5] && arguments[5],
                s = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null,
                u = arguments.length > 7 && void 0 !== arguments[7] && arguments[7],
                c = arguments.length > 8 && void 0 !== arguments[8] && arguments[8];
            l(this, e), this.variableNames = ["matrixA", "matrixB"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = r, this.enableShapeUniforms = xSe(this.outputShape.length);
            var h = a ? t[1] : t[2],
                p = Math.ceil(h / 2),
                f = a ? "i * 2, rc.y" : "rc.y, i * 2",
                d = i ? "rc.z, i * 2" : "i * 2, rc.z",
                v = a ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"],
                m = i ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"],
                g = "",
                y = "";
            s && (g = u ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(s, "\n        }") : c ? "vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(s, "\n        }") : "vec4 activation(vec4 x) {\n          ".concat(s, "\n        }"), y = "result = activation(result);");
            var b = o ? "result += getBiasAtOutCoords();" : "";
            o && this.variableNames.push("bias"), u && this.variableNames.push("preluActivationWeights"), c && this.variableNames.push("leakyreluAlpha");
            var x = "rc.x",
                k = "rc.x";
            t[0] < n[0] ? x = "imod(rc.x, ".concat(t[0], ")") : n[0] < t[0] && (k = "imod(rc.x, ".concat(n[0], ")")), this.userCode = "\n      ".concat(g, "\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ").concat(p, ".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ").concat(x, ";\n        int batchB = ").concat(k, ";\n        for (int i = 0; i < ").concat(p, "; i++) {\n          vec4 a = getMatrixA(batchA, ").concat(f, ");\n          vec4 b = getMatrixB(batchB, ").concat(d, ");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (").concat(v[0], " * ").concat(m[0], ");\n          result += (").concat(v[1], " * ").concat(m[1], ");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ").concat(b, "\n\n        ").concat(y, "\n\n        setOutput(result);\n      }\n    ")
        })),
        UEe = "return areal * breal - aimag * bimag;",
        VEe = "return areal * bimag + aimag * breal;",
        GEe = p((function e(t, n, r) {
            l(this, e), this.variableNames = ["AReal", "AImag", "BReal", "BImag"], this.outputShape = z7(n, r), this.userCode = "\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ".concat(t, "\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ")
        })),
        jEe = "return a * b;";

    function HEe(e) {
        var t, n = e.inputs,
            r = e.backend,
            a = n.a,
            i = n.b,
            o = h5(a.dtype, i.dtype);
        if ("complex64" === a.dtype) {
            var s = r.texData.get(a.dataId),
                u = r.texData.get(i.dataId),
                c = new GEe(UEe, a.shape, i.shape),
                l = new GEe(VEe, a.shape, i.shape),
                h = [{
                    dataId: s.complexTensorInfos.real.dataId,
                    dtype: s.complexTensorInfos.real.dtype,
                    shape: a.shape
                }, {
                    dataId: s.complexTensorInfos.imag.dataId,
                    dtype: s.complexTensorInfos.imag.dtype,
                    shape: a.shape
                }, {
                    dataId: u.complexTensorInfos.real.dataId,
                    dtype: u.complexTensorInfos.real.dtype,
                    shape: i.shape
                }, {
                    dataId: u.complexTensorInfos.imag.dataId,
                    dtype: u.complexTensorInfos.imag.dtype,
                    shape: i.shape
                }],
                p = r.runWebGLProgram(c, h, "float32"),
                f = r.runWebGLProgram(l, h, "float32"),
                d = AEe({
                    inputs: {
                        real: p,
                        imag: f
                    },
                    backend: r
                });
            return r.disposeIntermediateTensorInfo(p), r.disposeIntermediateTensorInfo(f), d
        }
        if (r.shouldExecuteOnCPU([a, i])) {
            var v = r.texData.get(a.dataId),
                m = r.texData.get(i.dataId),
                g = S(xTe(a.shape, i.shape, v.values, m.values, o), 2),
                y = g[0],
                b = g[1],
                x = r.makeTensorInfo(b, o);
            return r.texData.get(x.dataId).values = y, x
        }
        return t = k0().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new TEe(jEe, a.shape, i.shape) : new NEe(jEe, a.shape, i.shape), r.runWebGLProgram(t, [a, i], o)
    }
    var qEe = {
        kernelName: g2,
        backendName: "webgl",
        kernelFunc: HEe
    };

    function KEe(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs,
            a = t.x,
            i = r.shape,
            o = n,
            s = L$(a.shape),
            u = G$(i, s),
            c = L$(u);
        F$(s === c, (function() {
            return "The new shape (".concat(u, ") has ").concat(c, " elements and the old ") + "shape (".concat(a.shape, ") has ").concat(s, " elements. The new shape and old ") + "shape must have the same number of elements."
        }));
        var l = o.texData.get(a.dataId);
        return !l.isPacked || ENe(a.shape, u) || null !== l.texture && ENe(l.shape, u) ? (o.incRef(a.dataId), {
            dataId: a.dataId,
            shape: u,
            dtype: a.dtype
        }) : function(e, t, n) {
            var r = [wNe(e.shape)].concat(T(INe(e.shape))),
                a = {
                    dtype: e.dtype,
                    shape: r,
                    dataId: e.dataId
                },
                i = [wNe(t)].concat(T(INe(t))),
                o = new JTe(i, r),
                s = [r],
                u = n.runWebGLProgram(o, [a], e.dtype, s, !0);
            return {
                dataId: u.dataId,
                shape: t,
                dtype: u.dtype
            }
        }(a, u, o)
    }
    var XEe = {
            kernelName: z2,
            backendName: "webgl",
            kernelFunc: KEe
        },
        YEe = p((function e(t, n) {
            l(this, e), this.variableNames = ["x"];
            var r = t.windowSize,
                a = t.batchSize,
                i = t.inSize,
                o = t.outSize;
            this.outputShape = [a, o];
            var s = 4 * Math.floor(r / 4),
                u = r % 4,
                c = "sumValue += dot(values, ones);";
            if (null != n) {
                var h = 1 / n;
                c = "sumValue += dot(values * ".concat(B$(h) ? h.toPrecision(2) : h, ", ones);")
            }
            var p = "";
            i % r > 0 && (p = "\n        if (inIdx < 0 || inIdx >= ".concat(i, ") {\n          return 0.0;\n        }\n      ")), this.userCode = "\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ".concat(p, "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(r, ";\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(s, "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(c, "\n        }\n\n        int inIdx = inOffset + ").concat(s, ";\n        if (").concat(1 === u, ") {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ").concat(c, "\n        } else if (").concat(2 === u, ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ").concat(c, "\n        } else if (").concat(3 === u, ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ").concat(c, "\n        }\n        setOutput(sumValue);\n      }\n    ")
        })),
        JEe = p((function e(t, n) {
            l(this, e), this.variableNames = ["x"];
            var r = t.windowSize,
                a = t.batchSize,
                i = t.inSize,
                o = t.outSize;
            this.outputShape = [a, o];
            var s = "0.0",
                u = "";
            "prod" === n ? s = "1.0" : "min" === n ? (s = "1.0 / 1e-20", u = "min") : "max" === n && (s = "-1.0 / 1e-20", u = "max");
            var c = "".concat(n, "(").concat(n, "(").concat(n, "(") + "minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
            "sum" === n ? c = "sumValue" : "prod" === n ? c = "prodValue" : "all" === n ? c = "allValue" : "any" === n && (c = "anyValue");
            var h = 4 * Math.floor(r / 4),
                p = r % 4,
                f = "\n      if (".concat("sum" === n, ") {\n        sumValue += dot(values, ones);\n      } else if (").concat("prod" === n, ") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ").concat(u, "(values, minMaxValue);\n        if (").concat("min" === n, " || ").concat("max" === n, ") {\n          minMaxValue = ").concat(u, "(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    "),
                d = "vec4";
            "all" === n ? (s = "1.0", f = "\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ", d = "bvec4") : "any" === n && (s = "0.0", f = "\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ", d = "bvec4");
            var v = "";
            i % r > 0 && (v = "\n        if (inIdx < 0 || inIdx >= ".concat(i, ") {\n          return initializationValue;\n        }\n      ")), this.userCode = "\n      const float initializationValue = ".concat(s, ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ").concat(v, "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(r, ";\n\n        vec4 minMaxValue = vec4(").concat(s, ");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ").concat(h, "; i += 4) {\n          int inIdx = inOffset + i;\n          ").concat(d, " values = ").concat(d, "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(f, "\n        }\n\n        int inIdx = inOffset + ").concat(h, ";\n        if (").concat(1 === p, ") {\n          ").concat(d, " values = ").concat(d, "(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(f, "\n        } else if (").concat(2 === p, ") {\n          ").concat(d, " values = ").concat(d, "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(f, "\n        } else if (").concat(3 === p, ") {\n          ").concat(d, " values = ").concat(d, "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ").concat(f, "\n        }\n        setOutput(").concat(c, ");\n      }\n    ")
        }));

    function ZEe(e, t, n, r) {
        for (var a = function(e) {
                for (var t = []; 0 === t.length || 1 !== t[t.length - 1].outSize;) {
                    var n = t.length ? t[t.length - 1].outSize : e[1],
                        r = hie(n);
                    t.push({
                        inSize: n,
                        windowSize: r,
                        outSize: Math.ceil(n / r)
                    })
                }
                return t
            }(e.shape), i = e, o = 0; o < a.length; o++) {
            var s, u = a[o],
                c = u.inSize,
                l = u.windowSize,
                h = u.outSize,
                p = void 0;
            p = "mean" === n ? 0 === o ? new YEe({
                windowSize: l,
                inSize: c,
                batchSize: e.shape[0],
                outSize: h
            }, c) : new YEe({
                windowSize: l,
                inSize: c,
                batchSize: e.shape[0],
                outSize: h
            }) : new JEe({
                windowSize: l,
                inSize: c,
                batchSize: e.shape[0],
                outSize: h
            }, n), s = i, i = r.runWebGLProgram(p, [i], t), s.dataId !== e.dataId && r.disposeIntermediateTensorInfo(s)
        }
        return i
    }
    var QEe = p((function e(t, n) {
        l(this, e), this.variableNames = ["A"];
        for (var r = new Array(t.length), a = 0; a < r.length; a++) r[a] = t[n[a]];
        this.outputShape = r, this.rank = r.length;
        var i = hSe(this.rank),
            o = function(e) {
                var t = e.length;
                if (t > 6) throw Error("Transpose for rank ".concat(t, " is not yet supported"));
                for (var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"], r = new Array(t), a = 0; a < e.length; a++) r[e[a]] = n[a];
                return r.join()
            }(n);
        this.userCode = "\n    void main() {\n      ".concat(i, " resRC = getOutputCoords();\n      setOutput(getA(").concat(o, "));\n    }\n    ")
    }));
    var $Ee = p((function e(t, n) {
        l(this, e), this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0;
        for (var r = new Array(t.length), a = 0; a < r.length; a++) r[a] = t[n[a]];
        if (this.outputShape = r, this.rank = r.length, this.rank > 6) throw Error("Packed transpose for rank ".concat(this.rank, " is not yet supported."));
        for (var i = hSe(this.rank), o = KTe("rc", this.rank), s = new Array(this.rank), u = 0; u < n.length; u++) s[n[u]] = o[u];
        var c = "vec2(".concat(s.slice(-2).join(), ")"),
            h = "++".concat(o[this.rank - 1], " < ").concat(r[this.rank - 1]),
            p = "getChannel(getA(".concat(s.join(), "), ").concat(c, ")");
        this.userCode = "\n    void main() {\n      ".concat(i, " rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ").concat(p, ";\n      if(").concat(h, ") {\n        result[1] = ").concat(p, ";\n      }\n      --").concat(o[this.rank - 1], ";\n      if(++").concat(o[this.rank - 2], " < ").concat(r[this.rank - 2], ") {\n        result[2] = ").concat(p, ";\n        if(").concat(h, ") {\n          result[3] = ").concat(p, ";\n        }\n      }\n      setOutput(result);\n    }\n    ")
    }));

    function eCe(e, t, n) {
        var r = k0().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new $Ee(e.shape, t) : new QEe(e.shape, t);
        return n.runWebGLProgram(r, [e], e.dtype)
    }

    function tCe(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs;
        return function(e, t, n, r) {
            var a = t,
                i = e.shape.length,
                o = j$(a, e.shape),
                s = o,
                u = $7(s, i),
                c = null != u,
                l = e;
            c && (l = eCe(e, u, r), s = t9(s.length, i)), Q7("sum", s, i);
            var h = S(J7(l.shape, s), 2),
                p = h[0],
                f = h[1],
                d = p;
            n && (d = Z7(p, o));
            var v = L$(f),
                m = KEe({
                    inputs: {
                        x: l
                    },
                    attrs: {
                        shape: [L$(e.shape) / v, v]
                    },
                    backend: r
                }),
                g = ZEe(m, p5(e.dtype), "sum", r),
                y = KEe({
                    inputs: {
                        x: g
                    },
                    attrs: {
                        shape: d
                    },
                    backend: r
                });
            return r.disposeIntermediateTensorInfo(m), r.disposeIntermediateTensorInfo(g), c && r.disposeIntermediateTensorInfo(l), y
        }(t.x, r.axis, r.keepDims, n)
    }
    var nCe = {
        kernelName: a3,
        backendName: "webgl",
        kernelFunc: tCe
    };

    function rCe(e) {
        for (var t, n = e.inputs, r = e.backend, a = e.attrs, i = n.x, o = a.perm, s = r, u = i.shape.length, c = new Array(u), l = 0; l < c.length; l++) c[l] = i.shape[o[l]];
        if (s.shouldExecuteOnCPU([i])) {
            var h = s.texData.get(i.dataId).values,
                p = HTe(h, i.shape, i.dtype, o, c);
            t = s.makeTensorInfo(c, i.dtype), s.texData.get(t.dataId).values = p
        } else t = eCe(i, o, s);
        return t
    }
    var aCe = {
        kernelName: T3,
        backendName: "webgl",
        kernelFunc: rCe
    };

    function iCe(e) {
        var t = e.a,
            n = e.b,
            r = e.transposeA,
            a = e.transposeB,
            i = e.backend,
            o = e.bias,
            s = void 0 === o ? null : o,
            u = e.preluActivationWeights,
            c = void 0 === u ? null : u,
            l = e.leakyreluAlpha,
            h = void 0 === l ? 0 : l,
            p = e.activation,
            f = void 0 === p ? null : p,
            d = t.shape.length,
            v = n.shape.length,
            m = r ? t.shape[d - 2] : t.shape[d - 1],
            g = a ? n.shape[v - 1] : n.shape[v - 2],
            y = r ? t.shape[d - 1] : t.shape[d - 2],
            b = a ? n.shape[v - 2] : n.shape[v - 1],
            x = t.shape.slice(0, -2),
            k = n.shape.slice(0, -2),
            w = L$(x),
            I = L$(k),
            N = z7(t.shape.slice(0, -2), n.shape.slice(0, -2)).concat([y, b]);
        F$(m === g, (function() {
            return "Error in matMul: inner shapes (".concat(m, ") and (") + "".concat(g, ") of Tensors with shapes ").concat(t.shape, " and ") + "".concat(n.shape, " and transposeA=").concat(r) + " and transposeB=".concat(a, " must match.")
        }));
        var S, T = r ? [w, m, y] : [w, y, m],
            E = a ? [I, b, g] : [I, g, b],
            C = KEe({
                inputs: {
                    x: t
                },
                backend: i,
                attrs: {
                    shape: T
                }
            }),
            A = KEe({
                inputs: {
                    x: n
                },
                backend: i,
                attrs: {
                    shape: E
                }
            }),
            R = [C, A],
            _ = Math.max(w, I),
            O = r ? C.shape[1] : C.shape[2],
            F = null != s,
            D = null != c,
            M = "leakyrelu" === f,
            L = null != f ? BEe(f, !0) : null;
        if ((1 === y || 1 === b) && O > 1e3 && !1 === (F || D || M || null != L)) {
            var z = C,
                P = A;
            r && (z = rCe({
                inputs: {
                    x: C
                },
                backend: i,
                attrs: {
                    perm: [0, 2, 1]
                }
            }), R.push(z)), a && (P = rCe({
                inputs: {
                    x: A
                },
                backend: i,
                attrs: {
                    perm: [0, 2, 1]
                }
            }), R.push(P));
            var B = 1 === b,
                W = z;
            1 !== b && (W = KEe({
                inputs: {
                    x: z
                },
                backend: i,
                attrs: {
                    shape: [_, O, 1]
                }
            }), R.push(W));
            var U = 1 === b ? 2 : 1,
                V = P;
            B && (V = KEe({
                inputs: {
                    x: P
                },
                backend: i,
                attrs: {
                    shape: [_, 1, O]
                }
            }), R.push(V));
            var G = HEe({
                inputs: {
                    a: W,
                    b: V
                },
                backend: i
            });
            S = tCe({
                inputs: {
                    x: G
                },
                backend: i,
                attrs: {
                    axis: U,
                    keepDims: !0
                }
            }), R.push(G)
        } else {
            var j = h5(t.dtype, n.dtype),
                H = new WEe(T, E, [_, y, b], r, a, F, L, D, M),
                q = [C, A];
            if (null != s && q.push(s), D && q.push(c), M) {
                var K = i.makeTensorInfo([], "float32", M4(h, "float32"));
                q.push(K), R.push(K)
            }
            S = i.runWebGLProgram(H, q, j)
        }
        var X = KEe({
            inputs: {
                x: S
            },
            backend: i,
            attrs: {
                shape: N
            }
        });
        R.push(S);
        for (var Y = 0, J = R; Y < J.length; Y++) {
            var Z = J[Y];
            i.disposeIntermediateTensorInfo(Z)
        }
        return X
    }
    var oCe = {
            kernelName: D3,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.a,
                    i = t.b,
                    o = t.bias,
                    s = t.preluActivationWeights,
                    u = r.transposeA,
                    c = r.transposeB,
                    l = r.activation;
                return iCe({
                    a: a,
                    b: i,
                    transposeA: u,
                    transposeB: c,
                    backend: n,
                    bias: o,
                    preluActivationWeights: s,
                    leakyreluAlpha: r.leakyreluAlpha,
                    activation: l
                })
            }
        },
        sCe = "return abs(x);";
    var uCe = {
            kernelName: N0,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t, n = e.inputs,
                    r = e.backend,
                    a = n.x;
                if (r.shouldExecuteOnCPU([a]) && "complex64" !== a.dtype) {
                    var i = r.texData.get(a.dataId),
                        o = _Te(i.values);
                    return r.makeTensorInfo(a.shape, a.dtype, o)
                }
                return t = k0().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? new vEe(a.shape, sCe) : new tEe(a.shape, sCe), r.runWebGLProgram(t, [a], a.dtype)
            }
        },
        cCe = zEe({
            opSnippet: "if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"
        }),
        lCe = {
            kernelName: S0,
            backendName: "webgl",
            kernelFunc: cCe
        },
        hCe = zEe({
            opSnippet: "if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"
        }),
        pCe = {
            kernelName: T0,
            backendName: "webgl",
            kernelFunc: hCe
        },
        fCe = "return a + b;",
        dCe = PEe({
            opSnippet: fCe,
            packedOpSnippet: fCe,
            supportsComplex: !0,
            cpuKernelImpl: QSe
        }),
        vCe = {
            kernelName: E0,
            backendName: "webgl",
            kernelFunc: dCe
        },
        mCe = p((function e(t, n) {
            l(this, e), this.outputShape = [], this.outputShape = t, this.variableNames = n.map((function(e, t) {
                return "T".concat(t)
            }));
            var r = [];
            this.variableNames.forEach((function(e) {
                r.push("float v".concat(e, " = get").concat(e, "AtOutCoords();"))
            }));
            var a = this.variableNames.map((function(e) {
                return "v".concat(e)
            })).join(" + ");
            this.userCode = "\n      void main() {\n        ".concat(r.join("\n        "), "\n\n        float result = ").concat(a, ";\n        setOutput(result);\n      }\n    ")
        })),
        gCe = p((function e(t, n) {
            l(this, e), this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.variableNames = n.map((function(e, t) {
                return "T".concat(t)
            }));
            var r = [];
            this.variableNames.forEach((function(e) {
                r.push("vec4 v".concat(e, " = get").concat(e, "AtOutCoords();"))
            }));
            var a = this.variableNames.map((function(e) {
                return "v".concat(e)
            })).join(" + ");
            this.userCode = "\n      void main() {\n        ".concat(r.join("\n        "), "\n\n        vec4 result = ").concat(a, ";\n        setOutput(result);\n      }\n    ")
        }));
    var yCe = {
        kernelName: C0,
        backendName: "webgl",
        kernelFunc: function e(t) {
            var n = t.inputs,
                r = t.backend,
                a = n;
            if (1 === a.length) return EEe({
                inputs: {
                    x: a[0]
                },
                backend: r
            });
            if (a.length > k0().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")) {
                var i = Math.floor(a.length / 2),
                    o = e({
                        inputs: a.slice(0, i),
                        backend: r
                    }),
                    s = e({
                        inputs: a.slice(i),
                        backend: r
                    });
                return e({
                    inputs: [o, s],
                    backend: r
                })
            }
            var u = a.map((function(e) {
                    return e.dtype
                })).reduce((function(e, t) {
                    return h5(e, t)
                })),
                c = a.map((function(e) {
                    return e.shape
                })),
                l = k0().getBool("WEBGL_PACK") ? new gCe(a[0].shape, c) : new mCe(a[0].shape, c);
            return r.runWebGLProgram(l, a, u)
        }
    };
    var bCe = {
        kernelName: A0,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = r.axis,
                o = r.keepDims,
                s = a.shape.length,
                u = j$(i, a.shape),
                c = u,
                l = $7(c, s),
                h = a;
            null != l && (h = rCe({
                inputs: {
                    x: a
                },
                backend: n,
                attrs: {
                    perm: l
                }
            }), c = t9(c.length, s)), Q7("all", c, s);
            var p, f = S(J7(h.shape, c), 2),
                d = f[0],
                v = KEe({
                    inputs: {
                        x: h
                    },
                    backend: n,
                    attrs: {
                        shape: [-1, L$(f[1])]
                    }
                }),
                m = ZEe(v, v.dtype, "all", n);
            return p = KEe(o ? {
                inputs: {
                    x: m
                },
                backend: n,
                attrs: {
                    shape: Z7(d, u)
                }
            } : {
                inputs: {
                    x: m
                },
                backend: n,
                attrs: {
                    shape: d
                }
            }), n.disposeIntermediateTensorInfo(v), n.disposeIntermediateTensorInfo(m), null != l && n.disposeIntermediateTensorInfo(h), p
        }
    };
    var xCe = {
            kernelName: R0,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.axis,
                    o = r.keepDims,
                    s = a.shape.length,
                    u = j$(i, a.shape),
                    c = u,
                    l = $7(c, s),
                    h = a;
                null != l && (h = rCe({
                    inputs: {
                        x: a
                    },
                    backend: n,
                    attrs: {
                        perm: l
                    }
                }), c = t9(c.length, s)), Q7("any", c, s);
                var p, f = S(J7(h.shape, c), 2),
                    d = f[0],
                    v = KEe({
                        inputs: {
                            x: h
                        },
                        backend: n,
                        attrs: {
                            shape: [-1, L$(f[1])]
                        }
                    }),
                    m = ZEe(v, v.dtype, "any", n);
                return p = KEe(o ? {
                    inputs: {
                        x: m
                    },
                    backend: n,
                    attrs: {
                        shape: Z7(d, u)
                    }
                } : {
                    inputs: {
                        x: m
                    },
                    backend: n,
                    attrs: {
                        shape: d
                    }
                }), n.disposeIntermediateTensorInfo(v), n.disposeIntermediateTensorInfo(m), null != l && n.disposeIntermediateTensorInfo(h), p
            }
        },
        kCe = p((function e(t, n, r) {
            l(this, e), this.variableNames = ["A"];
            var a = t.windowSize,
                i = t.batchSize,
                o = t.outSize;
            r || this.variableNames.push("bestIndicesA"), this.outputShape = [i, o];
            var s = "max" === n ? ">" : "<",
                u = r ? "inOffset + i;" : "round(getBestIndicesA(batch, inOffset + i));";
            this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ".concat(a, ";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ").concat(a, "; i++) {\n          int inIdx = ").concat(u, ";\n          float candidate = getA(batch, inIdx);\n          if (candidate ").concat(s, " bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ")
        })),
        wCe = p((function e(t, n, r, a) {
            l(this, e), this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, F$(t.length > 2, (function() {
                return "Packed arg".concat(r.charAt(0).toUpperCase() + r.slice(1), " supports only inputs with rank above 2.")
            }));
            var i = t[t.length - 1],
                o = Math.ceil(i / n);
            this.outputShape = t.slice(0, -1), o > 1 && this.outputShape.push(o), a || this.variableNames.push("bestIndicesA");
            var s, u, c = this.outputShape,
                h = c.length,
                p = hSe(h),
                f = XTe("coords", h);
            if (1 === o) {
                var d = hSe(u = h + 1);
                s = "\n        ".concat(d, " sourceLocR = ").concat(d, "(").concat(f.join(), ", 0);\n        ++").concat(f[h - 1], ";\n        ").concat(d, " sourceLocG = ").concat(d, "(").concat(f.join(), ", 0);\n        ++").concat(f[h - 2], ";\n        ").concat(d, " sourceLocA = ").concat(d, "(").concat(f.join(), ", 0);\n        --").concat(f[h - 1], ";\n        ").concat(d, " sourceLocB = ").concat(d, "(").concat(f.join(), ", 0);\n        --").concat(f[h - 2], ";")
            } else u = h, s = "\n        ".concat(p, " sourceLocR = coords;\n        ++").concat(f[h - 1], ";\n        ").concat(p, " sourceLocG = coords;\n        ++").concat(f[h - 2], ";\n        ").concat(p, " sourceLocA = coords;\n        --").concat(f[h - 1], ";\n        ").concat(p, " sourceLocB = coords;\n        --").concat(f[h - 2], ";");
            var v = ["x", "y", "z", "w", "u", "v"].slice(0, u),
                m = "." + v[u - 1],
                g = v.map((function(e) {
                    return "int " + e
                })),
                y = XTe("sourceLocR", u - 1).concat("inIdx.r"),
                b = XTe("sourceLocG", u - 1).concat("inIdx.g"),
                x = XTe("sourceLocB", u - 1).concat("inIdx.b"),
                k = XTe("sourceLocA", u - 1).concat("inIdx.a"),
                w = "max" === r ? "greaterThan" : "lessThan",
                I = a ? "" : "\n          inIdx = round(vec4(getBestIndicesAChannel(".concat(y.join(), "),\n                             getBestIndicesAChannel(").concat(b.join(), "),\n                             getBestIndicesAChannel(").concat(x.join(), "),\n                             getBestIndicesAChannel(").concat(k.join(), ")));"),
                N = "vec4(\n            getAChannel(".concat(y.join(), "),\n            hasNextCol ? getAChannel(").concat(b.join(), ") : 0.,\n            hasNextRow ? getAChannel(").concat(x.join(), ") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(").concat(k.join(), ") : 0.)"),
                S = a ? "" : "\n      float getBestIndicesAChannel(".concat(g.join(), ") {\n        return getChannel(getBestIndicesA(").concat(v.join(), "),\n                                          vec2(").concat(v.slice(-2).join(), "));\n      }");
            this.userCode = "\n      float getAChannel(".concat(g.join(), ") {\n        return getChannel(getA(").concat(v.join(), "),\n                               vec2(").concat(v.slice(-2).join(), "));\n      }\n      ").concat(S, "\n      void main() {\n        ").concat(p, " coords = getOutputCoords();\n        bool hasNextCol = ").concat(f[h - 1], " < ").concat(c[h - 1] - 1, ";\n        bool hasNextRow = ").concat(f[h - 2], " < ").concat(c[h - 2] - 1, ";\n        ").concat(s, "\n        ivec4 srcIdx = ivec4(sourceLocR").concat(m, ", sourceLocG").concat(m, ",\n          sourceLocB").concat(m, ", sourceLocA").concat(m, ") * ").concat(n, ";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ").concat(N, ";\n\n        for (int i = 0; i < ").concat(n, "; i++) {\n          inIdx = srcIdx;\n          ").concat(I, "\n          vec4 candidate = ").concat(N, ";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(").concat(w, "(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ")
        }));

    function ICe(e, t, n) {
        var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
            a = t.shape[0],
            i = t.shape[1];
        null != r && (a = r.shape[0], i = r.shape[1]);
        var o = hie(i),
            s = {
                windowSize: o,
                inSize: i,
                batchSize: a,
                outSize: Math.ceil(i / o)
            },
            u = new kCe(s, n, null == r),
            c = [t];
        null != r && c.push(r);
        var l = e.runWebGLProgram(u, c, "int32");
        if (1 === l.shape[1]) return l;
        var h = ICe(e, t, n, l);
        return e.disposeIntermediateTensorInfo(l), h
    }

    function NCe(e, t, n) {
        var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
            a = null != r ? r.shape : t.shape,
            i = a[a.length - 1],
            o = hie(i),
            s = new wCe(a, o, n, null == r),
            u = null == r ? [t] : [t, r],
            c = e.runWebGLProgram(s, u, "int32");
        if (c.shape.length === t.shape.length) {
            var l = NCe(e, t, n, c);
            return e.disposeIntermediateTensorInfo(c), l
        }
        return c
    }

    function SCe(e, t, n, r) {
        var a = [n];
        if (Q7("arg" + r.charAt(0).toUpperCase() + r.slice(1), a, t.shape.length), !k0().getBool("WEBGL_PACK_REDUCE") || t.shape.length <= 2) {
            var i = [],
                o = e.texData.get(t.dataId),
                s = t;
            null !== o && o.isPacked && (s = e.unpackTensor(t), i.push(s));
            var u = S(J7(s.shape, a), 2),
                c = u[0],
                l = L$(u[1]),
                h = KEe({
                    inputs: {
                        x: s
                    },
                    backend: e,
                    attrs: {
                        shape: [-1, l]
                    }
                });
            i.push(h);
            var p = ICe(e, h, r);
            i.push(p);
            var f = KEe({
                inputs: {
                    x: p
                },
                backend: e,
                attrs: {
                    shape: c
                }
            });
            return i.forEach((function(t) {
                return e.disposeIntermediateTensorInfo(t)
            })), f
        }
        return NCe(e, t, r)
    }
    var TCe = {
        kernelName: _0,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = j$(r.axis, a.shape),
                o = $7(i, a.shape.length),
                s = a,
                u = [];
            null != o && (s = rCe({
                inputs: {
                    x: a
                },
                backend: n,
                attrs: {
                    perm: o
                }
            }), u.push(s), i = t9(i.length, s.shape.length)), Q7("argMax", [i[0]], s.shape.length);
            var c = SCe(n, s, i[0], "max");
            return u.forEach((function(e) {
                return n.disposeIntermediateTensorInfo(e)
            })), c
        }
    };
    var ECe = {
            kernelName: O0,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = j$(r.axis, a.shape),
                    o = $7(i, a.shape.length),
                    s = a,
                    u = [];
                null != o && (s = rCe({
                    inputs: {
                        x: a
                    },
                    backend: n,
                    attrs: {
                        perm: o
                    }
                }), u.push(s), i = t9(i.length, s.shape.length)), Q7("argMin", [i[0]], s.shape.length);
                var c = SCe(n, s, i[0], "min");
                return u.forEach((function(e) {
                    return n.disposeIntermediateTensorInfo(e)
                })), c
            }
        },
        CCe = zEe({
            opSnippet: "if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"
        }),
        ACe = {
            kernelName: F0,
            backendName: "webgl",
            kernelFunc: CCe
        },
        RCe = zEe({
            opSnippet: "if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"
        }),
        _Ce = {
            kernelName: D0,
            backendName: "webgl",
            kernelFunc: RCe
        },
        OCe = zEe({
            opSnippet: "if (isnan(x)) return x;\n  return atan(x);\n"
        }),
        FCe = {
            kernelName: M0,
            backendName: "webgl",
            kernelFunc: OCe
        },
        DCe = PEe({
            opSnippet: "\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",
            packedOpSnippet: "\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n"
        }),
        MCe = {
            kernelName: z0,
            backendName: "webgl",
            kernelFunc: DCe
        },
        LCe = zEe({
            opSnippet: "if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"
        }),
        zCe = {
            kernelName: L0,
            backendName: "webgl",
            kernelFunc: LCe
        },
        PCe = p((function e(t, n, r) {
            var a = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
                i = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
            if (l(this, e), this.variableNames = ["x"], "avg" === n && r) throw new Error("Cannot compute positions for average pool.");
            var o = t.filterWidth,
                s = t.strideHeight,
                u = t.strideWidth,
                c = t.dilationHeight,
                h = t.dilationWidth,
                p = t.effectiveFilterHeight,
                f = t.effectiveFilterWidth,
                d = t.padInfo.top,
                v = t.padInfo.left;
            this.outputShape = t.outShape;
            var m = "avg" === n,
                g = "((batch  * ".concat(t.inHeight, " + xR) * ").concat(t.inWidth, " + xC) * ").concat(t.inChannels, " + d"),
                y = "(xR * ".concat(t.inWidth, " + xC) * ").concat(t.inChannels, " + d"),
                b = "0.0";
            if (m || (b = "-1.0 / 1e-20"), r) {
                var x = ">=";
                this.userCode = "\n        const ivec2 strides = ivec2(".concat(s, ", ").concat(u, ");\n        const ivec2 pads = ivec2(").concat(d, ", ").concat(v, ");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ").concat(p, ";\n              wR += ").concat(c, ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(t.inHeight, ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(f, ";\n                wC += ").concat(h, ") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ").concat(t.inWidth, ") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ").concat(x, " currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ").concat(a ? i ? g : y : "wR * ".concat(f, " + wC"), ";\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ")
            } else {
                var k = "max",
                    w = "".concat(n, "(").concat(n, "(").concat(n, "(") + "minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
                "avg" === n && (w = "avgValue / max(count, 1.0)");
                var I = 4 * Math.floor(o / 4),
                    N = o % 4,
                    S = "\n      if (".concat(m, ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat(k, "(values, minMaxValue);\n      }\n    ");
                this.userCode = "\n      const ivec2 strides = ivec2(".concat(s, ", ").concat(u, ");\n      const ivec2 pads = ivec2(").concat(d, ", ").concat(v, ");\n      const float initializationValue = ").concat(b, ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ").concat(t.inWidth, ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(b, ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ").concat(p, ";\n            wR += ").concat(c, ") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ").concat(t.inHeight, ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(I, "; wC += 4) {\n            int xC = xCCorner + wC * ").concat(h, ";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(h, ", d),\n              getValue(batch, xR, xC + 2 * ").concat(h, ", d),\n              getValue(batch, xR, xC + 3 * ").concat(h, ", d)\n            );\n\n            ").concat(S, "\n          }\n\n          int xC = xCCorner + ").concat(I, ";\n          if (").concat(1 === N, ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(S, "\n          } else if (").concat(2 === N, ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(h, ", d),\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(S, "\n          } else if (").concat(3 === N, ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(h, ", d),\n              getValue(batch, xR, xC + 2 * ").concat(h, ", d),\n              initializationValue\n            );\n\n            ").concat(S, "\n          }\n        }\n        setOutput(").concat(w, ");\n      }\n    ")
            }
        })),
        BCe = p((function e(t, n, r) {
            var a = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
                i = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
            if (l(this, e), this.variableNames = ["x"], "avg" === n && r) throw new Error("Cannot compute positions for average pool.");
            var o = t.filterWidth,
                s = t.strideDepth,
                u = t.strideHeight,
                c = t.strideWidth,
                h = t.dilationDepth,
                p = t.dilationHeight,
                f = t.dilationWidth,
                d = t.effectiveFilterDepth,
                v = t.effectiveFilterHeight,
                m = t.effectiveFilterWidth,
                g = t.padInfo.front,
                y = t.padInfo.top,
                b = t.padInfo.left;
            this.outputShape = t.outShape;
            var x = "avg" === n,
                k = "0.0";
            if (x || (k = "-1.0 / 1e-20"), r) {
                var w = ">=";
                this.userCode = "\n        const ivec3 strides =\n            ivec3(".concat(s, ", ").concat(u, ", ").concat(c, ");\n        const ivec3 pads = ivec3(").concat(g, ", ").concat(y, ", ").concat(b, ");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ").concat(d, ";\n              wD += ").concat(h, ") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ").concat(t.inDepth, ") {\n              continue;\n            }\n\n            for (int wR = 0; wR < ").concat(v, ";\n                wR += ").concat(p, ") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ").concat(t.inHeight, ") {\n                continue;\n              }\n\n              for (int wC = 0; wC < ").concat(m, ";\n                  wC += ").concat(f, ") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ").concat(t.inWidth, ") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ").concat(w, " currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ").concat(a ? i ? "(((batch * ".concat(t.inDepth, " + xD) * ").concat(t.inHeight, " + xR) * ").concat(t.inWidth, " + xC) * ").concat(t.inChannels, " + ch") : "((xD * ".concat(t.inHeight, " + xR) * ").concat(t.inWidth, " + xC) * ").concat(t.inChannels, " + ch") : "wD * ".concat(v, " * ").concat(m, " +\n                      wR * ").concat(m, " + wC"), ";\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ")
            } else {
                var I = "max",
                    N = "".concat(n, "(").concat(n, "(").concat(n, "(") + "minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
                "avg" === n && (N = "avgValue / max(count, 1.0)");
                var S = 4 * Math.floor(o / 4),
                    T = o % 4,
                    E = "\n      if (".concat(x, ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat(I, "(values, minMaxValue);\n      }\n    ");
                this.userCode = "\n      const ivec3 strides =\n        ivec3(".concat(s, ", ").concat(u, ", ").concat(c, ");\n      const ivec3 pads = ivec3(").concat(g, ", ").concat(y, ", ").concat(b, ");\n      const float initializationValue = ").concat(k, ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ").concat(t.inWidth, ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(k, ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ").concat(d, ";\n            wD += ").concat(h, ") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ").concat(t.inDepth, ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(v, ";\n            wR += ").concat(p, ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(t.inHeight, ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(S, "; wC += 4) {\n              int xC = xCCorner + wC * ").concat(f, ";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(f, ", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(f, ", ch),\n                getValue(batch, xD, xR, xC + 3 * ").concat(f, ", ch)\n              );\n\n              ").concat(E, "\n            }\n\n            int xC = xCCorner + ").concat(S, ";\n            if (").concat(1 === T, ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(E, "\n            } else if (").concat(2 === T, ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(f, ", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(E, "\n            } else if (").concat(3 === T, ") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(f, ", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(f, ", ch),\n                initializationValue\n              );\n\n              ").concat(E, "\n            }\n          }\n        }\n        setOutput(").concat(N, ");\n      }\n    ")
            }
        }));
    var WCe = {
        kernelName: P0,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x;
            zNe(a, "avgPool");
            var i = r.filterSize,
                o = r.strides,
                s = r.pad,
                u = r.dimRoundingMode;
            F$(j8(o, 1), (function() {
                return "Error in avgPool: Either strides or dilations must be 1. " + "Got strides ".concat(o, " and dilations '").concat(1, "'")
            }));
            var c = O8(a.shape, i, o, 1, s, u);
            if (1 === c.filterWidth && 1 === c.filterHeight && P$(c.inShape, c.outShape)) return EEe({
                inputs: {
                    x: a
                },
                backend: n
            });
            var l = new PCe(c, "avg", !1);
            return n.runWebGLProgram(l, [a], "float32")
        }
    };
    var UCe = {
            kernelName: W0,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.filterSize,
                    o = r.strides,
                    s = r.pad,
                    u = r.dimRoundingMode,
                    c = r.dataFormat,
                    l = F8(a.shape, i, o, [1, 1, 1], s, u, c),
                    h = new BCe(l, "avg", !1);
                return n.runWebGLProgram(h, [a], "float32")
            }
        },
        VCe = p((function e(t) {
            l(this, e), this.variableNames = ["dy"], this.outputShape = t.inShape;
            var n = t.filterHeight,
                r = t.filterWidth,
                a = t.strideHeight,
                i = t.strideWidth,
                o = t.dilationHeight,
                s = t.dilationWidth,
                u = t.effectiveFilterHeight,
                c = t.effectiveFilterWidth,
                h = u - 1 - t.padInfo.top,
                p = c - 1 - t.padInfo.left,
                f = 1 / (n * r);
            this.userCode = "\n      const ivec2 pads = ivec2(".concat(h, ", ").concat(p, ");\n      const float avgMultiplier = float(").concat(f, ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(u, ";\n            wR += ").concat(o, ") {\n          float dyR = float(dyRCorner + wR) / ").concat(a, ".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(t.outHeight, ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(c, ";\n            wC+= ").concat(s, ") {\n            float dyC = float(dyCCorner + wC) / ").concat(i, ".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(t.outWidth, ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")
        })),
        GCe = p((function e(t) {
            l(this, e), this.variableNames = ["dy"], this.outputShape = t.inShape;
            var n = t.filterDepth,
                r = t.filterHeight,
                a = t.filterWidth,
                i = t.strideDepth,
                o = t.strideHeight,
                s = t.strideWidth,
                u = t.dilationDepth,
                c = t.dilationHeight,
                h = t.dilationWidth,
                p = t.effectiveFilterDepth,
                f = t.effectiveFilterHeight,
                d = t.effectiveFilterWidth,
                v = p - 1 - t.padInfo.front,
                m = f - 1 - t.padInfo.top,
                g = d - 1 - t.padInfo.left,
                y = 1 / (n * r * a);
            this.userCode = "\n      const ivec3 pads = ivec3(".concat(v, ", ").concat(m, ", ").concat(g, ");\n      const float avgMultiplier = float(").concat(y, ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(p, ";\n            wD += ").concat(u, ") {\n          float dyD = float(dyDCorner + wD) / ").concat(i, ".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(t.outDepth, ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(f, ";\n              wR += ").concat(c, ") {\n            float dyR = float(dyRCorner + wR) / ").concat(o, ".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(t.outHeight, ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(d, ";\n                wC += ").concat(h, ") {\n              float dyC = float(dyCCorner + wC) / ").concat(s, ".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(t.outWidth, ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")
        }));
    var jCe = {
        kernelName: U0,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.dy,
                i = t.input,
                o = r.filterSize,
                s = r.strides,
                u = r.pad,
                c = r.dimRoundingMode,
                l = F8(i.shape, o, s, [1, 1, 1], u, c),
                h = new GCe(l);
            return n.runWebGLProgram(h, [a], i.dtype)
        }
    };
    var HCe = {
        kernelName: B0,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.dy,
                i = t.input,
                o = i;
            zNe([a, i], "avgPoolGrad");
            var s = r.filterSize,
                u = r.strides,
                c = r.pad,
                l = O8(o.shape, s, u, 1, c),
                h = new VCe(l);
            return n.runWebGLProgram(h, [a], o.dtype)
        }
    };
    var qCe = {
            kernelName: V0,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs;
                return iCe({
                    a: t.a,
                    b: t.b,
                    transposeA: r.transposeA,
                    transposeB: r.transposeB,
                    backend: n
                })
            }
        },
        KCe = p((function e(t, n, r, a, i, o) {
            l(this, e), this.outputShape = [], this.variableNames = ["x", "mean", "variance"], z7(t, n), z7(t, r);
            var s = "0.0";
            null != a && (z7(t, a), this.variableNames.push("offset"), s = "getOffsetAtOutCoords()");
            var u = "1.0";
            null != i && (z7(t, i), this.variableNames.push("scale"), u = "getScaleAtOutCoords()"), this.outputShape = t, this.userCode = "\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ".concat(s, ";\n        float scale = ").concat(u, ";\n        float inv = scale * inversesqrt(variance + float(").concat(o, "));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ")
        })),
        XCe = p((function e(t, n, r, a, i, o) {
            l(this, e), this.packedInputs = !0, this.packedOutput = !0, this.variableNames = ["x", "mean", "variance"], z7(t, n), z7(t, r);
            var s = "vec4(0.0)";
            null != a && (z7(t, a), this.variableNames.push("offset"), s = "getOffsetAtOutCoords()");
            var u = "vec4(1.0)";
            null != i && (z7(t, i), this.variableNames.push("scale"), u = "getScaleAtOutCoords()"), this.outputShape = t, this.userCode = "\n      void main() {\n        vec4 offset = ".concat(s, ";\n        vec4 scale = ").concat(u, ";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(").concat(o, "));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ")
        })),
        YCe = {
            kernelName: M1,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.mean,
                    o = t.variance,
                    s = t.offset,
                    u = t.scale;
                F$(i.shape.length === o.shape.length, (function() {
                    return "Batch normalization gradient requires mean and variance to have equal ranks."
                })), F$(null == s || i.shape.length === s.shape.length, (function() {
                    return "Batch normalization gradient requires mean and offset to have equal ranks."
                })), F$(null == u || i.shape.length === u.shape.length, (function() {
                    return "Batch normalization gradient requires mean and scale to have equal ranks."
                }));
                var c = r.varianceEpsilon;
                null == c && (c = .001);
                var l = [a, i, o],
                    h = null;
                null != s && (h = s.shape, l.push(s));
                var p = null;
                null != u && (p = u.shape, l.push(u));
                var f = k0().getBool("WEBGL_PACK_NORMALIZATION") ? new XCe(a.shape, i.shape, o.shape, h, p, c) : new KCe(a.shape, i.shape, o.shape, h, p, c);
                return n.runWebGLProgram(f, l, l[0].dtype)
            }
        },
        JCe = p((function e(t) {
            l(this, e), this.variableNames = ["source"], this.outputShape = t, this.rank = t.length;
            var n = hSe(this.rank);
            this.customUniforms = [{
                name: "start",
                arrayIndex: this.rank,
                type: "int"
            }];
            var r, a = function(e) {
                    if (1 === e) return "sourceLoc";
                    if (e <= 6) return ZCe.slice(0, e).map((function(e) {
                        return "sourceLoc." + e
                    })).join(",");
                    throw Error("Slicing for rank ".concat(e, " is not yet supported"))
                }(this.rank),
                i = t.map((function(e, t) {
                    return "sourceLoc.".concat(ZCe[t], " = start[").concat(t, "] + coords.").concat(ZCe[t], ";")
                }));
            r = "\n        ".concat(n, " sourceLoc;\n        ").concat(n, " coords = getOutputCoords();\n        ").concat(i.join("\n"), "\n      "), this.userCode = "\n      void main() {\n        ".concat(r, "\n        setOutput(getSource(").concat(a, "));\n      }\n    ")
        })),
        ZCe = ["x", "y", "z", "w", "u", "v"];
    var QCe = p((function e(t) {
        l(this, e), this.variableNames = ["source"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.rank = t.length, this.customUniforms = [{
            name: "start",
            arrayIndex: this.rank,
            type: "int"
        }];
        var n = hSe(this.rank),
            r = XTe("coords", this.rank),
            a = XTe("sourceLoc", this.rank),
            i = 1 === this.rank ? "sourceLoc" : "vec2(".concat(a.slice(-2).join(), ")"),
            o = "getChannel(getSource(".concat(a.join(), "), ").concat(i, ")"),
            s = "\n      result.x = ".concat(o, ";\n      if (++").concat(r[this.rank - 1], " < ").concat(t[this.rank - 1], ") {\n        ++").concat(a[this.rank - 1], ";\n        result.y = ").concat(o, ";\n        --").concat(a[this.rank - 1], ";\n      }\n    "),
            u = 1 === this.rank ? "" : "\n      --".concat(r[this.rank - 1], ";\n      if (++").concat(r[this.rank - 2], " < ").concat(t[this.rank - 2], ") {\n        ++").concat(a[this.rank - 2], ";\n        result.z = ").concat(o, ";\n        if (++").concat(r[this.rank - 1], " < ").concat(t[this.rank - 1], ") {\n          ++").concat(a[this.rank - 1], ";\n          result.w = ").concat(o, ";\n        }\n      }\n    "),
            c = this.rank <= 4 ? "sourceLoc = coords +\n            ".concat(n, "(").concat(t.map((function(e, t) {
                return "start[".concat(t, "]")
            })).join(), ");") : t.map((function(e, t) {
                return "".concat(a[t], " = ").concat(r[t], " + start[").concat(t, "];")
            })).join("\n");
        this.userCode = "\n      void main() {\n        ".concat(n, " coords = getOutputCoords();\n        ").concat(n, " sourceLoc;\n        ").concat(c, "\n        vec4 result = vec4(0.);\n        ").concat(s, "\n        ").concat(u, "\n        setOutput(result);\n      }\n    ")
    }));

    function $Ce(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs,
            a = t.x,
            i = S(Yae(a, r.begin, r.size), 2),
            o = i[0],
            s = i[1];
        if (zae(a, o, s), 0 === L$(s)) return n.makeTensorInfo(s, a.dtype, []);
        if (n.shouldExecuteOnCPU([a]) || "string" === a.dtype) {
            var u = n.texData.get(a.dataId),
                c = OTe(u.values, o, s, a.shape, a.dtype);
            return n.makeTensorInfo(s, a.dtype, c)
        }
        var l = n.texData.get(a.dataId).isPacked,
            h = Kae(a.shape, o, s);
        if (l || !h) {
            var p = k0().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new QCe(s) : new JCe(s),
                f = [o];
            return n.runWebGLProgram(p, [a], a.dtype, f)
        }
        return n.uploadToGPU(a.dataId),
            function(e, t, n, r) {
                var a = r.texData.get(e.dataId),
                    i = r.makeTensorInfo(n, e.dtype),
                    o = r.texData.get(i.dataId);
                Object.assign(o, a), o.refCount = 1, o.shape = n, o.dtype = e.dtype;
                var s = Xae(t, i0(e.shape));
                a.slice && (s += a.slice.flatOffset), o.slice = {
                    flatOffset: s,
                    origDataId: a.slice && a.slice.origDataId || e.dataId
                };
                var u = r.dataRefCount.get(o.slice.origDataId) || 1;
                return r.dataRefCount.set(o.slice.origDataId, u + 1), i
            }(a, o, s, n)
    }
    var eAe = {
            kernelName: Z2,
            backendName: "webgl",
            kernelFunc: $Ce
        },
        tAe = {
            kernelName: G0,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.blockShape,
                    o = r.crops;
                F$(a.shape.length <= 4, (function() {
                    return "batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"
                }));
                var s = i.reduce((function(e, t) {
                        return e * t
                    })),
                    u = fie(a.shape, i, s),
                    c = die(u.length, i.length),
                    l = vie(a.shape, i, s),
                    h = mie(o, i.length),
                    p = gie(l, o, i.length),
                    f = [],
                    d = KEe({
                        inputs: {
                            x: a
                        },
                        backend: n,
                        attrs: {
                            shape: u
                        }
                    }),
                    v = rCe({
                        inputs: {
                            x: d
                        },
                        backend: n,
                        attrs: {
                            perm: c
                        }
                    }),
                    m = KEe({
                        inputs: {
                            x: v
                        },
                        backend: n,
                        attrs: {
                            shape: l
                        }
                    }),
                    g = $Ce({
                        inputs: {
                            x: m
                        },
                        backend: n,
                        attrs: {
                            begin: h,
                            size: p
                        }
                    });
                return f.push(d), f.push(v), f.push(m), f.forEach((function(e) {
                    return n.disposeIntermediateTensorInfo(e)
                })), g
            }
        };
    var nAe = {
        kernelName: j0,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = t.weights,
                o = r.size,
                s = n.readSync(a.dataId),
                u = n.readSync(i.dataId),
                c = $Se(s, u, i.dtype, i.shape, o);
            return n.makeTensorInfo([o], i.dtype, c)
        }
    };
    var rAe = {
        kernelName: H0,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t, n = e.inputs,
                r = e.backend,
                a = n.a,
                i = n.b,
                o = k0().getBool("WEBGL_PACK_BINARY_OPERATIONS"),
                s = k0().getNumber("WEBGL_VERSION");
            if (r.shouldExecuteOnCPU([a, i]) || 1 === s) {
                var u = r.texData.get(a.dataId).values,
                    c = r.texData.get(i.dataId).values,
                    l = S(tTe(a.shape, i.shape, u, c, a.dtype), 2),
                    h = l[0],
                    p = l[1],
                    f = r.makeTensorInfo(p, a.dtype);
                return r.texData.get(f.dataId).values = h, f
            }
            return t = o ? new TEe("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n", a.shape, i.shape, !1) : new NEe("\n  return float(int(a.r) & int(b.r));\n", a.shape, i.shape), r.runWebGLProgram(t, [a, i], a.dtype)
        }
    };
    var aAe = {
            kernelName: K0,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = t.s0,
                    a = t.s1,
                    i = n.readSync(r.dataId),
                    o = n.readSync(a.dataId),
                    s = z7(Array.from(i), Array.from(o));
                return n.makeTensorInfo([s.length], "int32", Int32Array.from(s))
            }
        },
        iAe = PEe({
            opSnippet: "return float(a != b);",
            cpuKernelImpl: wTe,
            dtype: "bool"
        }),
        oAe = {
            kernelName: b2,
            backendName: "webgl",
            kernelFunc: iAe
        };

    function sAe(e) {
        var t = e.inputs,
            n = e.backend,
            r = t.input;
        return EEe({
            inputs: {
                x: n.texData.get(r.dataId).complexTensorInfos.real
            },
            backend: n
        })
    }
    var uAe = {
        kernelName: D2,
        backendName: "webgl",
        kernelFunc: sAe
    };
    var cAe = {
            kernelName: X0,
            backendName: "webgl",
            kernelFunc: function e(t) {
                var n = t.inputs,
                    r = t.backend,
                    a = t.attrs,
                    i = n.x,
                    o = a.dtype;
                if ("complex64" === o) {
                    if ("complex64" === i.dtype) return EEe({
                        inputs: {
                            x: i
                        },
                        backend: r
                    });
                    var s = $9(i.shape),
                        u = e({
                            inputs: {
                                x: i
                            },
                            backend: r,
                            attrs: {
                                dtype: "float32"
                            }
                        }),
                        c = AEe({
                            inputs: {
                                real: u,
                                imag: s
                            },
                            backend: r
                        });
                    return s.dispose(), r.disposeIntermediateTensorInfo(u), c
                }
                if ("complex64" === i.dtype) {
                    var l = sAe({
                            inputs: {
                                input: i
                            },
                            backend: r
                        }),
                        h = e({
                            inputs: {
                                x: l
                            },
                            backend: r,
                            attrs: {
                                dtype: o
                            }
                        });
                    return r.disposeIntermediateTensorInfo(l), h
                }
                if (!J$(i.dtype, o)) {
                    var p = EEe({
                        inputs: {
                            x: i
                        },
                        backend: r
                    });
                    return {
                        dataId: p.dataId,
                        shape: p.shape,
                        dtype: o
                    }
                }
                if (r.shouldExecuteOnCPU([i])) {
                    var f = r.texData.get(i.dataId).values,
                        d = S(nTe(f, i.shape, i.dtype, o), 3),
                        v = d[0],
                        m = d[1],
                        g = d[2];
                    return r.makeTensorInfo(v, m, g)
                }
                if ("int32" === o) return function(e, t) {
                    var n = new tEe(e.shape, "return float(int(x));"),
                        r = t.runWebGLProgram(n, [e], "int32");
                    return {
                        dataId: r.dataId,
                        shape: r.shape,
                        dtype: r.dtype
                    }
                }(i, r);
                if ("bool" === o) {
                    var y = r.makeTensorInfo([], "bool", q$("bool", 1)),
                        b = iAe({
                            inputs: {
                                a: i,
                                b: y
                            },
                            backend: r
                        });
                    return r.disposeIntermediateTensorInfo(y), b
                }
                throw new Error("Error in Cast: failed to cast ".concat(i.dtype, " to ").concat(o))
            }
        },
        lAe = "return ceil(x);",
        hAe = zEe({
            opSnippet: lAe,
            packedOpSnippet: lAe,
            cpuKernelImpl: rTe
        }),
        pAe = {
            kernelName: Y0,
            backendName: "webgl",
            kernelFunc: hAe
        },
        fAe = p((function e(t) {
            l(this, e), this.variableNames = ["A"], this.customUniforms = [{
                name: "minVal",
                type: "float"
            }, {
                name: "maxVal",
                type: "float"
            }], this.outputShape = t, this.userCode = "\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "
        })),
        dAe = p((function e(t) {
            l(this, e), this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.customUniforms = [{
                name: "minVal",
                type: "float"
            }, {
                name: "maxVal",
                type: "float"
            }], this.outputShape = t, this.userCode = "\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "
        }));
    var vAe = {
            kernelName: J0,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t, n = e.inputs,
                    r = e.backend,
                    a = e.attrs,
                    i = n.x,
                    o = a.clipValueMin,
                    s = a.clipValueMax;
                t = k0().getBool("WEBGL_PACK_CLIP") ? new dAe(i.shape) : new fAe(i.shape);
                var u = [
                    [o],
                    [s]
                ];
                return r.runWebGLProgram(t, [i], i.dtype, u)
            }
        },
        mAe = p((function e(t) {
            l(this, e), this.variableNames = ["real", "imag"], this.outputShape = t, this.userCode = "\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "
        }));

    function gAe(e, t) {
        return {
            dataId: t.dataId,
            dtype: t.dtype,
            shape: e.shape
        }
    }
    var yAe = {
            kernelName: Q0,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = t.x,
                    a = n.texData.get(r.dataId),
                    i = new mAe(r.shape),
                    o = [gAe(r, a.complexTensorInfos.real), gAe(r, a.complexTensorInfos.imag)];
                return n.runWebGLProgram(i, o, o[0].dtype)
            }
        },
        bAe = p((function e(t) {
            l(this, e), this.outputShape = [], this.outputShape = oie(t, 1), this.variableNames = t.map((function(e, t) {
                return "T".concat(t)
            }));
            var n = new Array(t.length - 1);
            n[0] = t[0][1];
            for (var r = 1; r < n.length; r++) n[r] = n[r - 1] + t[r][1];
            for (var a = ["if (yC < ".concat(n[0], ") setOutput(getT0(yR, yC));")], i = 1; i < n.length; i++) {
                var o = n[i - 1];
                a.push("else if (yC < ".concat(n[i], ") ") + "setOutput(getT".concat(i, "(yR, yC-").concat(o, "));"))
            }
            var s = n.length,
                u = n[n.length - 1];
            a.push("else setOutput(getT".concat(s, "(yR, yC-").concat(u, "));")), this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ".concat(a.join("\n        "), "\n      }\n    ")
        })),
        xAe = p((function e(t, n) {
            l(this, e), this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [], this.outputShape = oie(t, n);
            var r = this.outputShape,
                a = r.length,
                i = hSe(a),
                o = XTe("coords", a),
                s = ["x", "y", "z", "w", "u", "v"].slice(0, a);
            this.variableNames = t.map((function(e, t) {
                return "T".concat(t)
            }));
            var u = new Array(t.length - 1);
            u[0] = t[0][n];
            for (var c = 1; c < u.length; c++) u[c] = u[c - 1] + t[c][n];
            for (var h = s[n], p = s.slice(-2), f = s.join(), d = "if (".concat(h, " < ").concat(u[0], ") {\n        return getChannel(\n            getT0(").concat(f, "), vec2(").concat(p.join(), "));\n        }"), v = 1; v < u.length; v++) {
                var m = u[v - 1];
                d += "\n        if (".concat(h, " < ").concat(u[v], "  && ").concat(h, " >= ").concat(u[v - 1], ") {\n          return getChannel(\n            getT").concat(v, "(").concat(kAe(s, h, m), "),\n            vec2(").concat(kAe(p, h, m), "));\n        }")
            }
            var g = u.length,
                y = u[u.length - 1];
            d += "\n        return getChannel(\n          getT".concat(g, "(").concat(kAe(s, h, y), "),\n          vec2(").concat(kAe(p, h, y), "));"), this.userCode = "\n      float getValue(".concat(s.map((function(e) {
                return "int " + e
            })), ") {\n        ").concat(d, "\n      }\n\n      void main() {\n        ").concat(i, " coords = getOutputCoords();\n        vec4 result = vec4(getValue(").concat(o, "), 0., 0., 0.);\n\n        ").concat(o[a - 1], " = ").concat(o[a - 1], " + 1;\n        if (").concat(o[a - 1], " < ").concat(r[a - 1], ") {\n          result.g = getValue(").concat(o, ");\n        }\n\n        ").concat(o[a - 2], " = ").concat(o[a - 2], " + 1;\n        if (").concat(o[a - 2], " < ").concat(r[a - 2], ") {\n          result.a = getValue(").concat(o, ");\n        }\n\n        ").concat(o[a - 1], " = ").concat(o[a - 1], " - 1;\n        if (").concat(o[a - 2], " < ").concat(r[a - 2], " &&\n            ").concat(o[a - 1], " < ").concat(r[a - 1], ") {\n          result.b = getValue(").concat(o, ");\n        }\n        setOutput(result);\n      }\n    ")
        }));

    function kAe(e, t, n) {
        var r = e.indexOf(t);
        return e.map((function(e, t) {
            return t === r ? "".concat(e, " - ").concat(n) : e
        })).join()
    }

    function wAe(e) {
        var t = e.inputs,
            n = e.backend,
            r = t.input;
        return EEe({
            inputs: {
                x: n.texData.get(r.dataId).complexTensorInfos.imag
            },
            backend: n
        })
    }
    var IAe = {
        kernelName: V1,
        backendName: "webgl",
        kernelFunc: wAe
    };

    function NAe(e, t, n) {
        var r = e[0].dtype;
        if ("complex64" === r) {
            var a = e.map((function(e) {
                    return sAe({
                        inputs: {
                            input: e
                        },
                        backend: n
                    })
                })),
                i = e.map((function(e) {
                    return wAe({
                        inputs: {
                            input: e
                        },
                        backend: n
                    })
                })),
                o = NAe(a, t, n),
                s = NAe(i, t, n),
                u = AEe({
                    inputs: {
                        real: o,
                        imag: s
                    },
                    backend: n
                });
            return a.forEach((function(e) {
                return n.disposeIntermediateTensorInfo(e)
            })), i.forEach((function(e) {
                return n.disposeIntermediateTensorInfo(e)
            })), n.disposeIntermediateTensorInfo(o), n.disposeIntermediateTensorInfo(s), u
        }
        var c = n.shouldExecuteOnCPU(e);
        if ("string" === r && (c = !0), c) {
            var l = e.map((function(e) {
                    var r = L$(e.shape.slice(t));
                    return KEe({
                        inputs: {
                            x: e
                        },
                        backend: n,
                        attrs: {
                            shape: [-1, r]
                        }
                    })
                })),
                h = l.map((function(e) {
                    return {
                        vals: n.readSync(e.dataId),
                        shape: e.shape
                    }
                })),
                p = oie(l.map((function(e) {
                    return e.shape
                })), 1),
                f = 1 === l[0].shape[0],
                d = aTe(h, p, r, f),
                v = oie(e.map((function(e) {
                    return e.shape
                })), t),
                m = n.makeTensorInfo(v, r, d);
            return l.forEach((function(e) {
                return n.disposeIntermediateTensorInfo(e)
            })), m
        }
        var g = e.filter((function(e) {
                return L$(e.shape) > 0
            })),
            y = k0().getBool("WEBGL_PACK_ARRAY_OPERATIONS") && g[0].shape.length > 1;
        if (1 === g.length) {
            var b = y ? new tEe(e[0].shape, uEe) : new vEe(e[0].shape, uEe);
            return n.runWebGLProgram(b, e, r)
        }
        var x = k0().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");
        if (g.length > x) {
            for (var k = [], w = 0; w < g.length; w += x) {
                var I = g.slice(w, w + x);
                k.push(NAe(I, t, n))
            }
            for (var N = NAe(k, t, n), S = 0, T = k; S < T.length; S++) {
                var E = T[S];
                n.disposeIntermediateTensorInfo(E)
            }
            return N
        }
        if (y) {
            var C = new xAe(g.map((function(e) {
                return e.shape
            })), t);
            return n.runWebGLProgram(C, g, r)
        }
        var A = function(e, t, n) {
                var r = oie(e.map((function(e) {
                    return e.shape
                })), t);
                return {
                    tensors2D: e.map((function(e) {
                        return KEe({
                            inputs: {
                                x: e
                            },
                            attrs: {
                                shape: [-1, L$(e.shape.slice(t))]
                            },
                            backend: n
                        })
                    })),
                    outShape: r
                }
            }(g, t, n),
            R = A.tensors2D,
            _ = A.outShape,
            O = new bAe(R.map((function(e) {
                return e.shape
            }))),
            F = n.runWebGLProgram(O, R, r);
        R.forEach((function(e) {
            return n.disposeIntermediateTensorInfo(e)
        }));
        var D = KEe({
            inputs: {
                x: F
            },
            attrs: {
                shape: _
            },
            backend: n
        });
        return n.disposeIntermediateTensorInfo(F), D
    }

    function SAe(e) {
        var t = e.inputs,
            n = e.backend,
            r = j$(e.attrs.axis, t[0].shape)[0];
        iie(t.map((function(e) {
            return e.shape
        })), r);
        var a = oie(t.map((function(e) {
            return e.shape
        })), r);
        if (0 === L$(a)) return n.makeTensorInfo(a, t[0].dtype, []);
        var i = t.filter((function(e) {
            return L$(e.shape) > 0
        }));
        return 1 === i.length ? EEe({
            inputs: {
                x: i[0]
            },
            backend: n
        }) : NAe(i, r, n)
    }
    var TAe = {
            kernelName: $0,
            backendName: "webgl",
            kernelFunc: SAe
        },
        EAe = p((function e(t) {
            var n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                a = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
                i = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
            l(this, e), this.variableNames = ["x", "W"], this.outputShape = t.outShape;
            var o = t.padInfo.top,
                s = t.padInfo.left,
                u = t.strideHeight,
                c = t.strideWidth,
                h = t.dilationHeight,
                p = t.dilationWidth,
                f = t.filterHeight,
                d = t.filterWidth,
                v = 4 * Math.floor(t.inChannels / 4),
                m = t.inChannels % 4,
                g = "channelsLast" === t.dataFormat,
                y = g ? 1 : 2,
                b = g ? 2 : 3,
                x = g ? 3 : 1,
                k = "",
                w = "";
            r && (k = a ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(r, "\n        }") : i ? "float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(r, "\n        }") : "\n          float activation(float x) {\n            ".concat(r, "\n          }\n        "), w = "result = activation(result);");
            var I = n ? "result += getBiasAtOutCoords();" : "";
            n && this.variableNames.push("bias"), a && this.variableNames.push("preluActivationWeights"), i && this.variableNames.push("leakyreluAlpha"), this.userCode = "\n      ".concat(k, "\n\n      const ivec2 strides = ivec2(").concat(u, ", ").concat(c, ");\n      const ivec2 pads = ivec2(").concat(o, ", ").concat(s, ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[").concat(x, "];\n\n        ivec2 xRCCorner =\n            ivec2(coords[").concat(y, "], coords[").concat(b, "]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(f, "; wR++) {\n          int xR = xRCorner + wR * ").concat(h, ";\n\n          if (xR < 0 || xR >= ").concat(t.inHeight, ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(d, "; wC++) {\n            int xC = xCCorner + wC * ").concat(p, ";\n\n            if (xC < 0 || xC >= ").concat(t.inWidth, ") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ").concat(v, "; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (").concat(g, ") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (").concat(1 === m, ") {\n\n              if (").concat(g, ") {\n                dotProd +=\n                    getX(batch, xR, xC, ").concat(v, ") *\n                    getW(wR, wC, ").concat(v, ", d2);\n              } else {\n                dotProd +=\n                    getX(batch, ").concat(v, ", xR, xC) *\n                    getW(wR, wC, ").concat(v, ", d2);\n              }\n\n            } else if (").concat(2 === m, ") {\n              vec2 wValues = vec2(\n                getW(wR, wC, ").concat(v, ", d2),\n                getW(wR, wC, ").concat(v, " + 1, d2)\n              );\n\n              if (").concat(g, ") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ").concat(v, "),\n                  getX(batch, xR, xC, ").concat(v, " + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ").concat(v, ", xR, xC),\n                  getX(batch, ").concat(v, " + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (").concat(3 === m, ") {\n              vec3 wValues = vec3(\n                getW(wR, wC, ").concat(v, ", d2),\n                getW(wR, wC, ").concat(v, " + 1, d2),\n                getW(wR, wC, ").concat(v, " + 2, d2)\n              );\n\n              if (").concat(g, ") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ").concat(v, "),\n                  getX(batch, xR, xC, ").concat(v, " + 1),\n                  getX(batch, xR, xC, ").concat(v, " + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ").concat(v, ", xR, xC),\n                  getX(batch, ").concat(v, " + 1, xR, xC),\n                  getX(batch, ").concat(v, " + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ").concat(I, "\n        ").concat(w, "\n        setOutput(result);\n      }\n    ")
        })),
        CAe = p((function e(t) {
            l(this, e), this.variableNames = ["x", "W"], this.outputShape = t.outShape;
            var n = t.padInfo.front,
                r = t.padInfo.top,
                a = t.padInfo.left,
                i = t.strideDepth,
                o = t.strideHeight,
                s = t.strideWidth,
                u = t.dilationDepth,
                c = t.dilationHeight,
                h = t.dilationWidth,
                p = t.filterDepth,
                f = t.filterHeight,
                d = t.filterWidth,
                v = 4 * Math.floor(t.inChannels / 4),
                m = t.inChannels % 4;
            this.userCode = "\n      const ivec3 strides = ivec3(".concat(i, ", ").concat(o, ", ").concat(s, ");\n      const ivec3 pads = ivec3(").concat(n, ", ").concat(r, ", ").concat(a, ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(p, "; wF++) {\n          int xF = xFCorner + wF * ").concat(u, ";\n\n          if (xF < 0 || xF >= ").concat(t.inDepth, ") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(f, "; wR++) {\n            int xR = xRCorner + wR * ").concat(c, ";\n\n            if (xR < 0 || xR >= ").concat(t.inHeight, ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(d, "; wC++) {\n              int xC = xCCorner + wC * ").concat(h, ";\n\n              if (xC < 0 || xC >= ").concat(t.inWidth, ") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ").concat(v, "; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (").concat(1 === m, ") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ").concat(v, ") *\n                  getW(wF, wR, wC, ").concat(v, ", d2);\n              } else if (").concat(2 === m, ") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ").concat(v, "),\n                  getX(batch, xF, xR, xC, ").concat(v, " + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ").concat(v, ", d2),\n                  getW(wF, wR, wC, ").concat(v, " + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (").concat(3 === m, ") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ").concat(v, "),\n                  getX(batch, xF, xR, xC, ").concat(v, " + 1),\n                  getX(batch, xF, xR, xC, ").concat(v, " + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ").concat(v, ", d2),\n                  getW(wF, wR, wC, ").concat(v, " + 1, d2),\n                  getW(wF, wR, wC, ").concat(v, " + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")
        })),
        AAe = p((function e(t) {
            var n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                a = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
                i = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
            l(this, e), this.variableNames = ["x", "W"], this.packedInputs = !0, this.packedOutput = !0, this.customUniforms = [{
                name: "pads",
                type: "ivec2"
            }, {
                name: "strides",
                type: "ivec2"
            }, {
                name: "dilations",
                type: "ivec2"
            }, {
                name: "inDims",
                type: "ivec2"
            }], this.outputShape = t.outShape, this.enableShapeUniforms = xSe(this.outputShape.length);
            for (var o = t.padInfo.left, s = t.strideWidth, u = t.dilationWidth, c = t.filterHeight, h = t.filterWidth, p = h, f = "\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;", d = 0; d < h; d++) f += "\n           vec4 xTexelC".concat(2 * d, ";\n           int xTexelC").concat(2 * d, "Ready;\n           vec4 xTexelC").concat(2 * d + 1, ";\n           int xTexelC").concat(2 * d + 1, "Ready;\n           vec4 xC").concat(d, ";");
            f += "\n     for (int r = 0; r < ".concat(c, "; r++) {\n      for (int d1 = 0; d1 < ").concat(t.inChannels, "; d1 += 2) {\n       ");
            for (var v = 0; v < h; v++) f += "\n           xTexelC".concat(2 * v, " = vec4(0.0);\n           xTexelC").concat(2 * v, "Ready = 0;\n           xTexelC").concat(2 * v + 1, " = vec4(0.0);\n           xTexelC").concat(2 * v + 1, "Ready = 0;\n           xC").concat(v, " = vec4(0.0);");
            f += "\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";
            for (var m = 0; m < (p + 1) / 2; m++) {
                var g = 2 * m;
                if (f += "\n           xC = xCCorner + ".concat(g * u, ";\n           "), 1 === s) {
                    if (g < h && (o % 2 == 1 ? (f += "\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(g, "Ready == 0) {\n                   xTexelC").concat(g, " = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(g, ".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(g, "Ready = 1;\n                 }\n               "), f += 1 === u && g > 0 ? "\n                 xC".concat(g, " = vec4(xTexelC").concat(g - 2, ".zw, xTexelC").concat(g, ".xy);\n                 ") : "\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC".concat(g, " = vec4(previous.zw, xTexelC").concat(g, ".xy);\n                   } else {\n                     xC").concat(g, " = vec4(0.0, 0.0, xTexelC").concat(g, ".xy);\n                   }\n                   ")) : f += "\n                 if (xC >= 0 && xC < inDims[1] && xTexelC".concat(g, "Ready == 0) {\n                   xTexelC").concat(g, " = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(g, ".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(g, "Ready = 1;\n                 }\n\n                 xC").concat(g, " = xTexelC").concat(g, ";\n                 "), g + 1 < h)) {
                        var y = o % 2 == 0 ? R$(u) : u;
                        u % 2 == 0 && o % 2 == 1 || u % 2 != 0 && o % 2 != 1 ? (f += "\n                   xCOffset = xC + imod(pads[1], 2) + ".concat(y, ";\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(g + 1, "Ready == 0) {\n                     xTexelC").concat(g + 1, " = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC").concat(g + 1, ".zw = vec2(0.0);\n                     }\n                     xTexelC").concat(g + 1, "Ready = 1;\n                   }\n                   "), f += u > 1 ? "\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC".concat(g + 1, " = vec4(previous.zw, xTexelC").concat(g + 1, ".xy);\n                     } else {\n                      xC").concat(g + 1, " = vec4(0.0, 0.0, xTexelC").concat(g + 1, ".xy);\n                     }\n                     ") : "\n                     xC".concat(g + 1, " = vec4(xTexelC").concat(g, ".zw, xTexelC").concat(g + 1, ".xy);\n                     ")) : f += 1 === y ? "\n                     xC".concat(g + 1, " = xTexelC").concat(g, ";\n                     ") : "\n                     xCOffset = xC + ".concat(y, ";\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(g + 1, "Ready == 0) {\n                       xTexelC").concat(g + 1, " = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC").concat(g + 1, ".zw = vec2(0.0);\n                       }\n                       xTexelC").concat(g + 1, "Ready = 1;\n                     }\n\n                     xC").concat(g + 1, " = xTexelC").concat(g + 1, ";\n                     ")
                    }
                } else g < h && (o % 2 == 1 ? (f += "\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(g, "Ready == 0) {\n                   xTexelC").concat(g, " = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(g, ".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(g, "Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(g + 1, "Ready == 0) {\n                   xTexelC").concat(g + 1, " = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC").concat(g + 1, ".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(g + 1, "Ready = 1;\n                 }\n\n                 xC").concat(g, " = vec4(xTexelC").concat(g, ".zw, xTexelC").concat(g + 1, ".zw);\n               "), g + 1 < h && (f += "\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC".concat(g + 1, " = vec4(xTexelC").concat(g + 1, ".xy, final.xy);\n                 "))) : (f += "\n                 if(xC >= 0 && xC < inDims[1] && xTexelC".concat(g, "Ready == 0) {\n                   xTexelC").concat(g, " = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(g, ".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(g, "Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(g + 1, "Ready == 0) {\n                   xTexelC").concat(g + 1, " = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(g + 1, ".zw = vec2(0.);\n                   }\n                   xTexelC").concat(g + 1, "Ready = 1;\n                 }\n\n                 xC").concat(g, " = vec4(\n                   xTexelC").concat(g, ".xy, xTexelC").concat(g + 1, ".xy);\n               "), g + 1 < h && (f += "\n                   xC".concat(g + 1, " = vec4(xTexelC").concat(g, ".zw, xTexelC").concat(g + 1, ".zw);\n                 "))));
                g < h && (f += "\n             wTexel = getW(r, ".concat(g, ", d1, d2);\n             dotProd += xC").concat(g, ".xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ").concat(t.inChannels, ") {\n               dotProd += xC").concat(g, ".yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           "), g + 1 < h && (f += "\n               wTexel = getW(r, ".concat(g + 1, ", d1, d2);\n               dotProd += xC").concat(g + 1, ".xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ").concat(t.inChannels, ") {\n                 dotProd += xC").concat(g + 1, ".yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             ")))
            }
            f += "\n     }\n   ", f += "\n     }\n   ", f += "\n     }\n   ";
            var b = "",
                x = "";
            r && (b = a ? "vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ".concat(r, "\n         }") : i ? "vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ".concat(r, "\n         }") : "vec4 activation(vec4 x) {\n           ".concat(r, "\n         }"), x = "result = activation(result);");
            var k = n ? "result += getBiasAtOutCoords();" : "";
            n && this.variableNames.push("bias"), a && this.variableNames.push("preluActivationWeights"), i && this.variableNames.push("leakyreluAlpha"), this.userCode = "\n       ".concat(b, "\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ").concat(f, "\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ").concat(k, "\n         ").concat(x, "\n         setOutput(result);\n       }\n     ")
        })),
        RAe = p((function e(t, n) {
            l(this, e), this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.customUniforms = [{
                name: "inputShape",
                type: "ivec4"
            }, {
                name: "pad",
                type: "ivec2"
            }, {
                name: "stride",
                type: "ivec2"
            }, {
                name: "dilation",
                type: "ivec2"
            }, {
                name: "inChannels",
                type: "int"
            }, {
                name: "itemsPerBlockRow",
                type: "int"
            }, {
                name: "outWidth",
                type: "int"
            }], this.outputShape = t, this.enableShapeUniforms = xSe(this.outputShape.length);
            for (var r = n.dataFormat, a = WNe(), i = "channelsLast" === r, o = i ? 1 : 2, s = i ? 2 : 3, u = this.enableShapeUniforms ? "if(blockIndex < outShape[2] && pos < outShape[1]) {" : "if(blockIndex < ".concat(t[2], " && pos < ").concat(t[1], ") {"), c = "", h = 0; h <= 1; h++)
                for (var p = 0; p <= 1; p++) c += "\n          blockIndex = rc.z + ".concat(p, ";\n          pos = rc.y + ").concat(h, ";\n\n          ").concat(u, "\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[").concat(o, "] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[").concat(s, "] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (").concat(i, ") {\n                  innerDims = vec2(d1, ch);\n                  result[").concat(2 * h + p, "] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[").concat(2 * h + p, "] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ");
            this.userCode = "\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ".concat(c, "\n\n        ").concat(a.output, " = result;\n      }\n    ")
        }));

    function _Ae(e, t) {
        var n = e.length;
        return n >= 3 ? [].concat(T(e.slice(0, -3)), t ? [e[n - 3] * e[n - 2], e[n - 1]] : [e[n - 3], e[n - 2] * e[n - 1]]) : !t && 1 === n && e[0] > 1 ? [e[0], 1] : null
    }

    function OAe(e) {
        var t, n = e.x,
            r = e.filter,
            a = e.convInfo,
            i = e.backend,
            o = e.bias,
            s = void 0 === o ? null : o,
            u = e.preluActivationWeights,
            c = void 0 === u ? null : u,
            l = e.leakyreluAlpha,
            h = void 0 === l ? 0 : l,
            p = e.activation,
            f = void 0 === p ? null : p,
            d = n.shape,
            v = i.texData.get(n.dataId),
            m = a.inChannels,
            g = d[0] * d[1] * d[2],
            y = a.outChannels,
            b = "channelsLast" === a.dataFormat,
            x = [];
        if (null != c) {
            var k = _Ae(c.shape, b);
            null != k && (c = KEe({
                inputs: {
                    x: c
                },
                backend: i,
                attrs: {
                    shape: k
                }
            }), x.push(c))
        }
        if (null != s) {
            var w = _Ae(s.shape, b);
            null != w && (s = KEe({
                inputs: {
                    x: s
                },
                backend: i,
                attrs: {
                    shape: w
                }
            }), x.push(s))
        }
        if (!((1 === g || 1 === y) && m > 1e3) && v.isPacked && b && null != v.texture && d[2] % 2 != 0 && P$(v.shape.slice(-3), d.slice(-3))) {
            var I = d[0] * d[1] * (d[2] + 1),
                N = {
                    dataId: n.dataId,
                    shape: [1, I, a.inChannels],
                    dtype: n.dtype
                },
                S = v.shape;
            v.shape = v.shape.slice(), v.shape[v.shape.length - 2]++, F$(ENe(v.shape, N.shape), (function() {
                return "packed reshape ".concat(v.shape, " to ").concat(N.shape, " isn't free")
            }));
            var T = KEe({
                inputs: {
                    x: r
                },
                backend: i,
                attrs: {
                    shape: [1, a.inChannels, a.outChannels]
                }
            });
            x.push(T);
            var E = iCe({
                    a: N,
                    b: T,
                    backend: i,
                    transposeA: !1,
                    transposeB: false,
                    bias: s,
                    activation: f,
                    preluActivationWeights: c,
                    leakyreluAlpha: h
                }),
                C = i.texData.get(E.dataId);
            F$(C.isPacked, (function() {
                return "batchMatMul result is expected to be packed"
            })), v.shape = S, C.shape = a.outShape, (t = EEe({
                inputs: {
                    x: E
                },
                backend: i
            })).shape = a.outShape, x.push(E)
        } else {
            var A = a.outHeight * a.outWidth,
                R = KEe({
                    inputs: {
                        x: n
                    },
                    backend: i,
                    attrs: {
                        shape: b ? [a.batchSize, A, a.inChannels] : [a.batchSize, a.inChannels, A]
                    }
                }),
                _ = KEe({
                    inputs: {
                        x: r
                    },
                    backend: i,
                    attrs: {
                        shape: [1, a.inChannels, a.outChannels]
                    }
                }),
                O = iCe({
                    a: b ? R : _,
                    b: b ? _ : R,
                    transposeA: !b,
                    transposeB: false,
                    backend: i,
                    bias: s,
                    activation: f,
                    preluActivationWeights: c,
                    leakyreluAlpha: h
                });
            t = KEe({
                inputs: {
                    x: O
                },
                backend: i,
                attrs: {
                    shape: a.outShape
                }
            }), x.push(R), x.push(_), x.push(O)
        }
        for (var F = 0, D = x; F < D.length; F++) {
            var M = D[F];
            i.disposeIntermediateTensorInfo(M)
        }
        return t
    }

    function FAe(e) {
        var t = e.x,
            n = e.filter,
            r = e.convInfo,
            a = e.backend,
            i = e.bias,
            o = void 0 === i ? null : i,
            s = e.preluActivationWeights,
            u = void 0 === s ? null : s,
            c = e.leakyreluAlpha,
            l = void 0 === c ? 0 : c,
            h = e.activation,
            p = void 0 === h ? null : h,
            f = r.filterWidth,
            d = r.filterHeight,
            v = r.inChannels,
            m = r.outWidth,
            g = r.outHeight,
            y = "channelsLast" === r.dataFormat,
            b = f * d * v,
            x = g * m,
            k = [r.batchSize, b, x],
            w = [];
        if (null != u) {
            var I = _Ae(u.shape, y);
            null != I && (u = KEe({
                inputs: {
                    x: u
                },
                backend: a,
                attrs: {
                    shape: I
                }
            }), w.push(u))
        }
        if (null != o) {
            var N = _Ae(o.shape, y);
            null != N && (o = KEe({
                inputs: {
                    x: o
                },
                backend: a,
                attrs: {
                    shape: N
                }
            }), w.push(o))
        }
        var S = KEe({
            inputs: {
                x: n
            },
            backend: a,
            attrs: {
                shape: [1, b, L$(n.shape) / b]
            }
        });
        w.push(S);
        var T = new RAe(k, r),
            E = [t.shape, [r.padInfo.top, r.padInfo.left],
                [r.strideHeight, r.strideWidth],
                [r.dilationHeight, r.dilationWidth],
                [r.inChannels],
                [r.filterWidth * r.inChannels],
                [r.outWidth]
            ],
            C = a.runWebGLProgram(T, [t], "float32", E),
            A = KEe({
                inputs: {
                    x: C
                },
                backend: a,
                attrs: {
                    shape: k
                }
            });
        w.push(C), w.push(A);
        var R = null != o,
            _ = null != u,
            O = "leakyrelu" === p,
            F = p ? BEe(p, !0) : null,
            D = new WEe(y ? A.shape : S.shape, y ? S.shape : A.shape, y ? [r.batchSize, x, r.outChannels] : [r.batchSize, r.outChannels, x], !0, !1, R, F, _, O),
            M = y ? [A, S] : [S, A];
        if (o && M.push(o), _ && M.push(u), O) {
            var L = a.makeTensorInfo([], "float32", M4(l, "float32"));
            M.push(L), w.push(L)
        }
        var z = a.runWebGLProgram(D, M, "float32"),
            P = KEe({
                inputs: {
                    x: z
                },
                backend: a,
                attrs: {
                    shape: r.outShape
                }
            });
        w.push(z);
        for (var B = 0, W = w; B < W.length; B++) {
            var U = W[B];
            a.disposeIntermediateTensorInfo(U)
        }
        return P
    }
    var DAe = {
            kernelName: e1,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t, n = e.inputs,
                    r = e.backend,
                    a = e.attrs,
                    i = n.x,
                    o = n.filter,
                    s = a.strides,
                    u = a.pad,
                    c = a.dataFormat,
                    l = a.dilations,
                    h = a.dimRoundingMode,
                    p = q8(c),
                    f = D8(i.shape, o.shape, s, l, u, h, !1, p);
                if (1 !== f.filterHeight || 1 !== f.filterWidth || 1 !== f.dilationHeight || 1 !== f.dilationWidth || 1 !== f.strideHeight || 1 !== f.strideWidth || "SAME" !== f.padInfo.type && "VALID" !== f.padInfo.type)
                    if (f.strideWidth <= 2 && "channelsLast" === p && k0().getBool("WEBGL_EXP_CONV")) {
                        var d = new AAe(f),
                            v = [
                                [f.padInfo.top, f.padInfo.left],
                                [f.strideHeight, f.strideWidth],
                                [f.dilationHeight, f.dilationWidth],
                                [f.inHeight, f.inWidth]
                            ];
                        t = r.runWebGLProgram(d, [i, o], "float32", v)
                    } else if (k0().getBool("WEBGL_CONV_IM2COL")) t = FAe({
                    x: i,
                    filter: o,
                    convInfo: f,
                    backend: r
                });
                else {
                    var m = new EAe(f);
                    t = r.runWebGLProgram(m, [i, o], "float32")
                } else t = OAe({
                    x: i,
                    filter: o,
                    convInfo: f,
                    backend: r
                });
                var g = KEe({
                    inputs: {
                        x: t
                    },
                    backend: r,
                    attrs: {
                        shape: f.outShape
                    }
                });
                return r.disposeIntermediateTensorInfo(t), g
            }
        },
        MAe = p((function e(t) {
            l(this, e), this.variableNames = ["x", "dy"], this.outputShape = t.filterShape;
            var n = t.strideHeight,
                r = t.strideWidth,
                a = t.padInfo.top,
                i = t.padInfo.left,
                o = "channelsLast" === t.dataFormat;
            this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(t.batchSize, "; b++) {\n          for (int yR = 0; yR < ").concat(t.outHeight, "; yR++) {\n            int xR = wR + yR * ").concat(n, " - ").concat(a, ";\n\n            if (xR < 0 || xR >= ").concat(t.inHeight, ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(t.outWidth, "; yC++) {\n              int xC = wC + yC * ").concat(r, " - ").concat(i, ";\n\n              if (xC < 0 || xC >= ").concat(t.inWidth, ") {\n                continue;\n              }\n\n              ").concat(o ? "float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);" : "float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);", "\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")
        })),
        LAe = p((function e(t) {
            l(this, e), this.variableNames = ["dy", "W"], this.outputShape = t.inShape;
            var n = t.filterHeight,
                r = t.filterWidth,
                a = t.strideHeight,
                i = t.strideWidth,
                o = "channelsLast" === t.dataFormat,
                s = n - 1 - t.padInfo.top,
                u = r - 1 - t.padInfo.left,
                c = o ? 1 : 2,
                h = o ? 2 : 3,
                p = o ? 3 : 1;
            this.userCode = "\n      const ivec2 pads = ivec2(".concat(s, ", ").concat(u, ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[").concat(p, "];\n\n        ivec2 dyCorner = ivec2(coords[").concat(c, "], coords[").concat(h, "]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(n, "; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(a, ".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(t.outHeight, ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(n, " - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(r, "; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(i, ".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(t.outWidth, ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(r, " - 1 - wC;\n\n            for (int d2 = 0; d2 < ").concat(t.outChannels, "; d2++) {\n\n              if (").concat(o, ") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")
        })),
        zAe = p((function e(t) {
            l(this, e), this.variableNames = ["x", "dy"], this.outputShape = t.filterShape;
            var n = t.strideDepth,
                r = t.strideHeight,
                a = t.strideWidth,
                i = t.padInfo.front,
                o = t.padInfo.top,
                s = t.padInfo.left;
            this.userCode = "\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(t.batchSize, "; b++) {\n          for (int yF = 0; yF < ").concat(t.outDepth, "; yF++) {\n            int xF = wF + yF * ").concat(n, " - ").concat(i, ";\n\n            if (xF < 0 || xF >= ").concat(t.inDepth, ") {\n              continue;\n            }\n\n            for (int yR = 0; yR < ").concat(t.outHeight, "; yR++) {\n              int xR = wR + yR * ").concat(r, " - ").concat(o, ";\n\n              if (xR < 0 || xR >= ").concat(t.inHeight, ") {\n                continue;\n              }\n\n              for (int yC = 0; yC < ").concat(t.outWidth, "; yC++) {\n                int xC = wC + yC * ").concat(a, " - ").concat(s, ";\n\n                if (xC < 0 || xC >= ").concat(t.inWidth, ") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")
        })),
        PAe = p((function e(t) {
            l(this, e), this.variableNames = ["dy", "W"], this.outputShape = t.inShape;
            var n = t.filterDepth,
                r = t.filterHeight,
                a = t.filterWidth,
                i = t.strideDepth,
                o = t.strideHeight,
                s = t.strideWidth,
                u = n - 1 - t.padInfo.front,
                c = r - 1 - t.padInfo.top,
                h = a - 1 - t.padInfo.left;
            this.userCode = "\n      const ivec3 pads = ivec3(".concat(u, ", ").concat(c, ", ").concat(h, ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(n, "; wF++) {\n          float dyF = float(dyFCorner + wF) / ").concat(i, ".0;\n\n          if (dyF < 0.0 || dyF >= ").concat(t.outDepth, ".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ").concat(n, " - 1 - wF;\n\n          for (int wR = 0; wR < ").concat(r, "; wR++) {\n            float dyR = float(dyRCorner + wR) / ").concat(o, ".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(t.outHeight, ".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ").concat(r, " - 1 - wR;\n\n            for (int wC = 0; wC < ").concat(a, "; wC++) {\n              float dyC = float(dyCCorner + wC) / ").concat(s, ".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(t.outWidth, ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ").concat(a, " - 1 - wC;\n\n              for (int d2 = 0; d2 < ").concat(t.outChannels, "; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")
        }));
    var BAe = {
            kernelName: t1,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.dy,
                    o = r.strides,
                    s = r.pad,
                    u = r.dataFormat,
                    c = r.dimRoundingMode,
                    l = r.filterShape,
                    h = q8(u),
                    p = D8(a.shape, l, o, 1, s, c, !1, h),
                    f = new MAe(p);
                return n.runWebGLProgram(f, [a, i], "float32")
            }
        },
        WAe = p((function e(t) {
            l(this, e), this.variableNames = ["dy", "W"], this.packedInputs = !0, this.packedOutput = !0, this.customUniforms = [{
                name: "strides",
                type: "vec2"
            }], this.outputShape = t.inShape, this.enableShapeUniforms = xSe(this.outputShape.length);
            var n = t.filterHeight,
                r = t.filterWidth,
                a = n - 1 - t.padInfo.top,
                i = r - 1 - t.padInfo.left;
            this.userCode = "\n      const ivec2 pads = ivec2(".concat(a, ", ").concat(i, ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ").concat(n, "; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ").concat(t.outHeight, ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ").concat(n, " - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(r, "; wC++) {\n            int wCPerm = ").concat(r, " - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ").concat(t.outWidth, ".0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ").concat(t.outWidth, ".0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(t.outChannels, "; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ").concat(t.outChannels, "; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(t.outChannels, "; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    ")
        }));
    var UAe = {
        kernelName: n1,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.dy,
                i = t.filter,
                o = r.inputShape,
                s = r.strides,
                u = r.pad,
                c = r.dataFormat,
                l = r.dimRoundingMode,
                h = q8(c),
                p = D8(o, i.shape, s, 1, u, l, !1, h);
            if (k0().getBool("WEBGL_PACK_CONV2DTRANSPOSE") && "channelsLast" === h) {
                var f = [
                        [p.strideHeight, p.strideWidth]
                    ],
                    d = new WAe(p);
                return n.runWebGLProgram(d, [a, i], "float32", f)
            }
            var v = new LAe(p);
            return n.runWebGLProgram(v, [a, i], "float32")
        }
    };
    var VAe = {
        kernelName: r1,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = t.filter,
                o = r.strides,
                s = r.pad,
                u = r.dilations,
                c = M8(a.shape, i.shape, o, u, s),
                l = new CAe(c);
            return n.runWebGLProgram(l, [a, i], "float32")
        }
    };
    var GAe = {
        kernelName: a1,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = t.dy,
                o = r.strides,
                s = r.pad,
                u = r.filterShape,
                c = M8(a.shape, u, o, 1, s),
                l = new zAe(c);
            return n.runWebGLProgram(l, [a, i], "float32")
        }
    };
    var jAe, HAe = {
            kernelName: i1,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.dy,
                    i = t.filter,
                    o = r.pad,
                    s = r.strides,
                    u = M8(r.inputShape, i.shape, s, 1, o),
                    c = new PAe(u);
                return n.runWebGLProgram(c, [a, i], "float32")
            }
        },
        qAe = zEe({
            opSnippet: "if (isnan(x)) return x;\n  return cos(x);\n",
            packedOpSnippet: "\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(SEe, "\n  return result;\n")
        }),
        KAe = {
            kernelName: o1,
            backendName: "webgl",
            kernelFunc: qAe
        },
        XAe = zEe({
            opSnippet: "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"
        }),
        YAe = {
            kernelName: s1,
            backendName: "webgl",
            kernelFunc: XAe
        },
        JAe = p((function e(t, n, r, a, i) {
            l(this, e), this.variableNames = ["Image", "Boxes", "BoxInd"], this.outputShape = [];
            var o = S(t, 4),
                s = o[0],
                u = o[1],
                c = o[2],
                h = o[3],
                p = S(n, 1)[0],
                f = S(r, 2),
                d = f[0],
                v = f[1];
            this.outputShape = [p, d, v, h];
            var m = "bilinear" === a ? 1 : 0,
                g = "".concat(u - 1, ".0"),
                y = "".concat(c - 1, ".0"),
                b = S(d > 1 ? ["".concat((u - 1) / (d - 1)), "(y2-y1) * height_ratio", "y1*".concat(g, " + float(y)*(height_scale)")] : ["0.0", "0.0", "0.5 * (y1+y2) * ".concat(g)], 3),
                x = b[0],
                k = b[1],
                w = b[2],
                I = S(v > 1 ? ["".concat((c - 1) / (v - 1)), "(x2-x1) * width_ratio", "x1*".concat(y, " + float(x)*(width_scale)")] : ["0.0", "0.0", "0.5 * (x1+x2) * ".concat(y)], 3),
                N = I[0],
                T = I[1],
                E = I[2];
            this.userCode = "\n      const float height_ratio = float(".concat(x, ");\n      const float width_ratio = float(").concat(N, ");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ").concat(s, ") {\n          return;\n        }\n\n        float height_scale = ").concat(k, ";\n        float width_scale = ").concat(T, ";\n\n        float in_y = ").concat(w, ";\n        if( in_y < 0.0 || in_y > ").concat(g, " ) {\n          setOutput(float(").concat(i, "));\n          return;\n        }\n        float in_x = ").concat(E, ";\n        if( in_x < 0.0 || in_x > ").concat(y, " ) {\n          setOutput(float(").concat(i, "));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(").concat(m, " == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ")
        })),
        ZAe = {
            kernelName: l1,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.image,
                    i = t.boxes,
                    o = t.boxInd,
                    s = r.cropSize,
                    u = r.method,
                    c = r.extrapolationValue,
                    l = new JAe(a.shape, i.shape, s, u, c);
                return n.runWebGLProgram(l, [a, i, o], "float32")
            }
        };
    ! function(e) {
        e.Prod = "*", e.Sum = "+"
    }(jAe || (jAe = {}));
    var QAe = p((function e(t, n, r, a) {
        l(this, e), this.op = t, this.outputShape = n, this.variableNames = ["x"], this.customUniforms = [{
            name: "index",
            type: "float"
        }];
        var i = this.outputShape.length,
            o = this.op === jAe.Prod ? "1.0" : "0.0",
            s = r ? o : "getX(".concat($Ae(i, "coords", this.op), ")"),
            u = this.outputShape[this.outputShape.length - 1],
            c = "",
            h = "";
        r ? (c = a ? "end != ".concat(u - 1) : "end != 0", h = a ? "end + 1" : "end - 1") : (c = a ? "end + pow2 < ".concat(u) : "end >= pow2", h = a ? "end + pow2" : "end - pow2"), this.userCode = "\n      void main() {\n        ".concat(hSe(i), " coords = getOutputCoords();\n        int end = ").concat(eRe(i, "coords", this.op), ";\n        float val = ").concat(s, ";\n        int pow2 = int(pow(2.0, index));\n        if (").concat(c, ") {\n          int idx = ").concat(h, ";\n          ").concat(eRe(i, "coords", this.op), " = idx;\n          val ").concat(this.op, "= getX(").concat($Ae(i, "coords", this.op), ");\n        }\n        setOutput(val);\n      }\n    ")
    }));

    function $Ae(e, t, n) {
        if (1 === e) return "".concat(t);
        if (2 === e) return "".concat(t, ".x, ").concat(t, ".y");
        if (3 === e) return "".concat(t, ".x, ").concat(t, ".y, ").concat(t, ".z");
        if (4 === e) return "".concat(t, ".x, ").concat(t, ".y, ").concat(t, ".z, ").concat(t, ".w");
        throw new Error("Cumulative ".concat(n, " for rank ").concat(e, " is not yet supported"))
    }

    function eRe(e, t, n) {
        if (1 === e) return "".concat(t);
        if (2 === e) return "".concat(t, ".y");
        if (3 === e) return "".concat(t, ".z");
        if (4 === e) return "".concat(t, ".w");
        throw new Error("Cumulative ".concat(n, " for rank ").concat(e, " is not yet supported"))
    }

    function tRe(e, t, n, r, a, i) {
        var o = t.shape.length,
            s = $7([r], o),
            u = t;
        null != s && (u = rCe({
            inputs: {
                x: t
            },
            backend: n,
            attrs: {
                perm: s
            }
        }));
        var c = t9(1, o)[0];
        if (c !== o - 1) throw new Error("WebGL cumprod shader expects an inner-most axis=".concat(t.shape.length - 1, " ") + "but got axis=".concat(r));
        for (var l = u.shape[c], h = EEe({
                inputs: {
                    x: u
                },
                backend: n
            }), p = 0; p <= Math.ceil(Math.log2(l)) - 1; p++) {
            var f = new QAe(e, u.shape, !1, i),
                d = [
                    [p]
                ],
                v = h;
            h = n.runWebGLProgram(f, [h], h.dtype, d), n.disposeIntermediateTensorInfo(v)
        }
        if (a) {
            var m = new QAe(e, u.shape, a, i),
                g = h;
            h = n.runWebGLProgram(m, [h], h.dtype), n.disposeIntermediateTensorInfo(g)
        }
        if (null != s) {
            var y = rCe({
                inputs: {
                    x: h
                },
                backend: n,
                attrs: {
                    perm: e9(s)
                }
            });
            return n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(u), y
        }
        return h
    }
    var nRe = {
        kernelName: u1,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = r.axis,
                o = r.exclusive,
                s = r.reverse;
            return tRe(jAe.Prod, a, n, i, o, s)
        }
    };
    var rRe = {
        kernelName: c1,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = r.axis,
                o = r.exclusive,
                s = r.reverse;
            return tRe(jAe.Sum, a, n, i, o, s)
        }
    };
    var aRe = {
            kernelName: h1,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.weights,
                    o = r.size,
                    s = r.binaryOutput;
                if (1 === a.shape.length) {
                    var u = n.readSync(a.dataId),
                        c = n.readSync(i.dataId),
                        l = $Se(u, c, i.dtype, i.shape, o);
                    return n.makeTensorInfo([o], i.dtype, l)
                }
                if (2 === a.shape.length) {
                    var h = n.bufferSync(a),
                        p = n.bufferSync(i),
                        f = eTe(h, p, o, s);
                    return n.makeTensorInfo(f.shape, i.dtype, f.values)
                }
                throw new Error("Error in denseBincount: input must be at most rank 2, but got rank" + "".concat(a.shape.length, "."))
            }
        },
        iRe = function() {
            function e(t, n, r) {
                l(this, e), this.variableNames = ["x"], this.outputShape = [], this.outputShape = t, this.blockSize = n, this.dataFormat = r, this.userCode = "\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ".concat(this.getHeightCoordString(), ";\n      int w = ").concat(this.getWidthCoordString(), ";\n      int d = ").concat(this.getDepthCoordString(), ";\n\n      int in_h = h / ").concat(n, ";\n      int offset_h = imod(h, ").concat(n, ");\n      int in_w = w / ").concat(n, ";\n      int offset_w = imod(w, ").concat(n, ");\n      int offset_d = (offset_h * ").concat(n, " + offset_w) *\n        ").concat(this.getOutputDepthSize(), ";\n      int in_d = d + offset_d;\n\n      float result = ").concat(this.getInputSamplingString(), ";\n      setOutput(result);\n    }\n  ")
            }
            return p(e, [{
                key: "getHeightCoordString",
                value: function() {
                    return "NHWC" === this.dataFormat ? "coords[1]" : "coords[2]"
                }
            }, {
                key: "getWidthCoordString",
                value: function() {
                    return "NHWC" === this.dataFormat ? "coords[2]" : "coords[3]"
                }
            }, {
                key: "getDepthCoordString",
                value: function() {
                    return "NHWC" === this.dataFormat ? "coords[3]" : "coords[1]"
                }
            }, {
                key: "getOutputDepthSize",
                value: function() {
                    return "NHWC" === this.dataFormat ? this.outputShape[3] : this.outputShape[1]
                }
            }, {
                key: "getInputSamplingString",
                value: function() {
                    return "NHWC" === this.dataFormat ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)"
                }
            }]), e
        }();
    var oRe = {
            kernelName: p1,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.blockSize,
                    o = r.dataFormat,
                    s = a.shape[0],
                    u = ("NHWC" === o ? a.shape[1] : a.shape[2]) * i,
                    c = ("NHWC" === o ? a.shape[2] : a.shape[3]) * i,
                    l = ("NHWC" === o ? a.shape[3] : a.shape[1]) / (i * i),
                    h = new iRe("NHWC" === o ? [s, u, c, l] : [s, l, u, c], i, o);
                return n.runWebGLProgram(h, [a], a.dtype)
            }
        },
        sRe = p((function e(t) {
            var n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                a = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
                i = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
            l(this, e), this.variableNames = ["x", "W"], this.customUniforms = [{
                name: "pads",
                type: "ivec2"
            }, {
                name: "strides",
                type: "ivec2"
            }, {
                name: "dilations",
                type: "ivec2"
            }, {
                name: "inDims",
                type: "ivec2"
            }], this.outputShape = t.outShape, this.enableShapeUniforms = xSe(this.outputShape.length);
            var o = t.filterHeight,
                s = t.filterWidth,
                u = t.outChannels / t.inChannels,
                c = "",
                h = "";
            r && (c = a ? "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(r, "\n        }") : i ? "float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(r, "\n        }") : "\n          float activation(float x) {\n            ".concat(r, "\n          }\n        "), h = "result = activation(result);");
            var p = n ? "result += getBiasAtOutCoords();" : "";
            n && this.variableNames.push("bias"), a && this.variableNames.push("preluActivationWeights"), i && this.variableNames.push("leakyreluAlpha"), this.userCode = "\n      ".concat(c, "\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(u, ";\n        int q = d2 - d1 * ").concat(u, ";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ").concat(o, "; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(s, "; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ").concat(p, "\n        ").concat(h, "\n        setOutput(result);\n      }\n    ")
        })),
        uRe = p((function e(t) {
            var n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                a = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
                i = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
            l(this, e), this.variableNames = ["x", "W"], this.packedInputs = !0, this.packedOutput = !0, this.customUniforms = [{
                name: "pads",
                type: "ivec2"
            }, {
                name: "strides",
                type: "ivec2"
            }, {
                name: "dilations",
                type: "ivec2"
            }, {
                name: "inDims",
                type: "ivec2"
            }], this.outputShape = t.outShape, this.enableShapeUniforms = xSe(this.outputShape.length);
            for (var o = t.outChannels / t.inChannels, s = t.padInfo.left, u = t.strideWidth, c = t.dilationWidth, h = t.filterHeight, p = t.filterWidth, f = p, d = "\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;", v = 0; v < p; v++) d += "\n          vec4 xTexelC".concat(2 * v, ";\n          int xTexelC").concat(2 * v, "Ready;\n          vec4 xTexelC").concat(2 * v + 1, ";\n          int xTexelC").concat(2 * v + 1, "Ready;\n          vec4 xC").concat(v, ";");
            d += "\n    for (int r = 0; r < ".concat(h, "; r++) {\n      ");
            for (var m = 0; m < p; m++) d += "\n          xTexelC".concat(2 * m, " = vec4(0.0);\n          xTexelC").concat(2 * m, "Ready = 0;\n          xTexelC").concat(2 * m + 1, " = vec4(0.0);\n          xTexelC").concat(2 * m + 1, "Ready = 0;\n          xC").concat(m, " = vec4(0.0);");
            d += "\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";
            for (var g = 0; g < (f + 1) / 2; g++) {
                var y = 2 * g;
                if (d += "\n          xC = xCCorner + ".concat(y * c, ";\n          "), 1 === u) {
                    if (y < p && (s % 2 == 1 ? (d += "\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(y, "Ready == 0) {\n                  xTexelC").concat(y, " = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(y, ".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(y, "Ready = 1;\n                }\n              "), d += 1 === c && y > 0 ? "\n                xC".concat(y, " = vec4(xTexelC").concat(y - 2, ".zw, xTexelC").concat(y, ".xy);\n                ") : "\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC".concat(y, " = vec4(previous.zw, xTexelC").concat(y, ".xy);\n                  } else {\n                    xC").concat(y, " = vec4(0.0, 0.0, xTexelC").concat(y, ".xy);\n                  }\n                  ")) : d += "\n                if (xC >= 0 && xC < inDims[1] && xTexelC".concat(y, "Ready == 0) {\n                  xTexelC").concat(y, " = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(y, ".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(y, "Ready = 1;\n                }\n\n                xC").concat(y, " = xTexelC").concat(y, ";\n                "), y + 1 < p)) {
                        var b = s % 2 == 0 ? R$(c) : c;
                        c % 2 == 0 && s % 2 == 1 || c % 2 != 0 && s % 2 != 1 ? (d += "\n                  xCOffset = xC + imod(pads[1], 2) + ".concat(b, ";\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(y + 1, "Ready == 0) {\n                    xTexelC").concat(y + 1, " = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC").concat(y + 1, ".zw = vec2(0.0);\n                    }\n                    xTexelC").concat(y + 1, "Ready = 1;\n                  }\n                  "), d += c > 1 ? "\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC".concat(y + 1, " = vec4(previous.zw, xTexelC").concat(y + 1, ".xy);\n                    } else {\n                     xC").concat(y + 1, " = vec4(0.0, 0.0, xTexelC").concat(y + 1, ".xy);\n                    }\n                    ") : "\n                    xC".concat(y + 1, " = vec4(xTexelC").concat(y, ".zw, xTexelC").concat(y + 1, ".xy);\n                    ")) : d += 1 === b ? "\n                    xC".concat(y + 1, " = xTexelC").concat(y, ";\n                    ") : "\n                    xCOffset = xC + ".concat(b, ";\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(y + 1, "Ready == 0) {\n                      xTexelC").concat(y + 1, " = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC").concat(y + 1, ".zw = vec2(0.0);\n                      }\n                      xTexelC").concat(y + 1, "Ready = 1;\n                    }\n\n                    xC").concat(y + 1, " = xTexelC").concat(y + 1, ";\n                    ")
                    }
                } else y < p && (s % 2 == 1 ? (d += "\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(y, "Ready == 0) {\n                  xTexelC").concat(y, " = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(y, ".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(y, "Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(y + 1, "Ready == 0) {\n                  xTexelC").concat(y + 1, " = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC").concat(y + 1, ".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(y + 1, "Ready = 1;\n                }\n\n                xC").concat(y, " = vec4(xTexelC").concat(y, ".zw, xTexelC").concat(y + 1, ".zw);\n              "), y + 1 < p && (d += "\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC".concat(y + 1, " = vec4(xTexelC").concat(y + 1, ".xy, final.xy);\n                "))) : (d += "\n                if(xC >= 0 && xC < inDims[1] && xTexelC".concat(y, "Ready == 0) {\n                  xTexelC").concat(y, " = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(y, ".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(y, "Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(y + 1, "Ready == 0) {\n                  xTexelC").concat(y + 1, " = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(y + 1, ".zw = vec2(0.);\n                  }\n                  xTexelC").concat(y + 1, "Ready = 1;\n                }\n\n                xC").concat(y, " = vec4(\n                  xTexelC").concat(y, ".xy, xTexelC").concat(y + 1, ".xy);\n              "), y + 1 < p && (d += "\n                  xC".concat(y + 1, " = vec4(xTexelC").concat(y, ".zw, xTexelC").concat(y + 1, ".zw);\n                "))));
                y < p && (d += "\n            wTexel = getW(r, ".concat(y, ", d1, q);\n            dotProd += xC").concat(y, " * vec4(wTexel.xz, wTexel.xz);\n          "), y + 1 < p && (d += "\n              wTexel = getW(r, ".concat(y + 1, ", d1, q);\n              dotProd += xC").concat(y + 1, " * vec4(wTexel.xz, wTexel.xz);\n            ")))
            }
            d += "\n    }\n  ", d += "\n      }\n    ";
            var x = "",
                k = "";
            r && (x = a ? "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(r, "\n        }") : i ? "vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(r, "\n        }") : "vec4 activation(vec4 x) {\n          ".concat(r, "\n        }"), k = "result = activation(result);");
            var w = n ? "result += getBiasAtOutCoords();" : "";
            n && this.variableNames.push("bias"), a && this.variableNames.push("preluActivationWeights"), i && this.variableNames.push("leakyreluAlpha"), this.userCode = "\n      ".concat(x, "\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(o, ";\n        int q = d2 - d1 * ").concat(o, ";\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ").concat(d, "\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ").concat(w, "\n        ").concat(k, "\n        setOutput(result);\n      }\n    ")
        }));
    var cRe = {
            kernelName: f1,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.filter,
                    o = r.strides,
                    s = r.pad,
                    u = r.dilations,
                    c = r.dimRoundingMode,
                    l = u;
                null == l && (l = [1, 1]), F$(j8(o, l), (function() {
                    return "Error in depthwiseConv2d: Either strides or dilations must be " + "1. Got strides ".concat(o, " and dilations '").concat(l, "'")
                }));
                var h, p = D8(a.shape, i.shape, o, l, s, c, !0);
                h = k0().getBool("WEBGL_PACK_DEPTHWISECONV") && p.strideWidth <= 2 && p.outChannels / p.inChannels == 1 ? new uRe(p) : new sRe(p);
                var f = [
                    [p.padInfo.top, p.padInfo.left],
                    [p.strideHeight, p.strideWidth],
                    [p.dilationHeight, p.dilationWidth],
                    [p.inHeight, p.inWidth]
                ];
                return n.runWebGLProgram(h, [a, i], "float32", f)
            }
        },
        lRe = p((function e(t) {
            l(this, e), this.variableNames = ["x", "dy"], this.outputShape = t.filterShape;
            var n = t.strideHeight,
                r = t.strideWidth,
                a = t.padInfo.top,
                i = t.padInfo.left,
                o = t.outChannels / t.inChannels;
            this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ".concat(o, " + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ").concat(t.batchSize, "; b++) {\n          for (int yR = 0; yR < ").concat(t.outHeight, "; yR++) {\n            int xR = wR + yR * ").concat(n, " - ").concat(a, ";\n\n            if (xR < 0 || xR >= ").concat(t.inHeight, ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(t.outWidth, "; yC++) {\n              int xC = wC + yC * ").concat(r, " - ").concat(i, ";\n\n              if (xC < 0 || xC >= ").concat(t.inWidth, ") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")
        })),
        hRe = p((function e(t) {
            l(this, e), this.variableNames = ["dy", "W"], this.outputShape = t.inShape;
            var n = t.filterHeight,
                r = t.filterWidth,
                a = t.strideHeight,
                i = t.strideWidth,
                o = n - 1 - t.padInfo.top,
                s = r - 1 - t.padInfo.left,
                u = t.outChannels / t.inChannels;
            this.userCode = "\n      const ivec2 pads = ivec2(".concat(o, ", ").concat(s, ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ").concat(n, "; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(a, ".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(t.outHeight, ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(n, " - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(r, "; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(i, ".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(t.outWidth, ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(r, " - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ").concat(u, "; dm++) {\n              int d2 = d1 * ").concat(u, " + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")
        }));
    var pRe = {
        kernelName: d1,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = t.dy,
                o = r.strides,
                s = r.dilations,
                u = r.pad,
                c = r.dimRoundingMode,
                l = r.filterShape,
                h = D8(a.shape, l, o, s, u, c, !0),
                p = new lRe(h);
            return n.runWebGLProgram(p, [a, i], "float32")
        }
    };
    var fRe = {
            kernelName: v1,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.dy,
                    i = t.filter,
                    o = r.strides,
                    s = r.dilations,
                    u = r.pad,
                    c = r.dimRoundingMode,
                    l = D8(r.inputShape, i.shape, o, s, u, c, !0),
                    h = new hRe(l);
                return n.runWebGLProgram(h, [a, i], "float32")
            }
        },
        dRe = p((function e(t) {
            l(this, e), this.variableNames = ["X"], this.outputShape = [t, t], this.userCode = "\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "
        }));
    var vRe = {
            kernelName: m1,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = t.x,
                    a = [].concat(T(r.shape), T(r.shape)),
                    i = L$(r.shape),
                    o = KEe({
                        inputs: {
                            x: r
                        },
                        backend: n,
                        attrs: {
                            shape: [i]
                        }
                    }),
                    s = new dRe(i),
                    u = n.runWebGLProgram(s, [o], o.dtype),
                    c = KEe({
                        inputs: {
                            x: u
                        },
                        backend: n,
                        attrs: {
                            shape: a
                        }
                    });
                return n.disposeIntermediateTensorInfo(o), n.disposeIntermediateTensorInfo(u), c
            }
        },
        mRe = p((function e(t) {
            l(this, e), this.variableNames = ["x", "W"], this.outputShape = t.outShape;
            var n = t.inHeight,
                r = t.inWidth,
                a = t.padInfo,
                i = t.strideHeight,
                o = t.strideWidth,
                s = t.filterHeight,
                u = t.filterWidth,
                c = t.dilationHeight,
                h = t.dilationWidth,
                p = a.top,
                f = a.left;
            this.userCode = "\n      const ivec2 strides = ivec2(".concat(i, ", ").concat(o, ");\n      const ivec2 pads = ivec2(").concat(p, ", ").concat(f, ");\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ").concat(s, "; h++) {\n          int hIn = hBeg + h * ").concat(c, ";\n\n          if (hIn >= 0 && hIn < ").concat(n, ") {\n            for (int w = 0; w < ").concat(u, "; w++) {\n              int wIn = wBeg + w * ").concat(h, ";\n\n              if (wIn >= 0 && wIn < ").concat(r, ") {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    ")
        }));
    var gRe = {
        kernelName: g1,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t, n = e.inputs,
                r = e.backend,
                a = e.attrs,
                i = n.x,
                o = n.filter,
                s = a.strides,
                u = a.pad,
                c = a.dilations,
                l = _8(i.shape, o.shape, s, u, "NHWC", c),
                h = new mRe(l),
                p = KEe({
                    inputs: {
                        x: t = r.runWebGLProgram(h, [i, o], "float32")
                    },
                    backend: r,
                    attrs: {
                        shape: l.outShape
                    }
                });
            return r.disposeIntermediateTensorInfo(t), p
        }
    };
    var yRe = {
            kernelName: w1,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = t,
                    a = Lie(e.attrs.equation, r.length),
                    i = a.allDims,
                    o = a.summedDims,
                    s = a.idDims;
                Pie(i.length, s, r);
                for (var u = Bie(o, s), c = u.path, l = u.steps, h = l.length, p = null, f = i.length, d = [], v = 0; v < h; ++v) {
                    var m, g = O(l[v]);
                    try {
                        for (g.s(); !(m = g.n()).done;) {
                            var y = m.value,
                                b = zie(f, s[y]),
                                x = b.permutationIndices,
                                k = b.expandDims,
                                w = void 0;
                            Wie(x) ? w = r[y] : (w = rCe({
                                inputs: {
                                    x: r[y]
                                },
                                backend: n,
                                attrs: {
                                    perm: x
                                }
                            }), d.push(w));
                            for (var I = w.shape.slice(), N = 0; N < k.length; ++N) I.splice(k[N], 0, 1);
                            P$(w.shape, I) || (w = KEe({
                                inputs: {
                                    x: w
                                },
                                backend: n,
                                attrs: {
                                    shape: I
                                }
                            }), d.push(w)), null === p ? p = w : (p = HEe({
                                inputs: {
                                    a: w,
                                    b: p
                                },
                                backend: n
                            }), d.push(p))
                        }
                    } catch (e) {
                        g.e(e)
                    } finally {
                        g.f()
                    }
                    v < h - 1 && (c[v] >= 0 && (p = tCe({
                        inputs: {
                            x: p
                        },
                        backend: n,
                        attrs: {
                            axis: c[v] - (i.length - f),
                            keepDims: !1
                        }
                    }), d.push(p)), f--)
                }
                for (var S = 0, T = d; S < T.length; S++) {
                    var E = T[S];
                    E !== p && n.disposeIntermediateTensorInfo(E)
                }
                return p
            }
        },
        bRe = zEe({
            opSnippet: "return (x >= 0.0) ? x : (exp(x) - 1.0);",
            packedOpSnippet: "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"
        }),
        xRe = {
            kernelName: I1,
            backendName: "webgl",
            kernelFunc: bRe
        },
        kRe = {
            kernelName: N1,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = t.dy,
                    a = t.y,
                    i = k0().getBool("WEBGL_PACK_BINARY_OPERATIONS") ? new TEe("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n", r.shape, a.shape) : new NEe("return (b >= 0.0) ? a : a * (b + 1.0);", r.shape, a.shape);
                return n.runWebGLProgram(i, [r, a], r.dtype)
            }
        },
        wRe = PEe({
            opSnippet: "return float(a == b);",
            packedOpSnippet: "\n  return vec4(equal(a, b));\n",
            dtype: "bool",
            cpuKernelImpl: iTe
        }),
        IRe = {
            kernelName: T1,
            backendName: "webgl",
            kernelFunc: wRe
        },
        NRe = zEe({
            opSnippet: '\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = '.concat(xie, ";\n  float a1 = ").concat(kie, ";\n  float a2 = ").concat(wie, ";\n  float a3 = ").concat(Iie, ";\n  float a4 = ").concat(Nie, ";\n  float a5 = ").concat(Sie, ";\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n")
        }),
        SRe = {
            kernelName: S1,
            backendName: "webgl",
            kernelFunc: NRe
        },
        TRe = zEe({
            opSnippet: "if (isnan(x)) return x;\n  return exp(x);\n",
            packedOpSnippet: "\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",
            cpuKernelImpl: oTe,
            dtype: "float32"
        }),
        ERe = {
            kernelName: E1,
            backendName: "webgl",
            kernelFunc: TRe
        };

    function CRe(e) {
        var t = e.inputs,
            n = e.attrs,
            r = e.backend,
            a = n.dim,
            i = t.input,
            o = i.shape.length,
            s = i.shape.slice(),
            u = a;
        return a < 0 && (F$(-(o + 1) <= a, (function() {
            return "Axis must be in the interval [".concat(-(o + 1), ", ").concat(o, "]")
        })), u = o + a + 1), s.splice(u, 0, 1), KEe({
            inputs: {
                x: i
            },
            backend: r,
            attrs: {
                shape: s
            }
        })
    }
    var ARe = {
            kernelName: C1,
            backendName: "webgl",
            kernelFunc: CRe
        },
        RRe = "return exp(x) - 1.0;",
        _Re = zEe({
            opSnippet: RRe,
            packedOpSnippet: RRe,
            cpuKernelImpl: sTe
        }),
        ORe = {
            kernelName: A1,
            backendName: "webgl",
            kernelFunc: _Re
        },
        FRe = p((function e(t, n, r) {
            l(this, e), this.variableNames = ["real", "imag"];
            var a = n[1];
            this.outputShape = n;
            var i, o = r ? "2.0 * ".concat(Math.PI) : "-2.0 * ".concat(Math.PI),
                s = r ? "".concat(a, ".0") : "1.0";
            if ("real" === t) i = "return real * expR - imag * expI;";
            else {
                if ("imag" !== t) throw new Error('FFT component must be either "real" or "imag", got '.concat(t, "."));
                i = "return real * expI + imag * expR;"
            }
            this.userCode = "\n      const float exponentMultiplier = ".concat(o, ";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ").concat(i, "\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(").concat(a, ");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ").concat(a, "; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ").concat(s, ";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ")
        }));

    function DRe(e, t, n) {
        var r = n.texData.get(e.dataId),
            a = L$(e.shape),
            i = e.shape[e.shape.length - 1],
            o = KEe({
                inputs: {
                    x: e
                },
                backend: n,
                attrs: {
                    shape: [a / i, i]
                }
            }),
            s = o.shape,
            u = new FRe("real", s, t),
            c = new FRe("imag", s, t),
            l = [{
                dataId: r.complexTensorInfos.real.dataId,
                dtype: r.complexTensorInfos.real.dtype,
                shape: s
            }, {
                dataId: r.complexTensorInfos.imag.dataId,
                dtype: r.complexTensorInfos.imag.dtype,
                shape: s
            }],
            h = n.runWebGLProgram(u, l, "float32"),
            p = n.runWebGLProgram(c, l, "float32"),
            f = AEe({
                inputs: {
                    real: h,
                    imag: p
                },
                backend: n
            });
        n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(p);
        var d = KEe({
            inputs: {
                x: f
            },
            backend: n,
            attrs: {
                shape: e.shape
            }
        });
        return n.disposeIntermediateTensorInfo(o), n.disposeIntermediateTensorInfo(f), d
    }
    var MRe = {
            kernelName: R1,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend;
                return DRe(t.input, !1, n)
            }
        },
        LRe = p((function e(t, n) {
            l(this, e), this.outputShape = [], this.customUniforms = [{
                name: "value",
                type: "float"
            }], this.variableNames = ["x"], this.outputShape = t, this.userCode = "\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "
        }));

    function zRe(e) {
        var t = e.backend,
            n = e.attrs,
            r = n.shape,
            a = n.value,
            i = n.dtype;
        if ("string" === (i = i || n0(a))) {
            var o = K$(i, L$(r));
            return o.fill(a), t.makeTensorInfo(r, i, o)
        }
        var s = new LRe(r, a),
            u = [
                [a]
            ];
        return t.runWebGLProgram(s, [], i, u)
    }
    var PRe, BRe = {
            kernelName: _1,
            backendName: "webgl",
            kernelFunc: zRe
        },
        WRe = p((function e(t) {
            l(this, e), this.variableNames = ["Image"], this.outputShape = [];
            var n = t[2];
            this.outputShape = t, this.userCode = "\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ".concat(n, " - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ").concat(n, ") {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")
        })),
        URe = {
            kernelName: O1,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = t.image,
                    a = n,
                    i = new WRe(r.shape);
                return a.runWebGLProgram(i, [r], r.dtype)
            }
        },
        VRe = "return floor(x);",
        GRe = zEe({
            opSnippet: VRe,
            packedOpSnippet: VRe,
            cpuKernelImpl: uTe
        }),
        jRe = {
            kernelName: F1,
            backendName: "webgl",
            kernelFunc: GRe
        },
        HRe = PEe({
            opSnippet: "\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",
            packedOpSnippet: "\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",
            dtype: "int32"
        }),
        qRe = {
            kernelName: D1,
            backendName: "webgl",
            kernelFunc: HRe
        },
        KRe = p((function e(t) {
            l(this, e), this.variableNames = ["A"];
            var n = WNe(),
                r = S(t, 2),
                a = r[0],
                i = r[1];
            this.outputShape = t, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(".concat(i, ".0, ").concat(a, ".0);\n\n        vec4 values = ").concat(n.texture2D, "(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ")
        })),
        XRe = p((function e(t) {
            l(this, e), this.variableNames = ["A"], this.packedInputs = !1, this.packedOutput = !0;
            var n = WNe(),
                r = S(t, 2),
                a = r[0],
                i = r[1];
            this.outputShape = t, this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(".concat(i, ".0, ").concat(a, ".0);\n            vec4 values = ").concat(n.texture2D, "(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ").concat(n.output, " = result;\n      }\n    ")
        })),
        YRe = {
            kernelName: O3,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.pixels,
                    i = r.numChannels,
                    o = "undefined" != typeof HTMLVideoElement && a instanceof HTMLVideoElement,
                    s = "undefined" != typeof HTMLImageElement && a instanceof HTMLImageElement,
                    u = S(o ? [a.videoWidth, a.videoHeight] : [a.width, a.height], 2),
                    c = u[0],
                    l = u[1],
                    h = [l, c],
                    p = [l, c, i];
                if (s || o) {
                    var f = k0().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
                    null != PRe && f === JRe || (JRe = f, PRe = document.createElement("canvas").getContext("2d", {
                        willReadFrequently: JRe
                    })), PRe.canvas.width = c, PRe.canvas.height = l, PRe.drawImage(a, 0, 0, c, l), a = PRe.canvas
                }
                var d = n.makeTensorInfo(h, "int32");
                n.texData.get(d.dataId).usage = zIe.PIXELS, n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId), a);
                var v = k0().getBool("WEBGL_PACK") ? new XRe(p) : new KRe(p),
                    m = n.runWebGLProgram(v, [d], "int32");
                return n.disposeData(d.dataId), m
            }
        },
        JRe = k0().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
    var ZRe = {
        kernelName: M3,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t, n = e.inputs,
                r = e.backend,
                a = e.attrs,
                i = n.x,
                o = n.filter,
                s = n.bias,
                u = n.preluActivationWeights,
                c = a.strides,
                l = a.pad,
                h = a.dataFormat,
                p = a.dilations,
                f = a.dimRoundingMode,
                d = a.activation,
                v = a.leakyreluAlpha,
                m = q8(h),
                g = D8(i.shape, o.shape, c, p, l, f, !1, m),
                y = [],
                b = null != s,
                x = null != u,
                k = "leakyrelu" === d,
                w = function() {
                    var e = [i, o],
                        t = function(e, t) {
                            if ("NCHW" === t && 1 === e.shape.length && 1 !== e.shape[0]) {
                                var n = KEe({
                                    inputs: {
                                        x: e
                                    },
                                    backend: r,
                                    attrs: {
                                        shape: [e.shape[0], 1, 1]
                                    }
                                });
                                return y.push(n), n
                            }
                            return e
                        };
                    if (b && e.push(t(s, h)), x && e.push(t(u, h)), k) {
                        var n = r.makeTensorInfo([], "float32", M4(v, "float32"));
                        e.push(n), y.push(n)
                    }
                    return e
                };
            if (1 !== g.filterHeight || 1 !== g.filterWidth || 1 !== g.dilationHeight || 1 !== g.dilationWidth || 1 !== g.strideHeight || 1 !== g.strideWidth || "SAME" !== g.padInfo.type && "VALID" !== g.padInfo.type)
                if (g.strideWidth <= 2 && "channelsLast" === m && k0().getBool("WEBGL_EXP_CONV")) {
                    var I = d ? BEe(d, !0) : null,
                        N = new AAe(g, b, I, x, k),
                        S = [
                            [g.padInfo.top, g.padInfo.left],
                            [g.strideHeight, g.strideWidth],
                            [g.dilationHeight, g.dilationWidth],
                            [g.inHeight, g.inWidth]
                        ],
                        T = w();
                    t = r.runWebGLProgram(N, T, "float32", S)
                } else if (k0().getBool("WEBGL_CONV_IM2COL")) t = FAe({
                x: i,
                filter: o,
                convInfo: g,
                backend: r,
                bias: s,
                activation: d,
                preluActivationWeights: u,
                leakyreluAlpha: v
            });
            else {
                var E = d ? BEe(d, !1) : null,
                    C = new EAe(g, b, E, x, k),
                    A = w();
                t = r.runWebGLProgram(C, A, "float32")
            } else t = OAe({
                x: i,
                filter: o,
                convInfo: g,
                backend: r,
                bias: s,
                activation: d,
                preluActivationWeights: u,
                leakyreluAlpha: v
            });
            var R = KEe({
                inputs: {
                    x: t
                },
                backend: r,
                attrs: {
                    shape: g.outShape
                }
            });
            return y.push(t), y.forEach((function(e) {
                return r.disposeIntermediateTensorInfo(e)
            })), R
        }
    };
    var QRe = {
            kernelName: L3,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.filter,
                    o = t.bias,
                    s = t.preluActivationWeights,
                    u = r.strides,
                    c = r.pad,
                    l = r.dilations,
                    h = r.dimRoundingMode,
                    p = r.activation,
                    f = r.leakyreluAlpha,
                    d = [],
                    v = l;
                null == v && (v = [1, 1]), F$(j8(u, v), (function() {
                    return "Error in depthwiseConv2d: Either strides or dilations must be " + "1. Got strides ".concat(u, " and dilations '").concat(v, "'")
                }));
                var m, g = D8(a.shape, i.shape, u, v, c, h, !0),
                    y = k0().getBool("WEBGL_PACK_DEPTHWISECONV") && g.strideWidth <= 2 && g.outChannels / g.inChannels == 1,
                    b = p ? BEe(p, y) : null,
                    x = [a, i],
                    k = null != o,
                    w = null != s,
                    I = "leakyrelu" === p;
                if (k && x.push(o), w && x.push(s), I) {
                    var N = n.makeTensorInfo([], "float32", M4(f, "float32"));
                    x.push(N), d.push(N)
                }
                m = y ? new uRe(g, k, b, w, I) : new sRe(g, k, b, w, I);
                var S = [
                        [g.padInfo.top, g.padInfo.left],
                        [g.strideHeight, g.strideWidth],
                        [g.dilationHeight, g.dilationWidth],
                        [g.inHeight, g.inWidth]
                    ],
                    T = n.runWebGLProgram(m, x, "float32", S);
                return d.forEach((function(e) {
                    return n.disposeIntermediateTensorInfo(e)
                })), T
            }
        },
        $Re = p((function e(t, n, r, a) {
            l(this, e), this.sliceDim = t, this.strides = n, this.paramsShape = a, this.variableNames = ["x", "indices"], this.outputShape = r;
            for (var i = hSe(r.length), o = "\n    int index;", s = 0; s < this.sliceDim; s++) o += "\n          index = round(getIndices(coords[0], ".concat(s, "));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ").concat(this.paramsShape[s], ";\n          flattenIndex += index * ").concat(this.strides[s], ";");
            this.userCode = "\n         void main() {\n          ".concat(i, " coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ").concat(o, "\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      ")
        }));
    var e_e = {
            kernelName: z1,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = t.params,
                    a = t.indices,
                    i = a.shape,
                    o = i[i.length - 1],
                    s = L$(r.shape),
                    u = S(Mae(r, a), 4),
                    c = u[0],
                    l = u[1],
                    h = u[2],
                    p = u[3],
                    f = KEe({
                        inputs: {
                            x: a
                        },
                        backend: n,
                        attrs: {
                            shape: [l, o]
                        }
                    }),
                    d = KEe({
                        inputs: {
                            x: r
                        },
                        backend: n,
                        attrs: {
                            shape: [L$(r.shape) / h, h]
                        }
                    });
                if (n.shouldExecuteOnCPU([r, a]) || "string" === r.dtype) {
                    var v = n.readSync(a.dataId),
                        m = n.bufferSync(r),
                        g = cTe(v, m, r.dtype, l, o, h, p, r.shape, s);
                    return n.makeTensorInfo(c, r.dtype, g.values)
                }
                var y = new $Re(o, p, [l, h], r.shape),
                    b = n.runWebGLProgram(y, [d, f], d.dtype),
                    x = KEe({
                        inputs: {
                            x: b
                        },
                        backend: n,
                        attrs: {
                            shape: c
                        }
                    });
                return n.disposeIntermediateTensorInfo(f), n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(b), x
            }
        },
        t_e = p((function e(t, n) {
            l(this, e), this.variableNames = ["A", "indices"], this.outputShape = n, this.rank = n.length;
            var r = hSe(this.rank),
                a = function(e, t) {
                    for (var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], r = [], a = 0; a < e.length; a++) 2 === a ? r.push("index") : r.push("".concat(n[a]));
                    return r.join()
                }(t);
            this.userCode = "\n      void main() {\n        ".concat(r, " resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ").concat(t[2], ") ? 1.0 : 0.0;\n        setOutput(inBounds * getA(").concat(a, "));\n      }\n    ")
        }));

    function n_e(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs,
            a = t.x,
            i = t.indices,
            o = r.axis,
            s = r.batchDims,
            u = j$(o, a.shape)[0];
        if (k0().get("DEBUG"))
            for (var c = n.readSync(i.dataId), l = a.shape[u], h = function() {
                    var e = c[p];
                    F$(e <= l - 1 && e >= 0, (function() {
                        return "GatherV2: the index value ".concat(e, " is not in [0, ").concat(l - 1, "]")
                    }))
                }, p = 0; p < c.length; ++p) h();
        var f = roe(a, i, u, s),
            d = L$(i.shape),
            v = [],
            m = KEe({
                inputs: {
                    x: a
                },
                backend: n,
                attrs: {
                    shape: [f.batchSize, f.outerSize, f.dimSize, f.sliceSize]
                }
            }),
            g = KEe({
                inputs: {
                    x: i
                },
                backend: n,
                attrs: {
                    shape: [f.batchSize, d / f.batchSize]
                }
            });
        v.push(m), v.push(g);
        var y = [f.batchSize, f.outerSize, d / f.batchSize, f.sliceSize];
        if (n.shouldExecuteOnCPU([a, i]) || "string" === a.dtype) {
            var b = n.bufferSync(g),
                x = n.bufferSync(m),
                k = lTe(x, b, y);
            return v.forEach((function(e) {
                return n.disposeIntermediateTensorInfo(e)
            })), n.makeTensorInfo(f.outputShape, k.dtype, k.values)
        }
        var w = new t_e(m.shape, y),
            I = n.runWebGLProgram(w, [m, g], m.dtype);
        v.push(I);
        var N = KEe({
            inputs: {
                x: I
            },
            backend: n,
            attrs: {
                shape: f.outputShape
            }
        });
        return v.forEach((function(e) {
            return n.disposeIntermediateTensorInfo(e)
        })), N
    }
    var r_e = {
            kernelName: L1,
            backendName: "webgl",
            kernelFunc: n_e
        },
        a_e = PEe({
            opSnippet: "return float(a > b);",
            packedOpSnippet: "\n  return vec4(greaterThan(a, b));\n",
            cpuKernelImpl: hTe,
            dtype: "bool"
        }),
        i_e = {
            kernelName: P1,
            backendName: "webgl",
            kernelFunc: a_e
        },
        o_e = PEe({
            opSnippet: "return float(a >= b);",
            packedOpSnippet: "\n  return vec4(greaterThanEqual(a, b));\n",
            dtype: "bool",
            cpuKernelImpl: pTe
        }),
        s_e = {
            kernelName: B1,
            backendName: "webgl",
            kernelFunc: o_e
        };
    var u_e = {
            kernelName: U1,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend;
                return DRe(t.input, !0, n)
            }
        },
        c_e = zEe({
            opSnippet: "return float(!isnan(x) && !isinf(x));",
            dtype: "bool"
        }),
        l_e = {
            kernelName: G1,
            backendName: "webgl",
            kernelFunc: c_e
        },
        h_e = zEe({
            opSnippet: "return float(isinf(x));",
            dtype: "bool"
        }),
        p_e = {
            kernelName: j1,
            backendName: "webgl",
            kernelFunc: h_e
        },
        f_e = zEe({
            opSnippet: "return float(isnan(x));",
            dtype: "bool"
        }),
        d_e = {
            kernelName: H1,
            backendName: "webgl",
            kernelFunc: f_e
        },
        v_e = PEe({
            opSnippet: "return float(a < b);",
            packedOpSnippet: "\n  return vec4(lessThan(a, b));\n",
            cpuKernelImpl: fTe,
            dtype: "bool"
        }),
        m_e = {
            kernelName: K1,
            backendName: "webgl",
            kernelFunc: v_e
        },
        g_e = PEe({
            opSnippet: "return float(a <= b);",
            packedOpSnippet: "\n  return vec4(lessThanEqual(a, b));\n",
            cpuKernelImpl: dTe,
            dtype: "bool"
        }),
        y_e = {
            kernelName: X1,
            backendName: "webgl",
            kernelFunc: g_e
        };
    var b_e = {
            kernelName: Y1,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.backend,
                    n = e.attrs,
                    r = n.start,
                    a = n.stop,
                    i = n.num,
                    o = vTe(r, a, i);
                return t.makeTensorInfo([o.length], "float32", o)
            }
        },
        x_e = zEe({
            opSnippet: "if (isnan(x)) return x;\n  return x < 0.0 ? 0./0. : log(x);\n",
            packedOpSnippet: "\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",
            cpuKernelImpl: mTe
        }),
        k_e = {
            kernelName: J1,
            backendName: "webgl",
            kernelFunc: x_e
        },
        w_e = zEe({
            opSnippet: "if (isnan(x)) return x;\n  return log(1.0 + x);\n"
        }),
        I_e = {
            kernelName: Z1,
            backendName: "webgl",
            kernelFunc: w_e
        },
        N_e = PEe({
            opSnippet: "return float(a >= 1.0 && b >= 1.0);",
            packedOpSnippet: "\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",
            dtype: "bool"
        }),
        S_e = {
            kernelName: Q1,
            backendName: "webgl",
            kernelFunc: N_e
        },
        T_e = zEe({
            opSnippet: "return float(!(x >= 1.0));"
        }),
        E_e = {
            kernelName: $1,
            backendName: "webgl",
            kernelFunc: T_e
        },
        C_e = PEe({
            opSnippet: "return float(a >= 1.0 || b >= 1.0);",
            packedOpSnippet: "\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",
            dtype: "bool"
        }),
        A_e = {
            kernelName: e2,
            backendName: "webgl",
            kernelFunc: C_e
        },
        R_e = p((function e(t, n, r, a, i) {
            l(this, e), this.variableNames = ["x"], this.outputShape = [];
            var o, s = n,
                u = t[3] - 1;
            this.outputShape = t;
            var c = "float(".concat(r, ") + float(").concat(a, ") * sum");
            o = .5 === i ? "inversesqrt(".concat(c, ")") : 1 === i ? "1.0/(".concat(c, ")") : "exp(log(".concat(c, ") * float(-").concat(i, "));"), this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -".concat(s, "; j <= ").concat(s, "; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ").concat(u, ") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ").concat(o, ";\n        setOutput(val);\n      }\n    ")
        })),
        __e = p((function e(t, n, r, a, i) {
            l(this, e), this.variableNames = ["x"], this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0;
            var o, s = n,
                u = t[3] - 1;
            this.outputShape = t;
            var c = "float(".concat(r, ") + float(").concat(a, ") * sum");
            o = .5 === i ? "inversesqrt(".concat(c, ")") : 1 === i ? "1.0/(".concat(c, ")") : "exp(log(".concat(c, ") * float(-").concat(i, "));"), this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ".concat(this.outputShape[3], ";\n        bool hasNextRow = c < ").concat(this.outputShape[2], ";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ").concat(s, ";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ").concat(s, "; j <= ").concat(s, "; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(").concat(u, "));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ").concat(o, ";\n        setOutput(result);\n      }\n    ")
        })),
        O_e = {
            kernelName: n2,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.depthRadius,
                    o = r.bias,
                    s = r.alpha,
                    u = r.beta,
                    c = k0().getBool("WEBGL_PACK_NORMALIZATION") ? new __e(a.shape, i, o, s, u) : new R_e(a.shape, i, o, s, u);
                return n.runWebGLProgram(c, [a], a.dtype)
            }
        },
        F_e = p((function e(t, n, r, a, i) {
            l(this, e), this.variableNames = ["inputImage", "outputImage", "dy"], this.outputShape = [], this.outputShape = t, this.depth = t[3], this.depthRadius = n, this.bias = r, this.alpha = a, this.beta = i, this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ".concat(this.depth, "; ++d) {\n          int depthBegin = int(max(0.0, float(d - ").concat(n, ")));\n          int depthEnd = int(min(float(").concat(this.depth, "),\n              float(d + ").concat(n, " + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ").concat(this.depth, ";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(").concat(a, ") * norm + float(").concat(r, ");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(").concat(a, ")\n                * float(").concat(i, ")\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ").concat(i, ");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ")
        })),
        D_e = {
            kernelName: r2,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.y,
                    o = t.dy,
                    s = r.depthRadius,
                    u = r.bias,
                    c = r.alpha,
                    l = r.beta,
                    h = new F_e(a.shape, s, u, c, l);
                return n.runWebGLProgram(h, [a, i, o], a.dtype)
            }
        };

    function M_e(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs,
            a = t.x,
            i = r.reductionIndices,
            o = r.keepDims,
            s = a.shape.length,
            u = j$(i, a.shape),
            c = u,
            l = $7(c, s),
            h = null != l,
            p = n.shouldExecuteOnCPU([a]),
            f = a;
        if (h) {
            if (p) {
                for (var d = n.texData.get(f.dataId).values, v = new Array(s), m = 0; m < v.length; m++) v[m] = a.shape[l[m]];
                var g = HTe(d, a.shape, a.dtype, l, v);
                f = n.makeTensorInfo(v, a.dtype), n.texData.get(f.dataId).values = g
            } else f = eCe(a, l, n);
            c = t9(c.length, s)
        }
        Q7("max", c, s);
        var y, b = S(J7(f.shape, c), 2),
            x = b[0],
            k = b[1],
            w = x;
        if (o && (w = Z7(x, u)), p) {
            var I = n.texData.get(f.dataId).values,
                N = gTe(I, L$(k), w, a.dtype);
            y = n.makeTensorInfo(w, a.dtype), n.texData.get(y.dataId).values = N
        } else y = function(e, t, n, r) {
            var a = L$(t),
                i = KEe({
                    inputs: {
                        x: e
                    },
                    attrs: {
                        shape: [L$(e.shape) / a, a]
                    },
                    backend: r
                }),
                o = ZEe(i, e.dtype, "max", r),
                s = KEe({
                    inputs: {
                        x: o
                    },
                    attrs: {
                        shape: n
                    },
                    backend: r
                });
            return r.disposeIntermediateTensorInfo(i), r.disposeIntermediateTensorInfo(o), s
        }(f, k, w, n);
        return h && n.disposeIntermediateTensorInfo(f), y
    }
    var L_e = {
            kernelName: a2,
            backendName: "webgl",
            kernelFunc: M_e
        },
        z_e = PEe({
            opSnippet: "\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",
            packedOpSnippet: "\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n",
            cpuKernelImpl: yTe
        }),
        P_e = {
            kernelName: i2,
            backendName: "webgl",
            kernelFunc: z_e
        };
    var B_e = {
        kernelName: o2,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x;
            zNe(a, "maxPool");
            var i = r.filterSize,
                o = r.strides,
                s = r.pad,
                u = r.dimRoundingMode;
            F$(j8(o, 1), (function() {
                return "Error in maxPool: Either strides or dilations must be 1. " + "Got strides ".concat(o, " and dilations '").concat(1, "'")
            }));
            var c = O8(a.shape, i, o, 1, s, u);
            if (1 === c.filterWidth && 1 === c.filterHeight && P$(c.inShape, c.outShape)) return EEe({
                inputs: {
                    x: a
                },
                backend: n
            });
            var l = new PCe(c, "max", !1);
            return n.runWebGLProgram(l, [a], a.dtype)
        }
    };
    var W_e = {
            kernelName: u2,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.filterSize,
                    o = r.strides,
                    s = r.pad,
                    u = r.dataFormat,
                    c = r.dimRoundingMode,
                    l = F8(a.shape, i, o, [1, 1, 1], s, c, u),
                    h = new BCe(l, "max", !1);
                return n.runWebGLProgram(h, [a], a.dtype)
            }
        },
        U_e = p((function e(t) {
            l(this, e), this.variableNames = ["dy", "maxPos"], this.outputShape = t.inShape;
            var n = t.strideHeight,
                r = t.strideWidth,
                a = t.dilationHeight,
                i = t.effectiveFilterHeight,
                o = t.effectiveFilterWidth,
                s = i - 1 - t.padInfo.top,
                u = o - 1 - t.padInfo.left,
                c = i * o - 1;
            this.userCode = "\n      const ivec2 pads = ivec2(".concat(s, ", ").concat(u, ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(i, ";\n          wR += ").concat(a, ") {\n          float dyR = float(dyRCorner + wR) / ").concat(n, ".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(t.outHeight, ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(o, "; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(r, ".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(t.outWidth, ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ").concat(c, " - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ").concat(o, " + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")
        })),
        V_e = p((function e(t) {
            l(this, e), this.variableNames = ["dy", "maxPos"], this.outputShape = t.inShape;
            var n = t.strideDepth,
                r = t.strideHeight,
                a = t.strideWidth,
                i = t.dilationDepth,
                o = t.dilationHeight,
                s = t.dilationWidth,
                u = t.effectiveFilterDepth,
                c = t.effectiveFilterHeight,
                h = t.effectiveFilterWidth,
                p = u - 1 - t.padInfo.front,
                f = c - 1 - t.padInfo.top,
                d = h - 1 - t.padInfo.left,
                v = u * c * h - 1;
            this.userCode = "\n      const ivec3 pads = ivec3(".concat(p, ", ").concat(f, ", ").concat(d, ");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(u, ";\n           wD += ").concat(i, ") {\n          float dyD = float(dyDCorner + wD) / ").concat(n, ".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(t.outDepth, ".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(c, ";\n              wR += ").concat(o, ") {\n            float dyR = float(dyRCorner + wR) / ").concat(r, ".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(t.outHeight, ".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(h, ";\n                wC += ").concat(s, ") {\n              float dyC = float(dyCCorner + wC) / ").concat(a, ".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(t.outWidth, ".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ").concat(v, " -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ").concat(c, " * ").concat(h, " +\n                  wR * ").concat(h, " + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")
        }));
    var G_e = {
        kernelName: c2,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.dy,
                i = t.input,
                o = r.filterSize,
                s = r.strides,
                u = r.pad,
                c = r.dimRoundingMode,
                l = F8(i.shape, o, s, [1, 1, 1], u, c),
                h = new BCe(l, "max", !0),
                p = n.runWebGLProgram(h, [i], i.dtype),
                f = new V_e(l),
                d = n.runWebGLProgram(f, [a, p], i.dtype);
            return n.disposeIntermediateTensorInfo(p), d
        }
    };
    var j_e = {
        kernelName: s2,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.dy,
                i = t.input,
                o = i;
            zNe([i, t.output], "maxPoolGrad");
            var s = r.filterSize,
                u = r.strides,
                c = r.pad,
                l = r.dimRoundingMode,
                h = O8(o.shape, s, u, 1, c, l),
                p = new PCe(h, "max", !0),
                f = n.runWebGLProgram(p, [o], o.dtype),
                d = new U_e(h),
                v = n.runWebGLProgram(d, [a, f], o.dtype);
            return n.disposeIntermediateTensorInfo(f), v
        }
    };
    var H_e = {
        kernelName: l2,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.attrs,
                r = e.backend,
                a = t.x,
                i = n.filterSize,
                o = n.strides,
                s = n.pad,
                u = n.includeBatchInIndex,
                c = r;
            F$(4 === a.shape.length, (function() {
                return "Error in maxPool: input must be rank 4 but got rank ".concat(a.shape.length, ".")
            }));
            var l = [1, 1];
            F$(j8(o, l), (function() {
                return "Error in maxPool: Either strides or dilations must be 1. " + "Got strides ".concat(o, " and dilations '").concat(l, "'")
            }));
            var h = O8(a.shape, i, o, l, s),
                p = function(e, t, n, r) {
                    var a = new PCe(n, "max", !1),
                        i = r.runWebGLProgram(a, [e], "float32");
                    return a = new PCe(n, "max", !0, !0, t), [i, r.runWebGLProgram(a, [e], "float32")]
                }(a, u, h, c),
                f = S(p, 2);
            return [f[0], f[1]]
        }
    };
    var q_e = {
        kernelName: h2,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.attrs,
                r = e.backend,
                a = t.x,
                i = n.keepDims,
                o = n.axis,
                s = r,
                u = a.shape.length,
                c = j$(o, a.shape),
                l = c,
                h = $7(l, u),
                p = null != h,
                f = s.shouldExecuteOnCPU([a]),
                d = [],
                v = a;
            if (p) {
                if (f) {
                    for (var m = s.texData.get(v.dataId).values, g = new Array(u), y = 0; y < g.length; y++) g[y] = a.shape[h[y]];
                    var b = HTe(m, a.shape, a.dtype, h, g);
                    v = s.makeTensorInfo(g, a.dtype), s.texData.get(v.dataId).values = b
                } else v = eCe(a, h, s);
                d.push(v), l = t9(l.length, u)
            }
            Q7("sum", l, u);
            var x = S(J7(v.shape, l), 2),
                k = x[0],
                w = x[1],
                I = k;
            i && (I = Z7(k, c));
            for (var N = function(e, t, n, r) {
                    var a = L$(t),
                        i = KEe({
                            inputs: {
                                x: e
                            },
                            attrs: {
                                shape: [L$(e.shape) / a, a]
                            },
                            backend: r
                        }),
                        o = ZEe(i, "float32", "mean", r),
                        s = KEe({
                            inputs: {
                                x: o
                            },
                            attrs: {
                                shape: n
                            },
                            backend: r
                        });
                    return r.disposeIntermediateTensorInfo(i), r.disposeIntermediateTensorInfo(o), s
                }(v, w, I, s), T = 0, E = d; T < E.length; T++) {
                var C = E[T];
                s.disposeIntermediateTensorInfo(C)
            }
            return N
        }
    };
    var K_e = {
            kernelName: p2,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.axis,
                    o = r.keepDims,
                    s = a.shape.length,
                    u = j$(i, a.shape),
                    c = u,
                    l = $7(c, s),
                    h = a;
                null != l && (h = rCe({
                    inputs: {
                        x: a
                    },
                    backend: n,
                    attrs: {
                        perm: l
                    }
                }), c = t9(c.length, a.shape.length)), Q7("min", c, s);
                var p, f = S(J7(h.shape, c), 2),
                    d = f[0],
                    v = KEe({
                        inputs: {
                            x: h
                        },
                        backend: n,
                        attrs: {
                            shape: [-1, L$(f[1])]
                        }
                    }),
                    m = ZEe(v, v.dtype, "min", n);
                return p = KEe(o ? {
                    inputs: {
                        x: m
                    },
                    backend: n,
                    attrs: {
                        shape: Z7(d, u)
                    }
                } : {
                    inputs: {
                        x: m
                    },
                    backend: n,
                    attrs: {
                        shape: d
                    }
                }), n.disposeIntermediateTensorInfo(v), n.disposeIntermediateTensorInfo(m), null != l && n.disposeIntermediateTensorInfo(h), p
            }
        },
        X_e = PEe({
            opSnippet: "\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",
            packedOpSnippet: "\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n",
            cpuKernelImpl: bTe
        }),
        Y_e = {
            kernelName: f2,
            backendName: "webgl",
            kernelFunc: X_e
        },
        J_e = p((function e(t, n, r) {
            l(this, e), this.variableNames = ["x"], this.outputShape = n.map((function(e, n) {
                return e[0] + t[n] + e[1]
            }));
            var a = t.length,
                i = hSe(a),
                o = n.map((function(e) {
                    return e[0]
                })).join(","),
                s = n.map((function(e, n) {
                    return e[0] + t[n]
                })).join(","),
                u = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, a),
                c = "reflect" === r ? 0 : 1;
            this.userCode = 1 !== a ? "\n      ".concat(i, " start = ").concat(i, "(").concat(o, ");\n      ").concat(i, " end = ").concat(i, "(").concat(s, ");\n\n      void main() {\n        ").concat(i, " outC = getOutputCoords();\n        for (int i = 0; i < ").concat(a, "; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ").concat(c, ";\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ").concat(c, ";\n          }\n        }\n        ").concat(i, " coords = outC - start;\n        setOutput(getX(").concat(u, "));\n      }\n    ") : "\n        int start = ".concat(o, ";\n        int end = ").concat(s, ";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ").concat(c, ";\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ").concat(c, ";\n          }\n          setOutput(getX(outC - start));\n        }\n      ")
        })),
        Z_e = p((function e(t, n, r) {
            l(this, e), this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = n.map((function(e, n) {
                return e[0] + t[n] + e[1]
            }));
            var a = t.length,
                i = hSe(a),
                o = n.map((function(e) {
                    return e[0]
                })).join(","),
                s = n.map((function(e, n) {
                    return e[0] + t[n]
                })).join(","),
                u = XTe("rc", a),
                c = XTe("source", a),
                h = "".concat(u[a - 1], " < ").concat(this.outputShape[a - 1]),
                p = 1 === a ? "source" : "vec2(".concat(c.slice(-2).join(), ")"),
                f = "reflect" === r ? 0 : 1,
                d = "";
            if (1 === a) {
                var v = "\n        ".concat(i, " source = rc;\n        if (source < start) {\n          source = start * 2 - source - ").concat(f, ";\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ").concat(f, ";\n        }\n        source -= start;\n      ");
                d = "\n        ".concat(i, " rc = outputLoc;\n        ").concat(v, "\n        result[0] = getChannel(getX(").concat(c.join(), "), ").concat(p, ");\n        ").concat(u[a - 1], " += 1;\n        if(").concat(h, ") {\n          ").concat(v, "\n          result[1] = getChannel(getX(").concat(c.join(), "), ").concat(p, ");\n        }\n      ")
            } else {
                var m = "\n        ".concat(i, " source = rc;\n        ").concat(i, " lt = ").concat(i, "(lessThan(source, start));\n        ").concat(i, " gte = ").concat(i, "(greaterThanEqual(source, end));\n        ").concat(i, " orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ").concat(f, ") +\n                gte * ((end - 1) * 2 - source + ").concat(f, ");\n        source -= start;\n      ");
                d = "\n        ".concat(i, " rc = outputLoc;\n        ").concat(m, "\n        result[0] = getChannel(getX(").concat(c.join(), "), ").concat(p, ");\n        ").concat(u[a - 1], " += 1;\n        if(").concat(h, ") {\n          ").concat(m, "\n          result[1] = getChannel(getX(").concat(c.join(), "), ").concat(p, ");\n        }\n        rc = outputLoc;\n        ").concat(u[a - 2], " += 1;\n        if(").concat(u[a - 2], " < ").concat(this.outputShape[a - 2], ") {\n          ").concat(m, "\n          result[2] = getChannel(getX(").concat(c.join(), "), ").concat(p, ");\n          ").concat(u[a - 1], " += 1;\n          if(").concat(h, ") {\n            ").concat(m, "\n            result[3] = getChannel(getX(").concat(c.join(), "), ").concat(p, ");\n          }\n        }\n      ")
            }
            this.userCode = "\n      const ".concat(i, " start = ").concat(i, "(").concat(o, ");\n      const ").concat(i, " end = ").concat(i, "(").concat(s, ");\n\n      void main() {\n        ").concat(i, " outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(d, "\n        setOutput(result);\n      }\n    ")
        })),
        Q_e = {
            kernelName: d2,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.paddings,
                    o = r.mode,
                    s = k0().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new Z_e(a.shape, i, o) : new J_e(a.shape, i, o);
                return n.runWebGLProgram(s, [a], a.dtype)
            }
        },
        $_e = PEe({
            opSnippet: "if (b == 0.0) return NAN;\n  return mod(a, b);",
            packedOpSnippet: "\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n"
        }),
        eOe = {
            kernelName: v2,
            backendName: "webgl",
            kernelFunc: $_e
        },
        tOe = p((function e(t, n, r) {
            l(this, e), this.variableNames = ["probs"], this.customUniforms = [{
                name: "seed",
                type: "float"
            }], this.outputShape = [t, r], this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ".concat(n - 1, "; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(").concat(n - 1, "));\n      }\n    ")
        })),
        nOe = PEe({
            opSnippet: "\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",
            packedOpSnippet: "\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",
            checkOutOfBounds: !0
        }),
        rOe = {
            kernelName: k1,
            backendName: "webgl",
            kernelFunc: nOe
        },
        aOe = "return a - b;",
        iOe = PEe({
            opSnippet: aOe,
            packedOpSnippet: aOe,
            supportsComplex: !0,
            cpuKernelImpl: VTe
        }),
        oOe = {
            kernelName: x3,
            backendName: "webgl",
            kernelFunc: iOe
        };

    function sOe(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs,
            a = t.logits,
            i = j$([r.dim], a.shape),
            o = M_e({
                inputs: {
                    x: a
                },
                backend: n,
                attrs: {
                    reductionIndices: i,
                    keepDims: !1
                }
            }),
            s = Z7(o.shape, i),
            u = KEe({
                inputs: {
                    x: o
                },
                backend: n,
                attrs: {
                    shape: s
                }
            }),
            c = iOe({
                inputs: {
                    a: a,
                    b: u
                },
                backend: n
            }),
            l = TRe({
                inputs: {
                    x: c
                },
                backend: n
            }),
            h = tCe({
                inputs: {
                    x: l
                },
                backend: n,
                attrs: {
                    axis: i,
                    keepDims: !1
                }
            }),
            p = KEe({
                inputs: {
                    x: h
                },
                backend: n,
                attrs: {
                    shape: s
                }
            }),
            f = nOe({
                inputs: {
                    a: l,
                    b: p
                },
                backend: n
            });
        return n.disposeIntermediateTensorInfo(o), n.disposeIntermediateTensorInfo(u), n.disposeIntermediateTensorInfo(c), n.disposeIntermediateTensorInfo(l), n.disposeIntermediateTensorInfo(h), n.disposeIntermediateTensorInfo(p), f
    }
    var uOe = {
        kernelName: s3,
        backendName: "webgl",
        kernelFunc: sOe
    };
    var cOe = {
        kernelName: m2,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.logits,
                i = r.numSamples,
                o = r.seed,
                s = r.normalized,
                u = s ? a : sOe({
                    inputs: {
                        logits: a
                    },
                    backend: n,
                    attrs: {
                        dim: a.shape.length - 1
                    }
                }),
                c = u.shape[0],
                l = u.shape[1],
                h = new tOe(c, l, i),
                p = [
                    [o]
                ],
                f = n.runWebGLProgram(h, [u], "int32", p);
            return s || n.disposeIntermediateTensorInfo(u), f
        }
    };
    var lOe = {
            kernelName: y2,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t, n = e.inputs,
                    r = e.backend,
                    a = n.x;
                if (r.shouldExecuteOnCPU([a])) {
                    var i = r.texData.get(a.dataId),
                        o = S(kTe(i.values, a.shape, a.dtype), 2),
                        s = o[0],
                        u = o[1];
                    return r.makeTensorInfo(u, a.dtype, s)
                }
                return t = k0().getBool("WEBGL_PACK_UNARY_OPERATIONS") ? new vEe(a.shape, "\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n") : new tEe(a.shape, "if (isnan(x)) return x;\n  return -x;\n"), r.runWebGLProgram(t, [a], a.dtype)
            }
        },
        hOe = qne;
    var pOe = {
            kernelName: x2,
            backendName: "webgl",
            kernelFunc: function(e) {
                z3("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.boxes,
                    i = t.scores,
                    o = r.maxOutputSize,
                    s = r.iouThreshold,
                    u = r.scoreThreshold,
                    c = n.readSync(a.dataId),
                    l = n.readSync(i.dataId),
                    h = hOe(c, l, o, s, u).selectedIndices;
                return n.makeTensorInfo([h.length], "int32", new Int32Array(h))
            }
        },
        fOe = Kne;
    var dOe = {
            kernelName: k2,
            backendName: "webgl",
            kernelFunc: function(e) {
                z3("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.boxes,
                    i = t.scores,
                    o = r.maxOutputSize,
                    s = r.iouThreshold,
                    u = r.scoreThreshold,
                    c = r.padToMaxOutputSize,
                    l = n.readSync(a.dataId),
                    h = n.readSync(i.dataId),
                    p = fOe(l, h, o, s, u, c),
                    f = p.selectedIndices,
                    d = p.validOutputs;
                return [n.makeTensorInfo([f.length], "int32", new Int32Array(f)), n.makeTensorInfo([], "int32", new Int32Array([d]))]
            }
        },
        vOe = Xne;
    var mOe = {
            kernelName: w2,
            backendName: "webgl",
            kernelFunc: function(e) {
                z3("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.boxes,
                    i = t.scores,
                    o = r.maxOutputSize,
                    s = r.iouThreshold,
                    u = r.scoreThreshold,
                    c = r.softNmsSigma,
                    l = n.readSync(a.dataId),
                    h = n.readSync(i.dataId),
                    p = vOe(l, h, o, s, u, c),
                    f = p.selectedIndices,
                    d = p.selectedScores;
                return [n.makeTensorInfo([f.length], "int32", new Int32Array(f)), n.makeTensorInfo([d.length], "float32", new Float32Array(d))]
            }
        },
        gOe = p((function e(t, n, r, a) {
            l(this, e), this.variableNames = ["indices"], this.outputShape = [t, n], this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(".concat(a, "), float(").concat(r, "),\n                      float(index == coords.y)));\n      }\n    ")
        })),
        yOe = {
            kernelName: N2,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.indices,
                    i = r.dtype,
                    o = r.depth,
                    s = r.onValue,
                    u = r.offValue,
                    c = L$(a.shape),
                    l = new gOe(c, o, s, u),
                    h = KEe({
                        inputs: {
                            x: a
                        },
                        backend: n,
                        attrs: {
                            shape: [c]
                        }
                    }),
                    p = n.runWebGLProgram(l, [h], i);
                n.disposeIntermediateTensorInfo(h);
                var f = KEe({
                    inputs: {
                        x: p
                    },
                    backend: n,
                    attrs: {
                        shape: [].concat(T(a.shape), [o])
                    }
                });
                return n.disposeIntermediateTensorInfo(p), f
            }
        };

    function bOe(e) {
        var t = e.inputs,
            n = e.backend,
            r = t.x;
        if ("complex64" === r.dtype) {
            var a = sAe({
                    inputs: {
                        input: r
                    },
                    backend: n
                }),
                i = bOe({
                    inputs: {
                        x: a
                    },
                    backend: n
                }),
                o = wAe({
                    inputs: {
                        input: r
                    },
                    backend: n
                }),
                s = bOe({
                    inputs: {
                        x: o
                    },
                    backend: n
                }),
                u = AEe({
                    inputs: {
                        real: i,
                        imag: s
                    },
                    backend: n
                });
            return n.disposeIntermediateTensorInfo(a), n.disposeIntermediateTensorInfo(i), n.disposeIntermediateTensorInfo(o), n.disposeIntermediateTensorInfo(s), u
        }
        return zRe({
            attrs: {
                shape: r.shape,
                dtype: r.dtype,
                value: "string" === r.dtype ? "" : 0
            },
            backend: n
        })
    }
    var xOe = {
        kernelName: R3,
        backendName: "webgl",
        kernelFunc: bOe
    };
    var kOe = {
        kernelName: I2,
        backendName: "webgl",
        kernelFunc: function e(t) {
            var n = t.inputs,
                r = t.backend,
                a = n.x;
            if ("string" === a.dtype) throw new Error("onesLike is not supported under string dtype");
            if ("complex64" === a.dtype) {
                var i = sAe({
                        inputs: {
                            input: a
                        },
                        backend: r
                    }),
                    o = e({
                        inputs: {
                            x: i
                        },
                        backend: r
                    }),
                    s = wAe({
                        inputs: {
                            input: a
                        },
                        backend: r
                    }),
                    u = bOe({
                        inputs: {
                            x: s
                        },
                        backend: r
                    }),
                    c = AEe({
                        inputs: {
                            real: o,
                            imag: u
                        },
                        backend: r
                    });
                return r.disposeIntermediateTensorInfo(i), r.disposeIntermediateTensorInfo(o), r.disposeIntermediateTensorInfo(s), r.disposeIntermediateTensorInfo(u), c
            }
            return zRe({
                attrs: {
                    shape: a.shape,
                    dtype: a.dtype,
                    value: 1
                },
                backend: r
            })
        }
    };
    var wOe = {
            kernelName: S2,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs.axis;
                if (1 === t.length) return CRe({
                    inputs: {
                        input: t[0]
                    },
                    backend: n,
                    attrs: {
                        dim: r
                    }
                });
                var a = t[0].shape,
                    i = t[0].dtype;
                t.forEach((function(e) {
                    D$(a, e.shape, "All tensors passed to stack must have matching shapes"), F$(i === e.dtype, (function() {
                        return "All tensors passed to stack must have matching dtypes"
                    }))
                }));
                var o = [],
                    s = SAe({
                        inputs: t.map((function(e) {
                            var t = CRe({
                                inputs: {
                                    input: e
                                },
                                backend: n,
                                attrs: {
                                    dim: r
                                }
                            });
                            return o.push(t), t
                        })),
                        backend: n,
                        attrs: {
                            axis: r
                        }
                    });
                return o.forEach((function(e) {
                    return n.disposeIntermediateTensorInfo(e)
                })), s
            }
        },
        IOe = p((function e(t, n, r) {
            l(this, e), this.variableNames = ["x"], this.customUniforms = [{
                name: "value",
                type: "float"
            }], this.outputShape = n.map((function(e, n) {
                return e[0] + t[n] + e[1]
            }));
            var a = t.length,
                i = hSe(a),
                o = n.map((function(e) {
                    return e[0]
                })).join(","),
                s = n.map((function(e, n) {
                    return e[0] + t[n]
                })).join(","),
                u = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"].slice(0, a);
            this.userCode = 1 !== a ? "\n      ".concat(i, " start = ").concat(i, "(").concat(o, ");\n      ").concat(i, " end = ").concat(i, "(").concat(s, ");\n\n      void main() {\n        ").concat(i, " outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ").concat(i, " coords = outC - start;\n          setOutput(getX(").concat(u, "));\n        }\n      }\n    ") : "\n        int start = ".concat(o, ";\n        int end = ").concat(s, ";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ")
        })),
        NOe = p((function e(t, n, r) {
            l(this, e), this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0, this.customUniforms = [{
                name: "value",
                type: "float"
            }], this.outputShape = n.map((function(e, n) {
                return e[0] + t[n] + e[1]
            }));
            for (var a = t.length, i = hSe(a), o = n.map((function(e) {
                    return e[0]
                })).join(","), s = n.map((function(e, n) {
                    return e[0] + t[n]
                })).join(","), u = XTe("rc", a), c = XTe("source", a), h = "".concat(u[a - 1], " < ").concat(this.outputShape[a - 1]), p = 1 === a ? "source" : "vec2(".concat(c.slice(-2).join(), ")"), f = ["".concat(i, " rc = outputLoc;"), "".concat(u[a - 1], " += 1;\n       if(").concat(h, ") {\n      "), 1 === a ? "" : "}\n       rc = outputLoc;\n       ".concat(u[a - 2], " += 1;\n       if(").concat(u[a - 2], " < ").concat(this.outputShape[a - 2], ") {"), 1 === a ? "" : "  ".concat(u[a - 1], " += 1;\n         if(").concat(h, ") {")], d = 1 === a ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))", v = "", m = 0, g = 1 === a ? 2 : 4; m < g; m++) v += "\n        ".concat(f[m], "\n        if (").concat(d, ") {\n          result[").concat(m, "] = float(value);\n        } else {\n          ").concat(i, " source = rc - start;\n          result[").concat(m, "] = getChannel(getX(").concat(c.join(), "), ").concat(p, ");\n        }\n      ");
            v += 1 === a ? "} " : "}}", this.userCode = "\n      const ".concat(i, " start = ").concat(i, "(").concat(o, ");\n      const ").concat(i, " end = ").concat(i, "(").concat(s, ");\n\n      void main() {\n        ").concat(i, " outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(v, "\n        setOutput(result);\n      }\n    ")
        })),
        SOe = function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x,
                i = r.paddings,
                o = r.constantValue;
            if (0 === L$(a.shape)) {
                var s = i.map((function(e, t) {
                    return e[0] + a.shape[t] + e[1]
                }));
                return zRe({
                    backend: n,
                    attrs: {
                        shape: s,
                        value: o,
                        dtype: a.dtype
                    }
                })
            }
            var u = k0().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new NOe(a.shape, i, o) : new IOe(a.shape, i, o),
                c = [
                    [o]
                ];
            return n.runWebGLProgram(u, [a], a.dtype, c)
        },
        TOe = {
            kernelName: T2,
            backendName: "webgl",
            kernelFunc: SOe
        },
        EOe = PEe({
            opSnippet: "\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",
            packedOpSnippet: "\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n"
        }),
        COe = {
            kernelName: E2,
            backendName: "webgl",
            kernelFunc: EOe
        };
    var AOe = {
        kernelName: A2,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t, n = e.inputs,
                r = e.backend,
                a = e.attrs,
                i = n.x,
                o = a.axis,
                s = a.keepDims,
                u = i.shape.length,
                c = [],
                l = j$(o, i.shape),
                h = l,
                p = $7(h, u),
                f = i;
            if (null != p && (f = rCe({
                    inputs: {
                        x: i
                    },
                    backend: r,
                    attrs: {
                        perm: p
                    }
                }), h = t9(h.length, u), c.push(f)), Q7("prod", h, u), r.shouldExecuteOnCPU([f])) {
                var d = r.texData.get(f.dataId).values,
                    v = ITe(f.shape, f.dtype, d, h),
                    m = v.outVals,
                    g = v.outShape,
                    y = v.outDtype;
                t = r.makeTensorInfo(g, y, m)
            } else {
                var b = S(J7(f.shape, h), 2),
                    x = b[0],
                    k = L$(b[1]),
                    w = KEe({
                        inputs: {
                            x: f
                        },
                        backend: r,
                        attrs: {
                            shape: [-1, k]
                        }
                    }),
                    I = ZEe(w, p5(i.dtype), "prod", r);
                t = KEe({
                    inputs: {
                        x: I
                    },
                    backend: r,
                    attrs: {
                        shape: x
                    }
                }), c.push(w), c.push(I)
            }
            if (s) {
                c.push(t);
                var N = Z7(t.shape, l);
                t = KEe({
                    inputs: {
                        x: t
                    },
                    backend: r,
                    attrs: {
                        shape: N
                    }
                })
            }
            return c.forEach((function(e) {
                return r.disposeIntermediateTensorInfo(e)
            })), t
        }
    };
    var ROe = {
        kernelName: R2,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.paramsNestedSplits,
                i = t.paramsDenseValues,
                o = t.indices,
                s = r.outputRaggedRank,
                u = a.map((function(e) {
                    return n.readSync(e.dataId)
                })),
                c = a.map((function(e) {
                    return e.shape
                })),
                l = n.readSync(i.dataId),
                h = n.readSync(o.dataId),
                p = S(NTe(u, c, l, i.shape, i.dtype, h, o.shape, s), 3),
                f = p[0],
                d = p[1],
                v = p[2],
                m = f.map((function(e) {
                    return n.makeTensorInfo([e.length], "int32", e)
                })),
                g = n.makeTensorInfo(v, i.dtype, d);
            return m.concat([g])
        }
    };
    var _Oe = {
        kernelName: _2,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = t.starts,
                a = t.limits,
                i = t.deltas,
                o = n.readSync(r.dataId),
                s = n.readSync(a.dataId),
                u = n.readSync(i.dataId),
                c = S(STe(o, r.shape, r.dtype, s, a.shape, u, i.shape), 2),
                l = c[0],
                h = c[1];
            return [n.makeTensorInfo([l.length], "int32", l), n.makeTensorInfo([h.length], r.dtype, h)]
        }
    };
    var OOe = {
            kernelName: O2,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.shape,
                    i = t.values,
                    o = t.defaultValue,
                    s = t.rowPartitionTensors,
                    u = r.rowPartitionTypes,
                    c = n.readSync(a.dataId),
                    l = n.readSync(i.dataId),
                    h = n.readSync(o.dataId),
                    p = s.map((function(e) {
                        return n.readSync(e.dataId)
                    })),
                    f = s.map((function(e) {
                        return e.shape
                    })),
                    d = S(TTe(c, a.shape, l, i.shape, i.dtype, h, o.shape, p, f, u), 2),
                    v = d[0],
                    m = d[1];
                return n.makeTensorInfo(v, i.dtype, m)
            }
        },
        FOe = function(e) {
            var t = e.backend,
                n = e.attrs,
                r = n.start,
                a = n.stop,
                i = n.step,
                o = n.dtype,
                s = ETe(r, a, i, o);
            return t.makeTensorInfo([s.length], o, s)
        },
        DOe = {
            kernelName: F2,
            backendName: "webgl",
            kernelFunc: FOe
        },
        MOe = zEe({
            opSnippet: "return 1.0 / x;"
        }),
        LOe = {
            kernelName: M2,
            backendName: "webgl",
            kernelFunc: MOe
        },
        zOe = zEe({
            opSnippet: "if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",
            packedOpSnippet: "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"
        }),
        POe = {
            kernelName: L2,
            backendName: "webgl",
            kernelFunc: zOe
        },
        BOe = zEe({
            opSnippet: "if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",
            packedOpSnippet: "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"
        }),
        WOe = {
            kernelName: V2,
            backendName: "webgl",
            kernelFunc: BOe
        },
        UOe = p((function e(t, n, r, a, i) {
            l(this, e), this.variableNames = ["A"], this.outputShape = [];
            var o = S(t, 4),
                s = o[0],
                u = o[1],
                c = o[2],
                h = o[3];
            this.outputShape = [s, n, r, h];
            var p, f = [a && n > 1 ? u - 1 : u, a && r > 1 ? c - 1 : c],
                d = [a && n > 1 ? n - 1 : n, a && r > 1 ? r - 1 : r];
            p = i ? "(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)" : "vec2(yRC) * effectiveInputOverOutputRatioRC", this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(f[0] / d[0], ",\n          ").concat(f[1] / d[1], ");\n      const vec2 inputShapeRC = vec2(").concat(u, ".0, ").concat(c, ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(p, ";\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ")
        })),
        VOe = p((function e(t, n, r, a, i) {
            l(this, e), this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [];
            var o = S(t, 4),
                s = o[0],
                u = o[1],
                c = o[2],
                h = o[3];
            this.outputShape = [s, n, r, h];
            var p, f = [a && n > 1 ? u - 1 : u, a && r > 1 ? c - 1 : c],
                d = [a && n > 1 ? n - 1 : n, a && r > 1 ? r - 1 : r];
            p = i ? "(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)" : "vec3(yRC) * effectiveInputOverOutputRatioRC", this.userCode = "\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(f[0] / d[0], ",\n          ").concat(f[1] / d[1], ",\n          ").concat(f[1] / d[1], ");\n      const vec3 inputShapeRC = vec3(").concat(u, ".0, ").concat(c, ".0,\n                                     ").concat(c, ".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(p, ";\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(h - 1, ";\n        bool hasNextRow = coords.z < ").concat(r - 1, ";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ")
        }));
    var GOe = {
            kernelName: W2,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.images,
                    i = r.alignCorners,
                    o = r.halfPixelCenters,
                    s = S(r.size, 2),
                    u = s[0],
                    c = s[1],
                    l = k0().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new VOe(a.shape, u, c, i, o) : new UOe(a.shape, u, c, i, o);
                return n.runWebGLProgram(l, [a], "float32")
            }
        },
        jOe = p((function e(t, n, r) {
            l(this, e), this.variableNames = ["dy"], this.outputShape = [], this.outputShape = n;
            var a = S(n, 3),
                i = a[1],
                o = a[2],
                s = S(t, 3),
                u = s[1],
                c = s[2],
                h = [r && u > 1 ? i - 1 : i, r && c > 1 ? o - 1 : o],
                p = [r && u > 1 ? u - 1 : u, r && c > 1 ? c - 1 : c],
                f = h[0] / p[0],
                d = h[1] / p[1],
                v = 1 / f,
                m = 1 / d,
                g = 2 * Math.ceil(v) + 2,
                y = 2 * Math.ceil(m) + 2;
            this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(f, ");\n        const float widthScale = float(").concat(d, ");\n\n        const float invHeightScale = float(").concat(v, ");\n        const float invWidthScale = float(").concat(m, ");\n\n        const int winHeight = int(").concat(g, ");\n        const int winWidth = int(").concat(y, ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(u, ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(c, ") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ").concat(i - 1, ".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ").concat(o - 1, ".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")
        }));
    var HOe = {
            kernelName: U2,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.images,
                    i = t.dy,
                    o = r.alignCorners,
                    s = new jOe(i.shape, a.shape, o);
                return n.runWebGLProgram(s, [i], i.dtype)
            }
        },
        qOe = p((function e(t, n, r, a, i) {
            l(this, e), this.variableNames = ["A"], this.outputShape = [];
            var o = S(t, 4),
                s = o[0],
                u = o[1],
                c = o[2],
                h = o[3];
            this.outputShape = [s, n, r, h];
            var p, f = [a && n > 1 ? u - 1 : u, a && r > 1 ? c - 1 : c],
                d = [a && n > 1 ? n - 1 : n, a && r > 1 ? r - 1 : r],
                v = a ? "0.5" : "0.0";
            p = i ? "max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))" : "vec2(yRC) * effectiveInputOverOutputRatioRC", this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(f[0] / d[0], ",\n          ").concat(f[1] / d[1], ");\n      const vec2 inputShapeRC = vec2(").concat(u, ".0, ").concat(c, ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(p, ";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(v, ")));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ")
        })),
        KOe = p((function e(t, n, r, a, i) {
            l(this, e), this.variableNames = ["A"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [];
            var o = S(t, 4),
                s = o[0],
                u = o[1],
                c = o[2],
                h = o[3];
            this.outputShape = [s, n, r, h];
            var p, f = [a && n > 1 ? u - 1 : u, a && r > 1 ? c - 1 : c],
                d = [a && n > 1 ? n - 1 : n, a && r > 1 ? r - 1 : r],
                v = a ? "0.5" : "0.0";
            p = i ? "max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))" : "vec3(yRC) * effectiveInputOverOutputRatioRC", this.userCode = "\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(f[0] / d[0], ",\n          ").concat(f[1] / d[1], ",\n          ").concat(f[1] / d[1], ");\n      const vec3 inputShapeRC = vec3(").concat(u, ".0, ").concat(c, ".0,\n                                     ").concat(c, ".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(p, ";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(v, ")));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(h - 1, ";\n        bool hasNextRow = coords.z < ").concat(r - 1, ";\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    ")
        }));
    var XOe = {
            kernelName: P2,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.images,
                    i = r.alignCorners,
                    o = r.halfPixelCenters,
                    s = S(r.size, 2),
                    u = s[0],
                    c = s[1],
                    l = k0().getBool("WEBGL_PACK_IMAGE_OPERATIONS") ? new KOe(a.shape, u, c, i, o) : new qOe(a.shape, u, c, i, o);
                return n.runWebGLProgram(l, [a], a.dtype)
            }
        },
        YOe = p((function e(t, n, r) {
            l(this, e), this.variableNames = ["dy"], this.outputShape = [], this.outputShape = n;
            var a = S(n, 3),
                i = a[1],
                o = a[2],
                s = S(t, 3),
                u = s[1],
                c = s[2],
                h = [r && u > 1 ? i - 1 : i, r && c > 1 ? o - 1 : o],
                p = [r && u > 1 ? u - 1 : u, r && c > 1 ? c - 1 : c],
                f = h[0] / p[0],
                d = h[1] / p[1],
                v = 1 / f,
                m = 1 / d,
                g = 2 * Math.ceil(v) + 2,
                y = 2 * Math.ceil(m) + 2;
            this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(f, ");\n        const float widthScale = float(").concat(d, ");\n\n        const float invHeightScale = float(").concat(v, ");\n        const float invWidthScale = float(").concat(m, ");\n\n        const int winHeight = int(").concat(g, ");\n        const int winWidth = int(").concat(y, ");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(u, ") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(c, ") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(").concat(h[0], ") *\n                (float(dyR) / float(").concat(p[0], "));\n\n            float sourceFracCol =\n                float(").concat(h[1], ") *\n                  (float(dyC) / float(").concat(p[1], "));\n\n            int sourceNearestRow = int(min(\n                float(int(").concat(i, ") - 1),\n                ").concat(r, " ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(").concat(o, ") - 1),\n                ").concat(r, " ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")
        }));
    var JOe = {
            kernelName: B2,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.images,
                    i = t.dy,
                    o = r.alignCorners,
                    s = new YOe(i.shape, a.shape, o);
                return n.runWebGLProgram(s, [i], i.dtype)
            }
        },
        ZOe = p((function e(t, n) {
            l(this, e), this.variableNames = ["x"];
            var r = t.length;
            if (r > 4) throw new Error("WebGL backend: Reverse of rank-".concat(r, " tensor is not yet supported"));
            if (this.outputShape = t, 1 !== r) {
                var a = t.map((function(e, r) {
                        return function(e) {
                            return -1 !== n.indexOf(e) && 1 !== t[e] ? "".concat(t[e], " - coords[").concat(e, "] - 1") : "coords[".concat(e, "]")
                        }(r)
                    })).join(","),
                    i = hSe(r);
                this.userCode = "\n      void main() {\n        ".concat(i, " coords = getOutputCoords();\n        setOutput(getX(").concat(a, "));\n      }\n    ")
            } else this.userCode = "\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(".concat(t[0], " - coord - 1));\n        }\n      ")
        })),
        QOe = p((function e(t, n) {
            l(this, e), this.variableNames = ["x"], this.packedInputs = !0, this.packedOutput = !0;
            var r = t.length;
            if (r > 4) throw new Error("WebGL backend: Reverse of rank-".concat(r, " tensor is not yet supported"));
            this.outputShape = t;
            var a = XTe("rc", r),
                i = "".concat(a[r - 1], " + 1 < ").concat(this.outputShape[r - 1]),
                o = "".concat(a[r - 2], " + 1 < ").concat(this.outputShape[r - 2]),
                s = hSe(r);

            function u(e) {
                var r = t.map((function(r, a) {
                        return function(e, r) {
                            return -1 !== n.indexOf(e) && 1 !== t[e] ? "".concat(t[e], " - ").concat(r[e], " - 1") : "".concat(r[e])
                        }(a, e)
                    })),
                    a = r.join(","),
                    i = r.slice(-2).join(",");
                return "getChannel(getX(".concat(a, "), vec2(").concat(i, "))")
            }
            this.userCode = 1 === r ? "\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(".concat(t[0], " - rc - 1),\n            ").concat(t[0], " - rc - 1);\n          if(").concat(i, "){\n              result.g = getChannel(getX(").concat(t[0], " - (rc  + 1) - 1),\n                ").concat(t[0], " - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      ") : "\n        void main() {\n          ".concat(s, " rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ").concat(function(e) {
                return u(e)
            }(a.slice()), ";\n          if(").concat(i, "){\n            result.g = ").concat(function(e) {
                return e[r - 1] = "(" + e[r - 1] + " + 1)", u(e)
            }(a.slice()), ";\n          }\n          if(").concat(o, ") {\n            result.b = ").concat(function(e) {
                return e[r - 2] = "(" + e[r - 2] + " + 1)", u(e)
            }(a.slice()), ";\n            if(").concat(i, ") {\n              result.a = ").concat(function(e) {
                return e[r - 1] = "(" + e[r - 1] + " + 1)", e[r - 2] = "(" + e[r - 2] + " + 1)", u(e)
            }(a.slice()), ";\n            }\n          }\n          setOutput(result);\n        }\n    ")
        }));
    var $Oe = {
            kernelName: G2,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.dims,
                    o = a.shape.length,
                    s = j$(i, a.shape);
                if (0 === o) return EEe({
                    inputs: {
                        x: a
                    },
                    backend: n
                });
                var u = k0().getBool("WEBGL_PACK_ARRAY_OPERATIONS") ? new QOe(a.shape, s) : new ZOe(a.shape, s);
                return n.runWebGLProgram(u, [a], a.dtype)
            }
        },
        eFe = p((function e(t, n) {
            l(this, e), this.variableNames = ["Image"], this.outputShape = [], this.customUniforms = [{
                name: "params",
                type: "vec4"
            }];
            var r = t[1],
                a = t[2];
            this.outputShape = t;
            var i = "";
            i = "number" == typeof n ? "float outputValue = ".concat(n.toFixed(2), ";") : "\n        vec3 fill = vec3(".concat(n.join(","), ");\n        float outputValue = fill[coords[3]];"), this.userCode = "\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ".concat(i, "\n          if(coordX >= 0 && coordX < ").concat(a, " && coordY >= 0 && coordY < ").concat(r, ") {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")
        })),
        tFe = {
            kernelName: F3,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.attrs,
                    r = e.backend,
                    a = t.image,
                    i = n.radians,
                    o = n.fillValue,
                    s = n.center,
                    u = r,
                    c = new eFe(a.shape, o),
                    l = S(pie(s, a.shape[1], a.shape[2]), 2),
                    h = [
                        [l[0], l[1], Math.sin(i), Math.cos(i)]
                    ];
                return u.runWebGLProgram(c, [a], a.dtype, h)
            }
        },
        nFe = zEe({
            opSnippet: "\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"
        }),
        rFe = {
            kernelName: j2,
            backendName: "webgl",
            kernelFunc: nFe
        },
        aFe = zEe({
            opSnippet: "return inversesqrt(x);",
            cpuKernelImpl: CTe
        }),
        iFe = {
            kernelName: H2,
            backendName: "webgl",
            kernelFunc: aFe
        },
        oFe = p((function e(t, n, r, a, i, o) {
            var s = arguments.length > 7 && void 0 !== arguments[7] && arguments[7];
            l(this, e), this.variableNames = ["updates", "indices", "defaultValue"], this.outputShape = o;
            var u = hSe(i.length),
                c = hSe(o.length),
                h = "";
            1 === r ? h = "i" : 2 === r && (h = "i, j");
            var p = "getIndices(".concat(h, ")"),
                f = "";
            1 === a ? f = "i" : 2 === a && (f = "i, coords[1]");
            var d = "getUpdates(".concat(f, ")"),
                v = "";
            s && (v = "coords[0], coords[1]");
            var m = "getDefaultValue(".concat(v, ")"),
                g = n > 1 ? "strides[j]" : "strides";
            this.userCode = "\n        ".concat(u, " strides = ").concat(u, "(").concat(i, ");\n\n        void main() {\n          ").concat(c, " coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ").concat(t, "; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ").concat(n, "; j++) {\n              int index = round(").concat(p, ");\n              flattenedIndex += index * ").concat(g, ";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ").concat(d, ";\n              found = true;\n            }\n          }\n          setOutput(mix(").concat(m, ", sum, float(found)));\n        }\n      ")
        })),
        sFe = p((function e(t, n, r, a, i, o) {
            var s = arguments.length > 7 && void 0 !== arguments[7] && arguments[7];
            l(this, e), this.variableNames = ["updates", "indices", "defaultValue"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = o;
            var u = hSe(i.length),
                c = hSe(o.length),
                h = "";
            1 === r ? h = "i" : 2 === r && (h = "i, j");
            var p = "getIndices(".concat(h, ")"),
                f = "";
            1 === a ? f = "i" : 2 === a && (f = "i, coords[1]");
            var d = "getUpdates(".concat(f, ")"),
                v = "";
            s && (v = "coords[0], coords[1]");
            var m = "getDefaultValue(".concat(v, ")"),
                g = n > 1 ? "strides[j]" : "strides",
                y = n > 1 ? "strides[j + 1]" : "strides";
            this.userCode = "\n        ".concat(u, " strides = ").concat(u, "(").concat(i, ");\n\n        void main() {\n          ").concat(c, " coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ").concat(t, "; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ").concat(n, "; j+=2) {\n              ivec4 index = round(").concat(p, ");\n              flattenedIndex += index.xz * ").concat(g, ";\n              if (j + 1 < ").concat(n, ") {\n                flattenedIndex += index.yw * ").concat(y, ";\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ").concat(d, ";\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(").concat(m, ", sum, found));\n        }\n      ")
        }));
    var uFe = {
            kernelName: q2,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.indices,
                    i = t.updates,
                    o = r.shape,
                    s = Jte(0, a, o),
                    u = s.sliceRank,
                    c = s.numUpdates,
                    l = s.sliceSize,
                    h = s.strides,
                    p = s.outputSize,
                    f = [p / l, l];
                if (0 === p) return n.makeTensorInfo(o, a.dtype);
                var d, v = KEe({
                        inputs: {
                            x: a
                        },
                        backend: n,
                        attrs: {
                            shape: [c, u]
                        }
                    }),
                    m = KEe({
                        inputs: {
                            x: i
                        },
                        backend: n,
                        attrs: {
                            shape: [c, l]
                        }
                    }),
                    g = n.makeTensorInfo([], "float32", new Float32Array([0]));
                d = k0().getBool("WEBGL_PACK") ? new sFe(c, u, v.shape.length, m.shape.length, h, f) : new oFe(c, u, v.shape.length, m.shape.length, h, f);
                var y = n.runWebGLProgram(d, [m, v, g], m.dtype),
                    b = KEe({
                        inputs: {
                            x: y
                        },
                        backend: n,
                        attrs: {
                            shape: o
                        }
                    });
                return n.disposeIntermediateTensorInfo(v), n.disposeIntermediateTensorInfo(m), n.disposeIntermediateTensorInfo(y), n.disposeIntermediateTensorInfo(g), b
            }
        },
        cFe = p((function e(t, n, r, a) {
            l(this, e), this.variableNames = ["sortedSequence", "values"], this.customUniforms = [{
                name: "numInputs",
                type: "int"
            }], this.outputShape = [t, r];
            var i = "for (int i = 0; i < ".concat(Math.ceil(Math.log2(n + 1)), "; ++i) { if (left >= right) break;"),
                o = 2 === k0().getNumber("WEBGL_VERSION") ? "while (left < right) {" : i,
                s = "left" === a ? "<" : "<=";
            this.userCode = "\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ".concat(o, "\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ").concat(s, " value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     ")
        }));
    var lFe = {
            kernelName: X2,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.sortedSequence,
                    i = t.values,
                    o = r.side,
                    s = new cFe(a.shape[0], a.shape[1], i.shape[1], o),
                    u = [
                        [a.shape[1]]
                    ];
                return n.runWebGLProgram(s, [a, i], "int32", u)
            }
        },
        hFe = p((function e(t, n, r) {
            var a, i;
            if (l(this, e), this.variableNames = ["c", "a", "b"], this.outputShape = n, r > 4) throw Error("Where for rank ".concat(r, " is not yet supported"));
            if (1 === r) i = "resRC", a = "resRC";
            else {
                for (var o = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], s = [], u = [], c = 0; c < n.length; c++) u.push("".concat(o[c])), c < t && s.push("".concat(o[c]));
                a = s.join(), i = u.join()
            }
            var h = hSe(r);
            this.userCode = "\n      void main() {\n        ".concat(h, " resRC = getOutputCoords();\n        float cVal = getC(").concat(a, ");\n        if (cVal >= 1.0) {\n          setOutput(getA(").concat(i, "));\n        } else {\n          setOutput(getB(").concat(i, "));\n        }\n      }\n    ")
        }));
    var pFe = {
            kernelName: Y2,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = t.condition,
                    a = t.t,
                    i = t.e,
                    o = new hFe(r.shape.length, a.shape, a.shape.length);
                return n.runWebGLProgram(o, [r, a, i], h5(a.dtype, i.dtype))
            }
        },
        fFe = zEe({
            opSnippet: "\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ".concat(yie, ";\n  float scale = ").concat(bie, ";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n")
        }),
        dFe = {
            kernelName: J2,
            backendName: "webgl",
            kernelFunc: fFe
        },
        vFe = zEe({
            opSnippet: "if (isnan(x)) return x;\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",
            packedOpSnippet: "\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",
            cpuKernelImpl: RTe
        }),
        mFe = {
            kernelName: t3,
            backendName: "webgl",
            kernelFunc: vFe
        },
        gFe = zEe({
            opSnippet: "\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"
        }),
        yFe = {
            kernelName: e3,
            backendName: "webgl",
            kernelFunc: gFe
        },
        bFe = zEe({
            opSnippet: "if (isnan(x)) return x;\n  return sin(x);\n",
            packedOpSnippet: "\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(SEe, "\n  return result;\n")
        }),
        xFe = {
            kernelName: Q2,
            backendName: "webgl",
            kernelFunc: bFe
        },
        kFe = zEe({
            opSnippet: "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"
        }),
        wFe = {
            kernelName: $2,
            backendName: "webgl",
            kernelFunc: kFe
        },
        IFe = zEe({
            opSnippet: "\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"
        }),
        NFe = {
            kernelName: n3,
            backendName: "webgl",
            kernelFunc: IFe
        },
        SFe = {
            kernelName: i3,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.blockShape,
                    o = r.paddings;
                F$(a.shape.length <= 4, (function() {
                    return "spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"
                }));
                var s = i.reduce((function(e, t) {
                        return e * t
                    })),
                    u = [
                        [0, 0]
                    ];
                u.push.apply(u, T(o));
                for (var c = 1 + i.length; c < a.shape.length; ++c) u.push([0, 0]);
                var l = [],
                    h = SOe({
                        inputs: {
                            x: a
                        },
                        backend: n,
                        attrs: {
                            paddings: u,
                            constantValue: 0
                        }
                    }),
                    p = fie(h.shape, i, s, !1),
                    f = die(p.length, i.length, !1),
                    d = vie(h.shape, i, s, !1),
                    v = KEe({
                        inputs: {
                            x: h
                        },
                        backend: n,
                        attrs: {
                            shape: p
                        }
                    }),
                    m = rCe({
                        inputs: {
                            x: v
                        },
                        backend: n,
                        attrs: {
                            perm: f
                        }
                    }),
                    g = KEe({
                        inputs: {
                            x: m
                        },
                        backend: n,
                        attrs: {
                            shape: d
                        }
                    });
                return l.push(h), l.push(v), l.push(m), l.forEach((function(e) {
                    return n.disposeIntermediateTensorInfo(e)
                })), g
            }
        };
    var TFe = {
        kernelName: u3,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = t.indices,
                a = t.values,
                i = t.denseShape,
                o = t.defaultValue;
            if (1 !== i.shape.length) throw new Error("Dense shape must be a vector, saw:\n         ".concat(i.shape));
            if (2 !== r.shape.length) throw new Error("Indices must be a matrix, saw:\n         ".concat(r.shape));
            if (1 !== a.shape.length) throw new Error("Values must be a vector, saw:\n         ".concat(a.shape));
            if (0 !== o.shape.length) throw new Error("Default value must be a scalar, saw:\n        ".concat(o.shape));
            var s = n.readSync(r.dataId),
                u = n.readSync(a.dataId),
                c = n.readSync(i.dataId),
                l = n.readSync(o.dataId)[0],
                h = S(FTe(s, r.shape, r.dtype, u, a.dtype, c, l), 5),
                p = h[0],
                f = h[1],
                d = h[2],
                v = h[3],
                m = h[4];
            return [n.makeTensorInfo(f, r.dtype, p), n.makeTensorInfo([f[0]], a.dtype, d), n.makeTensorInfo([v.length], "bool", new Uint8Array(v.map((function(e) {
                return Number(e)
            })))), n.makeTensorInfo([m.length], r.dtype, new Int32Array(m))]
        }
    };
    var EFe = {
        kernelName: c3,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = t.inputIndices,
                a = t.inputShape,
                i = t.newShape;
            if (2 !== r.shape.length) throw new Error("Input indices should be a matrix but received shape ".concat(r.shape));
            if (1 !== a.shape.length) throw new Error("Input shape should be a vector but received shape ".concat(a.shape));
            if (1 !== i.shape.length) throw new Error("Target shape should be a vector but received shape ".concat(i.shape));
            var o = Array.from(n.readSync(a.dataId)),
                s = n.readSync(r.dataId),
                u = Array.from(n.readSync(i.dataId)),
                c = S(DTe(s, r.shape, r.dtype, o, u), 3),
                l = c[0],
                h = c[1],
                p = c[2];
            return [n.makeTensorInfo(h, r.dtype, l), n.makeTensorInfo([p.length], i.dtype, new Int32Array(p))]
        }
    };
    var CFe = {
        kernelName: l3,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = t.data,
                a = t.indices,
                i = t.segmentIds;
            if (r.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
            if (1 !== a.shape.length) throw new Error("Indices should be a vector but received shape\n              ".concat(a.shape));
            if (1 !== i.shape.length) throw new Error("Segment ids should be a vector but received shape\n              ".concat(i.shape));
            var o = n.readSync(r.dataId),
                s = n.readSync(a.dataId),
                u = n.readSync(i.dataId),
                c = S(MTe(o, r.shape, r.dtype, s, u, !0), 2),
                l = c[0],
                h = c[1];
            return n.makeTensorInfo(h, r.dtype, l)
        }
    };
    var AFe = {
        kernelName: h3,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = t.data,
                a = t.indices,
                i = t.segmentIds;
            if (r.shape.length < 1) throw new Error("Data should be at least 1 dimensional but received scalar");
            if (1 !== a.shape.length) throw new Error("Indices should be a vector but received shape\n             ".concat(a.shape));
            if (1 !== i.shape.length) throw new Error("Segment ids should be a vector but received shape\n             ".concat(i.shape));
            var o = n.readSync(r.dataId),
                s = n.readSync(a.dataId),
                u = n.readSync(i.dataId),
                c = S(MTe(o, r.shape, r.dtype, s, u), 2),
                l = c[0],
                h = c[1];
            return n.makeTensorInfo(h, r.dtype, l)
        }
    };
    var RFe = {
        kernelName: p3,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.sparseIndices,
                i = t.sparseValues,
                o = t.defaultValue,
                s = r.outputShape,
                u = Jte(0, a, s),
                c = u.sliceRank,
                l = u.numUpdates,
                h = u.sliceSize,
                p = u.strides,
                f = u.outputSize;
            if ("string" === i.dtype) {
                var d = n.bufferSync(a),
                    v = n.bufferSync(i),
                    m = W4(n.readSync(o.dataId)[0]),
                    g = ATe(d, v, s, f, h, l, c, p, m, false);
                return n.makeTensorInfo(s, g.dtype, g.values)
            }
            var y = new oFe(l, c, a.shape.length, i.shape.length, p, [f, 1], false),
                b = n.runWebGLProgram(y, [i, a, o], i.dtype),
                x = KEe({
                    inputs: {
                        x: b
                    },
                    backend: n,
                    attrs: {
                        shape: s
                    }
                });
            return n.disposeIntermediateTensorInfo(b), x
        }
    };
    var _Fe = {
            kernelName: o3,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.numOrSizeSplits,
                    o = j$(r.axis, a.shape)[0],
                    s = Vie(a, i, o),
                    u = a.shape.length,
                    c = new Array(u).fill(0),
                    l = a.shape.slice();
                return s.map((function(e) {
                    var t = T(l);
                    t[o] = e;
                    var r = $Ce({
                        inputs: {
                            x: a
                        },
                        backend: n,
                        attrs: {
                            begin: c,
                            size: t
                        }
                    });
                    return c[o] += e, r
                }))
            }
        },
        OFe = "return sqrt(x);",
        FFe = zEe({
            opSnippet: OFe,
            packedOpSnippet: OFe,
            cpuKernelImpl: LTe
        }),
        DFe = {
            kernelName: r3,
            backendName: "webgl",
            kernelFunc: FFe
        },
        MFe = {
            kernelName: d3,
            backendName: "webgl",
            kernelFunc: zEe({
                opSnippet: "return x * x;"
            })
        },
        LFe = "return (a - b) * (a - b);",
        zFe = PEe({
            opSnippet: LFe,
            packedOpSnippet: LFe
        }),
        PFe = {
            kernelName: f3,
            backendName: "webgl",
            kernelFunc: zFe
        };
    var BFe = {
        kernelName: v3,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.x;
            if ("string" !== a.dtype) throw new Error("Input must be of datatype string");
            var i = aoe(n.readSync(a.dataId)),
                o = zTe(i, "string", r);
            return n.makeTensorInfo(a.shape, "string", o)
        }
    };
    var WFe = {
            kernelName: _3,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.attrs,
                    r = e.backend,
                    a = t.x,
                    i = nEe + "\n    return x > 0.0 ? 1.0 : float(".concat(n.alpha, ");\n  "),
                    o = new tEe(a.shape, i);
                return r.runWebGLProgram(o, [a], a.dtype)
            }
        },
        UFe = p((function e(t, n, r) {
            l(this, e), this.variableNames = ["x"], this.outputShape = r;
            var a = r.length,
                i = hSe(r.length),
                o = hSe(r.length),
                s = "";
            if (1 === a) s = "coords * strides + begin";
            else {
                var u = 0;
                s = r.map((function(e, t) {
                    return u++, 1 === r.length ? "coords * strides[".concat(t, "] + begin[").concat(t, "]") : "coords[".concat(u - 1, "] * strides[").concat(t, "] + begin[").concat(t, "]")
                })).join(",")
            }
            this.userCode = "\n      ".concat(i, " begin = ").concat(i, "(").concat(t, ");\n      ").concat(i, " strides = ").concat(i, "(").concat(n, ");\n\n      void main() {\n        ").concat(o, " coords = getOutputCoords();\n        setOutput(getX(").concat(s, "));\n      }\n    ")
        }));
    var VFe = {
        kernelName: m3,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t, n = e.inputs,
                r = e.backend,
                a = e.attrs,
                i = n.x,
                o = a.begin,
                s = a.end,
                u = a.strides,
                c = a.beginMask,
                l = a.endMask,
                h = a.ellipsisMask,
                p = a.newAxisMask,
                f = a.shrinkAxisMask,
                d = Jae(i.shape, o, s, u, c, l, h, p, f),
                v = d.finalShapeSparse,
                m = d.finalShape,
                g = d.isIdentity,
                y = d.sliceDim0,
                b = d.isSimpleSlice,
                x = d.begin,
                k = d.end,
                w = d.strides;
            if (g) t = KEe({
                inputs: {
                    x: i
                },
                backend: r,
                attrs: {
                    shape: m
                }
            });
            else if (y || b) {
                F$(i.shape.length >= 1, (function() {
                    return "Input must have rank at least 1, got: ".concat(i.shape.length)
                }));
                var I = Pae(x, k, w),
                    N = $Ce({
                        inputs: {
                            x: i
                        },
                        backend: r,
                        attrs: {
                            begin: x,
                            size: I
                        }
                    });
                t = KEe({
                    inputs: {
                        x: N
                    },
                    backend: r,
                    attrs: {
                        shape: m
                    }
                }), r.disposeIntermediateTensorInfo(N)
            } else {
                if (r.shouldExecuteOnCPU([i])) {
                    var S = r.readSync(i.dataId),
                        T = l8(i.shape, i.dtype, S),
                        E = PTe(v, T, w, x);
                    t = r.makeTensorInfo(m, i.dtype, E.values)
                } else {
                    var C = new UFe(x, w, v);
                    t = r.runWebGLProgram(C, [i], i.dtype)
                }
            }
            var A = KEe({
                inputs: {
                    x: t
                },
                backend: r,
                attrs: {
                    shape: m
                }
            });
            return r.disposeIntermediateTensorInfo(t), A
        }
    };
    var GFe = {
        kernelName: g3,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = r.separator,
                i = r.nGramWidths,
                o = r.leftPad,
                s = r.rightPad,
                u = r.padWidth,
                c = r.preserveShortSequences,
                l = t.data,
                h = t.dataSplits,
                p = n.readSync(l.dataId),
                f = n.readSync(h.dataId),
                d = S(BTe(p, f, a, i, o, s, u, c), 2),
                v = d[0],
                m = d[1];
            return [n.makeTensorInfo([v.length], "string", v), n.makeTensorInfo(h.shape, "int32", m)]
        }
    };
    var jFe = {
        kernelName: y3,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs.skipEmpty,
                a = t.input,
                i = t.delimiter;
            if ("string" !== a.dtype) throw new Error("Input must be of datatype string");
            if (1 !== a.shape.length) throw new Error("Input must be a vector, got shape: ".concat(a.shape));
            if (0 !== i.shape.length) throw new Error("Delimiter must be a scalar, got shape: ".concat(i.shape));
            var o = n.readSync(a.dataId),
                s = n.readSync(i.dataId)[0],
                u = S(WTe(o, s, r), 3),
                c = u[0],
                l = u[1],
                h = u[2],
                p = l.length;
            return [n.makeTensorInfo([p, 2], "int32", c), n.makeTensorInfo([p], "string", l), n.makeTensorInfo([2], "int32", new Int32Array(h))]
        }
    };
    var HFe = {
            kernelName: b3,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs.numBuckets,
                    a = t.input;
                if ("string" !== a.dtype) throw new Error("Input must be of datatype string");
                if (r <= 0) throw new Error("Number of buckets must be at least 1");
                var i = n.readSync(a.dataId),
                    o = UTe(i, r);
                return n.makeTensorInfo(a.shape, "int32", o)
            }
        },
        qFe = zEe({
            opSnippet: "return tan(x);"
        }),
        KFe = {
            kernelName: k3,
            backendName: "webgl",
            kernelFunc: qFe
        },
        XFe = zEe({
            opSnippet: "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"
        }),
        YFe = {
            kernelName: w3,
            backendName: "webgl",
            kernelFunc: XFe
        };
    var JFe = {
            kernelName: K2,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.tensor,
                    i = t.indices,
                    o = t.updates;
                ! function(e) {
                    if (null == e) throw new TypeError("Cannot destructure " + e)
                }(r);
                var s = Jte(0, i, a.shape),
                    u = s.sliceRank,
                    c = s.numUpdates,
                    l = s.sliceSize,
                    h = s.strides,
                    p = s.outputSize,
                    f = [p / l, l];
                if (0 === p) return n.makeTensorInfo(a.shape, i.dtype);
                var d = KEe({
                        inputs: {
                            x: i
                        },
                        backend: n,
                        attrs: {
                            shape: [c, u]
                        }
                    }),
                    v = KEe({
                        inputs: {
                            x: o
                        },
                        backend: n,
                        attrs: {
                            shape: [c, l]
                        }
                    }),
                    m = KEe({
                        inputs: {
                            x: a
                        },
                        backend: n,
                        attrs: {
                            shape: f
                        }
                    }),
                    g = new oFe(c, u, d.shape.length, v.shape.length, h, f, !1, !0),
                    y = n.runWebGLProgram(g, [v, d, m], m.dtype),
                    b = KEe({
                        inputs: {
                            x: y
                        },
                        backend: n,
                        attrs: {
                            shape: a.shape
                        }
                    });
                return n.disposeIntermediateTensorInfo(d), n.disposeIntermediateTensorInfo(v), n.disposeIntermediateTensorInfo(m), n.disposeIntermediateTensorInfo(y), b
            }
        },
        ZFe = p((function e(t, n) {
            l(this, e), this.variableNames = ["A"];
            for (var r = new Array(t.length), a = 0; a < r.length; a++) r[a] = t[a] * n[a];
            this.outputShape = r, this.rank = r.length;
            var i = hSe(this.rank),
                o = function(e) {
                    var t = e.length;
                    if (t > 5) throw Error("Tile for rank ".concat(t, " is not yet supported"));
                    if (1 === t) return "imod(resRC, ".concat(e[0], ")");
                    for (var n = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"], r = [], a = 0; a < e.length; a++) r.push("imod(".concat(n[a], ", ").concat(e[a], ")"));
                    return r.join()
                }(t);
            this.userCode = "\n      void main() {\n        ".concat(i, " resRC = getOutputCoords();\n        setOutput(getA(").concat(o, "));\n      }\n    ")
        }));

    function QFe(e) {
        var t = e.inputs,
            n = e.backend,
            r = e.attrs,
            a = t.x,
            i = r.reps;
        if ("string" === a.dtype || a.shape.length > 5) {
            var o = n.readSync(a.dataId),
                s = "string" === a.dtype ? o.map((function(e) {
                    return W4(e)
                })) : o,
                u = l8(a.shape, a.dtype, s),
                c = GTe(u, i);
            return n.makeTensorInfo(c.shape, c.dtype, c.values)
        }
        var l = new ZFe(a.shape, i);
        return n.runWebGLProgram(l, [a], a.dtype)
    }
    var $Fe = {
            kernelName: I3,
            backendName: "webgl",
            kernelFunc: QFe
        },
        eDe = p((function e(t) {
            l(this, e), this.variableNames = ["x", "indices"], this.customUniforms = [{
                name: "n",
                type: "int"
            }, {
                name: "firstPass",
                type: "int"
            }, {
                name: "negativeInf",
                type: "float"
            }, {
                name: "dir",
                type: "int"
            }, {
                name: "inc",
                type: "int"
            }], this.outputShape = t, this.userCode = "\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "
        })),
        tDe = p((function e(t) {
            l(this, e), this.variableNames = ["x", "indices"], this.customUniforms = [{
                name: "n",
                type: "int"
            }, {
                name: "firstPass",
                type: "int"
            }, {
                name: "k",
                type: "int"
            }], this.outputShape = t, this.userCode = "\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "
        }));

    function nDe(e, t) {
        null !== t && e.disposeIntermediateTensorInfo(t)
    }

    function rDe(e) {
        for (var t = 1; t < e;) t *= 2;
        return t
    }
    var aDe = {
            kernelName: N3,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = r.k,
                    o = r.sorted,
                    s = k0().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),
                    u = k0().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),
                    c = a.shape,
                    l = c[c.length - 1];
                if (n.shouldExecuteOnCPU([a]) || l < s || i > u) {
                    var h = n.readSync(a.dataId),
                        p = S(jTe(h, c, a.dtype, i, o), 2),
                        f = p[0],
                        d = p[1];
                    return [n.makeTensorInfo(f.shape, f.dtype, f.values), n.makeTensorInfo(d.shape, d.dtype, d.values)]
                }
                if (0 === i) return c[c.length - 1] = 0, [n.makeTensorInfo(c, a.dtype, []), n.makeTensorInfo(c, "int32", [])];
                if (1 === l) return [a, zRe({
                    attrs: {
                        shape: c,
                        dtype: "int32",
                        value: 0
                    },
                    backend: n
                })];
                var v = n.texData.get(a.dataId),
                    m = null !== v && v.isPacked,
                    g = m ? n.unpackTensor(a) : a,
                    y = L$(c) / l,
                    b = KEe({
                        inputs: {
                            x: g
                        },
                        attrs: {
                            shape: [y, l]
                        },
                        backend: n
                    });
                m && nDe(n, g);
                for (var x = rDe(i), k = rDe(l), w = null, I = function() {
                        return null === w ? [b, b] : [b, w]
                    }, N = function(e, t, r) {
                        var a = I(),
                            i = new eDe(r),
                            o = [
                                [l],
                                [null === w ? 1 : 0],
                                [Number.NEGATIVE_INFINITY],
                                [e],
                                [t]
                            ],
                            s = w;
                        w = n.runWebGLProgram(i, a, "int32", o), nDe(n, s)
                    }, T = 1; T < x; T *= 2)
                    for (var E = 2 * T, C = T; C >= 1; C /= 2) N(E, C, [y, k]);
                for (var A = k; A > x; A /= 2) {
                    var R = I(),
                        _ = new tDe([y, A / 2]),
                        O = [
                            [l],
                            [null === w ? 1 : 0],
                            [x]
                        ],
                        F = w;
                    w = n.runWebGLProgram(_, R, "int32", O), nDe(n, F);
                    for (var D = x / 2, M = 2 * D, L = D; L >= 1; L /= 2) N(M, L, w.shape)
                }
                var z = w;
                w = $Ce({
                    inputs: {
                        x: w
                    },
                    backend: n,
                    attrs: {
                        begin: 0,
                        size: [y, i]
                    }
                }), nDe(n, z);
                var P = n_e({
                    inputs: {
                        x: b,
                        indices: w
                    },
                    backend: n,
                    attrs: {
                        axis: 1,
                        batchDims: 1
                    }
                });
                nDe(n, b);
                var B = c.slice(0, -1);
                B.push(i), z = w, w = KEe({
                    inputs: {
                        x: w
                    },
                    attrs: {
                        shape: B
                    },
                    backend: n
                }), nDe(n, z);
                var W = P;
                return P = KEe({
                    inputs: {
                        x: P
                    },
                    attrs: {
                        shape: B
                    },
                    backend: n
                }), nDe(n, W), [P, w]
            }
        },
        iDe = p((function e(t, n, r, a, i, o) {
            l(this, e), this.variableNames = ["Image", "Transforms"], this.outputShape = o;
            var s, u = "nearest" === r ? 1 : 2;
            switch (a) {
                case "constant":
                default:
                    s = 1;
                    break;
                case "reflect":
                    s = 2;
                    break;
                case "wrap":
                    s = 3;
                    break;
                case "nearest":
                    s = 4
            }
            this.userCode = "\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(".concat(s, " == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(s, " == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(s, " == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ").concat(t, " && 0 <= coordX && coordX < ").concat(n, ") {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(").concat(i, ");\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(").concat(i, ");\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(").concat(n, "));\n                float mapY = mapCoord(inY, float(").concat(t, "));\n\n                if (").concat(u, " == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        ")
        }));
    var oDe = {
        kernelName: S3,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.backend,
                r = e.attrs,
                a = t.image,
                i = t.transforms,
                o = r.interpolation,
                s = r.fillMode,
                u = r.fillValue,
                c = r.outputShape,
                l = S(a.shape, 4),
                h = l[0],
                p = l[1],
                f = l[2],
                d = l[3],
                v = S(null != c ? c : [p, f], 2),
                m = v[0],
                g = v[1],
                y = new iDe(p, f, o, s, u, [h, m, g, d]);
            return n.runWebGLProgram(y, [a, i], "float32")
        }
    };
    var sDe = {
        kernelName: E3,
        backendName: "webgl",
        kernelFunc: function(e) {
            var t = e.inputs,
                n = e.attrs,
                r = e.backend,
                a = n.axis,
                i = t.x;
            zNe(i, "unique"), console.warn("WARNING: ", "UI might be locked temporarily as data is being downloaded");
            var o = r.readSync(i.dataId),
                s = qTe(o, a, i.shape, i.dtype),
                u = s.outputValues,
                c = s.outputShape,
                l = s.indices;
            return [r.makeTensorInfo(c, i.dtype, u), r.makeTensorInfo([l.length], "int32", l)]
        }
    };
    var uDe = {
            kernelName: C3,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.value,
                    i = r.axis;
                i < 0 && (i += a.shape.length);
                for (var o = a, s = o.shape.length, u = a.shape[i], c = new Array(s - 1), l = 0, h = 0; h < s; h++) h !== i && (c[l++] = o.shape[h]);
                var p = [],
                    f = new Array(s).fill(0),
                    d = o.shape.slice();
                d[i] = 1;
                for (var v = new Array(u), m = 0; m < v.length; m++) {
                    f[i] = m;
                    var g = $Ce({
                            inputs: {
                                x: o
                            },
                            backend: n,
                            attrs: {
                                begin: f,
                                size: d
                            }
                        }),
                        y = KEe({
                            inputs: {
                                x: g
                            },
                            backend: n,
                            attrs: {
                                shape: c
                            }
                        });
                    v[m] = y, p.push(g)
                }
                return p.forEach((function(e) {
                    return n.disposeIntermediateTensorInfo(e)
                })), v
            }
        },
        cDe = p((function e(t, n) {
            l(this, e), this.variableNames = ["x", "segmentIds"];
            var r = t.windowSize,
                a = t.batchSize,
                i = t.inSize,
                o = t.numSegments,
                s = o * Math.ceil(i / r);
            this.outputShape = [a, s];
            var u = 4 * Math.floor(r / 4),
                c = r % 4,
                h = "\n        sumValue += dot(values, segFilter);\n    ",
                p = "";
            i % r > 0 && (p = "\n        if (inIdx < 0 || inIdx >= ".concat(i, ") {\n          return initializationValue;\n        }\n      "));
            var f = "";
            i % r > 0 && (f = "\n        if (inIdx < 0 || inIdx >= ".concat(i, ") {\n          return -1.0;\n        }\n      ")), this.userCode = "\n      const float initializationValue = ".concat("0.0", ";\n\n      float getValue(int batch, int inIdx) {\n        ").concat(p, "\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ").concat(f, "\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ").concat(o, ")) * float(").concat(r, "));\n        int currentSeg = int(mod(float(outIdx), float(").concat(o, ")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(u, "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ").concat(h, "\n        }\n\n        int inIdx = inOffset + ").concat(u, ";\n        if (").concat(1 === c, ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ").concat(h, "\n        } else if (").concat(2 === c, ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ").concat(h, "\n        } else if (").concat(3 === c, ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ").concat(h, "\n        }\n        setOutput(").concat("sumValue", ");\n      }\n    ")
        }));
    for (var lDe = {
            kernelName: A3,
            backendName: "webgl",
            kernelFunc: function(e) {
                var t = e.inputs,
                    n = e.backend,
                    r = e.attrs,
                    a = t.x,
                    i = t.segmentIds,
                    o = r.numSegments,
                    s = a.shape.length,
                    u = [],
                    c = 0,
                    l = $7([c], s),
                    h = a;
                null != l && (h = rCe({
                    inputs: {
                        x: a
                    },
                    backend: n,
                    attrs: {
                        perm: l
                    }
                }), u.push(h), c = t9(1, s)[0]);
                var p = noe(h.shape, c, o),
                    f = L$([h.shape[c]]),
                    d = KEe({
                        inputs: {
                            x: h
                        },
                        backend: n,
                        attrs: {
                            shape: [-1, f]
                        }
                    });
                u.push(d);
                var v = function e(t, r, a, i, o) {
                        var s = t.shape[0],
                            c = t.shape[1],
                            l = toe(c, o),
                            h = new cDe({
                                windowSize: l,
                                inSize: c,
                                batchSize: s,
                                numSegments: o
                            }, r),
                            p = n.compileAndRun(h, [t, a], i);
                        if (u.push(p), p.shape[1] === o) return p;
                        var f = FOe({
                                backend: n,
                                attrs: {
                                    start: 0,
                                    stop: o,
                                    step: 1,
                                    dtype: "float32"
                                }
                            }),
                            d = QFe({
                                inputs: {
                                    x: f
                                },
                                backend: n,
                                attrs: {
                                    reps: [c / l]
                                }
                            });
                        return u.push(f), u.push(d), e(p, r, d, i, o)
                    }(d, "unsortedSegmentSum", i, p5(a.dtype), o),
                    m = KEe({
                        inputs: {
                            x: v
                        },
                        backend: n,
                        attrs: {
                            shape: p
                        }
                    }),
                    g = m;
                if (null != l) {
                    u.push(m);
                    var y = e9(l);
                    g = rCe({
                        inputs: {
                            x: g
                        },
                        backend: n,
                        attrs: {
                            perm: y
                        }
                    })
                }
                return u.forEach((function(e) {
                    return n.disposeIntermediateTensorInfo(e)
                })), g
            }
        }, hDe = 0, pDe = [oCe, uCe, lCe, pCe, vCe, yCe, bCe, xCe, TCe, ECe, ACe, _Ce, FCe, MCe, zCe, WCe, UCe, jCe, HCe, qCe, YCe, tAe, nAe, rAe, aAe, cAe, pAe, vAe, REe, yAe, TAe, DAe, BAe, UAe, VAe, GAe, HAe, KAe, YAe, ZAe, nRe, rRe, aRe, oRe, cRe, pRe, fRe, vRe, gRe, yRe, xRe, kRe, IRe, SRe, ERe, ARe, ORe, MRe, BRe, URe, jRe, qRe, YRe, ZRe, QRe, e_e, r_e, i_e, s_e, CEe, u_e, IAe, l_e, p_e, d_e, FEe, m_e, y_e, b_e, k_e, I_e, S_e, E_e, A_e, O_e, D_e, L_e, P_e, B_e, W_e, G_e, j_e, H_e, q_e, K_e, Y_e, Q_e, eOe, cOe, qEe, lOe, pOe, dOe, mOe, oAe, yOe, kOe, wOe, TOe, COe, LEe, AOe, ROe, _Oe, OOe, DOe, uAe, rOe, LOe, POe, WOe, XEe, GOe, HOe, XOe, JOe, $Oe, tFe, rFe, iFe, uFe, lFe, pFe, dFe, mFe, yFe, xFe, wFe, eAe, uOe, NFe, SFe, TFe, EFe, CFe, AFe, RFe, _Fe, DFe, MFe, PFe, BFe, WFe, VFe, GFe, jFe, HFe, oOe, nCe, KFe, YFe, JFe, $Fe, aDe, oDe, aCe, sDe, uDe, lDe, xOe]; hDe < pDe.length; hDe++) {
        G3(pDe[hDe])
    }
    var fDe = {
        "tfjs-core": eie,
        "tfjs-backend-cpu": zbe,
        "tfjs-backend-webgl": kEe,
        "tfjs-data": ige,
        "tfjs-layers": Ble,
        "tfjs-converter": Yve,
        tfjs: "4.22.0"
    };
    e.Abs = N0, e.Acos = S0, e.Acosh = T0, e.AdadeltaOptimizer = Jre, e.AdagradOptimizer = Zre, e.AdamOptimizer = Qre, e.AdamaxOptimizer = $re, e.Add = E0, e.AddN = C0, e.All = A0, e.Any = R0, e.ArgMax = _0, e.ArgMin = O0, e.Asin = F0, e.Asinh = D0, e.Atan = M0, e.Atan2 = z0, e.Atanh = L0, e.AvgPool = P0, e.AvgPool3D = W0, e.AvgPool3DGrad = U0, e.AvgPoolGrad = B0, e.BatchMatMul = V0, e.BatchToSpaceND = G0, e.Bincount = j0, e.BitwiseAnd = H0, e.BroadcastArgs = K0, e.BroadcastTo = q0, e.Callback = tde, e.CallbackList = Jce, e.Cast = X0, e.Ceil = Y0, e.ClipByValue = J0, e.Complex = Z0, e.ComplexAbs = Q0, e.Concat = $0, e.Conv2D = e1, e.Conv2DBackpropFilter = t1, e.Conv2DBackpropInput = n1, e.Conv3D = r1, e.Conv3DBackpropFilterV2 = a1, e.Conv3DBackpropInputV2 = i1, e.Cos = o1, e.Cosh = s1, e.CropAndResize = l1, e.Cumprod = u1, e.Cumsum = c1, e.CustomCallback = $ce, e.DataStorage = S$, e.DenseBincount = h1, e.DepthToSpace = p1, e.DepthwiseConv2dNative = f1, e.DepthwiseConv2dNativeBackpropFilter = d1, e.DepthwiseConv2dNativeBackpropInput = v1, e.Diag = m1, e.Dilation2D = g1, e.Dilation2DBackpropFilter = b1, e.Dilation2DBackpropInput = y1, e.Draw = x1, e.EarlyStopping = ade, e.Einsum = w1, e.Elu = I1, e.EluGrad = N1, e.Environment = y0, e.Equal = T1, e.Erf = S1, e.Exp = E1, e.ExpandDims = C1, e.Expm1 = A1, e.FFT = R1, e.Fill = _1, e.FlipLeftRight = O1, e.Floor = F1, e.FloorDiv = D1, e.FromPixels = O3, e.FusedBatchNorm = M1, e.FusedConv2D = M3, e.FusedDepthwiseConv2D = L3, e.GPGPUContext = ZSe, e.GatherNd = z1, e.GatherV2 = L1, e.GraphModel = qve, e.Greater = P1, e.GreaterEqual = B1, e.History = Qce, e.IFFT = U1, e.Identity = W1, e.Imag = V1, e.InputSpec = gce, e.IsFinite = G1, e.IsInf = j1, e.IsNan = H1, e.KernelBackend = T$, e.LRN = n2, e.LRNGrad = r2, e.LayerVariable = dce, e.LayersModel = vhe, e.LeakyRelu = q1, e.Less = K1, e.LessEqual = X1, e.LinSpace = Y1, e.Log = J1, e.Log1p = Z1, e.LogSoftmax = t2, e.LogicalAnd = Q1, e.LogicalNot = $1, e.LogicalOr = e2, e.LogicalXor = "LogicalXor", e.LowerBound = "LowerBound", e.MathBackendCPU = cge, e.MathBackendWebGL = xEe, e.MatrixBandPart = "MatrixBandPart", e.Max = a2, e.MaxPool = o2, e.MaxPool3D = u2, e.MaxPool3DGrad = c2, e.MaxPoolGrad = s2, e.MaxPoolWithArgmax = l2, e.Maximum = i2, e.Mean = h2, e.Min = p2, e.Minimum = f2, e.MirrorPad = d2, e.Mod = v2, e.MomentumOptimizer = tae, e.Multinomial = m2, e.Multiply = g2, e.Neg = y2, e.NonMaxSuppressionV3 = x2, e.NonMaxSuppressionV4 = k2, e.NonMaxSuppressionV5 = w2, e.NotEqual = b2, e.OP_SCOPE_SUFFIX = P5, e.OneHot = N2, e.OnesLike = I2, e.Optimizer = Yre, e.OptimizerConstructors = tie, e.Pack = S2, e.PadV2 = T2, e.Pool = "Pool", e.Pow = E2, e.Prelu = C2, e.Prod = A2, e.RMSPropOptimizer = nae, e.RNN = Spe, e.RaggedGather = R2, e.RaggedRange = _2, e.RaggedTensorToTensor = O2, e.Range = F2, e.Real = D2, e.RealDiv = k1, e.Reciprocal = M2, e.Relu = L2, e.Relu6 = V2, e.Reshape = z2, e.ResizeBilinear = W2, e.ResizeBilinearGrad = U2, e.ResizeNearestNeighbor = P2, e.ResizeNearestNeighborGrad = B2, e.Reverse = G2, e.RotateWithOffset = F3, e.Round = j2, e.Rsqrt = H2, e.SGDOptimizer = eae, e.ScatterNd = q2, e.SearchSorted = X2, e.Select = Y2, e.Selu = J2, e.Sequential = whe, e.Sigmoid = t3, e.Sign = e3, e.Sin = Q2, e.Sinh = $2, e.Slice = Z2, e.Softmax = s3, e.Softplus = n3, e.SpaceToBatchND = i3, e.SparseFillEmptyRows = u3, e.SparseReshape = c3, e.SparseSegmentMean = l3, e.SparseSegmentSum = h3, e.SparseToDense = p3, e.SplitV = o3, e.Sqrt = r3, e.Square = d3, e.SquaredDifference = f3, e.StaticRegexReplace = v3, e.Step = _3, e.StridedSlice = m3, e.StringNGrams = g3, e.StringSplit = y3, e.StringToHashBucketFast = b3, e.Sub = x3, e.Sum = a3, e.SymbolicTensor = yce, e.Tan = k3, e.Tanh = w3, e.Tensor = n5, e.TensorBuffer = $4, e.TensorScatterUpdate = K2, e.Tile = I3, e.TopK = N3, e.Transform = S3, e.Transpose = T3, e.Unique = E3, e.Unpack = C3, e.UnsortedSegmentSum = A3, e.UpperBound = "UpperBound", e.Variable = c5, e.ZerosLike = R3, e._FusedMatMul = D3, e.abs = y8, e.acos = b8, e.acosh = x8, e.add = d8, e.addN = k8, e.all = w8, e.any = I8, e.argMax = N8, e.argMin = S8, e.asin = T8, e.asinh = E8, e.atan = C8, e.atan2 = A8, e.atanh = R8, e.avgPool = Y8, e.avgPool3d = J8, e.backend = e6, e.backend_util = ooe, e.basicLSTMCell = n7, e.batchNorm = a7, e.batchNorm2d = i7, e.batchNorm3d = o7, e.batchNorm4d = s7, e.batchToSpaceND = r7, e.bincount = u7, e.bitwiseAnd = c7, e.booleanMaskAsync = lne, e.broadcastArgs = l7, e.broadcastTo = h7, e.broadcast_util = P7, e.browser = Dae, e.buffer = l8, e.callbacks = sde, e.cast = h8, e.ceil = p7, e.clipByValue = d7, e.clone = p8, e.complex = W5, e.concat = Z8, e.concat1d = v7, e.concat2d = m7, e.concat3d = g7, e.concat4d = y7, e.constraints = Gce, e.conv1d = x7, e.conv2d = b7, e.conv2dTranspose = w7, e.conv3d = I7, e.conv3dTranspose = S7, e.copyRegisteredKernels = function(e, t) {
        V3(e).forEach((function(e) {
            G3(Object.assign({}, e, {
                backendName: t
            }))
        }))
    }, e.cos = T7, e.cosh = E7, e.cosineWindow = bne, e.cumprod = C7, e.cumsum = A7, e.customGrad = F9, e.data = oge, e.denseBincount = R7, e.deprecationWarn = H5, e.depthToSpace = _7, e.depthwiseConv2d = O7, e.deregisterOp = function(e) {
        delete ude[e]
    }, e.device_util = _5, e.diag = F7, e.dilation2d = D7, e.disableDeprecationWarnings = function() {
        k0().set("DEPRECATION_WARNINGS_ENABLED", !1), console.warn("TensorFlow.js deprecation warnings have been disabled.")
    }, e.dispose = Y5, e.disposeVariables = function() {
        E5.disposeVariables()
    }, e.div = m8, e.divNoNan = V7, e.dot = G7, e.dropout = gne, e.einsum = j7, e.elu = H7, e.enableDebugMode = function() {
        k0().set("DEBUG", !0)
    }, e.enableProdMode = function() {
        k0().set("PROD", !0)
    }, e.enclosingPowerOfTwo = yne, e.engine = q5, e.ensureShape = q7, e.env = k0, e.equal = B7, e.erf = K7, e.euclideanNorm = h9, e.exp = p9, e.expandDims = f9, e.expm1 = d9, e.eye = m9, e.fft = _te, e.fill = f7, e.findBackend = function(e) {
        return E5.findBackend(e)
    }, e.findBackendFactory = function(e) {
        return E5.findBackendFactory(e)
    }, e.floor = g9, e.floorDiv = v8, e.forceHalfFloat = wEe, e.fused = One, e.gather = y9, e.gatherND = mne, e.gather_util = Lae, e.getBackend = Q5, e.getGradient = U3, e.getKernel = W3, e.getKernelsForBackend = V3, e.gpgpu_util = JSe, e.grad = function(e) {
        return F$(r0(e), (function() {
                return "The f passed in grad(f) must be a function"
            })),
            function(t, n) {
                var r = L5(t, "x", "tf.grad", "string_or_numeric"),
                    a = null != n ? L5(n, "dy", "tf.grad") : null;
                return E5.tidy((function() {
                    var t = E5.gradients((function() {
                            return e(r)
                        }), [r], a),
                        n = t.value,
                        i = t.grads;
                    return null != a && D$(n.shape, a.shape, "The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"), D9(i), i[0]
                }))
            }
    }, e.grads = function(e) {
        return F$(r0(e), (function() {
                return "The f passed in grads(f) must be a function"
            })),
            function(t, n) {
                F$(Array.isArray(t), (function() {
                    return "The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"
                }));
                var r = z5(t, "args", "tf.grads", "string_or_numeric"),
                    a = null != n ? L5(n, "dy", "tf.grads") : null;
                return E5.tidy((function() {
                    var t = E5.gradients((function() {
                            return e.apply(void 0, T(r))
                        }), r, a),
                        n = t.value,
                        i = t.grads;
                    return null != a && D$(n.shape, a.shape, "The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), D9(i), i
                }))
            }
    }, e.greater = b9, e.greaterEqual = x9, e.ifft = Ote, e.imag = k9, e.image = Pre, e.inTopKAsync = kne, e.initializers = Hce, e.input = Ihe, e.io = Nae, e.irfft = Fte, e.isFinite = w9, e.isInf = I9, e.isNaN = N9, e.keep = J5, e.kernel_impls = soe, e.layers = Zfe, e.leakyRelu = S9, e.less = T9, e.lessEqual = E9, e.linalg = Bre, e.linspace = C9, e.loadGraphModel = function(e) {
        return Kve.apply(this, arguments)
    }, e.loadGraphModelSync = function(e) {
        if (null == e) throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");
        var t;
        if (e instanceof Array) {
            var n = S(e, 2),
                r = n[0],
                a = n[1];
            if (!r) throw new Error("modelJSON must be the first element of the array");
            if (!(a && a instanceof ArrayBuffer)) throw new Error("An ArrayBuffer of weights must be the second element of the array");
            if (!("modelTopology" in r)) throw new Error("Model JSON is missing 'modelTopology'");
            if (!("weightsManifest" in r)) throw new Error("Model JSON is missing 'weightsManifest'");
            t = Iae(x6(r, N6(r.weightsManifest), a))
        } else if ("load" in e) t = e;
        else {
            if (!("modelTopology" in e && "weightSpecs" in e && "weightData" in e)) throw new Error("Unknown model format");
            t = Iae(e)
        }
        var i = new qve(t);
        return i.load(), i
    }, e.loadLayersModel = function(e, t) {
        return yhe.apply(this, arguments)
    }, e.localResponseNormalization = A9, e.log = R9, e.log1p = _9, e.logSigmoid = z9, e.logSoftmax = B9, e.logSumExp = W9, e.logicalAnd = U9, e.logicalNot = V9, e.logicalOr = G9, e.logicalXor = j9, e.losses = Wre, e.lowerBound = K9, e.matMul = Q8, e.math = Tae, e.max = n9, e.maxPool = X9, e.maxPool3d = Y9, e.maxPoolWithArgmax = J9, e.maximum = Z9, e.mean = Q9, e.memory = K5, e.meshgrid = tee, e.metrics = Qfe, e.min = r9, e.minimum = nee, e.mirrorPad = ree, e.mod = aee, e.model = function(e) {
        return new vhe(e)
    }, e.models = $fe, e.moments = iee, e.movingAverage = pne, e.mul = g8, e.multiRNNCell = oee, e.multinomial = see, e.neg = M9, e.nextFrame = aie, e.norm = l9, e.notEqual = uee, e.oneHot = cee, e.ones = eee, e.onesLike = lee, e.op = B5, e.outerProduct = hee, e.pad = pee, e.pad1d = fee, e.pad2d = dee, e.pad3d = vee, e.pad4d = mee, e.pool = yee, e.pow = a9, e.prelu = bee, e.print = f8, e.prod = xee, e.profile = function(e) {
        return E5.profile(e)
    }, e.raggedGather = kee, e.raggedRange = wee, e.raggedTensorToTensor = Iee, e.rand = Nee, e.randomGamma = nte, e.randomNormal = rte, e.randomStandardNormal = ate, e.randomUniform = ite, e.randomUniformInt = ote, e.range = ste, e.ready = function() {
        return E5.ready()
    }, e.real = ute, e.reciprocal = cte, e.registerBackend = $5, e.registerCallbackConstructor = function(e, t) {
        tle.registerCallbackConstructor(e, t)
    }, e.registerGradient = j3, e.registerKernel = G3, e.registerOp = function(e, t) {
        var n = {
            tfOpName: e,
            category: "custom",
            inputs: [],
            attrs: [],
            customExecutor: t
        };
        ude[e] = n
    }, e.regularizers = ede, e.relu = lte, e.relu6 = hte, e.removeBackend = function(e) {
        E5.removeBackend(e)
    }, e.reshape = X8, e.reverse = pte, e.reverse1d = fte, e.reverse2d = dte, e.reverse3d = vte, e.reverse4d = mte, e.rfft = Mte, e.round = gte, e.rsqrt = yte, e.scalar = i9, e.scatterND = fne, e.scatter_util = Zte, e.searchSorted = q9, e.selu = bte, e.separableConv2d = xte, e.sequential = function(e) {
        return new whe(e)
    }, e.serialization = Xre, e.setBackend = Z5, e.setPlatform = function(e, t) {
        k0().setPlatform(e, t)
    }, e.setWebGLContext = UIe, e.setdiff1dAsync = wte, e.shared = Lbe, e.sigmoid = $8, e.sign = Ite, e.signal = zre, e.sin = Nte, e.sinh = Ste, e.slice = e7, e.slice1d = Tte, e.slice2d = Ete, e.slice3d = Cte, e.slice4d = Ate, e.slice_util = $ae, e.softmax = Rte, e.softplus = L9, e.spaceToBatchND = gee, e.sparse = Ure, e.sparseToDense = vne, e.spectral = Lre, e.split = Dte, e.sqrt = o9, e.square = s9, e.squaredDifference = Lte, e.squeeze = zte, e.stack = Pte, e.step = Bte, e.stridedSlice = Wte, e.string = Vre, e.sub = P9, e.sum = u9, e.sumOutType = p5, e.tan = Ute, e.tanh = t7, e.tensor = V5, e.tensor1d = Vte, e.tensor2d = Gte, e.tensor3d = jte, e.tensor4d = Hte, e.tensor5d = qte, e.tensor6d = Kte, e.tensorScatterUpdate = Qte, e.tensor_util = x5, e.test_util = Qee, e.tidy = X5, e.tile = v9, e.time = function(e) {
        return E5.time(e)
    }, e.topk = $te, e.train = nie, e.transpose = hne, e.truncatedNormal = ene, e.unique = tne, e.unregisterGradient = function(e) {
        if (!B3.has(e)) throw new Error("The gradient '".concat(e, "' for backend is not registered"));
        B3.delete(e)
    }, e.unregisterKernel = function(e, t) {
        var n = H3(e, t);
        if (!P3.has(n)) throw new Error("The kernel '".concat(e, "' for backend ") + "'".concat(t, "' is not registered"));
        P3.delete(n)
    }, e.unsortedSegmentSum = nne, e.unstack = rne, e.upcastType = h5, e.upperBound = ane, e.util = G4, e.valueAndGrad = function(e) {
        return F$(r0(e), (function() {
                return "The f passed in valueAndGrad(f) must be a function"
            })),
            function(t, n) {
                F$(t instanceof n5, (function() {
                    return "The x passed in valueAndGrad(f)(x) must be a tensor"
                })), F$(null == n || n instanceof n5, (function() {
                    return "The dy passed in valueAndGrad(f)(x, dy) must be a tensor"
                }));
                var r = E5.gradients((function() {
                        return e(t)
                    }), [t], n),
                    a = r.grads,
                    i = r.value;
                return D9(a), {
                    grad: a[0],
                    value: i
                }
            }
    }, e.valueAndGrads = function(e) {
        return F$(r0(e), (function() {
                return "The f passed in valueAndGrads(f) must be a function"
            })),
            function(t, n) {
                F$(Array.isArray(t) && t.every((function(e) {
                    return e instanceof n5
                })), (function() {
                    return "The args passed in valueAndGrads(f)(args) must be array of tensors"
                })), F$(null == n || n instanceof n5, (function() {
                    return "The dy passed in valueAndGrads(f)(args, dy) must be a tensor"
                }));
                var r = E5.gradients((function() {
                    return e.apply(void 0, T(t))
                }), t, n);
                return null != n && D$(r.value.shape, n.shape, "The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"), D9(r.grads), r
            }
    }, e.variable = ine, e.variableGrads = O9, e.version = fDe, e.version_converter = Yve, e.version_core = eie, e.version_cpu = zbe, e.version_layers = Ble, e.version_webgl = kEe, e.webgl = IEe, e.webgl_util = PNe, e.where = W7, e.whereAsync = une, e.zeros = $9, e.zerosLike = U7
}));
//# sourceMappingURL=tf.min.js.map